<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=overlays-content">
    <title>Musche</title>
    <link rel="icon" href=https://gdpsiinrxhpmxvgvgxeh.supabase.co/storage/v1/object/public/avatars/icon.png>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chango&family=Josefin+Sans:ital,wght@0,100..700;1,100..700&family=Noto+Serif+SC:wght@200..900&family=Noto+Serif:ital,wght@0,100..900;1,100..900&family=Outfit:wght@100..900&display=swap"
          rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.css"/>
    <script src="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.js.iife.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.4.21/vue.global.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="https://unpkg.com/pinyin-pro"></script>
    <script src="https://cdn.jsdelivr.net/npm/jzz"></script>
    <script src="https://cdn.jsdelivr.net/npm/jzz-midi-smf"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        glass: {
                            light: 'rgba(255, 255, 255, 0.45)',
                            dark: 'rgba(20, 20, 20, 0.65)',
                            border: 'rgba(255, 255, 255, 0.2)',
                            borderDark: 'rgba(255, 255, 255, 0.08)'
                        }
                    },
                    boxShadow: {
                        'liquid': '0 8px 32px 0 rgba(0, 0, 0, 0.15)',
                        'glow': '0 0 15px rgba(59, 130, 246, 0.5)'
                    }
                }
            }
        }

        // ğŸŸ¢ [ä¿®æ”¹å] åŸºäº JZZ æ•°æ®çš„é‡åŒ–è®¡ç®— (Method B)
        function calculateBarQuantizedDuration(notes, tempoMap, timeSigs) {
            // 1. å¦‚æœæ²¡æœ‰éŸ³ç¬¦ï¼Œç›´æ¥è¿”å› 0
            if (notes.length === 0) return { seconds: 0, rawSeconds: 0, bars: 0 }; // ğŸŸ¢ æ”¹åŠ¨: å¢åŠ  bars: 0

            // 2. æ‰¾å‡ºè¯¥è½¨é“æœ€åä¸€ä¸ªéŸ³ç¬¦çš„ç»“æŸæ—¶é—´ (Ticks)
            let lastNoteOffTick = 0;
            notes.forEach(n => {
                const end = n.ticks + n.durationTicks;
                if (end > lastNoteOffTick) lastNoteOffTick = end;
            });

            const ppq = tempoMap.ppq;
            let currentTick = 0;
            let sigIndex = 0;
            let validSeconds = 0;
            let validBars = 0; // ğŸŸ¢ 1. æ–°å¢: å°èŠ‚è®¡æ•°å™¨

            // 4. [æ ¸å¿ƒå¾ªç¯] æ¨¡æ‹Ÿ Python çš„ get_downbeats å¹¶æ£€æŸ¥åŒºé—´
            while (currentTick < lastNoteOffTick) {
                // A. åˆ‡æ¢æ‹å·é€»è¾‘
                if (sigIndex + 1 < timeSigs.length && currentTick >= timeSigs[sigIndex + 1].ticks) {
                    sigIndex++;
                }
                const currentSig = timeSigs[sigIndex];
                const [num, den] = currentSig.timeSignature;

                // B. è®¡ç®—å½“å‰å°èŠ‚é•¿åº¦ (Ticks)
                const ticksPerBar = (ppq * 4 / den) * num;
                const barStartTick = currentTick;
                const barEndTick = currentTick + ticksPerBar;

                // C. æ£€æŸ¥å½“å‰å°èŠ‚æ˜¯å¦â€œæ´»è·ƒâ€ (æœ‰éŸ³ç¬¦è½åœ¨å…¶ä¸­)
                const isActiveBar = notes.some(n => {
                    const nStart = n.ticks;
                    const nEnd = n.ticks + n.durationTicks;
                    return Math.max(nStart, barStartTick) < Math.min(nEnd, barEndTick);
                });

                if (isActiveBar) {
                    // D. å¦‚æœæ´»è·ƒï¼Œè®¡ç®—è¯¥å°èŠ‚çš„ç§’æ•°å¹¶ç´¯åŠ 
                    const startSec = jzzTicksToSeconds(barStartTick, tempoMap);
                    const endSec = jzzTicksToSeconds(barEndTick, tempoMap);
                    validSeconds += (endSec - startSec);

                    validBars++; // ğŸŸ¢ 2. æ–°å¢: æœ‰æ•ˆå°èŠ‚æ•° +1
                }

                // æ¨è¿›åˆ°ä¸‹ä¸€å°èŠ‚
                currentTick += ticksPerBar;
            }

            const absoluteTotalSeconds = jzzTicksToSeconds(lastNoteOffTick, tempoMap);

            return {
                seconds: validSeconds,
                rawSeconds: absoluteTotalSeconds,
                bars: validBars // ğŸŸ¢ 3. æ–°å¢: è¿”å›è®¡ç®—å‡ºçš„å°èŠ‚æ•°
            };
        }

        // --- ğŸŸ¢ JZZ è¾…åŠ©å·¥å…·å‡½æ•° ---

        // 1. æ„å»º Tempo Map (ç”¨äºå°† Tick è½¬æ¢ä¸ºç§’)
        function buildTempoMap(smf) {
            const ppq = smf.ppqn;
            const tempoEvents = [];

            // éå†æ‰€æœ‰è½¨é“å¯»æ‰¾ Tempo äº‹ä»¶ (Meta 0x51)
            smf.forEach(track => {
                track.forEach(event => {
                    if (event.ff === 0x51) { // Set Tempo
                        tempoEvents.push({
                            tick: event.tt,
                            // JZZ è¿”å›çš„ microseconds per beat
                            bpm: 60000000 / event.dd.charCodeAt(0) << 16 | event.dd.charCodeAt(1) << 8 | event.dd.charCodeAt(2), // è§£æ raw data
                            mpb: event.dd.charCodeAt(0) << 16 | event.dd.charCodeAt(1) << 8 | event.dd.charCodeAt(2) // microseconds per beat
                        });
                    }
                });
            });

            // å¦‚æœæ²¡æœ‰ Tempo äº‹ä»¶ï¼Œé»˜è®¤ 120 BPM (500000 mpb)
            if (tempoEvents.length === 0) {
                tempoEvents.push({ tick: 0, mpb: 500000 });
            }

            // æŒ‰ Tick æ’åº
            tempoEvents.sort((a, b) => a.tick - b.tick);

            // ç¡®ä¿ä» 0 tick å¼€å§‹
            if (tempoEvents[0].tick > 0) {
                tempoEvents.unshift({ tick: 0, mpb: 500000 });
            }

            // é¢„è®¡ç®—æ¯ä¸ª Tempo åŒºé—´çš„èµ·å§‹ç§’æ•°ï¼Œä¼˜åŒ–æ€§èƒ½
            let currentSec = 0;
            for (let i = 0; i < tempoEvents.length; i++) {
                const curr = tempoEvents[i];
                const prev = tempoEvents[i - 1];
                if (prev) {
                    const deltaTicks = curr.tick - prev.tick;
                    // ç§’æ•° = deltaTicks * (mpb / 1000000) / ppq
                    currentSec += (deltaTicks * prev.mpb) / (ppq * 1000000.0);
                }
                curr.seconds = currentSec;
            }

            return { ppq, events: tempoEvents };
        }

        // 2. å°† Tick è½¬æ¢ä¸ºç§’ (æ ¸å¿ƒè½¬æ¢å‡½æ•°)
        function jzzTicksToSeconds(tick, tempoMap) {
            const { ppq, events } = tempoMap;
            // æ‰¾åˆ°å½“å‰ tick æ‰€åœ¨çš„ tempo åŒºé—´
            // ä»åå¾€å‰æ‰¾ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ª startTick <= tick çš„äº‹ä»¶
            let i = events.length - 1;
            while (i > 0 && events[i].tick > tick) {
                i--;
            }
            const tempo = events[i];
            const deltaTicks = tick - tempo.tick;
            return tempo.seconds + (deltaTicks * tempo.mpb) / (ppq * 1000000.0);
        }

        // 3. æ„å»º Time Signature Map (æ‹å·è¡¨)
        function buildTimeSigMap(smf) {
            const timeSigs = [];
            smf.forEach(track => {
                track.forEach(event => {
                    if (event.ff === 0x58) { // Time Signature
                        // JZZ data: [nn, dd, cc, bb]
                        // åˆ†å­ = nn, åˆ†æ¯ = 2^dd
                        const num = event.dd.charCodeAt(0);
                        const denPower = event.dd.charCodeAt(1);
                        const den = Math.pow(2, denPower);
                        timeSigs.push({
                            ticks: event.tt,
                            timeSignature: [num, den]
                        });
                    }
                });
            });
            // é»˜è®¤ 4/4
            if (timeSigs.length === 0) {
                timeSigs.push({ ticks: 0, timeSignature: [4, 4] });
            }
            timeSigs.sort((a, b) => a.ticks - b.ticks);
            return timeSigs;
        }

        // 4. ä» JZZ Track æå–éŸ³ç¬¦ (Note On/Off é…å¯¹)
        function extractNotesFromJZZTrack(track) {
            const notes = [];
            const activeNotes = {}; // key: midi_note_number, value: { startTick, velocity }

            track.forEach(event => {
                const tick = event.tt;
                // Note On (0x90) with velocity > 0
                if (event[0] >= 0x90 && event[0] <= 0x9F && event[2] > 0) {
                    const noteNum = event[1];
                    // å¦‚æœè¯¥éŸ³ç¬¦å·²ç»åœ¨æ’­æ”¾ä¸­ï¼ˆå³é‡å éŸ³ç¬¦ï¼‰ï¼Œå…ˆå…³æ‰å‰ä¸€ä¸ª
                    if (activeNotes[noteNum]) {
                        const prev = activeNotes[noteNum];
                        notes.push({
                            ticks: prev.startTick,
                            durationTicks: tick - prev.startTick,
                            midi: noteNum
                        });
                    }
                    activeNotes[noteNum] = { startTick: tick };
                }
                // Note Off (0x80) OR Note On with velocity 0
                else if ((event[0] >= 0x80 && event[0] <= 0x8F) || (event[0] >= 0x90 && event[0] <= 0x9F && event[2] === 0)) {
                    const noteNum = event[1];
                    if (activeNotes[noteNum]) {
                        const start = activeNotes[noteNum].startTick;
                        notes.push({
                            ticks: start,
                            durationTicks: tick - start,
                            midi: noteNum
                        });
                        delete activeNotes[noteNum];
                    }
                }
            });
            return notes;
        }
    </script>

    <style>


        /* --- åŠ¨æ€æ¶²æ€èƒŒæ™¯ --- */
        body {
            background: radial-gradient(at 0% 0%, hsla(253, 16%, 7%, 1) 0, transparent 50%),
            radial-gradient(at 50% 0%, hsla(225, 39%, 30%, 1) 0, transparent 50%),
            radial-gradient(at 100% 0%, hsla(339, 49%, 30%, 1) 0, transparent 50%);
            background-size: cover;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
            font-size: 14px;
            /* ğŸŸ¢ ä¼˜åŒ–: ä½¿ç”¨ dvh é€‚åº”ç§»åŠ¨ç«¯åœ°å€æ ï¼Œå›é€€å…¼å®¹ 100vh */
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            /* ğŸŸ¢ ä¼˜åŒ–: ç¦æ­¢ iOS æ©¡çš®ç­‹å›å¼¹æ•ˆæœï¼Œè®©å®ƒæ„Ÿè§‰åƒåŸç”Ÿ App */
            overscroll-behavior: none;
            color: #1d1d1f;
            transition: background 0.5s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        .font-mono {
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
        }

        /* å…è®¸è¾“å…¥æ¡†å¯é€‰æ‹© */
        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        /* ğŸŸ¢ ä¼˜åŒ–: äº®è‰²æ¨¡å¼èƒŒæ™¯ (é™å™ªã€æŠ¤çœ¼ç‰ˆ) */
        html:not(.dark) body {
            /* 1. åº•è‰²æ”¹ä¸ºåå†·çš„ç°è“è‰²ï¼Œä¸å†æ˜¯åˆºçœ¼çš„äº®ç™½ */
            background-color: #dfe1e5;

            /* 2. å¤§å¹…é™ä½å…‰æ–‘çš„é€æ˜åº¦ (0.5 -> 0.15)ï¼Œåªä¿ç•™æå…¶å¾®å¼±çš„æ°›å›´æ„Ÿ */
            background-image: radial-gradient(at 40% 20%, hsla(28, 100%, 74%, 0.15) 0px, transparent 50%),
            radial-gradient(at 80% 0%, hsla(189, 100%, 56%, 0.15) 0px, transparent 50%),
            radial-gradient(at 0% 50%, hsla(355, 100%, 93%, 0.15) 0px, transparent 50%),
            radial-gradient(at 80% 50%, hsla(340, 100%, 76%, 0.15) 0px, transparent 50%),
            radial-gradient(at 0% 100%, hsla(22, 100%, 77%, 0.15) 0px, transparent 50%),
            radial-gradient(at 80% 100%, hsla(242, 100%, 70%, 0.15) 0px, transparent 50%);

            /* æ–‡å­—é¢œè‰²åŠ æ·±ï¼Œå‡ ä¹çº¯é»‘ */
            color: #0f0f10;
        }

        html.dark body {
            color: #f5f5f7;
        }

        /* --- ğŸŸ¢ åˆ—è¡¨å¹³æ»‘åŠ¨ç”» (FLIP) --- */
        /* 1. ç§»åŠ¨ä¸­çš„å…ƒç´  (Vue ä¼šè‡ªåŠ¨å¤„ç†ä½ç½®è®¡ç®—) */
        .list-move,
        .list-enter-active,
        .list-leave-active {
            transition: all 0.3s cubic-bezier(0.55, 0, 0.1, 1);
        }

        /* 2. å…ƒç´ è¿›å…¥å‰/ç¦»å¼€åçš„çŠ¶æ€ */
        .list-enter-from,
        .list-leave-to {
            opacity: 0;
            transform: scaleY(0.01) translate(0, 10px);
        }

        /* 3. ç¡®ä¿ç¦»å¼€çš„å…ƒç´ è„±ç¦»æ–‡æ¡£æµï¼Œè®©åé¢çš„å…ƒç´ èƒ½å¹³æ»‘è¡¥ä½ (å…³é”®!) */
        .list-leave-active {
            position: absolute;
            width: 100%;
            z-index: -1; /* é˜²æ­¢é®æŒ¡ */
        }

        /* --- ğŸŸ¢ ä¿®å¤: Driver.js å¼•å¯¼å¼¹çª—çš„ç»ç’ƒæ‹Ÿæ€é£æ ¼ --- */
        /* åŠ¡å¿…åŠ  !important ä»¥è¦†ç›–åº“çš„é»˜è®¤æ ·å¼ */

        .driver-popover {
            /* 1. èƒŒæ™¯æ”¹ä¸ºåŠé€æ˜ç£¨ç ‚ç™½ */
            background-color: rgba(255, 255, 255, 0.85) !important;
            backdrop-filter: blur(20px) saturate(180%) !important;
            -webkit-backdrop-filter: blur(20px) saturate(180%) !important;

            /* 2. è¾¹æ¡†å’Œåœ†è§’ */
            border: 1px solid rgba(255, 255, 255, 0.4) !important;
            border-radius: 16px !important;

            /* 3. é˜´å½± */
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15) !important;

            /* 4. æ–‡å­—é¢œè‰² */
            color: #1d1d1f !important;
            padding: 20px !important;
            min-width: 280px !important;
        }

        /* æ ‡é¢˜æ ·å¼ */
        .driver-popover .driver-popover-title {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif !important;
            font-size: 18px !important;
            font-weight: 700 !important;
            margin-bottom: 8px !important;
            line-height: 1.2 !important;
        }

        /* æ­£æ–‡æ ·å¼ */
        .driver-popover .driver-popover-description {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif !important;
            font-size: 14px !important;
            line-height: 1.6 !important;
            color: #1d1d1f !important;
            opacity: 0.8 !important;
            margin-bottom: 20px !important;
        }

        /* æŒ‰é’®æ ·å¼é‡ç½® (å˜æˆä½ çš„è“è‰²åœ†è§’é£æ ¼) */
        .driver-popover button {
            background-color: #007aff !important;
            color: white !important;
            border: none !important;
            border-radius: 8px !important;
            padding: 8px 16px !important;
            font-size: 13px !important;
            font-weight: 600 !important;
            text-shadow: none !important;
            transition: all 0.2s !important;
            box-shadow: 0 4px 10px rgba(0, 122, 255, 0.3) !important;
        }

        .driver-popover button:hover {
            background-color: #0062cc !important;
            transform: scale(1.02);
        }

        /* "ä¸Šä¸€æ­¥"æŒ‰é’® (ç°è‰²) */
        .driver-popover button.driver-popover-prev-btn {
            background-color: transparent !important;
            color: #86868b !important;
            box-shadow: none !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
        }

        .driver-popover button.driver-popover-prev-btn:hover {
            background-color: rgba(0,0,0,0.05) !important;
            color: #000 !important;
        }

        /* éšè—é»˜è®¤çš„å°ç®­å¤´ (ç»ç’ƒé£æ ¼å¸¦ç®­å¤´å¾ˆéš¾çœ‹) */
        .driver-popover-arrow {
            display: none !important;
        }

        /* --- ğŸŸ¢ æš—è‰²æ¨¡å¼é€‚é… (Dark Mode) --- */
        html.dark .driver-popover {
            background-color: rgba(30, 30, 30, 0.85) !important;
            border-color: rgba(255, 255, 255, 0.1) !important;
            color: #f5f5f7 !important;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6) !important;
        }

        html.dark .driver-popover .driver-popover-description {
            color: #f5f5f7 !important;
        }

        html.dark .driver-popover button.driver-popover-prev-btn {
            color: #9ca3af !important;
            border-color: rgba(255,255,255,0.1) !important;
        }

        html.dark .driver-popover button.driver-popover-prev-btn:hover {
            background-color: rgba(255,255,255,0.1) !important;
            color: #fff !important;
        }

        /* ğŸŸ¢ æ–°å¢: ä¸“é—¨ä¿®å¤å…³é—­æŒ‰é’® (å‰å·) */
        .driver-popover button.driver-popover-close-btn {
            background-color: transparent !important; /* å»æ‰è“è‰²èƒŒæ™¯ */
            color: #9ca3af !important; /* æ”¹ä¸ºç°è‰²å‰å· */
            box-shadow: none !important; /* å»æ‰é˜´å½± */
            border: none !important;
            font-size: 20px !important; /* ç¨å¾®è°ƒå¤§ä¸€ç‚¹ */
            padding: 0 !important;      /* å»æ‰å†…è¾¹è· */
            width: 32px !important;     /* å›ºå®šå®½é«˜æ–¹ä¾¿ç‚¹å‡» */
            height: 32px !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
            top: 10px !important;       /* å¾®è°ƒä½ç½® */
            right: 10px !important;
        }
        /* é¼ æ ‡æ‚¬åœæ—¶ç¨å¾®å˜æ·±ä¸€ç‚¹ */
        .driver-popover button.driver-popover-close-btn:hover {
            background-color: rgba(0,0,0,0.05) !important;
            color: #1d1d1f !important;
        }
        /* æš—è‰²æ¨¡å¼é€‚é… */
        html.dark .driver-popover button.driver-popover-close-btn:hover {
            background-color: rgba(255,255,255,0.1) !important;
            color: #fff !important;
        }

        /* å®¹å™¨ä¸ä¾§è¾¹æ  (ä¿æŒä¸å˜) */
        /* 3. å¸ƒå±€å®¹å™¨ (ä¿®æ”¹èƒŒæ™¯ä¸ºæ¸å˜é€æ˜) */
        .liquid-window {
            border-radius: 0;
            border: none; /* ç§»é™¤è¾¹æ¡†ï¼Œè®©æ¸å˜è‡ªç„¶èåˆ */
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;

            /* ä¿®æ”¹è¿™é‡Œ: ä½¿ç”¨å åŠ çš„åŠé€æ˜ç™½ï¼Œè®©èƒŒæ™¯çœ‹èµ·æ¥åƒ"ç£¨ç ‚ç»ç’ƒä¸‹çš„ç°è‰²" */
            background: radial-gradient(
                    ellipse at center,
                    rgba(255, 255, 255, 0.6) 0%, /* ä¸­é—´ç¨å¾®äº®ä¸€ç‚¹ */ rgba(240, 242, 245, 0.8) 100% /* è¾¹ç¼˜å˜ç°ï¼Œå¢åŠ å®ä½“æ„Ÿ */
            );
            backdrop-filter: blur(30px);
        }

        html.dark .liquid-window {
            /* ğŸŸ¢ æš—è‰²æ¨¡å¼ï¼šç”±å†…å‘å¤–é€æ¸é€æ˜ */
            background: radial-gradient(
                    ellipse at center,
                    rgba(30, 32, 35, 0.95) 40%, /* ä¸­é—´ï¼šæ·±ç°è‰²ï¼Œå‡ ä¹ä¸é€ */ rgba(30, 32, 35, 0.2) 100% /* è¾¹ç¼˜ï¼šéå¸¸é€æ˜ï¼Œèå…¥èƒŒæ™¯ */
            );
            border: none;
            box-shadow: none; /* ç§»é™¤é˜´å½±ï¼Œå®Œå…¨é æ¸å˜ */
        }

        .glass-sidebar {
            background: rgba(245, 245, 247, 0.5);
            backdrop-filter: blur(40px);
            border-right: 1px solid rgba(0, 0, 0, 0.05);
        }

        html.dark .glass-sidebar {
            background: rgba(40, 40, 40, 0.4);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        * {
            scrollbar-width: none;
        }

        /* ğŸŸ¢ è°ƒæ•´ 2: å…³é”®å°ºå¯¸ä¸å˜é‡ */
        :root {
            --slot-height: 40px; /* é«˜åº¦å¢åŠ åˆ° 60pxï¼Œç»™å¤§å­—ä½“ç•™ç©ºé—´ */
            --time-col-width: 70px; /* æ—¶é—´åˆ—åŠ å®½ï¼Œé˜²æ­¢æ–‡å­—æ¢è¡Œ */
            --grid-line-light: rgba(0, 0, 0, 0.08);
            --grid-line-dark: rgba(255, 255, 255, 0.08);
        }

        .drag-item {
            cursor: grab;
        }

        .drag-item:active {
            cursor: grabbing;
            transform: scale(1.02);
        }

        /* å¡ç‰‡æ ·å¼ */
        .stat-card {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 12px; /* å¢åŠ å†…è¾¹è· */
            margin-bottom: 8px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative;
            border-left-width: 5px; /* åŠ ç²—è¾¹æ¡† */
        }

        html.dark .stat-card {
            background: rgba(60, 60, 60, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: #eee;
        }

        .stat-card:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }

        html.dark .stat-card:hover {
            background: rgba(80, 80, 80, 0.8);
        }

        .time-label-slot {
            height: var(--slot-height);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 12px;
            /* ğŸŸ¢ å­—ä½“åŠ å¤§ */
            font-size: 13px;
            color: #86868b;
            font-weight: 600;

            /* ğŸŸ¢ æ–°å¢: å‘ä¸Šå¹³ç§» 50%ï¼Œä½¿æ–‡å­—ä¸­å¿ƒå¯¹é½è¯¥æ—¶é—´æ ¼çš„é¡¶éƒ¨ç½‘æ ¼çº¿ */
            transform: translateY(-50%);
        }

        .grid-slot {
            height: var(--slot-height);
            border-bottom: 1px solid var(--grid-line-light);
            width: 100%;
            position: relative;
        }

        html.dark .grid-slot {
            border-bottom: 1px solid var(--grid-line-dark);
        }

        .grid-slot:nth-child(odd) {
            border-bottom-style: solid;
        }

        .grid-slot:nth-child(even) {
            border-bottom: none;
        }

        .grid-slot:nth-child(even)::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            border-bottom: 1px dotted var(--grid-line-light);
            opacity: 0.5;
        }

        html.dark .grid-slot:nth-child(even)::after {
            border-bottom-color: var(--grid-line-dark);
        }

        /* ğŸŸ¢ ä¿®å¤: æ—¥ç¨‹å—æ ·å¼ (å·¦ä¾§æ˜¾ç¤ºæ¼”å¥å‘˜é¢œè‰²æ¡) */
        .task-block {
            position: absolute;
            left: 4px;
            right: 2px;
            background: #fafafa !important;

            /* ğŸŸ¢ æ ¸å¿ƒä¿®å¤: å·¦è¾¹æ¡†å®½åº¦è®¾ä¸º 4pxï¼Œé¢œè‰²ç»‘å®šåˆ°å˜é‡ */
            border-left: 4px solid var(--task-border, #007aff) !important;

            border-radius: 6px;
            color: #000 !important;
            font-size: 12px;
            line-height: 1.3;
            overflow: hidden;
            cursor: grab;
            z-index: 10;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            padding: 4px 6px;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            border-right: 1px solid rgba(0, 0, 0, 0.05);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* ğŸŸ¢ ä¿®å¤: æš—è‰²æ¨¡å¼æ—¥ç¨‹å— (åŠ ä¸Š !important ä»¥è¦†ç›–äº®è‰²æ¨¡å¼çš„å¼ºåˆ¶è®¾ç½®) */
        html.dark .task-block {
            /* 1. èƒŒæ™¯è‰²åŠ  !important */
            background: rgba(45, 45, 48, 0.95) !important;

            /* 2. æ–‡å­—é¢œè‰²åŠ  !important */
            color: #f5f5f7 !important;

            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .task-block .secondary-text {
            color: #6e6e73 !important;
            font-size: 11px; /* æ¬¡è¦ä¿¡æ¯ç¨å¾®å¤§ä¸€ç‚¹ */
        }

        html.dark .task-block .secondary-text {
            color: #a1a1a6 !important; /* ç¡®ä¿è¿™é‡Œä¹Ÿæœ‰ !important */
        }

        .task-block.is-selected {
            box-shadow: 0 0 0 2px #0A84FF, 0 8px 16px rgba(0, 0, 0, 0.2);
            z-index: 100 !important;
            transform: scale(1.02);
        }

        html.dark .task-block.is-selected {
            /* æš—è‰²æ¨¡å¼ä¸‹ï¼šä½¿ç”¨ç™½è‰²/äº®è‰²å¤–è½®å»“ï¼Œå¹¶å¢åŠ é˜´å½±å¯¹æ¯”åº¦ */
            box-shadow: 0 0 0 2px #ffffff, /* 3px å®½çš„ç™½è‰²è¾¹æ¡†ï¼Œå¢åŠ å¯¹æ¯”åº¦ */ 0 8px 16px rgba(0, 0, 0, 0.5); /* æ›´é‡çš„é˜´å½± */

            /* ç¡®ä¿ z-index å’Œ transform ä¿æŒä¸å˜ */
            z-index: 100 !important;
            transform: scale(1.02);
        }

        /* å¼¹çª—ä¸æ§ä»¶ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9999;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-window {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(40px) saturate(200%);
            border-radius: 18px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        html.dark .modal-window {
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
        }

        .cursor-ns-resize {
            will-change: transform;
        }

        .segmented-control {
            background: rgba(118, 118, 128, 0.12);
            border-radius: 8px;
            padding: 3px;
            display: flex;
        }

        html.dark .segmented-control {
            background: rgba(118, 118, 128, 0.24);
        }

        .segment-btn {
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            color: #1d1d1f;
            cursor: default;
            transition: all 0.2s;
        }

        html.dark .segment-btn {
            color: #f5f5f7;
        }

        .segment-btn.active {
            background: white;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12), 0 3px 1px rgba(0, 0, 0, 0.04);
            color: black;
        }

        html.dark .segment-btn.active {
            background: #636366;
            color: white;
        }

        .glass-input {
            /* ğŸŸ¢ ä¿®æ”¹: èƒŒæ™¯æ”¹ä¸ºåŠé€æ˜ç™½è‰² */
            background: rgba(255, 255, 255, 0.8);

            /* åŠ æ·±æ–‡å­—é¢œè‰² */
            color: #111;

            /* ğŸŸ¢ æ–°å¢: å¼ºåˆ¶æ˜¾ç¤ºå…‰æ ‡é¢œè‰² (è®¾ä¸ºè“è‰²ï¼Œæˆ–è€…ç”¨ currentColor è·Ÿéšæ–‡å­—) */
            caret-color: #007aff;

            /* ğŸŸ¢ æ–°å¢: å¼ºåˆ¶å…è®¸é€‰ä¸­ (è§£å†³å…‰æ ‡æ¶ˆå¤±çš„æ ¸å¿ƒ) */
            -webkit-user-select: text !important;
            user-select: text !important;

            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 13px;
            transition: all 0.2s;
        }



        /* èšç„¦æ—¶ */
        .glass-input:focus {
            background: #fff;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        /* æš—è‰²æ¨¡å¼ä¸‹å…‰æ ‡æ”¹ä¸ºç™½è‰² */
        html.dark .glass-input {
            background: rgba(255, 255, 255, 0.1);
            color: inherit;
            border-color: transparent;

            /* ğŸŸ¢ æ–°å¢: æš—è‰²æ¨¡å¼å…‰æ ‡å˜ç™½ */
            caret-color: #fff;
        }

        html.dark .glass-input:focus {
            background: rgba(255, 255, 255, 0.15);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .resize-handle {
            height: 10px;
            opacity: 0;
            transition: opacity 0.2s;
            background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));
            cursor: ns-resize;
            position: absolute;
            bottom: 0;
            width: 100%;
        }

        .task-block:hover .resize-handle {
            opacity: 1;
        }

        /* --- ğŸŸ¢ ä¿®æ”¹åçš„ CSS: æ·¡é»„è‰²å‘¼å¸é—ªçƒ (2æ¬¡) --- */
        @keyframes flash-highlight {
            0%, 100% {
                /* èµ·å§‹å’Œç»“æŸï¼šå®Œå…¨é€æ˜ */
                box-shadow: 0 0 0 0 rgba(250, 204, 21, 0);
            }
            50% {
                /* ä¸­é—´çŠ¶æ€ï¼šæ·¡é»„è‰²å…‰æ™•ï¼Œ4px å®½åº¦ï¼Œ0.6 é€æ˜åº¦ */
                box-shadow: 0 0 0 4px rgba(250, 204, 21, 0.6);
            }
        }

        .is-flashing {
            /* å°†åŠ¨ç”»æ—¶é•¿ä» 0.8s å¢åŠ åˆ° 1.2sï¼Œä½¿å…¶å‘¼å¸æ›´ç¼“æ…¢æŸ”å’Œ */
            /* è®¾ç½®ä¸º infiniteï¼Œç”± JS çš„å®šæ—¶å™¨æ¥è´Ÿè´£ç§»é™¤ç±»ååœæ­¢åŠ¨ç”» */
            animation: flash-highlight 1.2s ease-in-out infinite;
            z-index: 110 !important; /* ç¡®ä¿é—ªçƒæ—¶å±‚çº§æœ€é«˜ï¼Œä¸è¢«é®æŒ¡ */
        }

        /* --- V11.7 æ–°å¢: å¤šæ—¥ç¨‹(Session) å¹½çµæ¨¡å¼æ ·å¼ --- */
        .task-block.is-ghost {
            /* ç°è‰²æ–œçº¿èƒŒæ™¯ï¼Œè¡¨ç¤ºä¸å¯ç”¨ */
            background: repeating-linear-gradient(
                    45deg,
                    rgba(200, 200, 200, 0.3),
                    rgba(200, 200, 200, 0.3) 10px,
                    rgba(180, 180, 180, 0.3) 10px,
                    rgba(180, 180, 180, 0.3) 20px
            ) !important;
            border-left-color: #9ca3af !important; /* ç°è‰²è¾¹æ¡† */
            color: #6b7280 !important; /* ç°è‰²æ–‡å­— */
            opacity: 0.6;
            pointer-events: auto !important; /* å…³é”®ï¼šç¦æ­¢é¼ æ ‡ç‚¹å‡»ã€æ‹–æ‹½ */
            filter: grayscale(100%); /* å¼ºåˆ¶é»‘ç™½ */
            z-index: 0 !important; /* å±‚çº§æœ€ä½ï¼Œå«åœ¨åº•ä¸‹ */
        }

        /* --- ğŸŸ¢ æ–°å¢: æœˆè§†å›¾å¹½çµæ ·å¼ --- */
        /* ç›®æ ‡: åŒ¹é… .grid-cols-7 å†…éƒ¨çš„ .text-[11px] ä»»åŠ¡æ¡ */
        .grid-cols-7 .text-\[11px\].is-ghost {
            /* ç»§æ‰¿ Week View çš„ç°è‰²æ–œçº¿èƒŒæ™¯ */
            background: repeating-linear-gradient(
                    45deg,
                    rgba(200, 200, 200, 0.3),
                    rgba(200, 200, 200, 0.3) 10px,
                    rgba(180, 180, 180, 0.3) 10px,
                    rgba(180, 180, 180, 0.3) 20px
            ) !important; /* å¼ºåˆ¶è¦†ç›– inline style */
            color: #6b7280 !important; /* ç°è‰²æ–‡å­— */
            opacity: 0.6;
            box-shadow: none !important; /* ç§»é™¤é˜´å½±ï¼Œé™ä½è§†è§‰å¹²æ‰° */
            border: 1px solid rgba(180, 180, 180, 0.3); /* æ·»åŠ ä¸€ä¸ªå¾®å¼±çš„è¾¹æ¡† */
            pointer-events: auto; /* ç¡®ä¿å¯ä»¥åŒå‡»è·³è½¬ */
        }

        /* ğŸŸ¢ æš—è‰²æ¨¡å¼é€‚é… */
        html.dark .grid-cols-7 .text-\[11px\].is-ghost {
            background: repeating-linear-gradient(
                    45deg,
                    rgba(60, 60, 60, 0.3),
                    rgba(60, 60, 60, 0.3) 10px,
                    rgba(80, 80, 80, 0.3) 10px,
                    rgba(80, 80, 80, 0.3) 20px
            ) !important;
            color: #9ca3af !important;
            border-color: rgba(80, 80, 80, 0.3);
        }

        /* ğŸŸ¢ ä¿®å¤: æœˆè§†å›¾å¹½çµå°åœ†ç‚¹é¢œè‰² */
        .grid-cols-7 .text-\[11px\].is-ghost .w-1\.5.h-1\.5 {
            background-color: #9ca3af !important;
        }

        html.dark .task-block.is-ghost {
            background: repeating-linear-gradient(
                    45deg,
                    rgba(60, 60, 60, 0.3),
                    rgba(60, 60, 60, 0.3) 10px,
                    rgba(80, 80, 80, 0.3) 10px,
                    rgba(80, 80, 80, 0.3) 20px
            ) !important;
            border-left-color: #4b5563 !important;
            color: #9ca3af !important;
        }

        @keyframes menu-slide-in {
            from {
                opacity: 0;
                transform: translateY(-8px) scale(0.98);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* ğŸŸ¢ ä¿®å¤: ç”¨æˆ·èœå• (æ”¹ä¸º Fixed å®šä½ï¼Œå½»åº•æ‘†è„±çˆ¶å®¹å™¨é™åˆ¶) */
        .mobile-user-menu {
            /* 1. æ ¸å¿ƒä¿®æ”¹: ä½¿ç”¨ fixed å®šä½ï¼Œç›´æ¥ç›¸å¯¹äºå±å¹•çª—å£ */
            position: fixed !important;

            /* 2. å‚ç›´å®šä½: é¡¶éƒ¨è·ç¦» = Headeré«˜åº¦ (çº¦60-70px) + é—´è· */
            /* ä½¿ç”¨ calc åŠ¨æ€è®¡ç®—ï¼Œé¿å¼€é¡¶éƒ¨å¯¼èˆªæ  */
            top: 76px !important;

            /* 3. æ°´å¹³å®šä½: è·ç¦»å±å¹•å³è¾¹ç¼˜ 16px (ä¸é¡µé¢ Padding ä¿æŒä¸€è‡´) */
            right: 30px !important;

            /* 4. æ¸…é™¤æ—§çš„å®šä½å¹²æ‰° */
            left: auto !important;
            margin: 0 !important;

            /* 5. å†…éƒ¨æ ·å¼ä¼˜åŒ– */
            padding: 24px !important;
            width: 320px !important;
            max-width: calc(100vw - 32px) !important;

            /* 6. åŠ¨ç”»åŸç‚¹ */
            transform-origin: top right !important;

            /* 7. ç¡®ä¿å±‚çº§æœ€é«˜ */
            z-index: 99999 !important;
        }

        .ease-spring {
            transition-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1.1);
        }

        /* ğŸŸ¢ ä¿®æ”¹: å…¨å±€åŠ è½½é¡µæ ·å¼ (æ¶²æ€ç£¨ç ‚é£æ ¼) */
        #global-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* ä½¿ç”¨ä¸ App ä¸€è‡´çš„æ·±è‰²æ¸å˜èƒŒæ™¯ */
            background: radial-gradient(at 0% 0%, hsla(253, 16%, 7%, 1) 0, transparent 50%),
            radial-gradient(at 50% 0%, hsla(225, 39%, 30%, 1) 0, transparent 50%),
            radial-gradient(at 100% 0%, hsla(339, 49%, 30%, 1) 0, transparent 50%),
            #121212; /* åº•è‰² */
            background-size: cover;
            z-index: 99999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.6s;
        }

        /* ç»ç’ƒè´¨æ„Ÿå®¹å™¨ */
        .loader-glass-box {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* ç°ä»£åŒ–çš„åŠ è½½åœˆ */
        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #007aff;
            border-right-color: #a855f7; /* æ¸å˜è‰²æ•ˆæœ */
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 20px;
        }

        .loader-text {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: pulse 2s infinite;
        }

        #global-loader.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transform: scale(1.05); /* æ¶ˆå¤±æ—¶è½»å¾®æ”¾å¤§ */
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        @keyframes pulse {
            0%, 100% {
                opacity: 0.6;
            }
            50% {
                opacity: 1;
            }
        }

        /* ğŸŸ¢ æœ€ç»ˆç‰ˆ: æç®€æ‰‹æœºé€‚é… (å…è®¸æ»šåŠ¨ï¼Œæ— é®æŒ¡) */
        @media (max-width: 800px) and (hover: none) {
            /* ğŸŸ¢ æ ¸å¿ƒä¿®å¤: é”æ­»é¡µé¢ï¼Œé˜²æ­¢é”®ç›˜é¡¶èµ·èƒŒæ™¯ */
            html, body {
                position: fixed !important; /* å¼ºåˆ¶å›ºå®šï¼Œä¸éšå†…å®¹æ»šåŠ¨ */
                width: 100%;
                height: 100%;
                height: 100dvh; /* å…¼å®¹åŠ¨æ€é«˜åº¦ */
                overflow: hidden !important; /* ç¦æ­¢æº¢å‡º */
                overscroll-behavior: none; /* ç¦æ­¢æ©¡çš®ç­‹æ•ˆæœ */
                touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ§è¡Œä¸º (ç”±å†…éƒ¨å®¹å™¨æ¥ç®¡) */
            }

            /* ç¡®ä¿åº”ç”¨å®¹å™¨å æ»¡å±å¹• */
            #app {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                overflow: hidden; /* #app æœ¬èº«ä¹Ÿä¸æ»šåŠ¨ï¼Œåªè®© main-content æ»šåŠ¨ */
            }

            body {
                min-width: 0 !important;      /* æ‰‹æœºç«¯ä¸éœ€è¦æœ€å°å®½åº¦ */
                overflow: hidden !important;  /* æ‰‹æœºç«¯æ¢å¤ç¦æ­¢æ»šåŠ¨ï¼Œä½“éªŒæ›´åƒåŸç”ŸApp */
                overflow-x: hidden !important;
            }

            /* 2. éšè—æ— å…³å…ƒç´  */
            .cursor-ew-resize {
                display: none !important;
            }

            .liquid-window {
                border-radius: 0 !important; /* å»æ‰çª—å£åœ†è§’ï¼Œå˜æˆç›´è§’ */
                border: none !important;
                box-shadow: none !important;
            }

            /* 4. ä¾§è¾¹æ  (ä»»åŠ¡æ± ) - ğŸŸ¢ ä¿®å¤: èƒŒæ™¯å¿…é¡»ææ·¡ï¼Œå¦åˆ™æŒ¡ä½åº•å±‚ç”»é¢ï¼Œå¯¼è‡´ä¸Šå±‚æ— æ³•æ¨¡ç³Š */
            #sidebar {
                position: fixed !important;
                top: 64px;
                left: 0;
                right: 0;
                bottom: 0 !important;
                padding-bottom: calc(80px + env(safe-area-inset-bottom)) !important;
                z-index: 40;
                width: 100% !important;

                /* ğŸŸ¢ å…³é”®ä¿®æ”¹: èƒŒæ™¯é¢œè‰²é€æ˜åº¦é™åˆ° 0.1 */
                background: rgba(255, 255, 255, 0.1) !important;

                /* ä¾§è¾¹æ è‡ªå·±ä¹Ÿè¦æœ‰æ¨¡ç³Šï¼Œå½¢æˆå±‚æ¬¡æ„Ÿ */
                backdrop-filter: blur(30px) saturate(150%) !important;
                -webkit-backdrop-filter: blur(30px) saturate(150%) !important;

                overflow-y: auto !important;
            }

            /* æš—è‰²æ¨¡å¼é€‚é… */
            html.dark #sidebar {
                background: rgba(30, 30, 30, 0.4) !important;
            }

            /* 5. ä¸»å†…å®¹åŒº (æ—¥ç¨‹è¡¨) */
            #main-content {
                position: fixed !important;
                top: 64px;
                left: 0;
                right: 0;
                bottom: 0 !important; /* å æ»¡åˆ°åº•éƒ¨ */
                padding-bottom: calc(60px + env(safe-area-inset-bottom)) !important; /* ğŸŸ¢ å…³é”®: ç”¨ padding æ’‘å¼€åº•éƒ¨ç©ºé—´ */
                z-index: 30;
                overflow-y: auto !important; /* ğŸŸ¢ å…³é”®: å…è®¸æ»šåŠ¨ */
            }

            /* 6. ç´§å‡‘åŒ–æ˜¾ç¤º */
            .task-block {
                padding: 2px 4px !important;
                border-left-width: 3px !important;
            }

            .stat-card {
                padding: 8px !important;
                border-left-width: 3px !important;
            }

            .is-zooming-now .task-block {
                transition: none !important;
            }

            :root {
                --time-col-width: 40px;
            }

            .pb-safe {
                padding-bottom: env(safe-area-inset-bottom);
            }

            .time-label-slot {
                font-size: 10px !important; /* å­—ä½“æ”¹å° */
                padding-right: 4px !important; /* å‡å°‘å³è¾¹è· */
                justify-content: center !important; /* å±…ä¸­å¯¹é½ */
            }

            /* ğŸŸ¢ ä¿®å¤å: ç§»é™¤å¤šä½™çš„ padding */
            .fixed.bottom-0 {
                /* åˆ é™¤è¿™è¡Œï¼Œå› ä¸ºå†…éƒ¨çš„ div å·²ç»æœ‰ .pb-safe ç±»äº†ï¼Œä¸éœ€è¦è¿™é‡Œå†åŠ ä¸€æ¬¡ */
                /* padding-bottom: env(safe-area-inset-bottom); */

                margin-bottom: 0px;
                /* å»ºè®®æŠŠèƒŒæ™¯è‰²ä¹Ÿå»æ‰ï¼Œå› ä¸ºé‡Œé¢çš„ div å·²ç»æœ‰èƒŒæ™¯è‰²äº†ï¼Œè¿™é‡Œä¿ç•™å¯èƒ½å¯¼è‡´é€æ˜åº¦å åŠ  */
                background-color: transparent;
            }

            html.dark .fixed.bottom-0 {
                background-color: rgba(28, 28, 30, 0.95);
            }

            #sidebar, #main-content {
                /* ğŸŸ¢ ä¿®æ”¹: ç§»é™¤æ‰€æœ‰å†…è¾¹è·ï¼Œè®©å†…å®¹å¡«æ»¡å±å¹• */
                padding-bottom: 0 !important;
                padding-left: 0 !important;
                padding-right: 0 !important;
            }

            /* 2. é’ˆå¯¹ã€ç”¨æˆ·å¤´åƒå¼¹çª—ã€‘(ğŸŸ¢ ä¿®å¤: å¢åŠ è¾¹ç•Œé˜²æ’ä¿æŠ¤) */
            .mobile-user-menu {
                /* 1. å‚ç›´å®šä½ï¼šHeaderåŸºç¡€é«˜åº¦(50px) + å®‰å…¨åŒºåŸŸ + é—´è·(8px) */
                /* ğŸ”´ ä¿®å¤: åŠ¨æ€è®¡ç®— Top å€¼ï¼Œç¡®ä¿åœ¨åˆ˜æµ·å±ä¸‹ä¹Ÿèƒ½ç´§è´´ Header ä¸‹æ–¹ */
                top: calc(50px + env(safe-area-inset-top) + 8px) !important;

                /* 2. æ°´å¹³å®šä½ï¼šè·ç¦»å³è¾¹ 16px (ä¸ Header å›¾æ ‡å¯¹é½) */
                right: 16px !important;

                /* 3. ä¿æŒå·¦ä¾§è‡ªåŠ¨ï¼Œé å³å±•å¼€ */
                left: auto !important;

                /* 4. åŠ¨ç”»åŸç‚¹è®¾ä¸ºå³ä¸Šè§’ */
                transform-origin: top right !important;

                /* 5. é™åˆ¶æœ€å¤§å®½åº¦ */
                max-width: calc(100vw - 32px) !important;

                /* ç§»é™¤ä¹‹å‰çš„ margin-topï¼Œå› ä¸º top å·²ç»ç®—å‡†äº† */
                margin-top: 0 !important;
            }

            /* 3. é’ˆå¯¹ã€ä¸­é—´ Session å¼¹çª—ã€‘çš„ç‰¹æ®Šä¿®æ­£ */
            /* æ‰¾åˆ°ä¸­é—´é‚£ä¸ªå®¹å™¨é‡Œçš„èœå• */
            .flex-1.flex.justify-center .custom-dropdown-menu {
                left: 50% !important;
                right: auto !important;
                transform: translateX(-50%) !important; /* æ°´å¹³å±…ä¸­ */
                transform-origin: top center !important; /* åŠ¨ç”»ä»é¡¶éƒ¨ä¸­é—´å±•å¼€ */
            }

            /* ... ä¹‹å‰çš„æ‰‹æœºç«¯æ ·å¼ ... */
            /* ğŸŸ¢ æ–°å¢: æ‰‹æœºç«¯æœˆè§†å›¾æ·±åº¦é€‚é… (ä»¿ iOS) */
            /* 1. æ˜ŸæœŸè¡¨å¤´: æç®€ã€ç¼©å° */
            .grid-cols-7 .p-3.text-right {
                padding: 4px !important;
                text-align: center !important;
                font-size: 10px !important;
                height: 24px !important;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* 2. æ—¥æœŸæ ¼å­: é«˜åº¦å‹ç¼©ï¼Œå»æ‰ä¸å¿…è¦çš„ç•™ç™½ */
            .grid-cols-7 .droppable-slot {
                height: auto !important;
                min-height: 50px !important; /* è®¾å®šæœ€å°é«˜åº¦ï¼Œç”±å†…å®¹æ’‘å¼€ */
                aspect-ratio: 0.5; /* ä¿æŒç±»ä¼¼æ—¥å†çš„æ¯”ä¾‹ */
                padding: 2px !important;
            }

            /* 3. æ—¥æœŸæ•°å­—: å±…ä¸­ã€å˜å° */
            .grid-cols-7 .text-right.mb-1 {
                text-align: center !important;
                margin-bottom: 2px !important;
            }

            .grid-cols-7 .text-sm.font-bold.w-7.h-7 {
                width: 20px !important;
                height: 20px !important;
                font-size: 12px !important;
                line-height: 20px !important;
            }

            /* 4. ä»»åŠ¡æ¡: å˜æˆè¶…è¿·ä½ çš„è‰²å— (Micro-bars) */
            .grid-cols-7 .space-y-1 .text-\[11px\] {
                font-size: 8px !important; /* æå°å­—ä½“ */
                padding: 1px 3px !important; /* æå°å†…è¾¹è· */
                height: 14px !important; /* å›ºå®šé«˜åº¦ */
                border-radius: 2px !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                display: flex !important;
                align-items: center !important;
            }

            /* éšè—ä»»åŠ¡æ¡å‰é¢çš„å°åœ†ç‚¹ (å¤ªå åœ°äº†) */
            .grid-cols-7 .space-y-1 .w-1\.5.h-1\.5 {
                display: none !important;
            }

            /* éšè—å…·ä½“æ—¶é—´ (å¤ªå åœ°äº†)ï¼Œåªæ˜¾ç¤ºåå­— */
            .grid-cols-7 .space-y-1 .font-mono.opacity-80 {
                display: none !important;
            }

            /* --- ğŸŸ¢ ä¿®å¤çµåŠ¨å²›/åˆ˜æµ·å±é®æŒ¡é—®é¢˜ --- */
            /* 1. å®šä¹‰é¡¶éƒ¨é«˜åº¦å˜é‡ï¼šåŸºç¡€é«˜åº¦ 64px + å®‰å…¨åŒºåŸŸé«˜åº¦ */
            :root {
                --header-base-height: 50px;
                --safe-top: env(safe-area-inset-top); /* è·å–ç³»ç»Ÿå®‰å…¨åŒºåŸŸé«˜åº¦ */
                --header-total-height: calc(var(--header-base-height) + var(--safe-top));
            }

            /* ğŸŸ¢ ä¿®å¤ 2: é¡¶éƒ¨ Header å¢åŠ å‘¼å¸ç©ºé—´ï¼Œé˜²æ­¢è´´è¾¹ */
            /* ğŸŸ¢ ä¿®å¤: é¡¶éƒ¨ Header é€æ˜åŒ– (ç§»é™¤é»‘è‰²èƒŒæ™¯å’Œè¾¹æ¡†) */
            header {
                padding-left: 16px !important;
                padding-right: 16px !important;

                /* é€‚é…åˆ˜æµ·å±é«˜åº¦ */
                height: var(--header-total-height) !important;
                padding-top: env(safe-area-inset-top) !important;

                /* ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: èƒŒæ™¯å…¨é€æ˜ï¼Œå»æ‰è¾¹æ¡† */
                background-color: transparent !important;
                backdrop-filter: none !important; /* å¦‚æœä¸éœ€è¦ç£¨ç ‚ä¹Ÿå»æ‰ï¼Œæˆ–è€…ä¿ç•™ blur(20px) */
                border-bottom: none !important;

                /* ç¡®ä¿å®ƒæ‚¬æµ®åœ¨å†…å®¹ä¹‹ä¸Š */
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 50;
            }

            /* æš—è‰²æ¨¡å¼ä¸‹ä¹Ÿå¼ºåˆ¶é€æ˜ */
            html.dark header {
                /* ğŸŸ¢ ä¿®å¤: ç»™æ‰‹æœºç«¯æš—è‰²æ¨¡å¼åŠ æ·±èƒŒæ™¯ï¼Œé˜²æ­¢å‘ç™½ (0.6 = 60% é»‘è‰²) */
                background-color: rgba(0, 0, 0, 0.3) !important;

                /* å¯é€‰: å¦‚æœå¸Œæœ›æ¨¡ç³ŠèƒŒæ™¯ï¼Œå¯ä»¥åŠ ä¸Šè¿™è¡Œ */
                backdrop-filter: blur(20px) !important;

                border-bottom: none !important;
            }

            /* 3. è°ƒæ•´æ‰‹æœºç«¯ä¾§è¾¹æ å’Œä¸»å†…å®¹çš„ top ä½ç½® */
            @media (max-width: 800px) {
                #sidebar,
                #main-content {
                    /* è¿™é‡Œçš„ top å¿…é¡»ç­‰äº header çš„æ–°é«˜åº¦ï¼Œå¦åˆ™ä¼šè¢« header æŒ¡ä½ */
                    top: var(--header-total-height) !important;
                }

                /* 4. å¦‚æœå…¨å±åŠ è½½é¡µä¹Ÿè¢«æŒ¡ä½äº†ï¼Œä¹Ÿä¿®ä¸€ä¸‹ */
                #global-loader {
                    padding-top: var(--safe-top);
                }
            }
        }

        /* ğŸŸ¢ ä¿®æ”¹: å¼ºåŠ›éšè—æµè§ˆå™¨åŸç”Ÿçš„æ—¶é—´é€‰æ‹©å›¾æ ‡ */
        input[type="time"]::-webkit-calendar-picker-indicator {
            background: transparent !important;
            display: none !important;
            -webkit-appearance: none !important;
            width: 0 !important;
            height: 0 !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* --- ğŸŸ¢ æ–°å¢: æ°”æ³¡é£æ ¼æ—¶é—´é€‰æ‹©å™¨ (ä»¿ iOS/VisionOS) --- */
        .bubble-picker-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            /* èƒŒæ™¯é€æ˜ï¼Œä¸å†éœ€è¦å˜æš—ï¼Œç‚¹å‡»ç©ºç™½å¤„å…³é—­ */
            background: transparent;
        }

        .bubble-picker-box {
            position: fixed; /* ä½¿ç”¨ fixed å®šä½ï¼Œé€šè¿‡ JS è®¡ç®—åæ ‡ */
            width: 280px;
            height: 320px;
            background: rgba(255, 255, 255, 0.95); /* ç•¥å¾®é€ç™½çš„èƒŒæ™¯ */
            backdrop-filter: blur(20px);
            border-radius: 32px; /* å¤§åœ†è§’ */
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05),
            0 20px 50px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            overflow: visible; /* å…è®¸å°ä¸‰è§’æº¢å‡º */
            animation: bubblePop 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        html.dark .bubble-picker-box {
            background: rgba(40, 40, 40, 0.95);
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1), 0 20px 50px rgba(0, 0, 0, 0.5);
        }


        html.dark .bubble-picker-box::after {
            border-color: rgba(40, 40, 40, 0.95) transparent transparent transparent;
        }

        /* ğŸŸ¢ ä¿®å¤: æ»šè½®åŒºåŸŸå¢åŠ  hidden é˜²æ­¢æº¢å‡º */
        .bubble-columns {
            flex: 1;
            display: flex;
            justify-content: center;
            position: relative;
            overflow: hidden; /* å…³é”®ï¼šå‰ªè£æº¢å‡ºçš„æ•°å­—ï¼Œé˜²æ­¢å®ƒä»¬è·‘åˆ°ç™½è‰²å¡ç‰‡å¤–é¢ */

            /* é®ç½©ä¿æŒä¸å˜ï¼Œç”¨äºä¸Šä¸‹æ¸éšæ•ˆæœ */
            mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);

            /* ç§»é™¤ä¹‹å‰çš„ padding-topï¼Œæ”¹ç”¨ flex å¸ƒå±€å¯¹é½ */
            margin-top: 20px;
            border-radius: 32px 32px 0 0; /* é¡ºä¾¿ä¿®å¤é¡¶éƒ¨åœ†è§’æº¢å‡º */
        }

        /* ğŸŸ¢ ä¿®å¤: è°ƒæ•´ padding ç¡®ä¿æ•°å­—å®Œç¾å±…ä¸­ */
        .bubble-col {
            flex: 1;
            overflow-y: auto;
            scroll-behavior: smooth;
            scroll-snap-type: y mandatory;
            height: 100%;

            /* è®¡ç®—å…¬å¼: (å®¹å™¨é«˜åº¦ - é€‰ä¸­é¡¹é«˜åº¦) / 2
               å®¹å™¨é«˜åº¦çº¦ 220px (320 - 80 footer - 20 margin)
               é€‰ä¸­é¡¹é«˜åº¦ 44px
               (220 - 44) / 2 = 88px
            */
            padding: 88px 0;
            z-index: 1;
        }

        /* éšè—æ»šåŠ¨æ¡ */
        .bubble-col::-webkit-scrollbar {
            display: none;
        }

        .bubble-item {
            height: 44px;
            line-height: 44px; /* åŠ é«˜ä¸€ç‚¹ï¼Œæ›´æ˜“ç‚¹å‡» */
            text-align: center;
            font-size: 26px; /* å­—ä½“åŠ å¤§ */
            font-weight: 400;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif;
            scroll-snap-align: center;
            color: #000;
            opacity: 0.3;
            transition: opacity 0.2s, transform 0.2s;
        }

        html.dark .bubble-item {
            color: #fff;
        }

        /* é€‰ä¸­æ€é«˜äº® (JSæ§åˆ¶ç±»å) */
        .bubble-item.active-item {
            opacity: 1;
            font-weight: 600;
        }

        /* åº•éƒ¨æŒ‰é’®æ  */
        .bubble-footer {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
        }

        /* Reset æŒ‰é’® (ç°è‰²èƒ¶å›Š) */
        .btn-reset {
            padding: 10px 24px;
            background: rgba(0, 0, 0, 0.05);
            color: #000;
            font-size: 16px;
            font-weight: 600;
            border-radius: 999px; /* èƒ¶å›Šåœ†è§’ */
            transition: background 0.2s;
        }

        html.dark .btn-reset {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .btn-reset:active {
            opacity: 0.7;
        }

        /* Confirm æŒ‰é’® (è“è‰²åœ†å½¢å¯¹å‹¾) */
        .btn-confirm {
            width: 56px;
            height: 56px;
            background: #007aff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
            transition: transform 0.1s;
        }

        .btn-confirm:active {
            transform: scale(0.95);
        }

        @keyframes bubblePop {
            0% {
                opacity: 0;
                transform: scale(0.9) translateY(10px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* --- ğŸŸ¢ ç§»åŠ¨ç«¯åŸç”Ÿ App é£æ ¼é‡ç½® (Mobile First UI) --- */

        /* 1. å…¨å±€å­—ä½“ä¸è§¦æ„Ÿä¼˜åŒ– */
        body {
            /* ä½¿ç”¨ iOS ç³»ç»Ÿå­—ä½“æ ˆ */
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", system-ui, sans-serif;
            -webkit-tap-highlight-color: transparent; /* å»é™¤ç‚¹å‡»é«˜äº®è‰²å— */
            min-width: 800px;
            /* 2. å…³é”®ä¿®æ”¹: å…è®¸æ¨ªå‘æ»šåŠ¨ï¼Œé˜²æ­¢å†…å®¹è¢«åˆ‡æ‰ */
            overflow-x: auto;
            overflow-y: hidden; /* ä¿æŒå‚ç›´æ–¹å‘ç”±å†…éƒ¨å®¹å™¨æ»šåŠ¨ */
        }

        /* 2. å¤§åœ†è§’è¾“å…¥æ¡† (Big Inputs) */
        .mobile-input-group {
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.03);
            margin-bottom: 12px;
        }

        html.dark .mobile-input-group {
            background: rgba(40, 40, 40, 0.6);
            border-color: rgba(255, 255, 255, 0.05);
        }

        /* 3. å·¨å¤§çš„åˆ—è¡¨æŒ‰é’® (List Item Buttons) */
        .mobile-list-btn {
            height: 64px !important; /* å¢å¤§é«˜åº¦ */
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            font-size: 18px !important;
            font-weight: 600;
            width: 100%;
            border-radius: 20px !important;
            transition: background 0.2s;
            margin-bottom: 12px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.03);
        }

        .mobile-list-btn:active {
            background-color: rgba(0, 0, 0, 0.05);
            transform: scale(0.98);
        }

        html.dark .mobile-list-btn:active {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* 4. æ‚¬æµ®åº•éƒ¨å¯¼èˆªæ  (Floating Tab Bar) */
        .mobile-tab-bar {
            position: fixed;
            bottom: 24px; /* è·ç¦»åº•éƒ¨æ‚¬æµ® */
            left: 20px;
            right: 20px;
            height: 70px; /* åŠ é«˜ */
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(25px) saturate(180%);
            border-radius: 35px; /* èƒ¶å›Šå½¢çŠ¶ */
            display: flex;
            align-items: center;
            justify-content: space-around;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15),
            0 0 0 1px rgba(255, 255, 255, 0.2);
            z-index: 900;
            padding: 0 10px;
        }

        html.dark .mobile-tab-bar {
            background: rgba(30, 30, 30, 0.85);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .mobile-tab-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            color: #8e8e93;
        }

        .mobile-tab-item.active {
            color: #fff;
            background: #007aff;
            transform: translateY(-10px); /* é€‰ä¸­æ—¶ç¨å¾®ä¸Šæµ® */
            box-shadow: 0 8px 20px rgba(0, 122, 255, 0.4);
        }

        .mobile-tab-item i {
            font-size: 22px;
            margin-bottom: 2px;
        }

        .mobile-tab-item span {
            font-size: 10px;
            font-weight: 600;
        }

        .mobile-tab-item.active span {
            display: none;
        }

        /* é€‰ä¸­æ—¶åªæ˜¾ç¤ºå¤§å›¾æ ‡ */
        .mobile-tab-item.active i {
            font-size: 26px;
            margin-bottom: 0;
        }

        /* 5. ä¼˜åŒ–åçš„ç»Ÿè®¡å¡ç‰‡ (Widget Style) */
        .mobile-stat-card {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 24px; /* å¤§åœ†è§’ */
            padding: 16px 20px;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.4);
            position: relative;
            overflow: hidden;
        }

        html.dark .mobile-stat-card {
            background: rgba(40, 40, 40, 0.6);
            border-color: rgba(255, 255, 255, 0.05);
        }

        /* 6. é¡¶éƒ¨æ—¥æœŸå¯¼èˆªæ ä¼˜åŒ– */
        .mobile-header-nav {
            height: 56px;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 100px;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin: 16px 16px;
        }

        /* ğŸŸ¢ ä¿®å¤: æš—è‰²æ¨¡å¼é¡¶éƒ¨å¯¼èˆªæ  (æ”¹ä¸ºç™½è‰²ä½é€æ˜åº¦ï¼Œå½¢æˆé«˜çº§ç°) */
        html.dark .mobile-header-nav {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.15);
        }

        /* æ·»åŠ åˆ° style æ ‡ç­¾å†… */
        .settings-item-input {
            /* ğŸŸ¢ æ ¸å¿ƒä¿®å¤: å¼ºåˆ¶å…è®¸é€‰ä¸­ï¼Œä¸”æ‹¥æœ‰æ–‡æœ¬å…‰æ ‡ */
            -webkit-user-select: text !important;
            user-select: text !important;
            cursor: text !important;

            /* ğŸŸ¢ æ ¸å¿ƒä¿®å¤: å¼ºåˆ¶æŒ‡å®šå…‰æ ‡é¢œè‰² (äº®è‰²ç”¨è“ï¼Œæš—è‰²ç”¨ç™½) */
            caret-color: #007aff;
        }

        html.dark .settings-item-input {
            caret-color: #fff;
        }

        /* ğŸŸ¢ æ–°å¢: æ‰‹æœºç«¯è°ƒæ•´æ—¶é•¿æ‰‹æŸ„ */
        .mobile-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px; /* å¢å¤§è§¦æ‘¸çƒ­åŒºï¼Œæ–¹ä¾¿æ‰‹æŒ‡æŒ‰ä½ */
            z-index: 20;
            display: flex;
            align-items: flex-end; /* é ä¸‹å¯¹é½ */
            justify-content: center;
            padding-bottom: 4px;
            cursor: ns-resize;
            /* åªæœ‰æ‰‹æœºç«¯æ˜¾ç¤ºï¼Œç”µè„‘ç«¯éšè— (ç”µè„‘ç«¯ç”¨ hover) */
            opacity: 1;
            touch-action: none;
        }

        /* è§†è§‰ä¸Šçš„å°æ¨ªæ¡ */
        .mobile-resize-bar {
            width: 32px;
            height: 4px;

            /* ğŸŸ¢ ä¿®æ”¹: ç§»é™¤åè‰²æ»¤é•œï¼Œç›´æ¥ç”¨åŠé€æ˜é»‘è‰² */
            background-color: rgba(0, 0, 0, 0.1);

            border-radius: 2px;
            /* backdrop-filter: invert(1); ğŸ‘ˆ åˆ é™¤è¿™è¡Œ */
        }

        /* æš—è‰²æ¨¡å¼ä¸‹ç”¨åŠé€æ˜ç™½è‰² */
        html.dark .mobile-resize-bar {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* ğŸŸ¢ æœ€ç»ˆå®Œç¾ç‰ˆï¼šå¹³è¡¡äº†ã€æ¸…æ™°åº¦ã€‘ä¸ã€ç£¨ç ‚æ„Ÿã€‘ */
        .custom-dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 8px;
            padding: 4px 4px 0 4px !important;

            /* --- äº®è‰²æ¨¡å¼è®¾ç½® --- */
            /* 0.75 æ˜¯äº®è‰²æ¨¡å¼çš„æœ€ä½³ç£¨ç ‚å€¼ */
            background-color: rgba(255, 255, 255, 0.99) !important;

            /* iOS é£æ ¼å¼ºåŠ›æ¨¡ç³Š */
            -webkit-backdrop-filter: blur(25px) saturate(180%) !important;
            backdrop-filter: blur(25px) saturate(180%) !important;

            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 16px;

            /* äº®è‰²æ¨¡å¼é˜´å½± */
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.2);

            z-index: 9999 !important;
            animation: menu-slide-in 0.25s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform: translate3d(0, 0, 0);
        }

        /* --- æš—è‰²æ¨¡å¼è®¾ç½® (å…³é”®ä¿®æ”¹) --- */
        html.dark .custom-dropdown-menu {
            /* ğŸŸ¢ å…³é”®: ä» 0.95 é™å› 0.8 */
            /* 0.8 æ—¢èƒ½æŒ¡ä½åº•ä¸‹çš„å­—(ä¸ä¹±)ï¼Œåˆèƒ½é€å‡ºåº•ä¸‹çš„å…‰(æœ‰ç£¨ç ‚æ„Ÿ) */
            background-color: rgba(30, 30, 30, 0.99) !important;

            /* æš—è‰²æ¨¡å¼è¾¹æ¡†è¦ç»†å¾® */
            border: 1px solid rgba(255, 255, 255, 0.1);

            /* åŠ é‡é˜´å½±ï¼Œä»¥æ­¤æ¥ä¿è¯æ–‡å­—å¯è¯»æ€§ï¼Œè€Œä¸æ˜¯é åŠ åšèƒŒæ™¯ */
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
        }

        /* é¡¶éƒ¨å¸é™„æ åŒæ­¥è°ƒæ•´ */
        html.dark .custom-dropdown-menu .sticky {
            /* ç¨å¾®æ¯”åˆ—è¡¨æ·±ä¸€ç‚¹ç‚¹ï¼Œå¢åŠ å±‚æ¬¡ */
            background-color: rgba(30, 30, 30, 0.99) !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #app .mobile-user-menu {
            /* å¼ºåˆ¶æ¢å¤å®½æ•çš„å†…è¾¹è·ï¼Œè¦†ç›–æ‰å…¨å±€çš„ 4px */
            padding: 24px !important;

            /* ä¿æŒä¹‹å‰çš„å®šä½è®¾ç½® */
            position: fixed !important;
            top: calc(50px + env(safe-area-inset-top) + 12px) !important;
            right: 16px !important;
            left: auto !important;
            margin: 0 !important;
            width: 320px !important;
            max-width: calc(100vw - 32px) !important;
            transform-origin: top right !important;
            z-index: 99999 !important;
        }

        /* --- ğŸŸ¢ ä¿®å¤ç‰ˆ: ç¼©æ”¾è§†å›¾åˆ‡æ¢åŠ¨ç”» --- */

        /* 1. åŸºç¡€åŠ¨ç”»å±æ€§: å¼€å¯ GPU åŠ é€Ÿï¼Œé˜²æ­¢é—ªçƒ */
        .zoom-in-enter-active,
        .zoom-in-leave-active,
        .zoom-out-enter-active,
        .zoom-out-leave-active {
            transition: all 0.35s cubic-bezier(0.34, 1.3, 0.64, 1);
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            /* ğŸš€ æ ¸å¿ƒä¿®å¤: å¼€å¯ç¡¬ä»¶åŠ é€Ÿ & éšè—èƒŒé¢ */
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-style: preserve-3d;
            transform-origin: center center;
        }

        /* ğŸŸ¢ åœºæ™¯ A: æ”¾å¤§ (Zoom In) - æœˆè§†å›¾ -> å‘¨è§†å›¾ */
        /* æ–°é¡µé¢(å‘¨): ä½äºä¸Šæ–¹ï¼Œä»å°å˜å¤§ */
        .zoom-in-enter-from {
            opacity: 0;
            transform: scale(0.85);
        }

        .zoom-in-enter-active {
            z-index: 20;
        }

        /* ç¡®ä¿è¿›å…¥çš„å…ƒç´ åœ¨ä¸Šé¢ */

        /* æ—§é¡µé¢(æœˆ): ä½äºä¸‹æ–¹ï¼Œå˜å¤§å¹¶å˜æ·¡ */
        .zoom-in-leave-to {
            opacity: 0;
            transform: scale(1.15);
        }

        .zoom-in-leave-active {
            z-index: 10;
        }

        /* ğŸŸ¢ åœºæ™¯ B: ç¼©å° (Zoom Out) - å‘¨è§†å›¾ -> æœˆè§†å›¾ */
        /* æ–°é¡µé¢(æœˆ): ä½äºä¸‹æ–¹ï¼Œä»å¤§å˜å›æ­£å¸¸ */
        .zoom-out-enter-from {
            opacity: 0;
            transform: scale(1.15);
        }

        .zoom-out-enter-active {
            z-index: 10;
        }

        /* æ—§é¡µé¢(å‘¨): ä½äºä¸Šæ–¹ï¼Œç¼©å°å¹¶æ¶ˆå¤± */
        .zoom-out-leave-to {
            opacity: 0;
            transform: scale(0.85);
        }

        /* ğŸš€ æ ¸å¿ƒä¿®å¤: è®©ç¦»å¼€çš„å‘¨è§†å›¾ä¿æŒåœ¨æœ€ä¸Šå±‚ï¼Œç›´åˆ°åŠ¨ç”»ç»“æŸ */
        .zoom-out-leave-active {
            z-index: 20;
        }

        /* --- ğŸŸ¢ ä¿®å¤: è§†å›¾åˆ‡æ¢åŠ¨ç”» (æ›´ç¨³å›ºçš„å¸ƒå±€) --- */
        .view-slide-left-enter-active,
        .view-slide-left-leave-active,
        .view-slide-right-enter-active,
        .view-slide-right-leave-active {
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            width: 100%; /* ç¡®ä¿åŠ¨ç”»æ—¶å æ»¡å®½åº¦ */
            flex: 1; /* ä¿æŒ Flex å¸ƒå±€æ¯”ä¾‹ */
        }

        /* 1. å‘å·¦æ»‘åŠ¨ (Week -> Month) */
        .view-slide-left-enter-from {
            opacity: 0;
            transform: translateX(30px); /* æ–°é¡µé¢ä»å³ä¾§è¿›æ¥ */
        }

        .view-slide-left-leave-to {
            opacity: 0;
            transform: translateX(-30px); /* æ—§é¡µé¢å‘å·¦ä¾§ç¦»å¼€ */
        }

        /* 2. å‘å³æ»‘åŠ¨ (Month -> Week) */
        .view-slide-right-enter-from {
            opacity: 0;
            transform: translateX(-30px); /* æ–°é¡µé¢ä»å·¦ä¾§è¿›æ¥ */
        }

        .view-slide-right-leave-to {
            opacity: 0;
            transform: translateX(30px); /* æ—§é¡µé¢å‘å³ä¾§ç¦»å¼€ */
        }

        /* --- ğŸŸ¢ ä¼˜åŒ–ç‰ˆ: å·¦å³æ»‘åŠ¨åŠ¨ç”» (iOS Push Style) --- */

        /* 1. åŸºç¡€è®¾ç½®: å¼€å¯ GPU åŠ é€Ÿï¼Œå®šä¹‰ç‰©ç†æ›²çº¿ */
        .slide-next-enter-active,
        .slide-next-leave-active,
        .slide-prev-enter-active,
        .slide-prev-leave-active {
            /* ä½¿ç”¨ç±» iOS çš„å¼¹ç°§æ›²çº¿ (Quart)ï¼Œå¼€å§‹å¿«ï¼Œç»“æŸæ—¶å¹³æ»‘å‡é€Ÿ */
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s ease;

            /* å…³é”®: ç»å¯¹å®šä½ï¼Œç¡®ä¿æ–°æ—§é¡µé¢åŒæ—¶å­˜åœ¨å¹¶é‡å  */
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100%;
            min-height: 100%;

            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-style: preserve-3d;

            overflow: hidden; /* é˜²æ­¢åŠ¨ç”»è¿‡ç¨‹ä¸­å‡ºç°åŒé‡æ»šåŠ¨æ¡ */
            z-index: 1;
        }

        /* --- Next: ä¸‹ä¸€å‘¨/æœªæ¥ (å‘å·¦æ¨) --- */

        /* è¿›åœº(æ–°): ä»å±å¹•å³ä¾§è¾¹ç¼˜æ»‘å…¥ */
        .slide-next-enter-from {
            transform: translate3d(100%, 0, 0);
        }

        /* è¿›åœºæ—¶å±‚çº§æ›´é«˜ï¼Œå¹¶å¸¦å·¦ä¾§é˜´å½±ï¼Œäº§ç”Ÿ"è¦†ç›–"æ„Ÿ */
        .slide-next-enter-active {
            z-index: 20;
            box-shadow: -20px 0 40px rgba(0, 0, 0, 0.05);
        }

        /* ç¦»åœº(æ—§): è¢«æ¨åˆ°å·¦ä¾§ï¼Œç¨å¾®å˜æš— (è§†å·®æ•ˆæœ) */
        .slide-next-leave-to {
            transform: translate3d(-25%, 0, 0); /* è¿™é‡Œçš„ -25% åˆ¶é€ è§†å·®ï¼Œä¸å®Œå…¨ç§»å‡ºï¼Œæ›´æœ‰è´¨æ„Ÿ */
            opacity: 0; /* é…åˆé€æ˜åº¦æ¶ˆå¤±ï¼Œé˜²æ­¢ç»ç’ƒèƒŒæ™¯é‡å æ˜¾å¾—æ‚ä¹± */
        }

        .slide-next-leave-active {
            z-index: 10;
        }

        /* --- Prev: ä¸Šä¸€å‘¨/è¿‡å» (å‘å³æ¨) --- */

        /* è¿›åœº(æ–°): ä»å±å¹•å·¦ä¾§è¾¹ç¼˜æ»‘å…¥ */
        .slide-prev-enter-from {
            transform: translate3d(-100%, 0, 0);
        }

        .slide-prev-enter-active {
            z-index: 20;
            box-shadow: 20px 0 40px rgba(0, 0, 0, 0.05);
        }

        /* ç¦»åœº(æ—§): è¢«æ¨åˆ°å³ä¾§ */
        .slide-prev-leave-to {
            transform: translate3d(25%, 0, 0);
            opacity: 0;
        }

        .slide-prev-leave-active {
            z-index: 10;
        }

        /* ğŸŸ¢ é¢å¤–ä¿®å¤: ç¡®ä¿ä¸»å®¹å™¨åœ¨åŠ¨ç”»æ—¶ä¸ä¼šè¢«æ’‘å¼€ */
        #main-content {
            position: relative; /* ç¡®ä¿ absolute å­å…ƒç´ ç›¸å¯¹äºå®ƒå®šä½ */
            overflow: hidden; /* è£å‰ªæ‰é£å‡ºå±å¹•çš„åŠ¨ç”»éƒ¨åˆ† */
        }

        /* ğŸŸ¢ æ ¸å¿ƒä¿®å¤: äº®è‰²æ¨¡å¼ä¸‹çš„ç½‘æ ¼çº¿/è¾¹æ¡†é¢œè‰² */
        /* åŸé…ç½®æ˜¯ç™½è‰²ï¼Œå¯¼è‡´åœ¨äº®èƒŒæ™¯ä¸‹ä¸å¯è§ã€‚è¿™é‡Œå¼ºåˆ¶æ”¹ä¸º 15% é»‘è‰² */
        html:not(.dark) .border-glass-border {
            border-color: rgba(0, 0, 0, 0.06) !important;
        }

        /* ğŸŸ¢ é¢å¤–ä¿®å¤: åŠ æ·±å‘¨è§†å›¾çš„æ¨ªå‘æ—¶é—´çº¿ */
        html:not(.dark) {
            --grid-line-light: rgba(0, 0, 0, 0.06) !important; /* åŠ æ·±åˆ° 15% */
        }

        /* ğŸŸ¢ é¢å¤–ä¿®å¤: æœˆè§†å›¾å¤–æ¡†é˜´å½±å¢å¼º (è®©è¡¨æ ¼æ›´ç«‹ä½“) */
        html:not(.dark) .shadow-liquid {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06) !important;
        }

        /* --- Settings åˆ†ç»„æ ·å¼ --- */
        .settings-group-container {
            background: rgba(0, 0, 0, 0.02);
            border-radius: 12px;
            margin-bottom: 12px;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        html.dark .settings-group-container {
            background: rgba(255, 255, 255, 0.03);
        }

        .settings-group-container.drag-over {
            background: rgba(0, 122, 255, 0.1);
            border-color: #007aff;
        }

        .settings-group-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            user-select: none;
        }

        .settings-group-input {
            background: transparent;
            border: 1px solid transparent;
            font-weight: 700;
            font-size: 13px;
            /* color: #007aff;  <-- ğŸ”´ åˆ é™¤è¿™ä¸€è¡Œï¼Œè®©é¢œè‰²å¯ä»¥åŠ¨æ€æ§åˆ¶ */
            padding: 4px 6px;
            border-radius: 6px;
            transition: all 0.2s;
            width: 100%;
        }

        .settings-group-input:focus {
            background: rgba(255, 255, 255, 0.8);
            border-color: #007aff;
            color: #000;
        }

        html.dark .settings-group-input:focus {
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
        }

        /* è‡ªå®šä¹‰æ»‘å—è½¨é“ */
        input[type=range].custom-slider {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            opacity: 1 !important; /* è¦†ç›–ä¹‹å‰çš„ hidden */
            height: 30px; /* å¢å¤§è§¦æ‘¸åŒºåŸŸ */
            position: relative;
            z-index: 10;
        }

        input[type=range].custom-slider:focus {
            outline: none;
        }

        /* è½¨é“ (Track) */
        input[type=range].custom-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 12px;
            cursor: pointer;
            background: #f3f4f6; /* ç°è‰²åº• */
            border-radius: 6px;
            border: 1px solid rgba(0,0,0,0.05);
        }
        .dark input[type=range].custom-slider::-webkit-slider-runnable-track {
            background: rgba(255,255,255,0.1);
            border: none;
        }

        /* æ»‘å—å¤´ (Thumb) */
        input[type=range].custom-slider::-webkit-slider-thumb {
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #ef4444; /* çº¢è‰²è¾¹æ¡† */
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -9px; /* (12pxè½¨é“é«˜åº¦ / 2) - (28pxæ»‘å—é«˜åº¦ / 2) */
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        /* --- ğŸŸ¢ æ‰‹æœºç«¯å¡ç‰‡ç´§å‡‘åŒ–è¡¥ä¸ --- */
        @media (max-width: 800px) {
            /* 1. å‹ç¼©å¡ç‰‡æ•´ä½“å®¹å™¨ */
            .mobile-stat-card {
                padding: 12px 14px !important; /* å¤§å¹…å‡å°å†…è¾¹è· */
                border-radius: 24px !important; /* å‡å°åœ†è§’ */
                margin-bottom: 6px !important;  /* å‡å°å¡ç‰‡é—´è· */
            }

            /* 2. å‡å°æ ‡é¢˜å­—ä½“ (Name) */
            .mobile-stat-card .font-bold.text-2xl {
                font-size: 18px !important;
                line-height: 1.2 !important;
            }

            /* 3. å‡å°å¤§æ•°å­—å­—ä½“ (Time) */
            .mobile-stat-card .font-mono.text-2xl {
                font-size: 18px !important;
            }

            /* 4. å‡å°æ¬¡è¦ä¿¡æ¯ (Items count / è¿›åº¦æ¡æ–‡å­—) */
            .mobile-stat-card .text-\[14px\] {
                font-size: 13px !important;
                opacity: 0.7 !important;
            }

            /* 7. ç¼©å°çŠ¶æ€æ ‡ç­¾ (å®Œæˆ/è¿›è¡Œä¸­/ç¼ºæ—¶) */
            .mobile-stat-card span.rounded-md {
                font-size: 12px !important;
                padding: 2px 6px !important;
                height: auto !important;
            }

            /* 8. ç¼©å°å€ç‡æŒ‰é’® (x20 ç­‰) */
            .mobile-stat-card button.rounded-md {
                font-size: 12px !important;
                padding: 2px 6px !important;
            }

            /* 9. å†…éƒ¨åˆ—è¡¨ (å±•å¼€åçš„ä»»åŠ¡) æ›´åŠ ç´§å‡‘ */
            .mobile-stat-card .mt-2.pt-2 .p-1\.5 {
                padding: 4px 2px !important; /* å‡å°åˆ—è¡¨é¡¹é—´è· */
            }

            .mobile-stat-card .mt-2.pt-2 .text-xs {
                font-size: 11px !important; /* åˆ—è¡¨æ–‡å­—å˜å° */
            }
        }

        /* ç¡®ä¿ SVG å†…éƒ¨å…ƒç´ æœ‰è¿‡æ¸¡æ•ˆæœ (å¯é€‰) */
        svg rect {
            transition: all 0.1s;
        }


    </style>
</head>
<body>
<div id="global-loader">
    <div class="loader-glass-box">
        <div class="loader-spinner"></div>
        <div class="loader-text">Loading</div>
    </div>
</div>
<div id="app" class="flex flex-col h-full w-full select-none">

    <div class="liquid-window flex-1 flex flex-col overflow-hidden relative">

        <header class="h-16 flex items-center gap-2 px-2 sm:px-6 border-b border-glass-border dark:border-glass-borderDark z-50 shrink-0 relative transition-colors duration-300 dark:bg-black/40">

            <div class="flex items-center gap-2 sm:gap-5 z-50 relative shrink-0">

                <div class="relative custom-select-container">
                    <button @click.stop="toggleMobileMenu"
                            class="w-11 h-11 rounded-full bg-white/40 dark:bg-black/20 border border-white/20 shadow-sm hover:bg-white/60 dark:hover:bg-black/30 flex items-center justify-center transition group backdrop-blur-md">
                        <i class="fa-solid fa-bars text-lg opacity-70"></i>
                    </button>

                    <div v-if="showMobileMenu"
                         class="custom-dropdown-menu w-48 absolute top-full left-0 mt-2 p-1.5 flex flex-col gap-1 bg-white/90 dark:bg-[#1c1c1e]/90 backdrop-blur-xl border border-white/20 shadow-2xl rounded-xl origin-top-left text-left">


                        <button @click="toggleTheme"
                                class="flex items-center gap-3 px-3 py-3.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-6 flex justify-center text-lg transition-colors"
                                 :class="{
                                         'text-blue-500': themeMode === 'auto',
                                         'text-yellow-500': themeMode === 'light',
                                         'text-purple-400': themeMode === 'dark'
                                     }">
                                <i class="fa-solid" :class="getThemeLabel.icon"></i>
                            </div>
                            <div class="flex flex-col items-start leading-none gap-0.5">
                                <span>{{ getThemeLabel.text }}</span>
                                <span class="text-[9px] opacity-40 font-normal uppercase tracking-wider">{{ themeMode
                                    }}</span>
                            </div>
                        </button>

                        <button @click="showSettings = true; showMobileMenu = false"
                                class="flex items-center gap-3 px-3 py-3.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-6 flex justify-center text-gray-500 dark:text-gray-400 text-lg"><i
                                    class="fa-solid fa-gear"></i></div>
                            <span>è®¾ç½®é€‰é¡¹</span>
                        </button>


                        <div class="h-px bg-black/5 dark:bg-white/5 my-1 mx-2"></div>

                        <button @click="exportToICS(); showMobileMenu=false"
                                class="flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-5 flex justify-center text-[#007aff]"><i
                                    class="fa-regular fa-calendar-check"></i></div>
                            <span>å¯¼å‡º ICS æ—¥å†</span>
                        </button>

                        <button @click="exportJSON(); showMobileMenu=false"
                                class="flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-5 flex justify-center text-orange-500"><i class="fa-solid fa-download"></i>
                            </div>
                            <span>å¤‡ä»½æ•°æ® (JSON)</span>
                        </button>

                        <button @click="importJSON(); showMobileMenu=false"
                                class="flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-5 flex justify-center text-green-500"><i class="fa-solid fa-upload"></i></div>
                            <span>æ¢å¤æ•°æ® (JSON)</span>
                        </button>

                        <button @click="openCreditModal(); showMobileMenu=false"
                                class="flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-5 flex justify-center text-purple-500"><i class="fa-solid fa-file-contract"></i></div>
                            <span>å¯¼å‡º Credit</span>
                        </button>
                    </div>
                </div>

                <h1 class="text-xl ml-3 mr-2 hidden lg:block select-none tracking-[0.1em]"
                    style="font-family: 'Chango', sans-serif; font-weight: 400;">

                        <span class="bg-clip-text text-transparent bg-gradient-to-r from-gray-800 to-gray-400 dark:from-white dark:to-gray-500">
                            MUSCHE
                        </span>
                </h1>

                <div class="flex items-center ml-1 gap-1 sm:gap-2">
                    <button id="tour-sync-btn"
                            @click="handleManualSync"
                            :disabled="isSyncing"
                            class="w-11 h-11 sm:w-9 sm:h-9 rounded-md hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition disabled:opacity-50 group relative"
                            :title="!user ? 'æœªç™»å½•' : (saveStatus==='saved'?'å·²åŒæ­¥':(saveStatus==='saving'?'æ­£åœ¨ä¿å­˜...':'æœ‰æœªä¿å­˜æ›´æ”¹'))">

                        <i class="fa-solid fa-cloud-arrow-down text-lg sm:text-base opacity-80"
                           :class="{'fa-bounce': isSyncing}"></i>

                        <div v-if="!user"
                             class="absolute top-2 right-2 w-1.5 h-1.5 bg-red-500 rounded-full border border-white/50 dark:border-black/50">
                        </div>

                        <div v-else
                             class="absolute top-2 right-2 w-2 h-2 rounded-full transition-all duration-300 border border-white/80 dark:border-black/50 shadow-sm"
                             :class="{
                                 'bg-green-500 scale-100': saveStatus === 'saved',        /* ğŸŸ¢ å·²ä¿å­˜ */
                                 'bg-orange-500 scale-110': saveStatus === 'unsaved',     /* ğŸŸ  æœ‰æ”¹åŠ¨ */
                                 'bg-[#007aff] scale-110 animate-pulse': saveStatus === 'saving', /* ğŸ”µ ä¿å­˜ä¸­ (å‘¼å¸) */
                                 'bg-red-600': saveStatus === 'error'                     /* ğŸ”´ å‡ºé”™ */
                             }">
                        </div>
                    </button>
                    <button @click="undo" :disabled="historyIndex <= 0"
                            class="w-11 h-11 sm:w-9 sm:h-9 rounded-md hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition disabled:opacity-30">
                        <i class="fa-solid fa-rotate-left text-lg"></i>
                    </button>
                    <button @click="redo" :disabled="historyIndex >= history.length - 1"
                            class="w-11 h-11 sm:w-9 sm:h-9 rounded-md hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition disabled:opacity-30">
                        <i class="fa-solid fa-rotate-right text-lg"></i>
                    </button>
                </div>
            </div>

            <div class="flex-1 flex justify-center px-2 min-w-0 z-40">
                <div id="tour-session-select" class="relative custom-select-container w-full max-w-[260px] min-w-0 sm:min-w-[180px]">
                    <button @mousedown.stop="toggleDropdown('session')"
                            class="flex items-center justify-between gap-2 bg-white/50 dark:bg-black/20 backdrop-blur-md px-3 py-1.5 rounded-full border border-glass-border dark:border-glass-borderDark hover:bg-white/80 dark:hover:bg-white/10 transition h-11 w-full shadow-sm group cursor-pointer">

                        <div class="flex items-center gap-2 overflow-hidden flex-1 min-w-0 justify-center sm:justify-start">
                            <i class="fa-solid fa-layer-group text-xs opacity-50 group-hover:text-[#007aff] transition-colors shrink-0"></i>
                            <span class="text-sm font-bold truncate">{{ currentSessionName }}</span>
                        </div>

                        <i class="fa-solid fa-chevron-down text-[10px] opacity-50 transition-transform duration-300 shrink-0 ml-1"
                           :class="{'rotate-180': activeDropdown==='session'}"></i>
                    </button>

                    <div v-if="activeDropdown === 'session'"
                         class="custom-dropdown-menu !w-64 absolute top-full left-0 mt-2 shadow-2xl ring-1 ring-black/5 origin-top">
                        <div class="px-3 py-2 text-[10px] uppercase font-bold opacity-50 tracking-wider border-b border-black/5 dark:border-white/5 text-left">
                            Switch Session
                        </div>
                        <div class="max-h-60 overflow-y-auto py-1 text-left">
                            <div v-for="s in settings.sessions" :key="s.id"
                                 @mousedown.prevent.stop="switchSession(s.id)"
                                 class="px-4 py-2.5 text-sm hover:bg-[#007aff] hover:text-white cursor-pointer flex justify-between items-center group transition-colors">
                                <span class="font-medium truncate">{{ s.name }}</span>
                                <i v-if="currentSessionId === s.id" class="fa-solid fa-check text-xs"></i>
                            </div>
                        </div>
                        <div class="p-2 bg-black/5 dark:bg-white/5 border-t border-black/5 dark:border-white/5 grid grid-cols-1 gap-1">
                            <button @mousedown.prevent.stop="handleSessionAction('new')"
                                    class="text-left px-3 py-2 text-xs font-bold rounded-md hover:bg-white dark:hover:bg-white/10 flex items-center gap-2 transition cursor-pointer">
                                <i class="fa-solid fa-plus text-green-500"></i> New Session
                            </button>
                            <button @mousedown.prevent.stop="handleSessionAction('rename')"
                                    class="text-left px-3 py-2 text-xs font-bold rounded-md hover:bg-white dark:hover:bg-white/10 flex items-center gap-2 transition cursor-pointer">
                                <i class="fa-solid fa-pen text-orange-500"></i> Rename
                            </button>
                            <button @mousedown.prevent.stop="handleSessionAction('delete')"
                                    class="text-left px-3 py-2 text-xs font-bold rounded-md hover:bg-red-50 dark:hover:bg-red-900/20 text-red-500 flex items-center gap-2 transition cursor-pointer">
                                <i class="fa-solid fa-trash"></i> Delete
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="hidden sm:flex items-center relative ml-4 mr-2 group">
                <i class="fa-solid fa-magnifying-glass absolute left-3 text-gray-400 text-xs group-focus-within:text-[#007aff] transition-colors"></i>

                <input v-model="globalSearchQuery"
                       @keydown.enter="handleSearchEnter"  class="glass-input h-9 pl-8 pr-8 w-40 focus:w-60 transition-all duration-300 text-xs font-bold bg-white/40 dark:bg-black/20 focus:bg-white dark:focus:bg-white/10 rounded-full"
                       placeholder="Search..."
                >

                <button v-if="globalSearchQuery"
                        @click="globalSearchQuery = ''"
                        class="absolute right-2 w-5 h-5 flex items-center justify-center rounded-full text-gray-400 hover:text-red-500 hover:bg-black/5 dark:hover:bg-white/10 transition cursor-pointer">
                    <i class="fa-solid fa-xmark text-[10px]"></i>
                </button>
            </div>

            <div class="flex items-center gap-2 sm:gap-3 z-50 relative shrink-0">

                <div class="relative z-50 user-menu-container">
                    <button @click="handleUserBtnClick"
                            class="flex items-center justify-center w-11 h-11 rounded-full transition border cursor-pointer select-none overflow-hidden shrink-0"
                            :class="user ? 'bg-transparent border-transparent' : 'bg-gray-500/10 text-gray-600 border-gray-500/20 border'">

                        <div v-if="user && userAvatar" class="w-full h-full bg-cover bg-center"
                             :style="{backgroundImage: `url(${userAvatar})`}"></div>
                        <i v-else class="fa-solid text-lg"
                           :class="user ? 'fa-user-check text-green-600' : 'fa-user'"></i>
                    </button>

                    <div v-if="showProfileMenu && user"
                         class="custom-dropdown-menu mobile-user-menu w-72 absolute top-full right-0 mt-2 p-4 flex flex-col gap-4 cursor-default text-left max-h-none">

                        <div class="flex items-center gap-4 border-b border-black/5 dark:border-white/5 pb-4">
                            <div class="w-16 h-16 rounded-full bg-black/5 dark:bg-white/10 flex items-center justify-center overflow-hidden border-2 border-white/20 shadow-inner relative shrink-0">
                                <div v-if="userAvatar" class="absolute inset-0 bg-cover bg-center"
                                     :style="{backgroundImage: `url(${userAvatar})`}"></div>
                                <span v-else class="text-2xl font-bold opacity-30">{{ user.email[0].toUpperCase()
                                    }}</span>
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="font-bold text-base truncate">{{ userDisplayName }}</div>
                                <div class="text-xs opacity-50 truncate">{{ user.email }}</div>
                            </div>
                        </div>

                        <div class="space-y-2">
                            <label class="text-[10px] uppercase font-bold opacity-50 tracking-wider">è®¾ç½®æ˜µç§°</label>
                            <div class="flex gap-2">
                                <input v-model="tempNickname"
                                       placeholder="è¾“å…¥æ–°æ˜µç§°"
                                       class="glass-input flex-1 min-w-0 h-9 text-sm"
                                       @keydown.enter="updateNickname">

                                <button @click="updateNickname"
                                        :disabled="authLoading"
                                        class="bg-[#007aff] hover:bg-[#0062cc] text-white rounded-lg px-3 h-9 text-xs font-bold transition flex items-center justify-center shadow-lg shadow-blue-500/30 disabled:opacity-50 shrink-0">
                                    <i v-if="authLoading" class="fa-solid fa-circle-notch fa-spin"></i>
                                    <span v-else>ä¿å­˜</span>
                                </button>
                            </div>
                        </div>

                        <div class="space-y-2">
                            <label class="text-[10px] uppercase font-bold opacity-50 tracking-wider">ä¸Šä¼ å¤´åƒ</label>
                            <div class="flex gap-2 items-center">
                                <label class="flex-1 cursor-pointer bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition rounded-lg h-9 flex items-center justify-center text-xs font-bold gap-2 text-gray-600 dark:text-gray-300 border border-transparent">
                                    <i class="fa-solid fa-cloud-arrow-up"></i>
                                    <span id="upload-text">é€‰æ‹©å›¾ç‰‡...</span>
                                    <input type="file" accept="image/*" class="hidden" @change="onFileSelect">
                                </label>
                            </div>
                            <p class="text-[10px] opacity-40 leading-tight">æ”¯æŒ JPG, PNG, GIFã€‚</p>
                        </div>

                        <button @click="handleLogout"
                                class="w-full py-2.5 rounded-xl bg-red-500/10 text-red-600 hover:bg-red-500/20 border border-red-500/10 transition text-sm font-bold flex items-center justify-center gap-2">
                            <i class="fa-solid fa-arrow-right-from-bracket"></i> é€€å‡ºç™»å½•
                        </button>
                    </div>
                </div>

                <div class="w-px h-6 bg-black/10 dark:bg-white/10 mx-1 hidden sm:block"></div>

                <button @click="startTour"
                        class="w-11 h-11 sm:w-9 sm:h-9 rounded-md hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition group relative"
                        title="æ–°æ‰‹å¼•å¯¼">
                    <i class="fa-solid fa-circle-question text-lg sm:text-base opacity-80 "></i>
                </button>


                <input id="json-upload" type="file" accept=".json" class="hidden" @change="handleJSONFile">
                <input id="midi-import-input" type="file" accept=".mid,.midi" class="absolute opacity-0 w-0 h-0 overflow-hidden pointer-events-none" @change="handleMidiFile">
            </div>
        </header>

        <div class="flex-1 flex overflow-hidden relative">

            <aside id="sidebar"
                   v-show="!isMobile || mobileTab==='pool' || (isMobile && dragElClone && dragSourceType === 'pool')"

                   :style="{
                           width: isMobile ? '100%' : (isSidebarOpen ? sidebarWidth + 'px' : '0px'),
                           opacity: (isMobile || isSidebarOpen) ? 1 : 0
                       }"

                   class="glass-sidebar flex flex-col relative z-20"

                   :class="[
                           isMobile ? 'w-full absolute inset-0 bg-white dark:bg-[#1e1e1e] transition-none' : 'min-w-0 transition-all duration-300 ease-in-out',
                           (isMobile && dragElClone && dragSourceType === 'pool') ? 'z-[-1] opacity-0' : 'z-40',
                           !isSidebarOpen && !isMobile ? 'border-none overflow-hidden' : ''
                       ]"
                   @dragover.prevent @dragenter="dragEnterPool" @dragleave="dragLeavePool" @drop="dropToPool"
                   @click="clearSelection"

                   @touchstart="onSidebarTouchStart"
                   @touchend="onSidebarTouchEnd">

                <div class="flex flex-col px-8 py-5 sm:px-3 sm:py-3 border-b border-glass-border dark:border-glass-borderDark gap-4 sm:gap-3 shrink-0">

                    <button id="tour-new-task"
                            @click="showMobileTaskInput = true"
                            class="hidden sm:flex w-full h-16 sm:h-auto sm:py-2.5 rounded-[24px] sm:rounded-full bg-[#007aff] hover:bg-[#0062cc] text-white font-bold text-xl sm:text-sm shadow-lg shadow-blue-500/30 transition items-center justify-center gap-2 group active:scale-95">
                        <i class="fa-solid fa-plus text-xl sm:text-base group-hover:scale-110 transition-transform"></i>
                        <span>New Task</span>
                    </button>

                    <div class="flex gap-2 w-full bg-black/5 dark:bg-white/5 p-1 rounded-xl">
                        <button @click="switchSidebarTab('musician')"
                                class="flex-1 py-1.5 rounded-lg text-[10px] sm:text-xs font-bold transition uppercase tracking-wide flex items-center justify-center gap-1"
                                :class="sidebarTab==='musician' ? 'bg-white dark:bg-white/20 text-black dark:text-white shadow-sm' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'">
                            <i class="fa-solid fa-microphone"></i> REC
                        </button>

                        <button @click="switchSidebarTab('project')"
                                class="flex-1 py-1.5 rounded-lg text-[10px] sm:text-xs font-bold transition uppercase tracking-wide flex items-center justify-center gap-1"
                                :class="sidebarTab==='project' ? 'bg-white dark:bg-white/20 text-black dark:text-white shadow-sm' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'">
                            <i class="fa-solid fa-pen-to-square"></i> EDIT
                        </button>

<!--                        <button @click="switchSidebarTab('instrument')"-->
<!--                                class="flex-1 py-1.5 rounded-lg text-[10px] sm:text-xs font-bold transition uppercase tracking-wide flex items-center justify-center gap-1"-->
<!--                                :class="sidebarTab==='instrument' ? 'bg-white dark:bg-white/20 text-black dark:text-white shadow-sm' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'">-->
<!--                            <i class="fa-solid fa-guitar"></i> INST-->
<!--                        </button>-->
                    </div>
                </div>
                <div class="shrink-0 h-8 px-4 border-t border-glass-border dark:border-glass-borderDark bg-white/80 dark:bg-[#1c1c1e] flex justify-between items-center text-[10px] font-mono font-bold text-gray-500 dark:text-gray-400 select-none cursor-default z-20">
                    <div class="flex items-center gap-1.5" title="å½“å‰æ—¥ç¨‹ä»»åŠ¡æ•° / Active Tasks">
                        <i class="fa-solid fa-list-check"></i>
                        <span>{{ activeTaskCount }}</span>
                    </div>
                    <div class="flex items-center gap-1.5" title="å½“å‰æ—¥ç¨‹äººå‘˜æ•° / Active Musicians">
                        <i class="fa-solid fa-user"></i>
                        <span>{{ musicianStats.length }}</span>
                    </div>
                    <div class="flex items-center gap-1.5" title="å½“å‰æ—¥ç¨‹é¡¹ç›®æ•° / Active Projects">
                        <i class="fa-solid fa-folder"></i>
                        <span>{{ projectStats.length }}</span>
                    </div>
                    <div class="flex items-center gap-1.5" title="å½“å‰æ—¥ç¨‹ä¹å™¨æ•° / Active Instruments">
                        <i class="fa-solid fa-guitar"></i>
                        <span>{{ instrumentStats.length }}</span>
                    </div>
                </div>

                <div class="flex-1 overflow-y-auto relative overflow-x-hidden"
                     ref="sidebarScrollRef">

                    <Transition :name="sidebarTransitionName">

                        <div :key="sidebarTab" class="w-full min-h-full p-3 pb-24">

                            <div class="flex justify-end gap-3 mb-2 px-1">
                                <button @click="toggleSort('name')"
                                        class="text-[10px] uppercase font-bold tracking-wider opacity-50 hover:opacity-100 transition flex items-center gap-1">
                                    Name <i class="fa-solid" :class="getSortIcon('name')" v-show="sortField==='name'"></i>
                                </button>
                                <button @click="toggleSort('status')"
                                        class="text-[10px] uppercase font-bold tracking-wider opacity-50 hover:opacity-100 transition flex items-center gap-1">
                                    Status <i class="fa-solid" :class="getSortIcon('status')" v-show="sortField==='status'"></i>
                                </button>
                                <button @click="toggleSort('duration')"
                                        class="text-[10px] uppercase font-bold tracking-wider opacity-50 hover:opacity-100 transition flex items-center gap-1">
                                    Time <i class="fa-solid" :class="getSortIcon('duration')"
                                            v-show="sortField==='duration'"></i>
                                </button>
                            </div>

                            <div v-for="(stat, index) in filteredSidebarList" :key="stat.id"
                                 :id="index === 0 ? 'tour-first-stat-card' : null"

                                 :data-stat-id="stat.id"

                                 class="mobile-stat-card group py-6 px-5 sm:p-3"
                                 :draggable="!stat.isFullyScheduled && stat.statusKey !== 'in-progress'"
                                 @dragstart="(!stat.isFullyScheduled && stat.statusKey !== 'in-progress') && dragStart($event, stat, 'aggregate')"

                                 @click.stop="handleStatCardClick(stat)"
                                 @touchstart="handlePoolTouchStart($event, stat, 'aggregate')"
                                 @touchmove="handleTouchMove"
                                 @touchend="handleTouchEnd"
                                 @contextmenu.prevent>

                            <button class="absolute left-0 top-0 bottom-0 w-3 sm:w-2 flex items-center justify-center transition-all duration-200 group/btn z-10 cursor-pointer hover:brightness-110 active:scale-95"
                                    :style="{backgroundColor: stat.statusKey === 'completed' ? '#3b82f6'
                                        : stat.statusKey === 'full' ? '#34c759'
                                        : stat.statusKey === 'insufficient' ? '#ff3b30'
                                        : stat.statusKey === 'in-progress' ? '#f59e0b'
                                        : (sidebarTab === 'project' ? '#eab308' : (sidebarTab === 'instrument' ? '#3b82f6' : '#a855f7'))}"
                                    @click.stop="jumpToStatSchedule(stat)"
                                    title="ç‚¹å‡»è·³è½¬åˆ°æ—¥ç¨‹">

                            </button>

                            <div class="pl-10">
                                <div class="flex justify-between items-center mb-1">
                                    <div class="flex items-center flex-1 min-w-0 pr-2">
                                        <div class="font-bold text-2xl sm:text-lg leading-none truncate">
                                            {{ stat.name }}
                                        </div>

                                        <span v-if="stat.scheduleCount > 1"
                                              class="ml-1 shrink-0 inline-flex items-center justify-center bg-black/5 dark:bg-white/10 px-1.5 h-4 rounded-md text-[10px] font-bold opacity-50">
                                            {{ stat.scheduleCount }}
                                        </span>
                                    </div>

                                    <div class="flex items-center gap-1 shrink-0">
                                        <span v-if="stat.statusKey === 'completed'"
                                              class="px-2 py-1 rounded-md bg-blue-500 text-white text-sm sm:text-xs font-bold shadow-sm whitespace-nowrap">å®Œæˆ</span>
                                        <span v-else-if="stat.statusKey === 'in-progress'"
                                              class="px-2 py-1 rounded-md bg-orange-500 text-white text-sm sm:text-xs font-bold shadow-sm whitespace-nowrap">è¿›è¡Œä¸­</span>
                                        <span v-else-if="stat.statusKey === 'full'"
                                              class="px-2 py-1 rounded-md bg-green-500/10 text-green-600 dark:text-green-400 text-sm sm:text-xs font-bold whitespace-nowrap">å·²æ’</span>
                                        <span v-else-if="stat.statusKey === 'insufficient'"
                                              class="px-2 py-1 rounded-md bg-red-500/10 text-red-500 dark:text-red-400 text-sm sm:text-xs font-bold whitespace-nowrap">ç¼ºæ—¶</span>

                                        <button v-if="stat.avgRealRatio > 0"
                                                @click.stop="autoUpdateEfficiency(stat.id, sidebarTab, true)"
                                                class="px-2 py-1 rounded-md bg-purple-100 dark:bg-purple-500/20 text-purple-700 dark:text-purple-300 text-sm sm:text-xs font-mono font-bold transition whitespace-nowrap border border-transparent dark:border-purple-500/20 hover:bg-purple-200 active:scale-95 cursor-pointer">
                                            x{{ stat.avgRealRatio }}
                                        </button>
                                    </div>
                                </div>

                                <div class="flex justify-between items-baseline">
                                    <div class="text-[14px] opacity-50 font-medium flex items-center gap-2">
                                        <span>{{ stat.trackCount }} Items</span>
                                        <span v-if="stat.scheduledSeconds > 0"
                                              class="text-[13px] font-mono font-bold opacity-60 bg-black/5 dark:bg-white/10 px-1.5 rounded-md">
                                                {{ formatSecs(stat.scheduledSeconds) }}
                                            </span>
                                    </div>
                                    <div class="flex items-baseline gap-1">
                                            <span class="text-2xl sm:text-lg font-mono font-bold tracking-tight"
                                                  :class="{
                                                      'text-blue-500 dark:text-blue-400': stat.statusKey === 'completed',
                                                      'text-orange-500 dark:text-orange-400': stat.statusKey === 'in-progress',
                                                      'text-green-600 dark:text-green-400': stat.statusKey === 'full',
                                                      'text-red-500 dark:text-red-400': stat.statusKey === 'insufficient',
                                                      'text-gray-800 dark:text-gray-100': stat.statusKey === 'unscheduled'
                                                  }">
                                                {{ stat.totalDuration }}
                                            </span>
                                    </div>
                                </div>

                                <div class="mt-2 h-1 w-full bg-black/5 dark:bg-white/10 rounded-full overflow-hidden relative">
                                    <div class="h-full rounded-full transition-all duration-500 relative"
                                         :style="{
                                                width: (stat.totalSeconds > 0)
                                                    ? (stat.statusKey === 'insufficient'
                                                        ? Math.min(100, (stat.scheduledSeconds / stat.totalSeconds) * 100).toFixed(1) + '%'
                                                        : (stat.statusKey === 'completed' ? '100%' : Math.min(100, (stat.completedSeconds / stat.totalSeconds) * 100).toFixed(1) + '%')
                                                      )
                                                    : '0%',
                                                backgroundColor: stat.statusKey === 'completed' ? '#3b82f6'
                                                    : stat.statusKey === 'full' ? '#34c759'
                                                    : stat.statusKey === 'insufficient' ? '#ff3b30'
                                                    : stat.statusKey === 'in-progress' ? '#f59e0b'
                                                    : (sidebarTab === 'project' ? '#eab308' : (sidebarTab === 'instrument' ? '#3b82f6' : '#a855f7'))
                                             }">
                                    </div>
                                </div>

                                <div v-if="expandedStatsIds.has(stat.id)"
                                     class="mt-2 pt-2 border-t border-black/5 dark:border-white/5 space-y-1" @click.stop>
                                    <div v-for="item in stat.items" :key="item.id"
                                         @click.stop="selectTask(item.id, 'pool', $event)"
                                         @dblclick.stop="openEditModal(item, 'pool')"
                                         @touchstart="handlePoolTouchStart($event, item)"
                                         @touchmove="handleTouchMove"
                                         @touchend="handleTouchEnd"
                                         class="flex items-center justify-between p-1.5 rounded hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer transition border border-transparent"
                                         :class="{
                                             'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800': selectedPoolIds.has(item.id),
                                             'opacity-40 grayscale': item.isSkipped
                                         }">

                                        <div class="flex items-center gap-2 min-w-0 overflow-hidden flex-1 mr-2">
                                            <div class="w-1.5 h-1.5 rounded-full shrink-0"
                                                 :style="{backgroundColor: getGroupColor(item, sidebarTab === 'project' ? 'musicianId' : 'projectId', true)}">
                                            </div>

                                            <div class="flex flex-col min-w-0">
                                                <span class="text-xs font-bold truncate leading-tight flex items-center gap-1.5"
                                                      :class="{'line-through decoration-black/50 dark:decoration-white/50': item.isSkipped}">
                                                     {{
                                                        sidebarTab === 'instrument'
                                                                ? getNameById(item.musicianId, 'musician')
                                                                : (item.name || getNameById(item.instrumentId, 'instrument'))
                                                    }}

                                                   <span v-if="item.splitTag"
                                                         class="text-[8px] px-1 rounded-sm font-mono font-bold uppercase tracking-wider shrink-0 bg-red-500/10 text-red-500 no-underline inline-block">
                                                        {{ item.splitTag }}
                                                    </span>

                                                    <span v-if="item.isSkipped"
                                                          class="text-[8px] px-1 rounded-sm font-mono font-bold uppercase tracking-wider shrink-0 bg-black/10 dark:bg-white/20 text-black dark:text-white no-underline inline-block">
                                                        SKIP
                                                    </span>

                                                </span>

                                                <span class="text-[9px] opacity-50 truncate leading-tight mt-0.5">
                                                      {{
                                                        sidebarTab === 'project'
                                                        ? getNameById(item.musicianId, 'musician')
                                                        : getNameById(item.projectId, 'project')
                                                        }}
                                                </span>
                                            </div>
                                        </div>

                                        <div class="flex items-center justify-end gap-2 shrink-0">
                                            <span v-if="item.actualDuration"
                                                  class="text-xs sm:text-[9px] font-mono font-bold px-1 py-0.5 rounded whitespace-nowrap"
                                                  :class="parseFloat(calculateSingleRatio(item)) > getTaskRatio(item) ? 'text-red-500 bg-red-500/10' : 'text-green-600 bg-green-500/10'">
                                                x{{ calculateSingleRatio(item) }}
                                            </span>

                                            <span v-else-if="item.isManualRatio"
                                                  class="text-xs sm:text-[9px] font-mono font-bold text-gray-400 dark:text-gray-500 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded whitespace-nowrap">
                                                x{{ item.ratio }}
                                            </span>

                                            <div class="flex flex-col items-end gap-0.5 leading-none">
                                                    <span class="font-mono text-sm sm:text-xs font-bold tabular-nums tracking-tight block"
                                                          :class="item.actualDuration ? 'text-[#007aff] dark:text-[#0a84ff]' : 'opacity-80'">
                                                        {{ item.actualDuration || item.estDuration }}
                                                    </span>
                                                <span v-if="item.musicDuration && item.musicDuration !== item.estDuration"
                                                      class="text-[9px] sm:text-[8px] font-mono font-bold text-gray-400 dark:text-gray-500 opacity-60 whitespace-nowrap">
                                                        {{ item.musicDuration }}
                                                    </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </Transition>
                </div>
            </aside>


            <main id="main-content"
                  v-show="!isMobile || mobileTab==='schedule'"
                  class="flex-1 flex flex-col relative bg-white/30 dark:bg-[#1e1e1e]/60 backdrop-blur-md"
                  :class="isMobile ? 'w-full absolute inset-0 z-30' : ''"
                  @scroll="handleInfiniteScroll"
                  @touchstart="onMainTouchStart"
                  @touchend="onMainTouchEnd"

                  @mousedown="onMainMouseDown"
                  @mouseup="onMainMouseUp"
                  @mouseleave="isMouseViewDrag = false"
                  @wheel="onMainWheel">
                <div class="flex items-center justify-between pr-4 shrink-0 z-50 relative">
                    <button @click="toggleSidebar"
                            class="hidden sm:flex w-14 h-14 rounded-full bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 items-center justify-center transition text-gray-500 hover:text-[#007aff] ml-4 shrink-0"
                            :title="isSidebarOpen ? 'æ”¶èµ·ä¾§è¾¹æ ' : 'å±•å¼€ä¾§è¾¹æ '">
                        <i class="fa-solid text-lg transition-transform duration-300"
                           :class="isSidebarOpen ? 'fa-outdent' : 'fa-indent'"></i>
                    </button>
                    <div class="mobile-header-nav flex-1 !ml-2">
                        <button @click="changeDate(-1)"
                                class="w-12 h-10 flex items-center justify-center text-xl text-[#007aff] active:opacity-50">
                            <i class="fa-solid fa-chevron-left"></i>
                        </button>

                        <button @click="jumpToToday"
                                class="flex-1 flex flex-col items-center justify-center leading-none">
                            <span class="text-xs opacity-50 font-bold uppercase mb-0.5">{{ isToday(formatDate(viewDate)) ? 'Today' : 'Date'
                                }}</span>
                            <span class="text-base font-bold">{{ currentDateLabel }}</span>
                        </button>

                        <button @click="changeDate(1)"
                                class="w-12 h-10 flex items-center justify-center text-xl text-[#007aff] active:opacity-50">
                            <i class="fa-solid fa-chevron-right"></i>
                        </button>
                    </div>

                    <button id="tour-view-switch"
                            @click="switchView(currentView === 'week' ? 'month' : 'week')"
                            class="ml-2 w-14 h-14 rounded-full bg-black/5 dark:bg-white/10 flex items-center justify-center active:bg-[#007aff] active:text-white transition shrink-0">
                        <i class="fa-solid" :class="currentView==='week'?'fa-calendar-week':'fa-calendar-days'"></i>
                    </button>

                    <button @click="cycleDayWidth"
                            class="ml-4 w-14 h-14 rounded-full bg-black/5 dark:bg-white/10 flex items-center justify-center active:bg-[#007aff] active:text-white transition shrink-0">
                        <i class="fa-solid" :class="widthIcon"></i>
                    </button>
                </div>

                <div class="flex-1 relative w-full overflow-hidden flex flex-col">

                    <Transition :name="viewTransitionName">

                        <div v-if="currentView === 'week'"
                             key="view-week"
                             class="w-full h-full flex flex-col overflow-y-auto relative no-scrollbar overscroll-none"

                             :class="{ 'touch-pan-y': dayColWidth < 60, 'is-zooming-now': isZooming }"

                             ref="weekContainer"
                             :style="{ '--slot-height': slotHeight + 'px' }"
                             @click="clearSelection">
                            <div class="flex min-w-full" ref="weekGridWrapper">

                                <Transition :name="dateTransitionName"
                                            @before-leave="onBeforeLeave"
                                            @after-leave="onAfterLeave">

                                    <div :key="currentWeekDays[0].dateStr" class="w-full min-h-full">

                                        <div class="flex min-w-full min-h-full">

                                            <div class="sticky left-0 z-[800] bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-xl border-r border-glass-border dark:border-glass-borderDark shadow-sm"
                                                 style="width: var(--time-col-width)">

                                                <div class="h-14 w-full border-b border-transparent"></div>

                                                <div v-for="t in timeSlots" :key="t" class="time-label-slot">
                                                    {{ t.endsWith('00') ? t : '' }}
                                                </div>
                                                <div class="time-label-slot">
                                                    {{ settings.endHour === 24 ? '00:00' : settings.endHour + ':00' }}
                                                </div>
                                            </div>

                                            <div v-for="day in currentWeekDays" :key="day.dateStr"
                                                 class="flex-1 border-r border-glass-border dark:border-glass-borderDark flex flex-col relative transition-all duration-300 ease-in-out"
                                                 :style="{ minWidth: dayColWidth + 'px' }"
                                                 :data-date-str="day.dateStr">

                                                <div class="h-14 sticky top-0 z-[600] flex flex-col items-center justify-center bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-xl border-b border-glass-border dark:border-glass-borderDark shadow-sm cursor-pointer transition-colors hover:bg-gray-50 dark:hover:bg-white/5"
                                                     @dblclick="switchView('month')"
                                                     @touchend="handleHeaderDoubleTap($event)"
                                                     title="åŒå‡»è¿”å›æœˆè§†å›¾">

                                                    <span class="text-xs uppercase font-bold opacity-60 mb-0.5">{{ day.weekday }}</span>

                                                    <div class="w-8 h-8 flex items-center justify-center rounded-full text-base font-bold"
                                                         :class="isToday(day.dateStr) ? 'bg-[#ff3b30] text-white' : 'opacity-90'">
                                                        {{ day.dateShort.split('/')[1] }}
                                                    </div>
                                                </div>

                                                <div class="relative" style="min-height: 1000px;">
                                                    <div v-for="t in timeSlots" :key="t"
                                                         class="grid-slot droppable-slot"
                                                         :data-time="t"
                                                         @dragenter="dragEnterSlot" @dragleave="dragLeaveSlot"
                                                         @dragover.prevent
                                                         @drop="dropToSchedule($event, day.dateStr)"></div>

                                                    <div v-for="task in (tasksByDateMap[day.dateStr] || [])"
                                                         :key="task.scheduleId"
                                                         class="task-block group"
                                                         :draggable="!isMobile"
                                                         @dragstart.stop="dragStart($event, task, 'schedule')"
                                                         @dragend="handleDragEnd"

                                                         @touchstart.stop="handleTouchStart($event, task, day.dateStr)"
                                                         @touchmove="handleTouchMove"
                                                         @touchend.stop="handleTouchEnd"

                                                         @dblclick.stop="handleTaskDblClick($event, task)"

                                                         @dragover.prevent
                                                         @drop.stop="dropToSchedule($event, day.dateStr)"

                                                         :class="{
                                                           'is-selected': selectedTaskId === task.scheduleId,
                                                           'is-overlapping': getOverlapCount(task) > 0,
                                                           'is-flashing': flashingTaskId === task.scheduleId,
                                                           'is-ghost': isTaskGhost(task)
                                                         }"
                                                         :style="getTaskStyle(task)"
                                                         @click.stop="selectTask(task.scheduleId, 'schedule')">

                                                        <div class="flex flex-col h-full justify-between pointer-events-none">
                                                            <div class="font-bold leading-tight truncate pr-1">
                                                                {{ getBlockTitle(task) }}
                                                            </div>
                                                            <div class="mt-auto text-[10px] sm:text-[11px] font-mono opacity-80 leading-none">
                                                                <div class="flex flex-col items-start">
                                                                    <span class="whitespace-nowrap">{{task.startTime}}</span>
                                                                    <span class="font-bold whitespace-nowrap text-[10px] opacity-70 mt-0.5">
                                                                        {{task.estDuration}}
                                                                    </span>
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <div class="resize-handle"
                                                             @mousedown.stop="initResize($event, task)"></div>
                                                        <div v-if="hasRecordingInfo(task)"
                                                             class="absolute bottom-[1px] right-[2px] z-[15] pointer-events-none">
                                                            <i class="fa-solid fa-circle-info text-[10px] opacity-90"></i>
                                                        </div>
                                                        <div v-if="isMobile" class="mobile-resize-handle"
                                                             @touchstart.stop.prevent="initMobileResize($event, task)">
                                                            <div class="mobile-resize-bar"></div>
                                                        </div>
                                                    </div>

                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </Transition>
                            </div>
                        </div>

                        <div v-else-if="currentView === 'month'"
                             key="view-month"
                             class="w-full h-full overflow-y-auto overflow-x-hidden relative scroll-smooth"
                             @click="clearSelection">

                            <Transition :name="dateTransitionName" v-if="monthViewMode === 'paged'">
                                <div :key="viewDate.getFullYear() + '-' + viewDate.getMonth()"
                                     class="w-full min-h-full"
                                     :class="isMobile ? 'p-2 pb-40' : 'p-4'">

                                    <div class="grid grid-cols-7 border-t border-l border-glass-border dark:border-glass-borderDark bg-white/50 dark:bg-[#1e1e1e]/50 rounded-xl overflow-hidden shadow-liquid"
                                         :class="isMobile ? 'w-full min-h-[50vh]' : 'min-w-[800px]'">

                                        <div v-for="w in ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']"
                                             class="p-3 text-right text-xs uppercase font-bold opacity-40 border-b border-r border-glass-border dark:border-glass-borderDark bg-black/5 dark:bg-white/5">
                                            {{w}}
                                        </div>

                                        <div v-for="day in currentMonthDays" :key="day.fullDate"
                                             class="min-h-[100px] sm:h-36 p-1.5 border-b border-r border-glass-border dark:border-glass-borderDark relative hover:bg-black/5 dark:hover:bg-white/5 transition droppable-slot group flex flex-col"
                                             :data-date="day.fullDate"
                                             @dblclick="switchToWeek(day.fullDate)"
                                             @touchend="handleMonthCellDoubleTap($event, day.fullDate)"
                                             @dragover.prevent @drop="dropToMonth($event, day.fullDate)">

                                            <div class="text-right mb-1 shrink-0">
                                                <span class="text-sm font-bold w-7 h-7 inline-flex items-center justify-center rounded-full"
                                                      :class="[isToday(day.fullDate) ? 'bg-[#ff3b30] text-white' : (day.isCurrentMonth ? 'opacity-80' : 'opacity-30')]">
                                                    {{ day.dayNum }}
                                                </span>
                                            </div>

                                            <div class="space-y-1 overflow-y-auto max-h-[90px] no-scrollbar flex-1">
                                                <div v-for="task in (tasksByDateMap[day.fullDate] || [])"
                                                     :key="task.scheduleId"
                                                     class="text-[11px] px-2 py-1 rounded-md truncate flex items-center gap-1.5 cursor-grab hover:brightness-110 shadow-sm"
                                                     :class="{
                                                                 'ring-1 ring-white': selectedTaskId === task.scheduleId,
                                                                 'is-flashing': flashingTaskId === task.scheduleId,
                                                                 'is-ghost': isTaskGhost(task)
                                                             }"
                                                     :style="{
                                                                 backgroundColor: task.projectId ? '#eab308' : (task.instrumentId ? '#3b82f6' : '#a855f7'),
                                                                 color: 'white'
                                                             }"
                                                     @click.stop="selectTask(task.scheduleId, 'schedule')"
                                                     @dblclick.stop="handleTaskDblClick($event, task)"
                                                     :draggable="!isMobile"
                                                     @dragstart.stop="dragStart($event, task, 'schedule')"
                                                     @dragend="handleDragEnd"
                                                     @touchstart="handleTouchStart($event, task, day.fullDate)"
                                                     @touchmove="handleTouchMove"
                                                     @touchend.stop="handleTouchEnd">
                                                    <div class="w-1.5 h-1.5 rounded-full bg-white/40"></div>
                                                    <span class="font-mono opacity-80">{{task.startTime}}</span>
                                                    <span class="font-bold truncate">{{ getBlockTitle(task) }}</span>
                                                    <i v-if="hasRecordingInfo(task)" class="fa-solid fa-circle-info text-[8px] opacity-60 ml-auto mr-0.5"></i>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </Transition>

                            <div v-else class="w-full pb-20 animate-[fadeIn_0.3s]">
                                <div class="sticky top-0 z-[100] grid grid-cols-7 bg-gray-100/95 dark:bg-[#1c1c1e]/95 backdrop-blur-md border-b border-glass-border dark:border-glass-borderDark shadow-sm">
                                    <div v-for="w in ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']"
                                         class="p-2 text-center text-[10px] uppercase font-bold opacity-50">
                                        {{w}}
                                    </div>
                                </div>

                                <div class="grid grid-cols-7 border-l border-glass-border dark:border-glass-borderDark bg-white/50 dark:bg-[#1e1e1e]/50"
                                     :class="isMobile ? 'w-full' : 'min-w-[800px]'">

                                    <div v-for="day in flatScrolledDays" :key="day.fullDate"
                                         class="min-h-[100px] sm:h-48 p-1.5 border-b border-r border-glass-border dark:border-glass-borderDark relative transition droppable-slot group flex flex-col"
                                         :class="day.isCurrentMonth ? 'hover:bg-black/5 dark:hover:bg-white/5' : 'bg-black/5 dark:bg-white/5 opacity-60'"
                                         :data-date="day.fullDate"
                                         :data-month-start="day.isFirstDay ? day.fullDate : null"
                                         :ref="day.isFirstDay ? setMonthRef : null"
                                         @dblclick="day.isCurrentMonth && switchToWeek(day.fullDate)"
                                         @touchend="day.isCurrentMonth && handleMonthCellDoubleTap($event, day.fullDate)"
                                         @dragover.prevent
                                         @drop="day.isCurrentMonth && dropToMonth($event, day.fullDate)">

                                        <div class="text-right mb-1 shrink-0">
                <span v-if="day.dayNum === 1" class="float-left ml-1 text-xs font-bold text-[#007aff] opacity-80">
                    {{ day.dateObj.getMonth() + 1 }}æœˆ
                </span>

                                            <span class="text-sm font-bold w-7 h-7 inline-flex items-center justify-center rounded-full"
                                                  :class="[isToday(day.fullDate) ? 'bg-[#ff3b30] text-white' : (day.isCurrentMonth ? 'opacity-80' : 'opacity-30')]">
                    {{ day.dayNum }}
                </span>
                                        </div>

                                        <div class="space-y-1 overflow-y-auto no-scrollbar flex-1">
                                            <div v-for="task in (tasksByDateMap[day.fullDate] || [])"
                                                 :key="task.scheduleId"
                                                 class="text-[11px] px-2 py-1 rounded-md truncate flex items-center gap-1.5 cursor-grab hover:brightness-110 shadow-sm"
                                                 :class="{
                         'ring-1 ring-white': selectedTaskId === task.scheduleId,
                         'is-flashing': flashingTaskId === task.scheduleId,
                         'is-ghost': isTaskGhost(task)
                     }"
                                                 :style="{
                         backgroundColor: task.projectId ? '#eab308' : (task.instrumentId ? '#3b82f6' : '#a855f7'),
                         color: 'white'
                     }"
                                                 @click.stop="selectTask(task.scheduleId, 'schedule')"
                                                 @dblclick.stop="handleTaskDblClick($event, task)"
                                                 :draggable="!isMobile"
                                                 @dragstart.stop="dragStart($event, task, 'schedule')"
                                                 @dragend="handleDragEnd"
                                                 @touchstart="handleTouchStart($event, task, day.fullDate)"
                                                 @touchmove="handleTouchMove"
                                                 @touchend.stop="handleTouchEnd">
                                                <div class="w-1.5 h-1.5 rounded-full bg-white/40"></div>
                                                <span class="font-mono opacity-80">{{task.startTime}}</span>
                                                <span class="font-bold truncate">{{ getBlockTitle(task) }}</span>
                                                <i v-if="hasRecordingInfo(task)" class="fa-solid fa-circle-info text-[8px] opacity-60 ml-auto mr-0.5"></i>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </Transition>
                </div>
            </main>

            <div v-if="isMobile"
                 class="fixed z-[850] transition-all duration-300 ease-spring"
                 :style="isSearchFocused
                     ? { top: '45%', left: '16px', right: '16px', height: '50px' }
                     : { top: 'calc(100dvh - 152px)', left: '20px', right: '20px', height: '50px' }">
                <div class="relative w-full h-full shadow-lg rounded-full">
                    <div class="absolute inset-0 backdrop-blur-xl rounded-full border border-white/40 dark:border-white/10 shadow-sm transition-colors"
                         :class="isSearchFocused ? 'bg-white/95 dark:bg-[#2c2c2e]' : 'bg-white/80 dark:bg-[#1c1c1e]/80'">
                    </div>

                    <i class="fa-solid fa-magnifying-glass absolute left-5 top-1/2 -translate-y-1/2 text-gray-400 text-sm z-10"></i>

                    <input v-model="globalSearchQuery"
                           @focus="onSearchFocus"
                           @blur="handleSearchBlur"
                           @keydown.enter="handleSearchEnter"
                           class="relative w-full h-full bg-transparent pl-12 pr-12 text-base font-bold text-gray-800 dark:text-white placeholder:text-gray-400 dark:placeholder:text-gray-500 rounded-full outline-none"
                           placeholder="Search..."
                           enterkeyhint="search"
                           style="caret-color: #007aff;">

                    <button v-if="globalSearchQuery"
                            @mousedown.prevent
                            @click="globalSearchQuery = ''"
                            class="absolute right-2 top-1/2 -translate-y-1/2 w-8 h-8 flex items-center justify-center rounded-full text-gray-400 active:bg-black/10 dark:active:bg-white/10 transition z-10">
                        <i class="fa-solid fa-circle-xmark text-lg opacity-80"></i>
                    </button>
                </div>
            </div>

            <div v-if="isMobile && isSearchFocused"
                 class="fixed inset-0 z-[840] bg-black/20 dark:bg-black/50 backdrop-blur-[2px] transition-opacity duration-300"
                 @click="isSearchFocused = false">
            </div>


            <div v-if="isMobile" class="mobile-tab-bar">
                <button @click="mobileTab='pool'; showMobileTaskInput=false"
                        class="mobile-tab-item"
                        :class="{'active': mobileTab==='pool' && !showMobileTaskInput}">
                    <i class="fa-solid fa-layer-group"></i>
                    <span>ä»»åŠ¡æ± </span>
                </button>

                <button @click="showMobileTaskInput = true"
                        class="mobile-tab-item"
                        :class="{'active': showMobileTaskInput}">
                    <i class="fa-solid fa-circle-plus text-2xl mb-0.5"></i>
                    <span>æ·»åŠ </span>
                </button>

                <button @click="mobileTab='schedule'; showMobileTaskInput=false"
                        class="mobile-tab-item"
                        :class="{'active': mobileTab==='schedule' && !showMobileTaskInput}">
                    <i class="fa-regular fa-calendar-days"></i>
                    <span>æ—¥ç¨‹è¡¨</span>
                </button>
            </div>
        </div>
    </div>

    <div v-if="showSettings" class="modal-overlay z-[5000]" @click.self="showSettings=false">
        <div class="modal-window w-[600px] flex flex-col p-8 animate-[fadeIn_0.2s] max-h-[85vh]">
            <div class="flex justify-between items-center mb-6 shrink-0">
                <h3 class="text-2xl font-bold">Preferences</h3>
                <button @click="showSettings=false"
                        class="w-8 h-8 rounded-full bg-black/10 dark:bg-white/10 hover:bg-black/20 flex items-center justify-center transition">
                    âœ•
                </button>
            </div>

            <div class="space-y-8 overflow-y-auto pr-2 flex-1" @scroll="onSettingsScroll">

                <section>
                    <h4 class="text-xs font-bold uppercase opacity-50 mb-3">Schedule View Range / æ—¥ç¨‹è¡¨æ˜¾ç¤ºèŒƒå›´</h4>
                    <div class="flex items-center gap-4 bg-black/5 dark:bg-white/5 p-4 rounded-xl border border-black/5 dark:border-white/5">
                        <div class="flex-1">
                            <label class="text-[10px] font-bold opacity-50 uppercase block mb-1">Start Hour (0-23)</label>
                            <input type="number" v-model.number="settings.startHour" min="0" max="23"
                                   class="glass-input w-full font-mono font-bold text-center h-10"
                                   @change="pushHistory">
                        </div>
                        <div class="text-xl opacity-30 pt-4">
                            <i class="fa-solid fa-arrow-right"></i>
                        </div>
                        <div class="flex-1">
                            <label class="text-[10px] font-bold opacity-50 uppercase block mb-1">End Hour (1-24)</label>
                            <input type="number" v-model.number="settings.endHour" min="1" max="24"
                                   class="glass-input w-full font-mono font-bold text-center h-10"
                                   @change="pushHistory">
                        </div>
                    </div>
<!--                    <p class="text-[10px] opacity-40 mt-2 ml-1">-->
<!--                        * è®¾ç½®æ—¥ç¨‹è¡¨çš„æ¯æ—¥èµ·å§‹å’Œç»“æŸæ—¶é—´ (ä¾‹å¦‚ 10ç‚¹ åˆ° 22ç‚¹)-->
<!--                    </p>-->
                </section>

                <template v-for="type in ['instrument', 'musician', 'project']" :key="type">
                    <section>
                        <div class="flex justify-between items-center mb-3">
                            <div class="flex items-center gap-3">
                                <h4 class="text-xs font-bold uppercase opacity-50">
                                    {{ type === 'instrument' ? 'Instruments' : (type === 'musician' ? 'Musicians' : 'Projects') }}
                                </h4>

                                <button @click="toggleAllGroups(type)"
                                        class="w-6 h-6 rounded-md bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 flex items-center justify-center transition text-gray-500"
                                        :title="isAllGroupsExpanded(type) ? 'å…¨éƒ¨æŠ˜å ' : 'å…¨éƒ¨å±•å¼€'">
                                    <i class="fa-solid text-[10px]"
                                       :class="isAllGroupsExpanded(type) ? 'fa-compress' : 'fa-expand'"></i>
                                </button>
                            </div>

                            <button @click="clearSettingsList(type)"
                                    class="text-[10px] font-bold text-red-500 bg-red-500/5 hover:bg-red-500/20 px-2 py-1 rounded transition uppercase tracking-wider">
                                Clear
                            </button>
                        </div>

                        <div class="space-y-3">
                            <div v-for="group in allSettingsGrouped[type]" :key="group.name"
                                 class="settings-group-container"
                                 @dragover.prevent="onSettingsDragOver"
                                 @dragleave="onSettingsDragLeave"
                                 @drop="onSettingsDrop(type, group.name, $event)">

                                <div class="settings-group-header group/header"
                                     @click="toggleSettingsGroup(type, group.name)">
                                    <div class="w-6 flex justify-center opacity-30 mr-2 transition-transform duration-200"
                                         :class="{'rotate-90': settingsExpandedGroups.has(type + '|' + group.name)}"> <i class="fa-solid fa-chevron-right text-[10px]"></i>
                                    </div>

                                    <input :value="group.name"
                                           @click.stop
                                           @change="renameGroup(type, group.name, $event.target.value)"
                                           class="settings-group-input flex-1"
                                           :style="{
                                                   color: type === 'project' ? '#eab308' :
                                                          (type === 'instrument' ? '#3b82f6' : '#a855f7')
                                               }"
                                           placeholder="æœªåˆ†ç»„">

                                    <span class="text-[10px] font-bold opacity-30 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded ml-2 text-black dark:text-white">
                                        {{ group.items.length }}
                                    </span>
                                </div>

                                <div v-show="settingsExpandedGroups.has(type + '|' + group.name)" class="pl-2 pr-2 pb-2 space-y-1">
                                    <div v-for="item in group.items" :key="item.id"
                                         class="flex items-center gap-2 p-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/5 transition group/item bg-white/40 dark:bg-black/20"
                                         draggable="true"
                                         @dragstart="onSettingsItemDragStart(item, type, $event)"
                                         @dragend="onSettingsItemDragEnd($event)"
                                         @dblclick="type === 'project' && openMidiManager(item)"> <div class="p-1 text-gray-400 opacity-30 group-hover/item:opacity-100 cursor-grab">
                                            <i class="fa-solid fa-grip-vertical text-xs"></i>
                                        </div>

                                        <button @click="openColorPicker(item, type)"
                                                class="w-6 h-6 rounded flex items-center justify-center text-white shadow-sm shrink-0 cursor-pointer hover:scale-110 active:scale-95 transition-transform"
                                                :style="{ backgroundColor: item.color }">
                                            <i class="fa-solid text-[10px]"
                                               :class="type==='project'?'fa-folder':(type==='instrument'?'fa-guitar':'fa-user')"></i>
                                        </button>

                                        <input :value="item.name"
                                               @change="handleItemRename(type, item, $event)"
                                               class="bg-transparent border-none outline-none font-medium flex-1 text-sm cursor-text min-w-0"
                                               placeholder="Name"
                                               @mousedown.stop
                                               @click.stop

                                               @mouseenter="disableRowDrag($event)"
                                               @mouseleave="enableRowDrag($event)"
                                               @focus="disableRowDrag($event)"
                                               @blur="enableRowDrag($event)">

                                        <button @click="openProjectInfoModal(item)"
                                                class="w-6 h-6 flex items-center justify-center rounded hover:bg-blue-500/10 text-gray-400 hover:text-blue-500 transition opacity-0 group-hover/item:opacity-100"
                                                :class="{'!text-blue-500 !opacity-100': item.mixingEngineer || item.mixingStudio || item.masteringEngineer || item.masteringStudio}"
                                                title="Project Info & Credits">
                                            <i class="fa-solid fa-circle-info text-xs"></i>
                                        </button>

                                        <button v-if="type === 'project'"
                                                @click.stop="openMidiManager(item)"
                                                class="w-6 h-6 flex items-center justify-center rounded hover:bg-teal-500/10 text-gray-400 hover:text-teal-500 transition opacity-0 group-hover/item:opacity-100"
                                                :class="{'!text-teal-500 !opacity-100': item.midiData && Object.keys(item.midiData).length > 0}"
                                                title="ç®¡ç† MIDI æ˜ å°„">
                                            <i class="fa-solid fa-users-line text-xs"></i>
                                        </button>

                                        <button @click="removeSettingsItem(type, item.id)"
                                                class="w-6 h-6 flex items-center justify-center rounded hover:bg-red-500/10 text-gray-400 hover:text-red-500 transition opacity-0 group-hover/item:opacity-100">
                                            <i class="fa-solid fa-trash text-xs"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div class="flex gap-2 items-center mt-4 p-1 relative isolate">

                                <div class="settings-name-wrapper relative flex-1">

                                    <input v-model="newSettingsItem[type].name"
                                           @focus="updateInputRect($event, 'name'); settingsNameFocus = type"
                                           class="glass-input w-full h-10 pr-8"
                                           :placeholder="'New ' + (type==='instrument'?'Instrument':(type==='musician'?'Musician':'Project')) + ' Name'"
                                           @keydown.enter="addSettingsItem(type)">

                                    <i class="fa-solid fa-chevron-up absolute right-2.5 top-3 text-[10px] transition-transform duration-200 cursor-pointer opacity-50 hover:opacity-100"
                                       :class="{'rotate-180': settingsNameFocus === type}"
                                       @mousedown.prevent="updateInputRect($event, 'name'); settingsNameFocus = (settingsNameFocus === type ? null : type)"></i>

                                    <Teleport to="body">
                                        <div v-if="settingsNameFocus === type"
                                             :style="getFloatingStyle('name')"
                                             class="custom-dropdown-menu max-h-40 overflow-y-auto p-1 origin-bottom animate-[fadeIn_0.1s] shadow-xl border border-black/5 dark:border-white/10">

                                            <div class="px-2 py-1 text-[10px] font-bold opacity-40 uppercase tracking-wider sticky top-0 bg-white/95 dark:bg-[#2c2c2e]/95 backdrop-blur z-10">
                                                æ•´ç†æœªåˆ†ç»„é¡¹ / æˆ–è¾“å…¥æ–°å:
                                            </div>

                                            <div v-for="u in getUngroupedItems(type)" :key="u.id"
                                                 @mousedown.prevent="newSettingsItem[type].name = u.name; settingsNameFocus = null"
                                                 class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-xs font-bold transition-colors flex items-center gap-2">
                                                <div class="w-2 h-2 rounded-full" :style="{backgroundColor: u.color}"></div>
                                                {{ u.name }}
                                            </div>

                                            <div v-if="getUngroupedItems(type).length === 0"
                                                 class="px-3 py-4 text-center opacity-40 text-[10px]">
                                                æš‚æ— æœªåˆ†ç»„é¡¹ç›®
                                            </div>
                                        </div>
                                    </Teleport>
                                </div>

                                <div class="settings-group-wrapper relative w-1/3">
                                    <input v-model="newSettingsItem[type].group"
                                           @focus="updateInputRect($event, 'group'); settingsGroupFocus = type"
                                           class="glass-input w-full h-10 text-xs pr-7"
                                           placeholder="åˆ†ç»„ (å¯é€‰)"
                                           @keydown.enter="addSettingsItem(type)">

                                    <i class="fa-solid fa-chevron-up absolute right-2.5 top-3 text-[10px] transition-transform duration-200 cursor-pointer opacity-50 hover:opacity-100"
                                       :class="{'rotate-180': settingsGroupFocus === type}"
                                       @mousedown.prevent="updateInputRect($event, 'group'); settingsGroupFocus = (settingsGroupFocus === type ? null : type)"></i>

                                    <Teleport to="body">
                                        <div v-if="settingsGroupFocus === type"
                                             :style="getFloatingStyle('group')"
                                             class="custom-dropdown-menu max-h-40 overflow-y-auto p-1 origin-bottom animate-[fadeIn_0.1s] shadow-xl border border-black/5 dark:border-white/10">

                                            <div class="px-2 py-1 text-[10px] font-bold opacity-40 uppercase tracking-wider sticky top-0 bg-white/95 dark:bg-[#2c2c2e]/95 backdrop-blur z-10">
                                                é€‰æ‹©ç°æœ‰åˆ†ç»„:
                                            </div>

                                            <div v-for="g in getExistingGroups(type)" :key="g"
                                                 @mousedown.prevent="newSettingsItem[type].group = g; settingsGroupFocus = null"
                                                 class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-xs font-bold transition-colors text-gray-800 dark:text-gray-200">
                                                {{ g }}
                                            </div>

                                            <div v-if="getExistingGroups(type).length === 0"
                                                 class="px-3 py-4 text-center opacity-40 text-[10px]">
                                                æš‚æ— åˆ†ç»„ï¼Œç›´æ¥è¾“å…¥åˆ›å»º
                                            </div>
                                        </div>
                                    </Teleport>
                                </div>

                                <button @click="addSettingsItem(type)"
                                        class="h-10 px-4 rounded-xl font-bold text-white shadow-lg transition text-sm flex items-center gap-2 shrink-0 active:scale-95"
                                        :class="type==='project'?'bg-[#eab308] hover:bg-[#ca8a04]':(type==='instrument'?'bg-[#3b82f6] hover:bg-[#2563eb]':'bg-[#a855f7] hover:bg-[#9333ea]')">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                            </div>
                        </div>
                    </section>
                </template>

                <section class="p-4 rounded-xl bg-black/5 dark:bg-white/5 border border-black/5 dark:border-white/5 transition-all duration-300">
                    <div class="flex justify-between items-center" :class="{'mb-4': showMetadataManager}">
                        <div class="flex items-center gap-3">
                            <div class="w-8 h-8 rounded-full bg-blue-500/10 flex items-center justify-center text-blue-500">
                                <i class="fa-solid fa-database"></i>
                            </div>
                            <div>
                                <h4 class="text-xs font-bold uppercase opacity-70">Metadata</h4>
                                <p class="text-[10px] opacity-40">Studios, Engineers, Assistants...</p>
                            </div>
                        </div>

                        <button @click="showMetadataManager = !showMetadataManager"
                                class="px-3 py-1.5 rounded-lg transition text-[10px] font-bold flex items-center gap-2 border"
                                :class="showMetadataManager
                    ? 'bg-[#007aff] text-white border-[#007aff] shadow-lg shadow-blue-500/30'
                    : 'bg-white dark:bg-white/10 hover:bg-gray-50 dark:hover:bg-white/20 border-black/5 dark:border-white/5'">
                            <i class="fa-solid" :class="showMetadataManager ? 'fa-chevron-up' : 'fa-pen-to-square'"></i>
                            <span>{{ showMetadataManager ? 'Close' : 'Edit MetaData' }}</span>
                        </button>
                    </div>

                    <div v-if="showMetadataManager" class="grid grid-cols-1 sm:grid-cols-2 gap-4 animate-[fadeIn_0.2s]">
                        <template v-for="type in ['studio', 'engineer', 'operator', 'assistant']" :key="type">
                            <div class="bg-white/50 dark:bg-black/20 rounded-xl p-3 border border-black/5 dark:border-white/5">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="text-xs font-bold capitalize opacity-70">{{ type }}s</span>
                                    <span class="text-[10px] opacity-30 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded font-mono">{{ settings[type+'s'].length }}</span>
                                </div>

                                <div class="space-y-1 mb-2 max-h-[120px] overflow-y-auto pr-1 custom-scrollbar">
                                    <div v-for="item in settings[type+'s']" :key="item.id"
                                         class="flex items-center justify-between p-2 rounded-lg bg-white/40 dark:bg-white/5 hover:bg-white/80 dark:hover:bg-white/10 group transition-colors">
                                        <input :value="item.name"
                                               @change="handleRecRename(type, item, $event)"
                                               class="bg-transparent border-none outline-none font-bold flex-1 text-xs cursor-text min-w-0 text-gray-800 dark:text-gray-200"
                                               placeholder="Name"
                                               @mousedown.stop
                                               @click.stop>
                                        <button @click="removeRecItem(type, item.id)" class="w-5 h-5 flex items-center justify-center rounded opacity-0 group-hover:opacity-100 text-gray-400 hover:text-red-500 hover:bg-red-500/10 transition">
                                            <i class="fa-solid fa-xmark text-[10px]"></i>
                                        </button>
                                    </div>
                                    <div v-if="settings[type+'s'].length === 0" class="text-[10px] opacity-30 text-center py-4">
                                        No items
                                    </div>
                                </div>

                                <div class="flex gap-2 relative">
                                    <input v-model="newRecInputs[type]"
                                           class="glass-input h-8 text-xs flex-1 min-w-0 pr-7"
                                           :placeholder="'Add ' + type + '...'"
                                           @keydown.enter="addRecItem(type)">

                                    <button @click="addRecItem(type)"
                                            class="absolute right-0 top-0 h-8 w-8 rounded-lg text-gray-400 hover:text-[#007aff] transition flex items-center justify-center">
                                        <i class="fa-solid fa-plus text-xs"></i>
                                    </button>
                                </div>
                            </div>
                        </template>
                    </div>
                </section>

                <section class="p-4 rounded-xl bg-orange-500/10 border border-orange-500/20">
                    <div class="flex justify-between items-center mb-3">
                        <div>
                            <h4 class="text-xs font-bold uppercase text-orange-600 dark:text-orange-400 mb-1">CSV Data Import</h4>
                            <p class="text-[11px] opacity-60">æ‰¹é‡å¯¼å…¥ä»»åŠ¡ã€æ—¶é—´æˆ–ç¼–åˆ¶ä¿¡æ¯</p>
                        </div>
                        <button @click="triggerCSV('general')"
                                class="flex items-center gap-2 px-4 py-2 rounded-lg bg-orange-500 hover:bg-orange-600 text-white shadow-lg shadow-orange-500/20 transition group">
                            <i class="fa-solid fa-file-csv text-lg"></i>
                            <span class="text-xs font-bold">é€‰æ‹© CSV æ–‡ä»¶...</span>
                        </button>
                    </div>
                    <input id="csv-import-input" type="file" accept=".csv" class="hidden" @change="handleCSVImport">
                </section>
<!--                <section class="p-4 rounded-xl bg-purple-500/10 border border-purple-500/20">-->
<!--                    <div class="flex justify-between items-center">-->
<!--                        <div>-->
<!--                            <h4 class="text-xs font-bold uppercase text-purple-600 dark:text-purple-400 mb-1">Ratio Maintenance</h4>-->
<!--                            <p class="text-[11px] opacity-60 max-w-[250px]">å°†æ‰€æœ‰ x20 (é»˜è®¤) çš„ä»»åŠ¡é‡ç½®ä¸ºâ€œè‡ªåŠ¨è·Ÿéšâ€æ¨¡å¼ï¼Œä»¥åº”ç”¨å¤§å¡ç‰‡çš„å¹³å‡æ•ˆç‡ã€‚</p>-->
<!--                        </div>-->
<!--                        <button @click="cleanOldRatios"-->
<!--                                class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow-lg shadow-purple-500/20 transition flex items-center gap-2">-->
<!--                            <i class="fa-solid fa-wand-magic-sparkles"></i> æ¸…é™¤è‡ªå®šä¹‰å€ç‡-->
<!--                        </button>-->
<!--                    </div>-->
<!--                </section>-->
            </div>

            <div class="mt-8 pt-4 border-t border-glass-border dark:border-glass-borderDark flex justify-between items-center shrink-0">
                <button @click="factoryReset"
                        class="text-xs font-bold text-red-400 hover:text-red-500 hover:bg-red-500/10 px-4 py-2 rounded-lg transition flex items-center gap-2">
                    <i class="fa-solid fa-triangle-exclamation"></i> æ¢å¤å‡ºå‚è®¾ç½®
                </button>

                <button @click="showSettings=false"
                        class="bg-[#007aff] hover:bg-[#0062cc] text-white px-8 py-2.5 rounded-xl font-bold shadow-lg shadow-blue-500/30 transition text-sm">
                    Done
                </button>
            </div>
        </div>
    </div>

    <div v-if="showEditor" class="modal-overlay" @click.self="showEditor=false">
        <div class="modal-window w-96 max-h-[85vh] flex flex-col p-6 animate-[fadeIn_0.1s] relative">

            <div v-if="editingSource === 'pool'" class="absolute top-6 right-6 z-10">
                <label class="flex items-center gap-2 cursor-pointer select-none group" title="è¯¥æ›²ç›®ä¸è®¡å…¥æ€»æ—¶é•¿ï¼Œä¸å‚ä¸æ’æœŸè®¡ç®—">
                <span class="text-[10px] font-bold uppercase tracking-wider transition-colors"
                      :class="editingItem.isSkipped ? 'text-red-500' : 'opacity-30 group-hover:opacity-100'">
                    {{ editingItem.isSkipped ? 'Skip / ä¸å½•' : 'Active' }}
                </span>
                    <div class="relative w-10 h-5 rounded-full transition-colors duration-300 border border-black/5 dark:border-white/5"
                         :class="editingItem.isSkipped ? 'bg-red-500' : 'bg-black/10 dark:bg-white/10'">
                        <input type="checkbox" v-model="editingItem.isSkipped" class="hidden" @change="triggerTouchHaptic('Medium')">
                        <div class="absolute top-1 left-1 w-3 h-3 bg-white rounded-full shadow-sm transition-transform duration-300"
                             :class="editingItem.isSkipped ? 'translate-x-5' : 'translate-x-0'"></div>
                    </div>
                </label>
            </div>

            <h3 class="font-bold text-xl mb-4 shrink-0">Edit Event</h3>

            <div class="space-y-4 text-sm overflow-y-auto flex-1 min-h-0 pr-1 custom-scrollbar">

                <div class="grid grid-cols-2 gap-3 relative">
                    <div class="relative transition-all" :class="activeDropdown === 'edit_project' ? 'z-[50]' : 'z-20'">
                        <button @click.stop="toggleDropdown('edit_project')" class="glass-input w-full h-[42px] flex items-center px-3 font-bold text-sm group">
                            <span class="flex-1 truncate text-center">{{ getNameById(editingItem.projectId, 'project') }}</span>
                            <i class="fa-solid fa-chevron-down opacity-30 text-[10px] transition-transform duration-200" :class="{'rotate-180': activeDropdown === 'edit_project'}"></i>
                        </button>
                        <div v-if="activeDropdown === 'edit_project'" class="custom-dropdown-menu">
                            <div class="sticky top-0 bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-md p-2 border-b border-black/5 dark:border-white/5 z-20">
                                <input v-model="dropdownSearch" placeholder="æœç´¢é¡¹ç›®..." class="w-full bg-transparent text-sm px-2 py-1 outline-none placeholder:opacity-50" @click.stop>
                            </div>
                            <div class="max-h-[200px] overflow-y-auto">
                                <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">
                                    <div class="sticky top-0 z-10 w-full px-3 py-1.5 text-[10px] font-bold uppercase tracking-wider opacity-50 bg-gray-50/90 dark:bg-[#2c2c2e]/90 backdrop-blur border-y border-black/5 dark:border-white/5 flex justify-between items-center cursor-pointer" @click.stop="toggleDropdownGroup(group.name)">
                                        {{ group.name }} <i class="fa-solid fa-chevron-right transition-transform" :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                    </div>
                                    <div v-for="item in group.items" :key="item.id" @click="selectOption('project', item)" class="px-3 py-2.5 text-sm border-b border-black/5 dark:border-white/5 hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer flex items-center gap-2">
                                        <div class="w-2 h-2 rounded-full shrink-0" :style="{backgroundColor: item.color || '#eab308'}"></div>
                                        {{ item.name }}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="relative transition-all" :class="activeDropdown === 'edit_instrument' ? 'z-[50]' : 'z-20'">
                        <button @click.stop="toggleDropdown('edit_instrument')" class="glass-input w-full h-[42px] flex items-center px-3 font-bold text-sm group">
                            <span class="flex-1 truncate text-center">{{ getNameById(editingItem.instrumentId, 'instrument') }}</span>
                            <i class="fa-solid fa-chevron-down opacity-30 text-[10px] transition-transform duration-200" :class="{'rotate-180': activeDropdown === 'edit_instrument'}"></i>
                        </button>
                        <div v-if="activeDropdown === 'edit_instrument'" class="custom-dropdown-menu">
                            <div class="sticky top-0 bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-md p-2 border-b border-black/5 dark:border-white/5 z-20">
                                <input v-model="dropdownSearch" placeholder="æœç´¢ä¹å™¨..." class="w-full bg-transparent text-sm px-2 py-1 outline-none placeholder:opacity-50" @click.stop>
                            </div>
                            <div class="max-h-[200px] overflow-y-auto">
                                <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">
                                    <div class="sticky top-0 z-10 w-full px-3 py-1.5 text-[10px] font-bold uppercase tracking-wider opacity-50 bg-gray-50/90 dark:bg-[#2c2c2e]/90 backdrop-blur border-y border-black/5 dark:border-white/5 flex justify-between items-center cursor-pointer" @click.stop="toggleDropdownGroup(group.name)">
                                        {{ group.name }} <i class="fa-solid fa-chevron-right transition-transform" :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                    </div>
                                    <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">
                                        <div v-for="item in group.items" :key="item.id" @click="selectOption('instrument', item)" class="px-3 py-2.5 text-sm border-b border-black/5 dark:border-white/5 hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer flex items-center gap-2">
                                            <div class="w-2 h-2 rounded-full shrink-0" :style="{backgroundColor: item.color || '#3b82f6'}"></div>
                                            {{ item.name }}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <input :value="editingItem.musicDuration" @input="editingItem.musicDuration = $event.target.value" :readonly="isMobile" @click="isMobile && openDurationPicker($event, editingItem, 'musicDuration')" class="glass-input w-full font-mono font-bold tracking-widest text-center text-lg h-[42px]" :class="isMobile ? 'cursor-pointer caret-transparent' : 'cursor-text'" placeholder="00:00">

                    <div class="relative transition-all" :class="activeDropdown === 'edit_musician' ? 'z-[50]' : 'z-20'">
                        <button @click.stop="toggleDropdown('edit_musician')" class="glass-input w-full h-[42px] flex items-center px-3 font-bold text-sm group">
                            <span class="flex-1 truncate text-center">{{ getNameById(editingItem.musicianId, 'musician') }}</span>
                            <i class="fa-solid fa-chevron-down opacity-30 text-[10px] transition-transform duration-200" :class="{'rotate-180': activeDropdown === 'edit_musician'}"></i>
                        </button>
                        <div v-if="activeDropdown === 'edit_musician'" class="custom-dropdown-menu">
                            <div class="sticky top-0 bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-md p-2 border-b border-black/5 dark:border-white/5 z-20">
                                <input v-model="dropdownSearch" placeholder="æœç´¢äººå‘˜..." class="w-full bg-transparent text-sm px-2 py-1 outline-none placeholder:opacity-50" @click.stop>
                            </div>
                            <div class="max-h-[200px] overflow-y-auto">
                                <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">
                                    <div class="sticky top-0 z-10 w-full px-3 py-1.5 text-[10px] font-bold uppercase tracking-wider opacity-50 bg-gray-50/90 dark:bg-[#2c2c2e]/90 backdrop-blur border-y border-black/5 dark:border-white/5 flex justify-between items-center cursor-pointer" @click.stop="toggleDropdownGroup(group.name)">
                                        {{ group.name }} <i class="fa-solid fa-chevron-right transition-transform" :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                    </div>
                                    <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">
                                        <div v-for="m in group.items" :key="m.id" @click="selectOption('musician', m)" class="px-3 py-2.5 text-sm border-b border-black/5 dark:border-white/5 hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer flex justify-between items-center">
                                            <div class="flex items-center gap-2">
                                                <div class="w-2 h-2 rounded-full shrink-0" :style="{backgroundColor: m.color || '#a855f7'}"></div>
                                                <span>{{ m.name }}</span>
                                            </div>
                                            <span class="text-[10px] opacity-50 font-mono bg-black/5 dark:bg-white/10 px-1 rounded">x{{m.defaultRatio}}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div v-if="showOrchestrationField" class="mt-3">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1 ml-1">Orchestration / ç¼–åˆ¶</label>
                    <div class="flex items-center gap-2">
                        <input v-model="editingItem.orchestration"
                               class="glass-input flex-1 text-sm font-mono placeholder:text-gray-400"
                               placeholder="ä¾‹å¦‚: 4 Fl, 3 Ob (è‡ªåŠ¨ç”Ÿæˆåå•)"
                               @keydown.enter="saveEdit">

                        <div class="flex gap-1">
                            <button @click="editingItem.orchestration = activeOrchPresets.full"
                                    class="px-2 py-1 rounded bg-black/5 hover:bg-black/10 text-[10px] font-mono transition"
                                    :title="activeOrchPresets.full">
                                Full
                            </button>
                            <button @click="editingItem.orchestration = activeOrchPresets.std"
                                    class="px-2 py-1 rounded bg-black/5 hover:bg-black/10 text-[10px] font-mono transition"
                                    :title="activeOrchPresets.std">
                                Std
                            </button>
                        </div>
                    </div>
                </div>

                <div v-if="showOrchestrationField && parsedRoster.length > 0" class="mt-3 bg-black/5 dark:bg-white/5 rounded-xl p-3 border border-black/5 dark:border-white/5">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-[10px] font-bold uppercase opacity-50 tracking-wider">Musician Roster / ä¹æ‰‹åå•</span>
                        <button @click="editingItem.roster = {}" class="text-[9px] opacity-40 hover:opacity-100 hover:text-red-500 transition">Clear</button>
                    </div>

                    <div class="space-y-3">
                        <div v-for="section in parsedRoster" :key="section.label" class="flex flex-col gap-1">
                            <div class="flex items-center gap-2">
                                <span class="text-[10px] font-bold w-8 text-right shrink-0 opacity-60">{{ section.label }}</span>
                                <div class="h-px bg-black/5 dark:bg-white/5 flex-1"></div>
                            </div>

                            <div class="grid grid-cols-2 gap-2 pl-10">
                                <input v-for="n in section.count"
                                       :key="section.label + n"
                                       :value="getRosterName(section.label, n-1)"
                                       @input="updateRosterName(section.label, n-1, $event.target.value)"
                                       class="glass-input h-7 text-xs px-2 bg-white/50 dark:bg-black/20"
                                       :placeholder="section.label + ' ' + n"
                                >
                            </div>
                        </div>
                    </div>
                </div>

                <div v-if="isPercussionMode" class="mt-4 bg-gray-50 dark:bg-white/5 rounded-xl border border-black/5 dark:border-white/5 overflow-hidden animate-[fadeIn_0.3s]">
                    <div class="px-3 py-2 border-b border-black/5 dark:border-white/5 flex justify-between items-center bg-gray-100/50 dark:bg-black/20">
                        <div class="flex items-center gap-2">
                            <span class="text-[10px] font-bold uppercase tracking-wider opacity-60">Percussion Dist. / æ‰“å‡»ä¹åˆ†éƒ¨</span>
                            <button @click="scanPercussionTags" class="w-5 h-5 rounded hover:bg-black/10 flex items-center justify-center transition" title="é‡æ–°æ‰«æä»»åŠ¡">
                                <i class="fa-solid fa-rotate text-[10px] opacity-50"></i>
                            </button>
                        </div>
                        <button @click="addPercPlayer" class="text-[9px] font-bold bg-[#007aff] text-white px-2 py-1 rounded hover:brightness-110 transition">
                            + Player
                        </button>
                    </div>

                    <div class="p-3 grid grid-cols-1 gap-3">

                        <div class="flex flex-wrap gap-1.5 min-h-[30px] content-start">
                            <div v-for="(tag, idx) in percState.tags" :key="idx"
                                 @click="togglePercTagSelect(idx)"
                                 class="px-2 py-1 rounded text-[10px] font-bold cursor-pointer border transition-all duration-200 select-none flex items-center gap-1"
                                 :class="[
                                     // é€‰ä¸­æ€ (é«˜äº®)
                                     percState.selectedTagIndices.has(idx)
                                        ? 'bg-[#007aff] text-white border-[#007aff] shadow-md transform scale-105'
                                        : (tag.assignedTo ? 'bg-green-500/10 text-green-600 border-transparent opacity-50' : 'bg-white dark:bg-white/10 border-black/10 dark:border-white/10 hover:border-[#007aff]')
                                 ]">
                                {{ tag.fullName }}
                                <span v-if="tag.name !== tag.fullName" class="opacity-60 font-mono">({{ tag.name }})</span>

                                <span v-if="tag.assignedTo" class="ml-1.5 px-1.5 h-4 min-w-[16px] rounded-full bg-green-500 text-white flex items-center justify-center text-[9px] font-bold shadow-sm whitespace-nowrap transform scale-90 sm:scale-100 origin-left">
                                    {{ percState.players.find(p => p.id === tag.assignedTo)?.name.replace('Perc ', '') }}
                                </span>
                            </div>
                            <div v-if="percState.tags.length === 0" class="text-[10px] opacity-30 w-full text-center py-2">
                                æœªæ£€æµ‹åˆ°æ‰“å‡»ä¹ä»»åŠ¡ (è¯·ç¡®ä¿ä»»åŠ¡ååŒ…å« Snare, Cymbal ç­‰)
                            </div>
                        </div>

                        <div v-if="percState.selectedTagIndices.size > 0" class="flex justify-center -my-1 animate-bounce text-[#007aff]">
                            <i class="fa-solid fa-arrow-down text-xs"></i>
                        </div>

                        <div class="space-y-1.5">
                            <div v-for="(player, pIdx) in percState.players" :key="player.id"
                                 @click="assignTagsToPlayer(player.id)"
                                 class="flex items-center gap-2 p-2 rounded-lg border transition-all cursor-pointer group"
                                 :class="percState.selectedTagIndices.size > 0 ? 'bg-blue-50 dark:bg-blue-500/10 border-blue-200 dark:border-blue-500/30 hover:bg-blue-100 dark:hover:bg-blue-500/20' : 'bg-white/50 dark:bg-black/20 border-transparent'">

                                <div class="w-6 h-6 rounded-full bg-black/5 dark:bg-white/10 flex items-center justify-center text-[10px] font-bold shrink-0">
                                    {{ player.id }}
                                </div>

                                <input v-model="player.name" @change="updatePercOrchestration" @click.stop class="bg-transparent font-bold text-xs w-16 outline-none">

                                <div class="flex-1 flex flex-wrap gap-1">
                                    <span v-for="tag in percState.tags.filter(t => t.assignedTo === player.id)"
                                          class="text-[9px] font-mono px-1 rounded bg-black/5 dark:bg-white/10 text-gray-500 dark:text-gray-400">
                                        {{ tag.name }}
                                    </span>
                                </div>

                                <button @click.stop="removePercPlayer(pIdx)" class="w-5 h-5 flex items-center justify-center text-gray-300 hover:text-red-500 transition opacity-0 group-hover:opacity-100">
                                    <i class="fa-solid fa-xmark"></i>
                                </button>
                            </div>
                        </div>

                    </div>
                </div>

                <div v-if="!isPercussionMode && showOrchestrationField" class="mt-3">
                </div>

                <div v-if="isPercussionMode" class="mt-2">
                    <label class="text-[9px] font-bold opacity-40 uppercase ml-1">Summary Preview</label>
                    <textarea v-model="editingItem.orchestration" readonly class="glass-input w-full text-xs font-mono h-16 resize-none opacity-80 bg-black/5"></textarea>
                </div>

                <div v-if="editingSource === 'schedule'" class="pt-4 border-t border-white/10 mt-2">
                    <div class="flex gap-3">
                        <input type="date" v-model="editingItem.date" class="glass-input flex-1 font-bold text-center">
                        <select v-model="editingItem.startTime" class="glass-input w-24 font-mono font-bold text-center">
                            <option v-for="t in timeSlots" :value="t">{{t}}</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="flex justify-between mt-4 pt-4 border-t border-black/5 dark:border-white/5 shrink-0">
                <button @click="deleteEditingItem"
                        class="text-red-500 hover:bg-red-500/10 px-4 py-2 rounded-lg transition text-sm font-bold">
                    Delete
                </button>
                <button @click="pushHistory(); saveEdit()"
                        class="bg-[#007aff] text-white px-6 py-2 rounded-lg font-bold shadow hover:shadow-lg transition text-sm">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div v-if="showAuthModal" class="modal-overlay" @click.self="showAuthModal=false">
        <div class="modal-window w-[400px] p-8 animate-[fadeIn_0.2s] text-center">
            <h3 class="text-2xl font-bold mb-2">äº‘ç«¯åŒæ­¥</h3>
            <p class="text-sm opacity-60 mb-6">ç™»å½•åï¼Œæ‚¨çš„æ—¥ç¨‹å°†åœ¨ä¸åŒè®¾å¤‡é—´è‡ªåŠ¨åŒæ­¥ã€‚</p>

            <div class="space-y-4">
                <input id="auth-email"
                       v-model="authForm.email"
                       type="email"
                       placeholder="Email"
                       class="glass-input w-full text-base p-3"
                       enterkeyhint="next"
                       @keydown.enter.prevent="authPasswordRef.focus()">

                <input id="auth-password"
                       ref="authPasswordRef"
                       v-model="authForm.password"
                       type="password"
                       placeholder="Password"
                       class="glass-input w-full text-base p-3"
                       enterkeyhint="go"
                       @keydown.enter.prevent="handleLogin">

                <button @click="handleLogin" :disabled="authLoading"
                        class="w-full bg-[#007aff] text-white py-3 rounded-xl font-bold hover:bg-[#0062cc] transition disabled:opacity-50 shadow-lg shadow-blue-500/30">
                    {{ authLoading ? 'å¤„ç†ä¸­...' : 'ç™» å½•' }}
                </button>

                <div class="flex justify-between items-center text-xs mt-4 px-1">
                    <button @click="handleRegister" :disabled="authLoading"
                            class="text-gray-500 dark:text-gray-400 hover:text-[#007aff] transition font-bold">
                        æ²¡æœ‰è´¦å·ï¼Ÿæ³¨å†Œæ–°å·
                    </button>

                    <button @click="handleResetPwd" :disabled="authLoading"
                            class="text-gray-500 dark:text-gray-400 hover:text-orange-500 transition">
                        å¿˜è®°å¯†ç ï¼Ÿ
                    </button>
                </div>
            </div>
        </div>
    </div>


    <div v-if="showTrackList" class="modal-overlay" @click.self="showTrackList=false">
        <div class="modal-window w-[450px] max-w-[90vw] max-h-[80vh] flex flex-col p-0 overflow-hidden animate-[fadeIn_0.1s]">

            <div class="p-5 bg-white/50 dark:bg-black/20 backdrop-blur border-b border-glass-border dark:border-glass-borderDark flex justify-between items-center shrink-0 gap-4">

                <div class="flex items-center gap-3 min-w-0">
                    <h3 class="font-bold text-lg truncate" :title="trackListData.name">
                        {{ trackListData.name }}
                    </h3>

                    <button @click="openRecInfoModal"
                            class="w-7 h-7 rounded-full bg-blue-500/10 hover:bg-blue-500 text-blue-600 hover:text-white flex items-center justify-center transition shadow-sm group shrink-0"
                            :title="sidebarTab === 'musician' ? 'å¡«å†™å½•éŸ³ä¿¡æ¯ (Recording Info)' : 'å¡«å†™ç¼–è¾‘ä¿¡æ¯ (Editing Info)'">
                        <i class="fa-solid fa-clipboard-user text-xs"></i>
                    </button>
                </div>

                <div class="flex items-center gap-2 shrink-0">
                    <div class="relative group mr-2">
                        <i class="fa-solid fa-magnifying-glass absolute left-2.5 top-1/2 -translate-y-1/2 text-[10px] text-gray-400 group-focus-within:text-[#007aff] transition-colors"></i>
                        <input
                                v-model="trackListSearchQuery"
                                @input="handleTrackListSearchAction(false)"
                                @keydown.enter.prevent="handleTrackListSearchAction(true)"
                                type="text"
                                placeholder="Search..."
                                class="glass-input h-8 pl-7 pr-2 text-xs w-24 focus:w-40 transition-all duration-300 rounded-full bg-black/5 dark:bg-white/10 border-transparent focus:bg-white dark:focus:bg-black/40 placeholder:text-gray-400"
                        >
                    </div>
                    <button @click="autoDistributeSections"
                            class="w-8 h-8 flex items-center justify-center hover:bg-black/10 dark:hover:bg-white/10 rounded-full transition group"
                            title="æ ¹æ®æ—¥ç¨‹æ—¶é•¿è‡ªåŠ¨åˆ†é…æ›²ç›® (Auto Distribute)">
                        <i class="fa-solid fa-wand-magic-sparkles text-xs opacity-50 group-hover:opacity-100 group-hover:text-purple-500 transition-all"></i>
                    </button>
                    <button @click="sortTrackList"
                            class="w-8 h-8 flex items-center justify-center hover:bg-black/10 dark:hover:bg-white/10 rounded-full transition group"
                            title="æŒ‰æ—¶é—´æ’åº">
                        <i class="fa-solid fa-arrow-down-short-wide text-xs opacity-50 group-hover:opacity-100 group-hover:text-[#007aff] transition-all"></i>
                    </button>

                    <button @click="showTrackList=false"
                            class="w-8 h-8 flex items-center justify-center hover:bg-black/10 dark:hover:bg-white/10 rounded-full transition">
                        âœ•
                    </button>
                </div>
            </div>

            <div ref="trackListContainerRef" class="p-3 overflow-y-auto flex-1 min-h-[100px] relative">
                <Transition-group name="list" tag="div" class="space-y-1 relative">
                    <template v-for="(item, index) in trackListData.items" :key="item.id">

                        <div v-if="index === 0 || (index > 0 && item.sectionIndex !== trackListData.items[index-1].sectionIndex)"
                             :key="'div-sec-' + item.sectionIndex"
                             :id="'sec-divider-' + item.sectionIndex"
                             class="py-3 flex items-center gap-3 select-none group/divider transition-opacity duration-0"
                             :class="{ 'opacity-0': draggingSectionIndex === item.sectionIndex }">

                            <div class="h-px bg-black/10 dark:bg-white/10 flex-1 group-hover/divider:bg-[#007aff]/50 transition-colors"></div>

                            <div class="px-3 py-1.5 rounded-full bg-black/5 dark:bg-white/10 border border-black/5 dark:border-white/5 flex items-center gap-2 text-[10px] font-bold transition-all shadow-sm touch-none"
                                 :class="index === 0
                        ? 'cursor-default opacity-80'
                        : 'cursor-ns-resize opacity-60 group-hover/divider:opacity-100 group-hover/divider:text-[#007aff] group-hover/divider:bg-[#007aff]/10'"
                                 @mousedown="index > 0 && startDividerDrag($event, item.sectionIndex)"
                                 @touchstart.prevent.stop="index > 0 && startDividerDrag($event, item.sectionIndex)">

                                <i v-if="index > 0" class="fa-solid fa-grip-lines-vertical mr-1 opacity-50"></i>

                                <i class="fa-regular fa-calendar"></i>

                                <span>
                        {{ trackListData.schedules[item.sectionIndex] ? trackListData.schedules[item.sectionIndex].date.split('-').slice(1).join('/') : `Session ${item.sectionIndex + 1}` }}
                        <span class="opacity-50 ml-1 font-mono">
                            ({{ trackListData.schedules[item.sectionIndex]?.startTime }})
                        </span>
                    </span>
                            </div>
                            <div class="h-px bg-black/10 dark:bg-white/10 flex-1 group-hover/divider:bg-[#007aff]/50 transition-colors"></div>
                        </div>

                        <div :id="'track-item-' + item.id"
                             class="track-card p-2.5 rounded-lg border border-transparent hover:border-white/10 transition-colors relative flex flex-col gap-2 mb-2 group transition-all duration-300"
                             :class="[
                                 item.sectionIndex === trackListData.currentSectionIndex
                                     ? 'bg-black/5 dark:bg-white/10'
                                     : 'bg-black/[0.02] dark:bg-white/[0.02] opacity-60 hover:opacity-100',
                                 item.isSkipped ? '!opacity-50 grayscale' : ''
                             ]"
                             @mousedown="startTrackDrag($event, item)"
                             @touchstart="startTrackDrag($event, item)"
                             @contextmenu.prevent
                        >

                            <label class="absolute top-2 right-[60px] h-4 flex items-center justify-center z-20 cursor-pointer transition-opacity duration-200 sm:opacity-0 sm:group-hover:opacity-100"
                                   :class="{'!opacity-100': item.isSkipped}"
                                   @click.stop
                                   title="è·³è¿‡/æ¢å¤ (Skip)">

                                <div class="relative w-8 h-4 rounded-full transition-colors duration-200 border border-black/10 dark:border-white/10"
                                     :class="item.isSkipped ? 'bg-red-500 border-red-500' : 'bg-black/5 dark:bg-white/5 hover:bg-black/10'">

                                    <input type="checkbox"
                                           v-model="item.isSkipped"
                                           class="hidden"
                                           @change="pushHistory(); triggerTouchHaptic('Medium')">

                                    <div class="absolute top-0.45 left-0.5 w-3 h-3 bg-white rounded-full shadow-sm transition-transform duration-200"
                                         :class="item.isSkipped ? 'translate-x-4' : 'translate-x-0'"></div>
                                </div>
                            </label>

                            <button @click.stop="deleteTrackFromList(item)"
                                    class="absolute top-1 right-1 w-6 h-6 flex items-center justify-center rounded-md text-gray-400/50 hover:text-white hover:bg-red-500 transition-all z-20 cursor-pointer sm:opacity-0 sm:group-hover:opacity-100"
                                    :class="{'!opacity-100': item.isSkipped}"> <i class="fa-solid fa-trash-can text-[10px]"></i>
                            </button>

                            <button v-if="!item.isSkipped && item.musicDuration && item.musicDuration !== '00:00'"
                                    @click.stop="openSplitSlider(item)"
                                    title="æ‹†åˆ†ä»»åŠ¡ï¼šå½•äº†ä¸€åŠï¼Œå‰©ä¸‹çš„ä¸‹æ¬¡å½•"
                                    class="absolute top-1 right-8 w-6 h-6 flex items-center justify-center rounded-md text-gray-400/50 hover:text-orange-500 hover:bg-orange-500/10 transition-all z-20 cursor-pointer sm:opacity-0 sm:group-hover:opacity-100">
                                <i class="fa-solid fa-scissors text-[10px]"></i>
                            </button>

                            <div class="flex items-center gap-3 overflow-hidden flex-1">
                                <div class="w-2.5 h-2.5 rounded-full shadow-sm shrink-0 mt-0.5"
                                     :style="{backgroundColor: trackListData.viewType === 'project' ? getGroupColor(item, 'instrumentId', true) : getGroupColor(item, 'projectId', true)}">
                                </div>

                                <div class="flex flex-col min-w-0 w-full">

    <span class="text-xs font-bold leading-tight flex items-center gap-1.5 min-w-0"
          :class="{'line-through decoration-black/50 dark:decoration-white/50': item.isSkipped}">

        <span class="truncate">
            {{
                (trackListData.viewType || sidebarTab) === 'instrument'
                        ? getNameById(item.musicianId, 'musician')
                        : (item.name || getNameById(item.instrumentId, 'instrument'))
            }}
        </span>

        <span v-if="item.splitTag"
              class="text-[9px] px-1 py-0.5 rounded-sm font-mono font-bold uppercase tracking-wider shrink-0 bg-red-500/10 text-red-500 no-underline inline-block">
            {{ item.splitTag }}
        </span>

        <span v-if="item.orchestration && !isPercussionGroup(item) && !isStringGroup(item)"
              class="text-[10px] font-mono font-bold bg-yellow-500/10 text-yellow-600 dark:text-yellow-400 px-1.5 py-0.5 rounded border border-yellow-500/20 shrink-0 ml-1 select-none max-w-[200px] whitespace-normal text-left leading-tight">
            {{ item.orchestration }}
        </span>

        <span v-if="item.isSkipped"
              class="text-[9px] px-1 py-0.5 rounded-sm font-mono font-bold uppercase tracking-wider shrink-0 bg-black/10 dark:bg-white/20 text-black dark:text-white no-underline inline-block">
            SKIP
        </span>
    </span>

                                    <div class="flex items-center justify-between mt-0.5 min-w-0">

        <span class="text-[10px] opacity-50 truncate">
            <template v-if="(trackListData.viewType || sidebarTab) === 'project'">
                {{ getNameById(item.musicianId, 'musician') }}
            </template>

            <template v-else>
                {{ getNameById(item.projectId, 'project') }}
            </template>
        </span>

                                        <span v-if="item.musicDuration && item.musicDuration !== '00:00'"
                                              class="text-[10px] font-mono font-bold text-gray-500 dark:text-gray-400 opacity-60 shrink-0 ml-2">
            {{ item.musicDuration }}
        </span>
                                    </div>
                                </div>
                            </div>

                            <div class="flex items-center gap-2 bg-white/50 dark:bg-black/20 rounded-md p-1.5 border border-black/5 dark:border-white/5 transition-opacity duration-200"
                                 :class="{'opacity-20 pointer-events-none select-none': item.isSkipped}">

                                <div class="flex items-center gap-1 flex-1">
                                    <input type="time"
                                           v-model="item.records[trackListData.viewType].recStart"
                                           @change="calcTrackDiff(item)"
                                           class="glass-input flex-1 h-7 text-xs text-center font-mono bg-white/60 dark:bg-black/30 focus:bg-white dark:focus:bg-black/50 rounded-md transition-colors p-0 cursor-text">

                                    <button @click="setTrackNow(item, 'start')" title="è®¾ä¸ºå½“å‰æ—¶é—´"
                                            class="h-7 w-7 rounded-md bg-black/5 dark:bg-white/10 border border-black/5 dark:border-white/5 hover:bg-[#007aff] hover:border-[#007aff] hover:text-white flex items-center justify-center transition shrink-0 group/btn">
                                        <i class="fa-solid fa-clock text-[10px] opacity-60 group-hover/btn:opacity-100"></i>
                                    </button>
                                </div>

                                <button @click="setTrackBreak(item)"
                                        class="h-6 min-w-[20px] px-1 flex items-center justify-center rounded cursor-pointer transition hover:bg-black/5 dark:hover:bg-white/10 group/break"
                                        :title="item.records[trackListData.viewType].breakMinutes > 0 ? `å·²æ‰£é™¤ ${item.records[trackListData.viewType].breakMinutes} åˆ†é’Ÿä¼‘æ¯` : 'è®¾ç½®ä¼‘æ¯æ—¶é—´'">

                                    <div v-if="item.records[trackListData.viewType].breakMinutes > 0"
                                         class="flex items-center gap-0.5 text-[9px] font-bold text-orange-500">
                                        <span>-{{ item.records[trackListData.viewType].breakMinutes }}m</span>
                                    </div>

                                    <span v-else
                                          class="text-[10px] opacity-20 font-bold group-hover/break:opacity-100 group-hover/break:text-[#007aff] transition-all">-</span>
                                </button>

                                <div class="flex items-center gap-1 flex-1">
                                    <input type="time"
                                           v-model="item.records[trackListData.viewType].recEnd"
                                           @change="calcTrackDiff(item)"
                                           class="glass-input flex-1 h-7 text-xs text-center font-mono bg-white/60 dark:bg-black/30 focus:bg-white dark:focus:bg-black/50 rounded-md transition-colors p-0 cursor-text">

                                    <button @click="setTrackNow(item, 'end')" title="è®¾ä¸ºå½“å‰æ—¶é—´"
                                            class="h-7 w-7 rounded-md bg-black/5 dark:bg-white/10 border border-black/5 dark:border-white/5 hover:bg-[#007aff] hover:border-[#007aff] hover:text-white flex items-center justify-center transition shrink-0 group/btn">
                                        <i class="fa-solid fa-clock text-[10px] opacity-60 group-hover/btn:opacity-100"></i>
                                    </button>
                                </div>

                                <button @click="clearTrackTime(item)"
                                        :disabled="!item.records[trackListData.viewType].recStart && !item.records[trackListData.viewType].recEnd"
                                        title="æ¸…é™¤æ—¶é—´è®°å½•"
                                        class="w-7 h-7 ml-1 flex items-center justify-center rounded-md transition shrink-0"
                                        :class="(!item.records[trackListData.viewType].recStart && !item.records[trackListData.viewType].recEnd) ? 'opacity-20 cursor-default text-gray-400' : 'text-gray-400 hover:text-red-500 hover:bg-red-500/10 cursor-pointer'">
                                    <i class="fa-solid fa-eraser text-xs"></i>
                                </button>

                                <div class="w-px h-5 bg-black/10 dark:bg-white/10 mx-1"></div>

                                <div class="flex flex-col items-end min-w-[50px] leading-none gap-1">
                                    <span class="font-mono text-xs font-bold"
                                          :class="item.records[trackListData.viewType].actualDuration ? 'text-indigo-500' : 'opacity-30'">
                                        {{ item.records[trackListData.viewType].actualDuration || '--:--' }}
                                    </span>

                                    <div class="flex items-center gap-1" title="æ•ˆç‡æ¯”å€¼">
                                        <span class="text-[8px] opacity-40 uppercase">EFF</span>
                                        <span class="font-mono text-[10px] font-bold"
                                              :class="calculateSingleRatio(item) > item.ratio ? 'text-red-500' : 'text-green-500'">
                                            x{{ calculateSingleRatio(item) }}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>

                    <template v-if="trackListData.items.length > 0">
                        <div v-for="secIndex in (trackListData.totalSections - 1)"
                             :key="'end-div-'+secIndex"
                             :id="'sec-divider-' + secIndex"
                             v-show="secIndex > trackListData.items[trackListData.items.length-1].sectionIndex"
                             class="py-3 flex items-center gap-3 select-none group/divider transition-opacity duration-0"
                             :class="{ 'opacity-0': draggingSectionIndex === secIndex }">

                            <div class="h-px bg-black/10 dark:bg-white/10 flex-1 group-hover/divider:bg-[#007aff]/50 transition-colors"></div>

                            <div class="px-3 py-1.5 rounded-full bg-black/5 dark:bg-white/10 border border-black/5 dark:border-white/5 flex items-center gap-2 text-[10px] font-bold opacity-60 group-hover/divider:opacity-100 group-hover/divider:text-[#007aff] group-hover/divider:bg-[#007aff]/10 transition-all shadow-sm cursor-ns-resize touch-none"
                                 @mousedown="startDividerDrag($event, secIndex)"
                                 @touchstart.prevent.stop="startDividerDrag($event, secIndex)">
                                <i class="fa-solid fa-grip-lines-vertical mr-1 opacity-50"></i>
                                <i class="fa-regular fa-calendar"></i>
                                <span>
                                      {{ trackListData.schedules[secIndex] ? trackListData.schedules[secIndex].date.split('-').slice(1).join('/') : `Session ${secIndex + 1}`
                                }}
                                      <span class="opacity-50 ml-1 font-mono">
                                        ({{ trackListData.schedules[secIndex]?.startTime }})
                                      </span>
                                </span>
                            </div>

                            <div class="h-px bg-black/10 dark:bg-white/10 flex-1 group-hover/divider:bg-[#007aff]/50 transition-colors"></div>
                        </div>
                    </template>

                </TransitionGroup>
            </div>

            <div class="p-4 border-t border-glass-border dark:border-glass-borderDark bg-gray-50/50 dark:bg-white/5 shrink-0 flex justify-between items-center">

                <div class="flex items-center gap-2" v-if="trackListData.taskRef">
                    <div class="w-6 h-6 rounded-md bg-black/5 dark:bg-white/10 flex items-center justify-center shrink-0">
                        <i class="fa-regular fa-bell text-xs opacity-60"></i>
                    </div>

                    <select
                            v-model.number="trackListData.taskRef.reminderMinutes"
                            @change="onTrackListReminderChange(trackListData.taskRef)"
                            class="glass-input h-8 text-xs font-bold py-0 pr-8 cursor-pointer bg-transparent focus:bg-white/50 w-32"
                    >
                        <option :value="0">æ— æé†’</option>
                        <option :value="5">æå‰ 5 åˆ†é’Ÿ</option>
                        <option :value="10">æå‰ 10 åˆ†é’Ÿ</option>
                        <option :value="15">æå‰ 15 åˆ†é’Ÿ</option>
                        <option :value="30">æå‰ 30 åˆ†é’Ÿ</option>
                        <option :value="60">æå‰ 1 å°æ—¶</option>
                    </select>
                </div>

                <button @click="deleteCurrentSchedule"
                        class="px-4 py-2 rounded-lg bg-red-500/10 hover:bg-red-500 text-red-600 hover:text-white border border-red-500/20 transition text-xs font-bold flex items-center gap-2 shadow-sm">
                    <i class="fa-solid fa-trash-can"></i> DELETE
                </button>
            </div>
        </div>
    </div>

    <div v-if="showCropModal" class="modal-overlay z-[1000]" @click.self="cancelCrop">
        <div class="modal-window w-[500px] max-w-[90vw] p-6 animate-[fadeIn_0.2s] flex flex-col">
            <h3 class="font-bold text-xl mb-4">è°ƒæ•´å¤´åƒ</h3>

            <div class="w-full h-[300px] bg-black/5 dark:bg-black/50 rounded-lg mb-6 relative z-10">
                <img ref="cropImgRef" :src="cropImgSrc" class="max-w-full block" style="max-height: 100%;">
            </div>

            <div class="flex justify-end gap-3">
                <button @click="cancelCrop"
                        class="px-4 py-2 rounded-lg text-sm font-bold text-gray-500 hover:bg-gray-100 dark:hover:bg-white/10 transition">
                    å–æ¶ˆ
                </button>
                <button @click="confirmCrop" :disabled="authLoading"
                        class="px-6 py-2 rounded-lg text-sm font-bold bg-[#007aff] text-white hover:bg-[#0062cc] transition shadow-lg shadow-blue-500/30 flex items-center gap-2">
                    <i v-if="authLoading" class="fa-solid fa-circle-notch fa-spin"></i>
                    {{ authLoading ? 'ä¸Šä¼ ä¸­...' : 'ç¡®è®¤å¹¶ä¸Šä¼ ' }}
                </button>
            </div>
        </div>
    </div>

    <div v-if="showQuickAddModal" class="modal-overlay z-[2000]" @click.self="showQuickAddModal=false">
        <div class="modal-window w-[350px] p-6 animate-[fadeIn_0.2s] flex flex-col gap-4">
            <h3 class="font-bold text-lg capitalize">Add New {{ quickAddType }}</h3>

            <div class="space-y-3">
                <div>
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1">Name</label>
                    <input id="quick-add-name" v-model="quickAddForm.name"
                           class="glass-input w-full text-base"
                           placeholder="Enter name..."
                           @keydown.enter="!$event.isComposing && confirmQuickAdd()">
                </div>

                <div class="quick-add-group-wrapper relative transition-all"
                     :class="showGroupSuggestions ? 'z-50' : 'z-20'">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1">Group (Optional)</label>

                    <div class="relative">
                        <input v-model="quickAddForm.group"
                               @focus="showGroupSuggestions = true"
                               class="glass-input w-full pr-8"
                               placeholder="è¾“å…¥æ–°åˆ†ç»„æˆ–é€‰æ‹©..."
                               @keydown.enter="!$event.isComposing && confirmQuickAdd()">

                        <i class="fa-solid fa-chevron-down absolute right-3 top-3.5 text-xs transition-transform duration-200 cursor-pointer opacity-50 hover:opacity-100"
                           :class="{'rotate-180': showGroupSuggestions}"
                           @mousedown.prevent="showGroupSuggestions = !showGroupSuggestions"></i>

                        <div v-if="showGroupSuggestions"
                             class="custom-dropdown-menu absolute top-full left-0 w-full mt-1 max-h-40 overflow-y-auto p-1 origin-top animate-[fadeIn_0.1s] z-[100]">

                            <div v-for="g in currentQuickAddGroups" :key="g"
                                 @mousedown.prevent="quickAddForm.group = g; showGroupSuggestions = false"
                                 class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-sm font-medium transition-colors text-gray-800 dark:text-gray-200">
                                {{ g }}
                            </div>

                            <div v-if="currentQuickAddGroups.length === 0"
                                 class="px-3 py-2 opacity-40 text-xs text-center text-gray-800 dark:text-gray-200">
                                æš‚æ— åˆ†ç»„ï¼Œç›´æ¥è¾“å…¥åˆ›å»º
                            </div>
                        </div>
                    </div>
                </div>

                <div v-if="quickAddType === 'musician'">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1">Default Ratio</label>
                    <div class="flex items-center gap-2">
                        <input type="number" v-model="quickAddForm.defaultRatio"
                               class="glass-input w-24 text-center font-mono"
                               @keydown.enter="!$event.isComposing && confirmQuickAdd()">
                        <span class="text-xs opacity-50">x (Efficiency)</span>
                    </div>
                </div>
            </div>

            <div class="flex justify-end gap-2 mt-2">
                <button @click="showQuickAddModal=false"
                        class="px-4 py-2 rounded-lg text-sm font-bold opacity-60 hover:opacity-100 hover:bg-black/5 dark:hover:bg-white/10 transition">
                    Cancel
                </button>
                <button @click="confirmQuickAdd"
                        class="px-6 py-2 rounded-lg text-sm font-bold bg-[#007aff] text-white hover:bg-[#0062cc] transition shadow-lg shadow-blue-500/30">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div v-if="showInputModal" class="modal-overlay z-[10000]" @click.self="closeInputModal">
        <div class="modal-window w-[350px] p-6 animate-[fadeIn_0.2s] flex flex-col gap-4">
            <h3 class="font-bold text-lg">{{ inputModalConfig.title }}</h3>

            <div>
                <input ref="universalInputRef"
                       v-model="inputModalConfig.value"
                       :placeholder="inputModalConfig.placeholder"
                       class="glass-input w-full text-base p-3"
                       @keydown.enter="!$event.isComposing && confirmInputModal()">
                <p v-if="inputModalConfig.hint" class="text-[10px] opacity-50 mt-1.5 ml-1">{{ inputModalConfig.hint
                    }}</p>
            </div>

            <div class="flex justify-end gap-2 mt-2">
                <button @click="closeInputModal"
                        class="px-4 py-2 rounded-lg text-sm font-bold opacity-60 hover:opacity-100 hover:bg-black/5 dark:hover:bg-white/10 transition">
                    å–æ¶ˆ
                </button>
                <button @click="confirmInputModal"
                        class="px-6 py-2 rounded-lg text-sm font-bold bg-[#007aff] text-white hover:bg-[#0062cc] transition shadow-lg shadow-blue-500/30">
                    ç¡®å®š
                </button>
            </div>
        </div>
    </div>

    <div v-if="showConfirmModal" class="modal-overlay z-[9999]"
         @click.self="!confirmModalConfig.isAlert && closeConfirmModal()">

        <div class="modal-window w-[90vw] sm:w-[500px] max-h-[80vh] p-6 animate-[bubblePop_0.2s] flex flex-col gap-4 text-center">

            <div class="shrink-0">
                <div class="flex justify-center mb-2">
                    <div v-if="confirmModalConfig.isDestructive"
                         class="w-12 h-12 rounded-full bg-red-500/10 flex items-center justify-center text-red-500 text-2xl">
                        <i class="fa-solid fa-triangle-exclamation"></i>
                    </div>
                    <div v-else-if="confirmModalConfig.isAlert"
                         class="w-12 h-12 rounded-full bg-blue-500/10 flex items-center justify-center text-blue-500 text-2xl">
                        <i class="fa-solid fa-circle-info"></i>
                    </div>
                    <div v-else
                         class="w-12 h-12 rounded-full bg-orange-500/10 flex items-center justify-center text-orange-500 text-2xl">
                        <i class="fa-solid fa-circle-question"></i>
                    </div>
                </div>

                <h3 class="font-bold text-lg leading-tight">{{ confirmModalConfig.title }}</h3>
            </div>

            <div class="flex-1 overflow-y-auto custom-scrollbar w-full bg-black/5 dark:bg-white/5 rounded-lg border border-black/5 dark:border-white/5 text-left p-3 min-h-0">
                <p class="text-sm opacity-70 whitespace-pre-wrap leading-relaxed font-mono text-xs break-all">
                    {{ confirmModalConfig.content }}
                </p>
            </div>

            <div class="flex gap-3 justify-center shrink-0 mt-2">
                <button v-if="!confirmModalConfig.isAlert"
                        @click="closeConfirmModal"
                        class="flex-1 py-2.5 rounded-xl font-bold bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition text-sm">
                    {{ confirmModalConfig.cancelText || 'å–æ¶ˆ' }}
                </button>

                <button @click="handleConfirmAction"
                        class="flex-1 py-2.5 rounded-xl font-bold text-white shadow-lg transition text-sm flex items-center justify-center gap-2"
                        :class="confirmModalConfig.isDestructive ? 'bg-red-500 hover:bg-red-600 shadow-red-500/30' : 'bg-[#007aff] hover:bg-[#0062cc] shadow-blue-500/30'">
                    {{ confirmModalConfig.confirmText || 'ç¡®å®š' }}
                </button>
            </div>
        </div>
    </div>

    <div v-if="showImportModal" class="modal-overlay z-[4000]" @click.self="showImportModal=false">
        <div class="modal-window w-[400px] p-8 animate-[bubblePop_0.2s] flex flex-col items-center text-center">

            <h3 class="text-xl font-bold mb-2">æ¢å¤æ•°æ®</h3>
            <p class="text-xs opacity-50 mb-6 max-w-[260px] leading-relaxed">
                è¯·é€‰æ‹©ä¹‹å‰å¯¼å‡ºçš„ .json å¤‡ä»½æ–‡ä»¶ã€‚<br>æ³¨æ„ï¼šè¿™å°†è¦†ç›–å½“å‰çš„æ—¥ç¨‹å®‰æ’ã€‚
            </p>

            <div @click="triggerFileSelect"
                 class="w-full h-32 rounded-2xl border-2 border-dashed border-black/10 dark:border-white/10 bg-black/5 dark:bg-white/5 hover:bg-black/10 dark:hover:bg-white/10 transition cursor-pointer flex flex-col items-center justify-center gap-2 group relative overflow-hidden">

                <i class="fa-solid fa-file-import text-6xl absolute opacity-[0.03] group-hover:scale-110 transition-transform duration-500"></i>

                <div class="w-12 h-12 rounded-full bg-blue-500/10 text-[#007aff] flex items-center justify-center text-xl mb-1 group-hover:scale-110 transition-transform">
                    <i class="fa-solid fa-cloud-arrow-up"></i>
                </div>
                <span class="text-sm font-bold opacity-70 group-hover:opacity-100 transition">ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</span>
                <span class="text-[10px] font-mono opacity-40 uppercase">Support: .JSON</span>
            </div>

            <div class="flex gap-3 w-full mt-6">
                <button @click="showImportModal=false"
                        class="flex-1 py-3 rounded-xl font-bold bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition text-sm">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    </div>

    <div v-if="showRecInfoModal" class="modal-overlay z-[12000]" @click.self="showRecInfoModal=false">
        <div class="modal-window w-[350px] p-6 animate-[bubblePop_0.2s] flex flex-col gap-4">

            <div class="flex items-center gap-2 mb-2">
                <div class="w-8 h-8 rounded-full bg-blue-500/10 flex items-center justify-center text-blue-500">
                    <i class="fa-solid" :class="sidebarTab === 'musician' ? 'fa-microphone-lines' : 'fa-sliders'"></i>
                </div>
                <div>
                    <h3 class="font-bold text-lg leading-none">
                        {{ sidebarTab === 'musician' ? 'Recording Info' : 'Editing Info' }}
                    </h3>
                    <p class="text-[10px] opacity-40 uppercase tracking-wider">Session Details</p>
                </div>
            </div>

            <div class="space-y-3">
                <div class="rec-dropdown-wrapper relative z-50">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1 ml-1">
                        {{ sidebarTab === 'musician' ? 'Recording Studio' : 'Editing Studio' }}
                    </label>
                    <div class="relative">
                        <input v-model="recInfoForm.studio"
                               class="glass-input w-full text-sm pr-8"
                               placeholder="Select or type..."
                               @focus="activeRecDropdown = 'studio'; recDropdownSearch = ''"
                               @input="activeRecDropdown = 'studio'; recDropdownSearch = $event.target.value"
                        >
                        <i class="fa-solid fa-chevron-down absolute right-3 top-3 text-[10px] opacity-30 pointer-events-none transition-transform"
                           :class="{'rotate-180': activeRecDropdown === 'studio'}"></i>

                        <div v-if="activeRecDropdown === 'studio'" class="custom-dropdown-menu !z-[13000] absolute top-full left-0 w-full mt-1 max-h-40 overflow-y-auto p-1 origin-top animate-[fadeIn_0.1s] shadow-xl border border-black/5 dark:border-white/10">
                            <div v-for="item in filteredRecOptions" :key="item.id" @mousedown.prevent="selectRecOption(item)" class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-xs font-bold transition-colors">{{ item.name }}</div>
                            <div v-if="recDropdownSearch && !filteredRecOptions.some(i => i.name === recDropdownSearch)" @mousedown.prevent="createRecOption" class="px-3 py-2 rounded-lg bg-blue-500/10 text-blue-600 hover:bg-blue-500/20 cursor-pointer text-xs font-bold transition-colors flex items-center gap-2"><i class="fa-solid fa-plus"></i> åˆ›å»º "{{ recDropdownSearch }}"</div>
                        </div>
                    </div>
                </div>

                <div class="rec-dropdown-wrapper relative z-40">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1 ml-1">
                        {{ sidebarTab === 'musician' ? 'Recording Engineer' : 'Editing Engineer' }}
                    </label>
                    <div class="relative">
                        <input v-model="recInfoForm.engineer" class="glass-input w-full text-sm pr-8" placeholder="Name"
                               @focus="activeRecDropdown = 'engineer'; recDropdownSearch = ''"
                               @input="activeRecDropdown = 'engineer'; recDropdownSearch = $event.target.value"
                        >
                        <i class="fa-solid fa-chevron-down absolute right-3 top-3 text-[10px] opacity-30 pointer-events-none transition-transform" :class="{'rotate-180': activeRecDropdown === 'engineer'}"></i>
                        <div v-if="activeRecDropdown === 'engineer'" class="custom-dropdown-menu !z-[13000] absolute top-full left-0 w-full mt-1 max-h-40 overflow-y-auto p-1 origin-top animate-[fadeIn_0.1s] shadow-xl border border-black/5 dark:border-white/10">
                            <div v-for="item in filteredRecOptions" :key="item.id" @mousedown.prevent="selectRecOption(item)" class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-xs font-bold transition-colors">{{ item.name }}</div>
                            <div v-if="recDropdownSearch && !filteredRecOptions.some(i => i.name === recDropdownSearch)" @mousedown.prevent="createRecOption" class="px-3 py-2 rounded-lg bg-blue-500/10 text-blue-600 hover:bg-blue-500/20 cursor-pointer text-xs font-bold transition-colors flex items-center gap-2"><i class="fa-solid fa-plus"></i> åˆ›å»º "{{ recDropdownSearch }}"</div>
                        </div>
                    </div>
                </div>

                <div class="rec-dropdown-wrapper relative z-30">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1 ml-1">
                        {{ sidebarTab === 'musician' ? 'Recording Operator' : 'Editing Operator' }}
                    </label>
                    <div class="relative">
                        <input v-model="recInfoForm.operator" class="glass-input w-full text-sm pr-8" placeholder="Name"
                               @focus="activeRecDropdown = 'operator'; recDropdownSearch = ''"
                               @input="activeRecDropdown = 'operator'; recDropdownSearch = $event.target.value"
                        >
                        <i class="fa-solid fa-chevron-down absolute right-3 top-3 text-[10px] opacity-30 pointer-events-none transition-transform" :class="{'rotate-180': activeRecDropdown === 'operator'}"></i>
                        <div v-if="activeRecDropdown === 'operator'" class="custom-dropdown-menu !z-[13000] absolute top-full left-0 w-full mt-1 max-h-40 overflow-y-auto p-1 origin-top animate-[fadeIn_0.1s] shadow-xl border border-black/5 dark:border-white/10">
                            <div v-for="item in filteredRecOptions" :key="item.id" @mousedown.prevent="selectRecOption(item)" class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-xs font-bold transition-colors">{{ item.name }}</div>
                            <div v-if="recDropdownSearch && !filteredRecOptions.some(i => i.name === recDropdownSearch)" @mousedown.prevent="createRecOption" class="px-3 py-2 rounded-lg bg-blue-500/10 text-blue-600 hover:bg-blue-500/20 cursor-pointer text-xs font-bold transition-colors flex items-center gap-2"><i class="fa-solid fa-plus"></i> åˆ›å»º "{{ recDropdownSearch }}"</div>
                        </div>
                    </div>
                </div>

                <div class="rec-dropdown-wrapper relative z-20">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1 ml-1">
                        {{ sidebarTab === 'musician' ? 'Recording Assistant' : 'Editing Assistant' }}
                    </label>
                    <div class="relative">
                        <input v-model="recInfoForm.assistant" class="glass-input w-full text-sm pr-8" placeholder="Name"
                               @focus="activeRecDropdown = 'assistant'; recDropdownSearch = ''"
                               @input="activeRecDropdown = 'assistant'; recDropdownSearch = $event.target.value"
                        >
                        <i class="fa-solid fa-chevron-down absolute right-3 top-3 text-[10px] opacity-30 pointer-events-none transition-transform" :class="{'rotate-180': activeRecDropdown === 'assistant'}"></i>
                        <div v-if="activeRecDropdown === 'assistant'" class="custom-dropdown-menu !z-[13000] absolute top-full left-0 w-full mt-1 max-h-40 overflow-y-auto p-1 origin-top animate-[fadeIn_0.1s] shadow-xl border border-black/5 dark:border-white/10">
                            <div v-for="item in filteredRecOptions" :key="item.id" @mousedown.prevent="selectRecOption(item)" class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-xs font-bold transition-colors">{{ item.name }}</div>
                            <div v-if="recDropdownSearch && !filteredRecOptions.some(i => i.name === recDropdownSearch)" @mousedown.prevent="createRecOption" class="px-3 py-2 rounded-lg bg-blue-500/10 text-blue-600 hover:bg-blue-500/20 cursor-pointer text-xs font-bold transition-colors flex items-center gap-2"><i class="fa-solid fa-plus"></i> åˆ›å»º "{{ recDropdownSearch }}"</div>
                        </div>
                    </div>
                </div>

                <div class="relative z-10">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1 ml-1">Other Information</label>
                    <textarea v-model="recInfoForm.notes"
                              class="glass-input w-full text-sm min-h-[80px] resize-none"
                              placeholder="å¤‡å¿˜å½•ã€æ³¨æ„äº‹é¡¹..."
                              @keydown.ctrl.enter="saveRecInfo"></textarea>
                </div>
            </div>

            <div class="flex justify-end gap-2 mt-2">
                <button @click="showRecInfoModal=false"
                        class="px-4 py-2 rounded-lg text-sm font-bold opacity-60 hover:opacity-100 hover:bg-black/5 dark:hover:bg-white/10 transition">
                    å–æ¶ˆ
                </button>
                <button @click="saveRecInfo"
                        class="px-6 py-2 rounded-lg text-sm font-bold bg-[#007aff] text-white hover:bg-[#0062cc] transition shadow-lg shadow-blue-500/30 flex items-center gap-2">
                    <i class="fa-solid fa-check"></i> ä¿å­˜
                </button>
            </div>
        </div>
    </div>

    <div v-if="showColorPickerModal" class="modal-overlay z-[6000]" @click.self="showColorPickerModal=false">
        <div class="modal-window w-[340px] p-6 animate-[bubblePop_0.2s] flex flex-col gap-5">

            <div class="text-center">
                <h3 class="font-bold text-lg mb-1">é€‰æ‹©é¢œè‰²</h3>
                <p class="text-[10px] opacity-40 uppercase tracking-widest">Color Picker</p>
            </div>

            <div class="flex items-center gap-3 bg-black/5 dark:bg-white/5 p-2 rounded-xl border border-black/5 dark:border-white/5">
                <div class="w-10 h-10 rounded-full shadow-sm shrink-0 border border-black/10 dark:border-white/10 transition-colors duration-300"
                     :style="{backgroundColor: tempColor}"></div>

                <div class="flex-1 relative">
                    <span class="absolute left-3 top-2.5 text-xs font-bold opacity-30">#</span>
                    <input v-model="tempColor"
                           class="glass-input w-full pl-6 font-mono uppercase text-sm"
                           maxlength="7">
                </div>
            </div>

            <div class="grid grid-cols-5 gap-3 justify-items-center">
                <button v-for="color in presetColors" :key="color"
                        @click="tempColor = color"
                        class="w-9 h-9 rounded-full shadow-sm border border-black/5 dark:border-white/10 hover:scale-110 active:scale-95 transition-all flex items-center justify-center relative group"
                        :style="{backgroundColor: color}">

                    <i v-if="tempColor.toLowerCase() === color.toLowerCase()"
                       class="fa-solid fa-check text-white text-xs drop-shadow-md"></i>
                </button>
            </div>

            <div class="flex items-center gap-3 mt-2">
                <button @click="resetColorPicker"
                        class="w-10 h-10 rounded-xl bg-gray-100 dark:bg-white/10 text-gray-500 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-500/20 transition flex items-center justify-center shrink-0"
                        title="é‡ç½®ä¸ºé»˜è®¤é¢œè‰²">
                    <i class="fa-solid fa-rotate-left"></i>
                </button>

                <button @click="saveColorPicker"
                        class="flex-1 h-10 rounded-xl bg-[#007aff] hover:bg-[#0062cc] text-white font-bold text-sm shadow-lg shadow-blue-500/30 transition">
                    Done
                </button>
            </div>

        </div>
    </div>

    <div v-if="showDurationPicker" class="bubble-picker-overlay" @click.self="closePicker">

        <div class="bubble-picker-box" :style="{ top: pickerPos.top + 'px', left: pickerPos.left + 'px' }">

            <div class="bubble-columns">
                <div class="bubble-highlight"></div>

                <div class="bubble-col" ref="pickerMinRef" @scroll="onScroll($event, 'm')"
                     @mousedown.prevent="onDragStart($event, 'm')">
                    <div v-for="m in 60" :key="'m'+(m-1)"
                         class="bubble-item"
                         :class="{'active-item': tempDuration.m === m-1}">
                        {{ (m - 1).toString().padStart(2, '0') }}
                    </div>
                </div>

                <div class="bubble-col" ref="pickerSecRef" @scroll="onScroll($event, 's')"
                     @mousedown.prevent="onDragStart($event, 's')">
                    <div v-for="s in 60" :key="'s'+(s-1)"
                         class="bubble-item"
                         :class="{'active-item': tempDuration.s === s-1}">
                        {{ (s - 1).toString().padStart(2, '0') }}
                    </div>
                </div>
            </div>

            <div class="bubble-footer">
                <button @click="resetDuration" class="btn-reset">Reset</button>
                <button @click="confirmDurationPicker" class="btn-confirm">
                    <i class="fa-solid fa-check"></i>
                </button>
            </div>
        </div>
    </div>

    <div v-if="showSplitModal" class="modal-overlay z-[11000]" @click.self="showSplitModal=false">
        <div class="modal-window w-[90vw] sm:w-[400px] p-6 animate-[bubblePop_0.2s] flex flex-col items-center">

            <h3 class="font-bold text-xl mb-1 mt-2">æ‹†åˆ†ä»»åŠ¡</h3>
            <p class="text-xs opacity-50 mb-8">æ‹–åŠ¨æ»‘å—è®¾å®šåˆ†å‰²ç‚¹</p>

            <div class="flex justify-between items-end w-full mb-6 px-4">
                <div class="flex flex-col items-center">
                    <span class="text-[10px] font-bold uppercase tracking-wider text-red-500 opacity-80 mb-1">æœ¬æ¬¡å®Œæˆ</span>
                    <span class="text-3xl font-mono font-bold text-red-500">{{ splitState.part1Str }}</span>
                    <span class="text-[9px] px-1.5 py-0.5 rounded bg-red-500/10 text-red-500 font-bold mt-1">PART 1</span>
                </div>

                <i class="fa-solid fa-arrow-right text-gray-300 dark:text-gray-600 mb-4"></i>

                <div class="flex flex-col items-center">
                    <span class="text-[10px] font-bold uppercase tracking-wider opacity-40 mb-1">ç•™ç»™ä¸‹æ¬¡</span>
                    <span class="text-3xl font-mono font-bold opacity-60">{{ splitState.part2Str }}</span>
                    <span class="text-[9px] px-1.5 py-0.5 rounded bg-black/5 dark:bg-white/10 opacity-50 font-bold mt-1">PART 2</span>
                </div>
            </div>

            <div class="w-full px-2 mb-8 relative flex items-center justify-center">
                <input type="range"
                       min="0"
                       :max="splitState.totalSec"
                       v-model.number="splitState.splitPoint"
                       @input="onSplitSliderInput"
                       class="custom-slider"
                       :style="{backgroundSize: (splitState.splitPoint / splitState.totalSec * 100) + '% 100%'}"
                >
                <div class="absolute left-2 top-[50%] -translate-y-[50%] h-[12px] bg-red-500 rounded-l-full pointer-events-none z-0"
                     :style="{width: `calc(${(splitState.splitPoint / splitState.totalSec * 100)}% - 10px)`}"></div>
            </div>

            <div class="flex gap-3 w-full">
                <button @click="showSplitModal=false"
                        class="flex-1 py-3 rounded-xl font-bold bg-black/5 dark:bg-white/10 hover:bg-black/10 transition text-sm">
                    å–æ¶ˆ
                </button>
                <button @click="confirmSplitSlider"
                        class="flex-1 py-3 rounded-xl font-bold text-white bg-red-500 hover:bg-red-600 shadow-lg shadow-red-500/30 transition text-sm">
                    ç¡®è®¤æ‹†åˆ†
                </button>
            </div>

        </div>
    </div>

    <div v-if="showMobileTaskInput" class="modal-overlay z-[1000]" @click.self="showMobileTaskInput=false">
        <div class="modal-window w-[90vw] sm:w-[300px] p-5 animate-[bubblePop_0.3s] relative bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-2xl border border-white/20 shadow-2xl rounded-3xl">
            <h3 class="text-lg font-bold mb-5 text-center opacity-60 uppercase tracking-widest">æ·»åŠ æ–°ä»»åŠ¡</h3>

            <div class="space-y-3 relative">

                <div class="mobile-input-group transition-all duration-200"
                     :class="activeDropdown === 'project' ? 'z-[100] relative' : 'z-20 relative'">
                    <button @click.stop="toggleDropdown('project')"
                            class="w-full h-[64px] flex items-center justify-between px-4 bg-transparent active:bg-black/5 rounded-xl transition">
                        <div class="flex flex-col items-start min-w-0"><span
                                class="text-[10px] opacity-40 font-bold uppercase tracking-wider mb-0.5">Project</span>
                            <div class="flex items-center gap-2 w-full">
                                <div class="w-1.5 h-4 rounded-full shrink-0"
                                     :style="{backgroundColor: newItem.projectId ? getGroupColor({projectId: newItem.projectId}, 'projectId', true) : '#3b82f6'}"></div>
                                <span class="font-bold text-lg truncate leading-tight">{{ getNameById(newItem.projectId, 'project') === 'æœªçŸ¥é¡¹ç›®' ? 'é€‰æ‹©é¡¹ç›®' : getNameById(newItem.projectId, 'project')
                                    }}</span></div>
                        </div>
                        <i class="fa-solid fa-chevron-down opacity-30 text-xs transition-transform duration-300"
                           :class="{'rotate-180': activeDropdown === 'project'}"></i>
                    </button>
                    <div v-if="activeDropdown === 'project'" class="custom-dropdown-menu">
                        <div class="sticky top-0 bg-white/10 dark:bg-black/10 backdrop-blur-sm p-2 border-b border-black/5 dark:border-white/5 z-20">
                            <input v-model="dropdownSearch" placeholder="æœç´¢é¡¹ç›®..."
                                   class="w-full bg-transparent text-base px-2 py-1 outline-none placeholder:text-black/30 dark:placeholder:text-white/30"
                                   @click.stop></div>

                        <div class="max-h-[35vh] overflow-y-auto">
                            <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">

                                <div class="sticky top-0 z-10 w-full px-4 py-2 text-[10px] font-bold uppercase tracking-wider text-gray-500 dark:text-gray-400 bg-gray-50/95 dark:bg-[#2c2c2e]/95 backdrop-blur-md border-y border-black/5 dark:border-white/10 shadow-sm flex justify-between items-center cursor-pointer select-none"
                                     @click.stop="toggleDropdownGroup(group.name)">
                                    <span>{{ group.name }}</span>

                                    <i class="fa-solid fa-chevron-right text-[10px] opacity-50 transition-transform duration-200"
                                       :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                </div>

                                <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">

                                    <div v-if="activeDropdown !== 'musician'" v-for="item in group.items" :key="item.id"
                                         @click="selectOption(activeDropdown === 'project' ? 'project' : 'instrument', item)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex items-center gap-3">

                                        <div class="w-3 h-3 rounded-full shrink-0"
                                             :style="{backgroundColor: item.color ? item.color : (activeDropdown === 'project' ? '#eab308' : '#3b82f6')}">
                                        </div>

                                        {{ item.name }}
                                    </div>

                                    <div v-if="activeDropdown === 'musician'" v-for="m in group.items" :key="m.id"
                                         @click="selectOption('musician', m)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex justify-between items-center">

                                        <div class="flex items-center gap-3">
                                            <div class="w-3 h-3 rounded-full shrink-0"
                                                 :style="{backgroundColor: m.color || '#a855f7'}">
                                            </div>
                                            <span>{{ m.name }}</span>
                                        </div>

                                        <span class="text-xs opacity-50 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded font-mono">x{{m.defaultRatio}}</span>
                                    </div>

                                </div>
                            </div>
                            <div v-if="filteredOptions.length===0" class="p-8 text-center opacity-40 text-sm">æ— ç»“æœ
                            </div>
                        </div>
                        <button @click.stop="openQuickAdd('project')"
                                class="w-full py-3 text-sm font-bold text-[#007aff] bg-black/5 dark:bg-white/5 hover:bg-[#007aff] hover:text-white transition flex items-center justify-center gap-2 border-t border-black/5 dark:border-white/5 sticky bottom-0 backdrop-blur-md">
                            <i class="fa-solid fa-plus"></i> æ–°å»ºé¡¹ç›®
                        </button>
                    </div>
                </div>

                <div class="mobile-input-group transition-all duration-200"
                     :class="activeDropdown === 'instrument' ? 'z-[90] relative' : 'z-10 relative'">
                    <button @click.stop="toggleDropdown('instrument')"
                            class="w-full h-[64px] flex items-center justify-between px-4 bg-transparent active:bg-black/5 rounded-xl transition">
                        <div class="flex flex-col items-start min-w-0"><span
                                class="text-[10px] opacity-40 font-bold uppercase tracking-wider mb-0.5">Instrument</span>
                            <div class="flex items-center gap-2 w-full">
                                <div class="w-1.5 h-4 rounded-full shrink-0"
                                     :style="{backgroundColor: newItem.instrumentId ? getGroupColor({instrumentId: newItem.instrumentId}, 'instrumentId', true) : '#3b82f6'}"></div>
                                <span class="font-bold text-lg truncate leading-tight">{{ getNameById(newItem.instrumentId, 'instrument') === 'æœªçŸ¥ä¹å™¨' ? 'é€‰æ‹©ä¹å™¨' : getNameById(newItem.instrumentId, 'instrument')
                                    }}</span></div>
                        </div>
                        <i class="fa-solid fa-chevron-down opacity-30 text-xs transition-transform duration-300"
                           :class="{'rotate-180': activeDropdown === 'instrument'}"></i>
                    </button>
                    <div v-if="activeDropdown === 'instrument'" class="custom-dropdown-menu">
                        <div class="sticky top-0 bg-white/10 dark:bg-black/10 backdrop-blur-sm p-2 border-b border-black/5 dark:border-white/5 z-20">
                            <input v-model="dropdownSearch" placeholder="æœç´¢ä¹å™¨..."
                                   class="w-full bg-transparent text-base px-2 py-1 outline-none placeholder:text-black/30 dark:placeholder:text-white/30"
                                   @click.stop></div>

                        <div class="max-h-[35vh] overflow-y-auto">
                            <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">

                                <div class="sticky top-0 z-10 w-full px-4 py-2 text-[10px] font-bold uppercase tracking-wider text-gray-500 dark:text-gray-400 bg-gray-50/95 dark:bg-[#2c2c2e]/95 backdrop-blur-md border-y border-black/5 dark:border-white/10 shadow-sm flex justify-between items-center cursor-pointer select-none"
                                     @click.stop="toggleDropdownGroup(group.name)">
                                    <span>{{ group.name }}</span>

                                    <i class="fa-solid fa-chevron-right text-[10px] opacity-50 transition-transform duration-200"
                                       :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                </div>

                                <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">

                                    <div v-if="activeDropdown !== 'musician'" v-for="item in group.items" :key="item.id"
                                         @click="selectOption(activeDropdown === 'project' ? 'project' : 'instrument', item)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex items-center gap-3">

                                        <div class="w-3 h-3 rounded-full shrink-0"
                                             :style="{backgroundColor: item.color ? item.color : (activeDropdown === 'project' ? '#eab308' : '#3b82f6')}">
                                        </div>

                                        {{ item.name }}
                                    </div>

                                    <div v-if="activeDropdown === 'musician'" v-for="m in group.items" :key="m.id"
                                         @click="selectOption('musician', m)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex justify-between items-center">

                                        <div class="flex items-center gap-3">
                                            <div class="w-3 h-3 rounded-full shrink-0"
                                                 :style="{backgroundColor: m.color || '#a855f7'}">
                                            </div>
                                            <span>{{ m.name }}</span>
                                        </div>

                                        <span class="text-xs opacity-50 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded font-mono">x{{m.defaultRatio}}</span>
                                    </div>

                                </div>
                            </div>
                            <div v-if="filteredOptions.length===0" class="p-8 text-center opacity-40 text-sm">æ— ç»“æœ
                            </div>
                        </div>
                        <button @click.stop="openQuickAdd('instrument')"
                                class="w-full py-3 text-sm font-bold text-[#007aff] bg-black/5 dark:bg-white/5 hover:bg-[#007aff] hover:text-white transition flex items-center justify-center gap-2 border-t border-black/5 dark:border-white/5 sticky bottom-0 backdrop-blur-md">
                            <i class="fa-solid fa-plus"></i> æ–°å»ºä¹å™¨
                        </button>
                    </div>
                </div>

                <div class="mobile-input-group transition-all duration-200"
                     :class="activeDropdown === 'musician' ? 'z-[80] relative' : 'z-10 relative'">
                    <button @click.stop="toggleDropdown('musician')"
                            class="w-full h-[64px] flex items-center justify-between px-4 bg-transparent active:bg-black/5 rounded-xl transition">
                        <div class="flex flex-col items-start min-w-0"><span
                                class="text-[10px] opacity-40 font-bold uppercase tracking-wider mb-0.5">Musician</span>
                            <div class="flex items-center gap-2 w-full">
                                <div class="w-1.5 h-4 rounded-full shrink-0"
                                     :style="{backgroundColor: newItem.musicianId ? getGroupColor({musicianId: newItem.musicianId}, 'musicianId', true) : '#3b82f6'}"></div>
                                <span class="font-bold text-lg truncate leading-tight">{{ getNameById(newItem.musicianId, 'musician') === 'æœªçŸ¥æ¼”å¥å‘˜' ? 'é€‰æ‹©äººå‘˜' : getNameById(newItem.musicianId, 'musician')
                                    }}</span></div>
                        </div>
                        <i class="fa-solid fa-chevron-down opacity-30 text-xs transition-transform duration-300"
                           :class="{'rotate-180': activeDropdown === 'musician'}"></i>
                    </button>
                    <div v-if="activeDropdown === 'musician'" class="custom-dropdown-menu">
                        <div class="sticky top-0 bg-white/10 dark:bg-black/10 backdrop-blur-sm p-2 border-b border-black/5 dark:border-white/5 z-20">
                            <input v-model="dropdownSearch" placeholder="æœç´¢äººå‘˜..."
                                   class="w-full bg-transparent text-base px-2 py-1 outline-none placeholder:text-black/30 dark:placeholder:text-white/30"
                                   @click.stop></div>

                        <div class="max-h-[35vh] overflow-y-auto">
                            <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">

                                <div class="sticky top-0 z-10 w-full px-4 py-2 text-[10px] font-bold uppercase tracking-wider text-gray-500 dark:text-gray-400 bg-gray-50/95 dark:bg-[#2c2c2e]/95 backdrop-blur-md border-y border-black/5 dark:border-white/10 shadow-sm flex justify-between items-center cursor-pointer select-none"
                                     @click.stop="toggleDropdownGroup(group.name)">
                                    <span>{{ group.name }}</span>

                                    <i class="fa-solid fa-chevron-right text-[10px] opacity-50 transition-transform duration-200"
                                       :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                </div>

                                <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">

                                    <div v-if="activeDropdown !== 'musician'" v-for="item in group.items" :key="item.id"
                                         @click="selectOption(activeDropdown === 'project' ? 'project' : 'instrument', item)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex items-center gap-3">

                                        <div class="w-3 h-3 rounded-full shrink-0"
                                             :style="{backgroundColor: item.color ? item.color : (activeDropdown === 'project' ? '#eab308' : '#3b82f6')}">
                                        </div>

                                        {{ item.name }}
                                    </div>

                                    <div v-if="activeDropdown === 'musician'" v-for="m in group.items" :key="m.id"
                                         @click="selectOption('musician', m)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex justify-between items-center">

                                        <div class="flex items-center gap-3">
                                            <div class="w-3 h-3 rounded-full shrink-0"
                                                 :style="{backgroundColor: m.color || '#a855f7'}">
                                            </div>
                                            <span>{{ m.name }}</span>
                                        </div>

                                        <span class="text-xs opacity-50 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded font-mono">x{{m.defaultRatio}}</span>
                                    </div>

                                </div>
                            </div>
                            <div v-if="filteredOptions.length===0" class="p-8 text-center opacity-40 text-sm">æ— ç»“æœ
                            </div>
                        </div>
                        <button @click.stop="openQuickAdd('musician')"
                                class="w-full py-3 text-sm font-bold text-[#007aff] bg-black/5 dark:bg-white/5 hover:bg-[#007aff] hover:text-white transition flex items-center justify-center gap-2 border-t border-black/5 dark:border-white/5 sticky bottom-0 backdrop-blur-md">
                            <i class="fa-solid fa-plus"></i> æ–°å»ºæ¼”å¥å‘˜
                        </button>
                    </div>
                </div>

                <div class="flex gap-3 items-stretch relative z-0">
                    <div class="mobile-input-group flex-1 mb-0 flex items-center justify-center relative bg-white/80 dark:bg-black/40 h-[64px]">
                        <input
                                :value="newItem.musicDuration"
                                @click="isMobile && openDurationPicker($event, newItem, 'musicDuration')"
                                :readonly="isMobile"
                                @input="newItem.musicDuration = $event.target.value"
                                placeholder="00:00"
                                class="w-full h-full bg-transparent text-center font-mono text-3xl font-bold outline-none text-[#8e8e93] tracking-widest placeholder:text-gray-300"
                                :class="isMobile ? 'cursor-pointer' : 'cursor-text'">
                    </div>
                    <button @click="addItemToPool()"
                            class="w-20 h-[64px] bg-[#007aff] hover:bg-[#0062cc] text-white rounded-2xl shadow-lg shadow-blue-500/30 flex items-center justify-center active:scale-95 transition">
                        <i class="fa-solid fa-plus text-3xl"></i>
                    </button>
                </div>
            </div>

            <button @click="showMobileTaskInput=false"
                    class="absolute top-3 right-3 w-8 h-8 flex items-center justify-center rounded-full bg-black/5 dark:bg-white/5 hover:bg-black/10 dark:hover:bg-white/10 transition z-[150]">
                <i class="fa-solid fa-xmark opacity-50"></i></button>
        </div>
    </div>

    <div v-if="showCreditModal" class="modal-overlay z-[5000]" @click.self="showCreditModal=false">
        <div class="modal-window w-[600px] max-w-[95vw] h-[80vh] flex flex-col p-6 animate-[bubblePop_0.2s]">

            <div class="flex justify-between items-center mb-4 shrink-0">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-full bg-purple-500/10 flex items-center justify-center text-purple-600 dark:text-purple-400">
                        <i class="fa-solid fa-file-signature text-xl"></i>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold">Project Credits</h3>
                        <p class="text-[10px] opacity-50 uppercase tracking-wider">
                            Tempo: {{ midiBpm }} BPM | Sig: {{ midiTimeSig[0] }}/{{ midiTimeSig[1] }} | Project: {{ managingProject?.name }}
                        </p>
                    </div>
                </div>
                <button @click="showCreditModal=false" class="w-8 h-8 rounded-full hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition">âœ•</button>
            </div>

            <div class="flex-1 min-h-0 relative bg-black/5 dark:bg-white/5 rounded-xl border border-black/5 dark:border-white/5 overflow-hidden flex flex-col">
                <div class="absolute top-2 right-2 z-10">
                    <button @click="copyCreditText" class="px-3 py-1.5 rounded-lg bg-[#007aff] hover:bg-[#0062cc] text-white text-xs font-bold shadow-lg transition flex items-center gap-2">
                        <i class="fa-regular fa-copy"></i> å¤åˆ¶å…¨éƒ¨
                    </button>
                </div>
                <textarea v-model="generatedCreditText"
                          class="w-full h-full bg-transparent p-4 resize-none outline-none font-mono text-xs leading-relaxed text-gray-700 dark:text-gray-300 custom-scrollbar"
                          spellcheck="false"></textarea>
            </div>

            <p class="mt-3 text-[10px] opacity-40 text-center">
                * åå•åŸºäºå½“å‰æ—¥ç¨‹è¡¨(Schedule)ä¸­ã€å·²æ’æœŸã€‘çš„ä»»åŠ¡è‡ªåŠ¨ç”Ÿæˆã€‚<br>
                * è¯·æ£€æŸ¥å¹¶æ‰‹åŠ¨è¡¥å……æŒ‡æŒ¥ã€ä¹å›¢åç§°ç­‰æœªå½•å…¥ä¿¡æ¯ã€‚
            </p>
        </div>
    </div>

    <div v-if="showMidiManager" class="modal-overlay z-[6000]" @click.self="showMidiManager=false">
        <div class="modal-window w-[600px] max-w-[90vw] max-h-[85vh] flex flex-col p-6 animate-[bubblePop_0.2s]">

            <div class="flex justify-between items-center mb-4 shrink-0">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-full bg-teal-500/10 flex items-center justify-center text-teal-600 dark:text-teal-400">
                        <i class="fa-solid fa-music text-xl"></i>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold truncate max-w-[200px]">{{ managingProject?.name }}</h3>
                        <p class="text-[10px] opacity-50 uppercase tracking-wider">MIDI æ˜ å°„ç®¡ç†</p>
                    </div>
                </div>
                <button @click="showMidiManager=false" class="w-8 h-8 rounded-full hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition">âœ•</button>
            </div>

            <div class="flex gap-2 mb-4 mx-6">
                <button @click="triggerMidiImportForProject"
                        class="flex-1 py-2 rounded-lg bg-teal-500 hover:bg-teal-600 text-white text-xs font-bold shadow-lg shadow-teal-500/20 transition flex items-center justify-center gap-2">
                    <i class="fa-solid fa-file-import"></i> å¯¼å…¥/æ›´æ–° MIDI
                </button>
                <button @click="clearProjectMidi"
                        class="px-4 py-2 rounded-lg bg-red-500/10 text-red-500 hover:bg-red-500 hover:text-white text-xs font-bold transition">
                    æ¸…ç©º
                </button>
            </div>

            <div class="flex-1 overflow-y-auto custom-scrollbar p-3 space-y-3 bg-black/5 dark:bg-white/5 rounded-xl border border-black/5 dark:border-white/5 mx-6 mb-6">

                <div v-if="projectMidiGroups.length === 0" class="h-full flex flex-col items-center justify-center opacity-40 gap-2 min-h-[150px]">
                    <i class="fa-solid fa-music-slash text-2xl"></i>
                    <span class="text-xs">æš‚æ—  MIDI æ•°æ®</span>
                </div>

                <div v-else v-for="group in projectMidiGroups" :key="group.name" class="rounded-xl overflow-hidden bg-white/40 dark:bg-white/5 border border-black/5 dark:border-white/5">

                    <div @click="toggleMidiManagerGroup(group.name)"
                         class="px-3 py-2 flex justify-between items-center cursor-pointer hover:bg-black/5 dark:hover:bg-white/10 transition select-none group/header bg-white/60 dark:bg-black/20 backdrop-blur-sm">

                        <div class="flex items-center gap-2">
                            <i class="fa-solid fa-chevron-right text-[10px] opacity-30 transition-transform duration-200"
                               :class="{'rotate-90': midiManagerExpandedGroups.has(group.name)}"></i>
                            <span class="text-xs font-bold uppercase tracking-wider opacity-70">{{ group.name }}</span>
                            <span class="text-[9px] font-bold px-1.5 py-0.5 rounded-md bg-black/5 dark:bg-white/10 opacity-50">{{ group.items.length }}</span>
                        </div>
                    </div>

                    <div v-show="midiManagerExpandedGroups.has(group.name)" class="p-1 space-y-1">

                        <div v-for="row in group.items" :key="row.instId + '_' + row.subIndex"
                             class="flex items-center gap-3 p-2 rounded-lg hover:bg-white/50 dark:hover:bg-white/10 border border-transparent transition group">

                            <div class="flex-1 min-w-0 flex items-center gap-2">
                                <div class="w-1.5 h-4 rounded-full bg-teal-500 shrink-0 opacity-50"></div>
                                <span class="text-sm font-bold truncate" :title="row.instName">{{ row.instName }}</span>
                            </div>

                            <div class="relative">
                                <button @click.stop="openMidiGroupDropdown($event, row.instId)"
                                        class="h-7 px-2 rounded-md bg-transparent border border-transparent hover:bg-black/5 dark:hover:bg-white/10 hover:border-black/10 dark:hover:border-white/10 transition flex items-center gap-1 min-w-[20px] max-w-[120px] group/btn">
                                    <span class="text-[10px] font-bold truncate opacity-30 group-hover/btn:opacity-100">{{ row.group || 'Unassigned' }}</span>
                                    <i class="fa-solid fa-folder-tree text-[10px] opacity-20 group-hover/btn:opacity-60"></i>
                                </button>
                            </div>

                            <div class="relative group/input">
                                <input v-model.lazy="row.duration"
                                       @change="updateMidiDuration(row.instId, row.subIndex, $event.target.value)"
                                       class="glass-input w-20 h-8 text-center font-mono text-xs font-bold text-teal-600 dark:text-teal-400 bg-teal-500/5 focus:bg-white focus:w-24 transition-all z-10 relative"
                                       placeholder="00:00">
                            </div>

                            <button @click="removeMidiMapping(row.instId, row.subIndex)"
                                    class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-red-500 hover:bg-red-500/10 rounded-md transition opacity-0 group-hover:opacity-100">
                                <i class="fa-solid fa-xmark"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <p class="mt-3 text-[10px] opacity-40 text-center">
                * ä¿®æ”¹åˆ†ç»„ä¼šåŒæ­¥æ›´æ–°è¯¥ä¹å™¨çš„å…¨å±€è®¾ç½®
            </p>
        </div>

        <Teleport to="body">
            <div v-if="activeMidiGroupRow" class="fixed inset-0 z-[99999]" @click="activeMidiGroupRow = null" @contextmenu.prevent>
                <div class="custom-dropdown-menu fixed overflow-hidden flex flex-col p-0 animate-[fadeIn_0.1s] origin-top-left shadow-2xl border border-white/20 rounded-xl"
                     :style="{
                         top: midiGroupPos.top + 'px',
                         left: midiGroupPos.left + 'px',
                         minWidth: '200px',
                         maxHeight: '300px',
                         width: 'auto'
                     }"
                     @click.stop>

                    <div class="p-2 border-b border-black/5 dark:border-white/5 bg-gray-50/90 dark:bg-[#2c2c2e]/90 backdrop-blur shrink-0">
                        <input id="midi-group-search-input"
                               v-model="midiGroupSearchQuery"
                               placeholder="Search or Create..."
                               class="w-full bg-white/50 dark:bg-black/20 rounded-md px-2 py-1.5 text-xs font-bold outline-none border border-black/5 dark:border-white/10 focus:border-[#007aff] transition-colors"
                               @keydown.enter="updateInstrumentGroup(activeMidiGroupRow, midiGroupSearchQuery)">
                    </div>

                    <div class="overflow-y-auto flex-1 p-1 custom-scrollbar">

                        <div v-if="midiGroupSearchQuery && !filteredMidiGroups.includes(midiGroupSearchQuery)"
                             @click="updateInstrumentGroup(activeMidiGroupRow, midiGroupSearchQuery)"
                             class="px-3 py-2 rounded-md bg-green-500/10 text-green-600 hover:bg-green-500 hover:text-white cursor-pointer text-xs font-bold transition-colors flex items-center gap-2 mb-1">
                            <i class="fa-solid fa-plus"></i>
                            <span>Create "{{ midiGroupSearchQuery }}"</span>
                        </div>

                        <div v-for="g in filteredMidiGroups" :key="g"
                             @click="updateInstrumentGroup(activeMidiGroupRow, g)"
                             class="px-3 py-2.5 rounded-md hover:bg-[#007aff] hover:text-white cursor-pointer text-xs font-bold transition-colors flex justify-between items-center group/item">
                            <span>{{ g }}</span>
                            <i v-if="settings.instruments.find(i => i.id === activeMidiGroupRow)?.group === g"
                               class="fa-solid fa-check text-[10px]"></i>
                        </div>

                        <div v-if="filteredMidiGroups.length === 0 && !midiGroupSearchQuery" class="p-4 text-center text-[10px] opacity-40">
                            No groups found.
                        </div>
                    </div>
                </div>
            </div>
        </Teleport>
    </div>
    <div v-if="showMidiImportModal" class="modal-overlay z-[99999]" @click.self="showMidiImportModal=false">
        <div class="modal-window w-[950px] max-w-[98vw] h-[85vh] flex flex-col p-0 overflow-hidden animate-[bubblePop_0.2s]">

            <div class="p-5 border-b border-glass-border dark:border-glass-borderDark bg-gray-50/50 dark:bg-white/5 flex justify-between items-center shrink-0">
                <div>
                    <h3 class="text-xl font-bold flex items-center gap-2">
                        <i class="fa-solid fa-file-audio text-teal-500"></i>
                        MIDI Import
                    </h3>
                    <p class="text-[10px] opacity-50 uppercase tracking-wider mt-1">
                        Tempo: {{ midiBpm }} BPM | {{ managingProject?.name }}
                    </p>
                </div>

                <div class="bg-black/5 dark:bg-white/10 p-1 rounded-lg flex text-xs font-bold">
                    <button @click="midiViewMode = 'tracks'"
                            class="px-3 py-1.5 rounded-md transition-all"
                            :class="midiViewMode === 'tracks' ? 'bg-white dark:bg-white/20 shadow-sm text-teal-600 dark:text-teal-400' : 'opacity-50 hover:opacity-100'">
                        Tracks ({{ midiImportData.length }})
                    </button>
                    <button @click="midiViewMode = 'groups'"
                            class="px-3 py-1.5 rounded-md transition-all"
                            :class="midiViewMode === 'groups' ? 'bg-white dark:bg-white/20 shadow-sm text-teal-600 dark:text-teal-400' : 'opacity-50 hover:opacity-100'">
                        Groups ({{ midiGroupData.length }})
                    </button>
                </div>

                <button @click="showMidiImportModal=false" class="w-8 h-8 ...">âœ•</button>
            </div>

            <div class="grid grid-cols-[40px_1.5fr_80px_60px_60px_1.5fr_1fr] gap-4 px-6 py-2 border-b border-black/5 dark:border-white/5 text-[10px] font-bold opacity-50 uppercase tracking-wider items-center bg-white/30 dark:bg-black/20">
                <div class="text-center">Import</div>
                <div>Track Name</div>
                <div class="text-right">Time</div>
                <div class="text-center">Bars</div>
                <div class="text-center">Notes</div>
                <div>Target Instrument</div>
                <div>Group</div>
            </div>

            <div class="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-1" @scroll="closeImportMenu">

                <template v-if="midiViewMode === 'tracks'">
                    <div v-for="track in midiImportData" :key="track.id"
                         class="group grid grid-cols-[40px_1.5fr_80px_60px_60px_1.5fr_1fr] gap-4 items-center p-2 rounded-xl border border-transparent hover:border-black/5 dark:hover:border-white/5 bg-white/40 dark:bg-white/5 transition-all"
                         :class="{'opacity-40 grayscale': !track.selected}">

                        <div class="flex justify-center">
                            <input type="checkbox" v-model="track.selected" class="cursor-pointer accent-teal-500 w-4 h-4">
                        </div>
                        <div class="min-w-0">
                            <input v-model="track.name" class="bg-transparent font-bold text-sm outline-none w-full truncate" :disabled="!track.selected">
                        </div>
                        <div class="text-right font-mono font-bold text-[#007aff]">{{ formatSecs(track.quantizedDuration) }}</div>
                        <div class="text-center font-mono text-xs opacity-60">{{ track.bars }}</div>
                        <div class="text-center font-mono text-xs font-bold opacity-70">{{ track.noteCount }}</div>

                        <div class="relative min-w-0">
                            <button @click.stop="openImportMenu($event, track.id, 'inst')" :disabled="!track.selected"
                                    class="w-full h-9 px-3 rounded-lg bg-black/50 border border-white/10 flex items-center justify-between gap-2 text-left text-white hover:border-[#007aff] transition-colors">
                                        <span class="text-xs font-bold truncate">
                                            {{ track.instrumentId
                                                ? getNameById(track.instrumentId, 'instrument')
                                                : '+ Create: ' + getSmartName(track)
                                            }}
                                        </span>
                                <i class="fa-solid fa-chevron-down text-[8px] opacity-50"></i>
                            </button>
                        </div>

                        <div class="relative min-w-0">
                            <button @click.stop="openImportMenu($event, track.id, 'group')" :disabled="!track.selected"
                                    class="w-full h-9 px-3 rounded-lg bg-black/50 border border-white/10 flex items-center justify-between gap-2 text-left text-white hover:border-[#007aff] transition-colors">
                                <span class="text-xs font-bold truncate opacity-80">{{ track.group || 'Unassigned' }}</span>
                                <i class="fa-solid fa-chevron-down text-[8px] opacity-50"></i>
                            </button>
                        </div>
                    </div>
                </template>

                <template v-else>
                    <div v-for="group in midiGroupData" :key="group.id" class="mb-2">

                        <div class="grid grid-cols-[40px_1.5fr_80px_60px_60px_1.5fr_1fr] gap-4 items-center p-2 rounded-xl border border-teal-500/20 bg-teal-50/80 dark:bg-teal-900/20 transition-all"
                             :class="{'opacity-60': !group.selected}">

                            <div class="flex justify-center">
                                <input type="checkbox"
                                       :checked="group.selected"
                                       @change="toggleGroupSelection(group.items, $event.target.checked)"
                                       class="cursor-pointer accent-teal-500 w-4 h-4">
                            </div>

                            <div class="min-w-0 flex items-center gap-2 cursor-pointer select-none"
                                 @click="toggleMidiGroupExpand(group.id)">

                                <div class="w-5 h-5 flex items-center justify-center rounded hover:bg-black/5 transition">
                                    <i class="fa-solid fa-chevron-right text-xs opacity-50 transition-transform duration-200"
                                       :class="{'rotate-90': midiGroupExpanded.has(group.id)}"></i>
                                </div>

                                <i class="fa-solid fa-layer-group text-teal-500 text-xs"></i>
                                <span class="font-bold text-sm">{{ group.name }}</span>
                                <span class="text-[9px] opacity-40 font-mono bg-black/5 px-1.5 rounded">{{ group.description }}</span>
                            </div>

                            <div class="text-right flex flex-col justify-center">
                                <div class="text-sm font-mono font-bold text-teal-600 dark:text-teal-400">
                                    {{ formatSecs(group.quantizedDuration) }}
                                </div>
                            </div>

                            <div class="text-center font-mono text-xs opacity-60">{{ group.bars }}</div>
                            <div class="text-center font-mono text-xs font-bold opacity-70">{{ group.noteCount }}</div>

                            <div class="relative min-w-0">
                                <button @click.stop="openImportMenu($event, group.id, 'inst')"
                                        :disabled="!group.selected"
                                        class="w-full h-9 px-3 rounded-lg bg-black/50 border border-white/10 hover:border-[#007aff] transition flex items-center justify-between gap-2 group/btn text-left text-white">
                                    <div class="flex items-center gap-2 truncate flex-1">
                                        <div v-if="group.instrumentId" class="w-2 h-2 rounded-full bg-blue-500 shrink-0"></div>
                                        <span class="text-xs font-bold truncate">
                                {{ group.instrumentId ? getNameById(group.instrumentId, 'instrument') : '+ Create: ' + group.name }}
                            </span>
                                    </div>
                                    <i class="fa-solid fa-chevron-down text-[8px] opacity-50 group-hover/btn:opacity-100"></i>
                                </button>
                            </div>

                            <div class="text-xs font-bold opacity-50 pl-2">
                                {{ group.group }}
                            </div>
                        </div>

                        <div v-if="midiGroupExpanded.has(group.id)"
                             class="ml-10 mt-1 border-l-2 border-black/5 dark:border-white/5 pl-2 space-y-1 bg-black/5 dark:bg-white/5 rounded-r-xl p-2">

                            <div v-for="track in group.items" :key="track.id"
                                 class="grid grid-cols-[1.5fr_80px_1fr] gap-4 items-center p-1.5 rounded-lg hover:bg-white/50 dark:hover:bg-white/10 transition-colors"
                                 :class="{'opacity-40 grayscale': !track.selected}">

                                <div class="flex items-center gap-3 min-w-0">
                                    <input type="checkbox" v-model="track.selected" class="cursor-pointer accent-teal-500 w-3 h-3">
                                    <span class="text-xs font-medium truncate" :title="track.originalName">{{ track.originalName }}</span>
                                </div>

                                <div class="text-right font-mono text-xs opacity-70">
                                    {{ formatSecs(track.quantizedDuration) }}
                                </div>

                                <div class="text-xs opacity-40 font-mono">
                                    {{ track.noteCount }} notes
                                </div>
                            </div>
                        </div>

                    </div>
                </template>

            </div>

            <div class="p-5 border-t border-glass-border dark:border-glass-borderDark bg-gray-50/50 dark:bg-white/5 flex justify-between items-center shrink-0">
                <div class="text-xs opacity-50">
                    <span class="font-bold">
                        {{ midiViewMode === 'groups'
                            ? midiGroupData.filter(g => g.selected).length
                            : midiImportData.filter(t => t.selected).length
                        }}
                    </span>
                    {{ midiViewMode === 'groups' ? 'groups' : 'tracks' }} selected
                </div>
                <button @click="confirmMidiImport"
                        class="bg-teal-500 hover:bg-teal-600 text-white px-8 py-2.5 rounded-xl font-bold shadow-lg shadow-teal-500/20 transition text-sm flex items-center gap-2 active:scale-95">
                    <i class="fa-solid fa-file-import"></i>
                    Import Data
                </button>
            </div>
        </div>

        <Teleport to="body">
            <div v-if="activeImportMenu.rowId !== null" class="fixed inset-0 z-[99999]" @click="closeImportMenu" @contextmenu.prevent>
                <div class="custom-dropdown-menu fixed overflow-hidden flex flex-col animate-[fadeIn_0.1s] origin-top-left shadow-2xl border border-white/20"
                     :style="{
                         top: importMenuPos.top + 'px',
                         left: importMenuPos.left + 'px',
                         width: Math.max(importMenuPos.width, 200) + 'px',
                         maxHeight: '300px'
                     }"
                     @click.stop>

                    <div class="p-2 border-b border-black/5 dark:border-white/5 bg-white/95 dark:bg-[#2c2c2e]/95 backdrop-blur shrink-0">
                        <input id="midi-import-search"
                               v-model="importSearchQuery"
                               :placeholder="activeImportMenu.type === 'inst' ? 'Search Instruments...' : 'Search Groups...'"
                               class="w-full bg-black/5 dark:bg-white/10 rounded-md px-2 py-1.5 text-xs font-bold outline-none border border-transparent focus:border-[#007aff] transition-colors">
                    </div>

                    <div class="overflow-y-auto flex-1 p-1">

                        <div v-if="activeImportMenu.type === 'inst' && !importSearchQuery"
                             @click="selectImportNewInst(midiImportData.find(t => t.id === activeImportMenu.rowId))"
                             class="px-3 py-2 rounded-md bg-green-500/10 text-green-600 hover:bg-green-500 hover:text-white cursor-pointer text-xs font-bold transition-colors flex items-center gap-2 mb-1">
                            <i class="fa-solid fa-plus"></i>
                            <span>Create: {{ getSmartName(currentMidiDisplayList.find(t => t.id === activeImportMenu.rowId)) }}</span>
                        </div>

                        <template v-if="activeImportMenu.type === 'inst'">
                            <div v-for="inst in filteredImportOptions" :key="inst.id"
                                 @click="selectImportInst(midiImportData.find(t => t.id === activeImportMenu.rowId), inst)"
                                 class="px-3 py-2 rounded-md hover:bg-[#007aff] hover:text-white cursor-pointer text-xs font-bold transition-colors flex items-center gap-2">
                                <div class="w-2 h-2 rounded-full shrink-0" :style="{backgroundColor: inst.color}"></div>
                                <span>{{ inst.name }}</span>
                                <span v-if="inst.group" class="opacity-50 text-[10px] ml-auto font-mono">{{ inst.group }}</span>
                            </div>
                        </template>
                        <div v-if="filteredImportOptions.length === 0" class="p-4 text-center text-[10px] opacity-40">
                            No matches found.
                        </div>

                        <template v-if="activeImportMenu.type === 'group'">

                            <div v-if="importSearchQuery && !availableInstrumentGroups.includes(importSearchQuery)"
                                 @click="selectImportGroup(midiImportData.find(t => t.id === activeImportMenu.rowId), importSearchQuery)"
                                 class="px-3 py-2 rounded-md bg-green-500/10 text-green-600 hover:bg-green-500 hover:text-white cursor-pointer text-xs font-bold transition-colors flex items-center gap-2 mb-1">
                                <i class="fa-solid fa-plus"></i>
                                <span>Create "{{ importSearchQuery }}"</span>
                            </div>

                            <div v-for="g in filteredImportOptions" :key="g"
                                 @click="selectImportGroup(midiImportData.find(t => t.id === activeImportMenu.rowId), g)"
                                 class="px-3 py-2 rounded-md hover:bg-[#007aff] hover:text-white cursor-pointer text-xs font-bold transition-colors">
                                {{ g }}
                            </div>

                        </template>
                    </div>
                </div>
            </div>
        </Teleport>
    </div>

    <div v-if="showCsvImportModal" class="modal-overlay z-[7000]" @click.self="showCsvImportModal=false">
        <div class="modal-window w-[1000px] max-w-[95vw] max-h-[90vh] flex flex-col p-6 animate-[bubblePop_0.2s]">

            <div class="flex justify-between items-center mb-4 shrink-0">
                <div>
                    <h3 class="text-xl font-bold">Import CSV Data</h3>
                    <p class="text-[10px] opacity-50 uppercase tracking-wider">æ‰¹é‡å¯¼å…¥ä¸æ›´æ–°</p>
                </div>

                <div class="flex gap-4 border-b border-black/10 dark:border-white/10 px-2 shrink-0">
                    <button @click="activeImportTab = 'rec'"
                            class="pb-2 px-2 text-sm font-bold border-b-2 transition-colors flex items-center gap-2"
                            :class="activeImportTab === 'rec' ? 'border-[#007aff] text-[#007aff]' : 'border-transparent opacity-50 hover:opacity-100'">
                        <i class="fa-solid fa-microphone-lines"></i>
                        Recording Import
                    </button>
                    <button @click="activeImportTab = 'edt'"
                            class="pb-2 px-2 text-sm font-bold border-b-2 transition-colors flex items-center gap-2"
                            :class="activeImportTab === 'edt' ? 'border-purple-500 text-purple-500' : 'border-transparent opacity-50 hover:opacity-100'">
                        <i class="fa-solid fa-sliders"></i>
                        Editing Import
                    </button>
                </div>
                <div class="mb-4 relative w-40 group">
    <span class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none text-gray-400 group-focus-within:text-blue-400 transition-colors">
        <i class="fa-solid fa-search text-xs"></i>
    </span>

                    <input type="text"
                           v-model="csvSearchQuery"
                           placeholder="æœç´¢é¡¹ç›®ã€ä¹å™¨ã€æ¼”å¥å‘˜..."
                           class="glass-input h-9 w-full pl-9 pr-8 transition-all duration-300 text-xs font-bold bg-white/40 dark:bg-black/20 focus:bg-white dark:focus:bg-white/10 text-gray-200 placeholder-gray-400 rounded-full border-none outline-none focus:ring-0"
                    >

                    <button v-if="csvSearchQuery"
                            @click="csvSearchQuery = ''"
                            class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-white transition-colors">
                        <i class="fa-solid fa-circle-xmark text-xs"></i>
                    </button>
                </div>

                <button @click="showCsvImportModal=false" class="w-8 h-8 rounded-full hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition">âœ•</button>
            </div>

            <div class="bg-black/5 dark:bg-white/5 rounded-xl p-4 mb-4 shrink-0 grid grid-cols-1 sm:grid-cols-2 gap-4">

                <div class="flex flex-col h-full">
                    <h4 class="text-[10px] font-bold opacity-50 uppercase mb-2">Import Data Types / å¯¼å…¥å†…å®¹</h4>
                    <div class="flex gap-2 h-full">
                        <label class="flex flex-col items-center justify-center gap-1 bg-white/50 dark:bg-black/20 px-2 py-3 rounded-lg cursor-pointer hover:bg-white/80 dark:hover:bg-black/40 transition flex-1 border border-transparent h-full relative"
                               :class="{'border-[#007aff] bg-blue-500/10': csvImportConfig.importTypes.tasks}">
                            <input type="checkbox" v-model="csvImportConfig.importTypes.tasks" @change="refreshCsvStatus" class="hidden">
                            <i class="fa-solid fa-file-circle-plus text-lg mb-1 transition-colors"
                               :class="csvImportConfig.importTypes.tasks ? 'text-[#007aff]' : 'opacity-30'"></i>
                            <span class="text-[10px] font-bold">Tasks (ä»»åŠ¡)</span>

                            <div v-if="csvImportConfig.importTypes.tasks" class="absolute top-1 right-1 text-[#007aff] text-[8px]">
                                <i class="fa-solid fa-check"></i>
                            </div>
                        </label>

                        <label class="flex flex-col items-center justify-center gap-1 bg-white/50 dark:bg-black/20 px-2 py-3 rounded-lg cursor-pointer hover:bg-white/80 dark:hover:bg-black/40 transition flex-1 border border-transparent h-full relative"
                               :class="{'border-orange-500 bg-orange-500/10': csvImportConfig.importTypes.time}">
                            <input type="checkbox" v-model="csvImportConfig.importTypes.time" @change="refreshCsvStatus" class="hidden">
                            <i class="fa-solid fa-clock text-lg mb-1 transition-colors"
                               :class="csvImportConfig.importTypes.time ? 'text-orange-500' : 'opacity-30'"></i>
                            <span class="text-[10px] font-bold">Time (æ—¶é—´)</span>

                            <div v-if="csvImportConfig.importTypes.time" class="absolute top-1 right-1 text-orange-500 text-[8px]">
                                <i class="fa-solid fa-check"></i>
                            </div>
                        </label>

                        <label class="flex flex-col items-center justify-center gap-1 bg-white/50 dark:bg-black/20 px-2 py-3 rounded-lg cursor-pointer hover:bg-white/80 dark:hover:bg-black/40 transition flex-1 border border-transparent h-full relative"
                               :class="{'border-purple-500 bg-purple-500/10': csvImportConfig.importTypes.orch}">
                            <input type="checkbox" v-model="csvImportConfig.importTypes.orch" @change="refreshCsvStatus" class="hidden">
                            <i class="fa-solid fa-users text-lg mb-1 transition-colors"
                               :class="csvImportConfig.importTypes.orch ? 'text-purple-500' : 'opacity-30'"></i>
                            <span class="text-[10px] font-bold">Orch (ç¼–åˆ¶)</span>

                            <div v-if="csvImportConfig.importTypes.orch" class="absolute top-1 right-1 text-purple-500 text-[8px]">
                                <i class="fa-solid fa-check"></i>
                            </div>
                        </label>
                    </div>
                </div>

                <div class="flex flex-col h-full">
                    <h4 class="text-[10px] font-bold opacity-50 uppercase mb-2">Naming Strategy / å‘½åç­–ç•¥</h4>
                    <div class="flex gap-2 h-full">
                        <label class="flex flex-col items-center justify-center gap-1 bg-white/50 dark:bg-black/20 px-2 py-3 rounded-lg cursor-pointer hover:bg-white/80 dark:hover:bg-black/40 transition flex-1 border border-transparent h-full relative"
                               :class="{'border-blue-500 bg-blue-500/10': csvImportConfig.nameStrategy === 'merge'}">
                            <input type="radio" value="merge" v-model="csvImportConfig.nameStrategy" class="hidden">
                            <i class="fa-solid fa-layer-group text-lg mb-1 transition-colors"
                               :class="csvImportConfig.nameStrategy === 'merge' ? 'text-blue-500' : 'opacity-30'"></i>
                            <span class="text-[10px] font-bold text-center leading-tight">æ™ºèƒ½åˆå¹¶<br><span class="opacity-60 text-[9px]">(Strings)</span></span>

                            <div v-if="csvImportConfig.nameStrategy === 'merge'" class="absolute top-1 right-1 text-blue-500 text-[8px]">
                                <i class="fa-solid fa-check"></i>
                            </div>
                        </label>

                        <label class="flex flex-col items-center justify-center gap-1 bg-white/50 dark:bg-black/20 px-2 py-3 rounded-lg cursor-pointer hover:bg-white/80 dark:hover:bg-black/40 transition flex-1 border border-transparent h-full relative"
                               :class="{'border-blue-500 bg-blue-500/10': csvImportConfig.nameStrategy === 'csv'}">
                            <input type="radio" value="csv" v-model="csvImportConfig.nameStrategy" class="hidden">
                            <i class="fa-solid fa-list-ol text-lg mb-1 transition-colors"
                               :class="csvImportConfig.nameStrategy === 'csv' ? 'text-blue-500' : 'opacity-30'"></i>
                            <span class="text-[10px] font-bold text-center leading-tight">ä¿ç•™åŸå<br><span class="opacity-60 text-[9px]">(Violin 1, 2)</span></span>

                            <div v-if="csvImportConfig.nameStrategy === 'csv'" class="absolute top-1 right-1 text-blue-500 text-[8px]">
                                <i class="fa-solid fa-check"></i>
                            </div>
                        </label>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-[40px_1.2fr_1fr_1fr_80px_80px] gap-2 px-3 py-2 bg-black/10 dark:bg-white/10 rounded-t-lg text-[10px] font-bold uppercase opacity-60 shrink-0">
                <div class="flex items-center justify-center">
                    <input type="checkbox"
                           :checked="csvImportData.length > 0 && csvImportData.every(r => r.selected)"
                           @change="toggleAllRows($event.target.checked)">
                </div>
                <div>Task Name ({{ csvImportConfig.nameStrategy === 'csv' ? 'Original' : 'Merged' }})</div>
                <div>Player / Group</div>
                <div>Orchestration</div>
                <div class="text-center">Duration</div>
                <div class="text-center">Status</div>
            </div>

            <div class="flex-1 overflow-y-auto min-h-0 border border-black/5 dark:border-white/5 rounded-lg bg-white/30 dark:bg-black/10 custom-scrollbar flex flex-col w-full">

                <div v-if="groupedCsvData.length === 0" class="flex flex-col items-center justify-center flex-1 opacity-40 min-h-[200px]">
                    <i class="fa-solid fa-filter-circle-xmark text-4xl mb-3"></i>
                    <span class="text-sm font-bold">æ²¡æœ‰éœ€è¦å¯¼å…¥çš„æ•°æ®</span>
                </div>

                <div class="p-2 min-w-[800px]">
                    <div v-for="group in groupedCsvData" :key="group.projectName"
                         class="mb-3 border border-black/5 dark:border-white/5 rounded-xl overflow-hidden bg-white/40 dark:bg-black/20">

                        <div @click="toggleProjectCollapse(group.projectName)"
                             class="flex items-center gap-2 p-2 bg-black/5 dark:bg-white/5 rounded-lg cursor-pointer select-none hover:bg-black/10 dark:hover:bg-white/10 transition">

                            <i class="fa-solid fa-chevron-right text-xs opacity-50 transition-transform duration-200"
                               :class="{'rotate-90': !collapsedProjects.has(group.projectName)}"></i>

                            <div class="flex items-center mr-2" @click.stop>
                                <input type="checkbox"
                                       :checked="isGroupSelected(group.rows)"
                                       @change="toggleGroupSelection(group, $event.target.checked)"
                                       class="w-4 h-4 rounded border-gray-300 text-[#007aff] focus:ring-[#007aff] cursor-pointer">
                            </div>

                            <span class="font-bold text-sm opacity-80">{{ group.projectName }}</span>

                            <span class="text-[10px] opacity-40 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded ml-auto">
                                {{ group.rows.length }} ITEMS
                            </span>
                        </div>

                        <div v-show="!collapsedProjects.has(group.projectName)" class="border-t border-black/5 dark:border-white/5">

                            <div class="grid grid-cols-[30px_1.5fr_1fr_0.8fr_50px_70px_50px_1fr_60px] gap-2 px-3 py-2 bg-black/5 dark:bg-white/5 text-[9px] font-bold uppercase opacity-50">
                                <div class="text-center">Select</div>
                                <div>Task Name</div>
                                <div>Player / Group</div>
                                <div>Orchestration</div>
                                <div class="text-center">Dur</div>
                                <div>Date</div>
                                <div>Time</div>
                                <div>{{ activeImportTab === 'rec' ? 'Rec Engineer' : 'Edit Engineer' }}</div>
                                <div class="text-center">Status</div>
                            </div>

                            <div v-for="(row, idx) in group.rows" :key="idx"
                                 class="grid grid-cols-[30px_1.5fr_1fr_0.8fr_50px_70px_50px_1fr_60px] gap-2 px-3 py-2 border-b border-black/5 dark:border-white/5 text-xs hover:bg-black/5 dark:hover:bg-white/5 transition items-center last:border-0"
                                 :class="{'opacity-50 grayscale': !row.selected}"
                                 @click="row.selected = !row.selected">

                                <div class="flex items-center justify-center">
                                    <input type="checkbox" v-model="row.selected" @click.stop
                                           class="cursor-pointer rounded border-gray-500/50 bg-transparent text-[#007aff] focus:ring-0 focus:ring-offset-0 w-3.5 h-3.5">
                                </div>

                                <div class="min-w-0 font-bold truncate"
                                     :title="csvImportConfig.nameStrategy === 'csv' ? row.name_display : row.name_merge"
                                     :class="row.isDuplicate ? 'text-blue-600 dark:text-blue-400' : ''">
                                    {{ csvImportConfig.nameStrategy === 'csv' ? row.name_display : row.name_merge }}
                                    <span v-if="row.isSplit" class="text-[9px] opacity-50 font-normal ml-1">Part {{ row.partIndex + 1 }}</span>
                                </div>

                                <div class="min-w-0">
                                    <div class="truncate font-bold text-[#007aff] text-[11px]" :title="row.playerName">{{ row.playerName || '-' }}</div>
                                    <div class="truncate text-[9px] opacity-60" :title="row.group">{{ row.group || '-' }}</div>
                                </div>

                                <div class="min-w-0">
                    <span v-if="row.orchestration"
                          class="truncate inline-block max-w-full text-[9px] bg-orange-500/10 text-orange-600 dark:text-orange-400 px-1.5 py-0.5 rounded"
                          :title="row.orchestration">
                        {{ row.orchestration }}
                    </span>
                                </div>

                                <div class="text-center font-mono opacity-70 text-[10px]">{{ row.duration }}</div>

                                <div class="font-mono text-[10px] opacity-80 truncate">
                                    {{ activeImportTab === 'rec' ? (row.recDate || '-') : (row.edtDate || '-') }}
                                </div>

                                <div class="font-mono text-[10px] font-bold text-[#007aff] truncate">
                                    {{ activeImportTab === 'rec' ? (row.recStart || '-') : (row.edtStart || '-') }}
                                </div>

                                <div class="min-w-0 flex flex-col justify-center">
                    <span class="truncate font-bold text-[10px]"
                          :title="activeImportTab === 'rec' ? row.recEngineer : row.edtEngineer">
                        {{ activeImportTab === 'rec' ? (row.recEngineer || '-') : (row.edtEngineer || '-') }}
                    </span>
                                    <span class="truncate text-[9px] opacity-50"
                                          :title="activeImportTab === 'rec' ? row.recStudio : row.edtStudio">
                        {{ activeImportTab === 'rec' ? row.recStudio : row.edtStudio }}
                    </span>
                                </div>

                                <div class="text-center flex justify-center">
                     <span v-if="(activeImportTab==='rec'?row.recStatusText:row.editStatusText) === 'NEW'"
                           class="px-2 py-0.5 rounded-full bg-green-500/10 text-green-600 dark:text-green-400 text-[9px] font-bold border border-green-500/20">
                         NEW
                     </span>
                                    <span v-else-if="(activeImportTab==='rec'?row.recStatusText:row.editStatusText) === 'UPDATE'"
                                          class="px-2 py-0.5 rounded-full bg-blue-500/10 text-blue-600 dark:text-blue-400 text-[9px] font-bold border border-blue-500/20">
                         UPDATE
                     </span>
                                    <span v-else
                                          class="px-2 py-0.5 rounded-full bg-gray-500/10 text-gray-500 text-[9px] font-bold border border-gray-500/20">
                         SKIP
                     </span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-4 flex justify-between items-center shrink-0">

                <div class="flex items-center gap-3">
                    <button @click="csvImportConfig.showSkipRows = !csvImportConfig.showSkipRows"
                            class="flex items-center gap-2 px-3 py-2 rounded-xl text-xs font-bold transition-all border"
                            :class="csvImportConfig.showSkipRows
                    ? 'bg-black/5 dark:bg-white/10 border-black/5 dark:border-white/5 opacity-60'
                    : 'bg-orange-500/10 text-orange-600 border-orange-500/20'">
                        <i class="fa-solid" :class="csvImportConfig.showSkipRows ? 'fa-eye' : 'fa-eye-slash'"></i>
                        <span>{{ csvImportConfig.showSkipRows ? 'æ˜¾ç¤ºå…¨éƒ¨' : 'éšè—é‡å¤ä»»åŠ¡ (SKIP)' }}</span>
                    </button>

                    <span v-if="!csvImportConfig.showSkipRows" class="text-[10px] opacity-40 font-bold uppercase italic">
            * ä»…æ˜¾ç¤º NEW æˆ– UPDATE ä»»åŠ¡
        </span>
                </div>

                <div class="flex gap-3">
                    <button @click="showCsvImportModal=false" class="px-5 py-2 rounded-xl font-bold bg-black/5 dark:bg-white/10 hover:bg-black/10 transition text-sm">
                        å–æ¶ˆ
                    </button>
                    <button @click="confirmCsvImport" class="px-6 py-2 rounded-xl font-bold bg-[#007aff] hover:bg-[#0062cc] text-white shadow-lg shadow-blue-500/30 transition text-sm flex items-center gap-2">
                        <i class="fa-solid fa-file-import"></i>
                        <span>
                ç¡®è®¤å¯¼å…¥ ({{ csvImportData.filter(r => r.selected && (activeImportTab === 'rec' ? r.hasRecData : r.hasEditData)).length }})
            </span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div v-if="showProjectInfoModal" class="modal-overlay z-[20000]" @click.self="showProjectInfoModal = false">

        <div class="modal-window w-full max-w-2xl bg-[#f0f2f5] dark:bg-[#1a1a1a] rounded-2xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh] animate-[scaleIn_0.2s_ease-out]">

            <div class="px-6 py-4 border-b border-black/5 dark:border-white/5 flex justify-between items-center bg-white dark:bg-[#252525]">
                <h3 class="text-lg font-bold flex items-center gap-2">
                    <i class="fa-solid fa-compact-disc text-blue-500"></i>
                    Project Metadata
                </h3>
                <button @click="showProjectInfoModal = false" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-black/5 dark:hover:bg-white/10 transition">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>

            <div class="flex-1 overflow-y-auto p-6 custom-scrollbar">
                <div class="space-y-6">

                    <div class="space-y-4">
                        <h4 class="text-xs font-bold uppercase opacity-50 tracking-wider">Basic Information</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Title (Track Name)</label>
                                <input v-model="projectInfoForm.title" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="e.g. Symphony No.5">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Composer</label>
                                <input v-model="projectInfoForm.composer" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Composer Name">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Arranger</label>
                                <input v-model="projectInfoForm.arranger" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Arranger Name">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Music Producer</label>
                                <input v-model="projectInfoForm.producer" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Producer Name">
                            </div>
                        </div>
                    </div>

                    <hr class="border-black/5 dark:border-white/5">

                    <div class="space-y-4">
                        <h4 class="text-xs font-bold uppercase opacity-50 tracking-wider">Audio Engineering</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Mixing Engineer</label>
                                <input v-model="projectInfoForm.mixingEngineer" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Name">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Mixing Studio</label>
                                <input v-model="projectInfoForm.mixingStudio" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Studio Name">
                            </div>

                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Mastering Engineer</label>
                                <input v-model="projectInfoForm.masteringEngineer" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Name">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Mastering Studio</label>
                                <input v-model="projectInfoForm.masteringStudio" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Studio Name">
                            </div>
                        </div>

                        <div class="space-y-1 pt-2">
                            <label class="text-[10px] uppercase font-bold opacity-50 flex items-center gap-1">
                                <span class="bg-black text-white dark:bg-white dark:text-black text-[9px] px-1 rounded">ATMOS</span>
                                Dolby Atmos Mastering Studio
                            </label>
                            <input v-model="projectInfoForm.dolbyStudio" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Dolby Studio Name">
                        </div>
                    </div>

                    <hr class="border-black/5 dark:border-white/5">

                    <div class="space-y-4">
                        <h4 class="text-xs font-bold uppercase opacity-50 tracking-wider">Copyright & Production</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Published By (Company)</label>
                                <input v-model="projectInfoForm.publishedBy" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Publisher / Label">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[10px] uppercase font-bold opacity-50">Produced By (Organization)</label>
                                <input v-model="projectInfoForm.producedBy" class="glass-input w-full h-10 px-3 rounded-xl" placeholder="Production Company / Client">
                            </div>
                        </div>
                    </div>

                </div>
            </div>

            <div class="p-4 border-t border-black/5 dark:border-white/5 bg-white/50 dark:bg-black/20 flex justify-end gap-3">
                <button @click="showProjectInfoModal = false" class="px-5 py-2.5 rounded-xl text-sm font-bold opacity-60 hover:bg-black/5 dark:hover:bg-white/10 transition">
                    Cancel
                </button>
                <button @click="saveProjectInfo" class="px-5 py-2.5 rounded-xl text-sm font-bold bg-[#007aff] text-white shadow-lg shadow-blue-500/30 hover:scale-105 active:scale-95 transition">
                    Save Metadata
                </button>
            </div>
        </div>
    </div>

</div>


<script>
    const {createApp, ref, computed, onMounted, onUnmounted, watch, reactive, nextTick} = Vue;
    const SUPABASE_URL = 'https://gdpsiinrxhpmxvgvgxeh.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdkcHNpaW5yeGhwbXh2Z3ZneGVoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5MDI2MDcsImV4cCI6MjA3OTQ3ODYwN30.7INv-SkxE97mylnsxICpd7YVG6SNFHyQTy8qVH1e3Mc';
    const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    const hexToRgb = hex => {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return [r, g, b];
    };
    const flashingTaskId = ref(null); // æ§åˆ¶å“ªä¸ªä»»åŠ¡æ­£åœ¨é—ªçƒ
    const statClickIndexMap = reactive({}); // è®°å½•æ¯ä¸ªæ¼”å¥å‘˜ç‚¹å‡»å¾ªç¯åˆ°äº†ç¬¬å‡ ä¸ªä»»åŠ¡
    const getTextColor = hex => {
        if (!hex) return '#1f2937';
        const [r, g, b] = hexToRgb(hex);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness > 150 ? '#1f2937' : '#f9fafb';
    };
    const generateRandomHexColor = () => {
        return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
    };
    const adjustColor = (hex, percent) => { // percent: 0.1 for 10% brighter, -0.1 for 10% darker
        if (!hex) return '#f3f4f6';
        const [r, g, b] = hexToRgb(hex);
        const factor = 1 + percent;
        const newR = Math.min(255, Math.max(0, Math.floor(r * factor)));
        const newG = Math.min(255, Math.max(0, Math.floor(g * factor)));
        const newB = Math.min(255, Math.max(0, Math.floor(b * factor)));
        return '#' + [newR, newG, newB].map(x => x.toString(16).padStart(2, '0')).join('');
    };
    const generateUniqueId = () => {
        // ç”Ÿæˆä¸€ä¸ªåŸºäºæ—¶é—´å’Œéšæœºæ•°çš„å”¯ä¸€å­—ç¬¦ä¸² (UUID é£æ ¼)
        return 't' + Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
    };
    window.triggerTouchHaptic = async (style = 'Light') => {
        // ä½¿ç”¨å…¨å±€å¯¹è±¡è·å–æ’ä»¶ï¼Œç¡®ä¿åœ¨ä»»ä½•åœ°æ–¹éƒ½èƒ½è°ƒç”¨
        const Haptics = window.Capacitor?.Plugins?.Haptics;
        if (Haptics) {
            try {
                // ä½¿ç”¨ Impact æ¨¡å¼è¿›è¡Œ UI çº§åé¦ˆ
                await Haptics.impact({style: style.toUpperCase()});
            } catch (e) {
                console.warn("Haptics APIè°ƒç”¨å¤±è´¥:", e.message);
            }
        }
    };


    createApp({
        setup() {
            const itemPool = ref([]);
            const scheduledTasks = ref([]);
            const slotHeight = ref(window.innerWidth < 800 ? 30 : 40);
            const pxPerMin = computed(() => slotHeight.value / 30);
            const currentView = ref('month');      // é»˜è®¤ç›´æ¥è¿›å…¥æœˆè§†å›¾
            const monthViewMode = ref('scrolled'); // é»˜è®¤ç›´æ¥ä½¿ç”¨æ»šåŠ¨æ¨¡å¼
            const viewDate = ref(new Date());
            const selectedTaskId = ref(null);
            const selectedSource = ref(null);
            const selectedPoolIds = ref(new Set()); // å­˜å‚¨ä»»åŠ¡æ± å¤šé€‰çš„ ID
            // V10.2 æ–°å¢ï¼šå·¦ä¾§æ å®½åº¦è°ƒèŠ‚çŠ¶æ€ (è¯·æ·»åŠ åˆ°å…¶ä»– ref å˜é‡é™„è¿‘)
            const savedSidebarWidth = localStorage.getItem('musche_sidebar_width');
            const sidebarWidth = ref(savedSidebarWidth ? Number(savedSidebarWidth) : 350);
            const lastPoolClickId = ref(null);      // è®°å½•ä¸Šä¸€æ¬¡ç‚¹å‡»çš„ ID (ç”¨äº Shift èŒƒå›´é€‰æ‹©)
            const lastPoolFocusId = ref(null);      // æ–°å¢ï¼šè®°å½•é”®ç›˜/é¼ æ ‡æœ€åäº¤äº’çš„ ID (ä½œä¸ºé”®ç›˜å¯¼èˆªçš„èµ·ç‚¹)
            const showSettings = ref(false);
            const showProjectInfoModal = ref(false);
            const showMetadataManager = ref(false);
            const showEditor = ref(false);
            const showTrackList = ref(false);
            const trackListData = ref({name: '', items: []});
            const editingItem = ref({});
            const editingSource = ref('');
            const weekContainer = ref(null);
            const flashingTaskId = ref(null); // æ§åˆ¶å“ªä¸ªä»»åŠ¡æ­£åœ¨é—ªçƒ
            const statClickIndexMap = reactive({}); // è®°å½•æ¯ä¸ªæ¼”å¥å‘˜ç‚¹å‡»å¾ªç¯åˆ°äº†ç¬¬å‡ ä¸ªä»»åŠ¡
            const showProfileMenu = ref(false);
            const tempAvatarUrl = ref(''); // ç”¨äºè¾“å…¥æ¡†ä¸´æ—¶å­˜å‚¨
            const initialTouchY = ref(0);         // è®°å½•èµ·å§‹ Y åæ ‡ï¼Œç”¨äºåˆ¤æ–­é•¿æŒ‰åæ˜¯å¦ç§»åŠ¨
            // --- ğŸŸ¢ æ–°å¢: æ°”æ³¡é€‰æ‹©å™¨é€»è¾‘ ---
            const showDurationPicker = ref(false);
            const tempDuration = reactive({m: 0, s: 0});
            const pickerMinRef = ref(null);
            const pickerSecRef = ref(null);
            const pickerPos = reactive({top: 0, left: 0}); // ğŸŸ¢ æ–°å¢ï¼šå­˜å‚¨å¼¹çª—åæ ‡
            const showMobileTaskInput = ref(false);
            const trackListContainerRef = ref(null);
            const draggingSectionIndex = ref(null);
            const savedWidth = localStorage.getItem('musche_day_width');
            const dayColWidth = ref(savedWidth ? Number(savedWidth) : 52);
            const isResizingMobile = ref(false);
            const mobileResizeState = reactive({task: null, startY: 0, startHeight: 0});
            const saveStatus = ref('saved'); // 'saved', 'saving', 'unsaved'
            // --- ğŸŸ¢ æ–°å¢: å…¨å±€æœç´¢çŠ¶æ€ ---
            const globalSearchQuery = ref('');
            const lastTapState = reactive({ id: null, time: 0 });
            const currentSearchIndex = ref(0);
            const resizing = ref(null);
            const isSearchFocused = ref(false);
            const localDataVersion = ref(0);
            const showSplitModal = ref(false);
            // --- ğŸŸ¢ æ–°å¢ï¼šCSV å¯¼å…¥æ¨¡å¼æ§åˆ¶ ---
            const csvImportMode = ref('tasks'); // 'tasks', 'time', 'orch'
            // --- ğŸŸ¢ Credit å¯¼å‡ºé€»è¾‘ ---
            const showCreditModal = ref(false);
            const generatedCreditText = ref('');
            const visibleTopDate = ref(new Date()); // ç”¨äºå­˜å‚¨æ»šåŠ¨æ¨¡å¼ä¸‹å½“å‰è§†å£é¡¶éƒ¨çš„æ—¥æœŸ
            const monthObserver = ref(null); // è§‚å¯Ÿå™¨å®ä¾‹
            const monthRefs = ref([]);
            const showMidiManager = ref(false);
            const managingProject = ref(null);
            // --- ğŸ¹ MIDI é«˜çº§å¯¼å…¥é€»è¾‘ ---
            const showMidiImportModal = ref(false);
            // --- ğŸŸ¢ [æ–°å¢] CSV å¯¼å…¥å¼¹çª—çŠ¶æ€ä¸é…ç½® ---
            // 1. å®šä¹‰çŠ¶æ€å˜é‡ (å·²é€‚é…ä½ æ–‡ä»¶çš„å˜é‡å‘½åä¹ æƒ¯)
            const showCsvImportModal = ref(false);
            const csvImportData = ref([]);
            const csvColumnMap = reactive({}); // ğŸŸ¢ æ–°å¢ï¼šç”¨äºå­˜å‚¨ CSV åˆ—ç´¢å¼•æ˜ å°„
            // ğŸŸ¢ ä¿®æ”¹åçš„é…ç½®å¯¹è±¡
            const csvImportConfig = reactive({
                importTypes: {
                    tasks: true,
                    time: true,
                    orch: true
                },
                nameStrategy: 'merge', // ğŸŸ¢ å¿…é¡»åŠ å›è¿™ä¸ªï¼Œé»˜è®¤ 'merge' (åˆå¹¶) æˆ– 'csv' (åŸå)
                showSkipRows: true // ğŸŸ¢ æ–°å¢ï¼šæ§åˆ¶æ˜¯å¦æ˜¾ç¤ºçŠ¶æ€ä¸º SKIP çš„è¡Œ
            });

            const midiImportData = ref([]); // æš‚å­˜è§£æåçš„è½¨é“æ•°æ®
            const midiBpm = ref(120); // æš‚å­˜ MIDI çš„åŸºç¡€é€Ÿåº¦
            const midiTempoMap = ref(null);
            const midiTimeSigs = ref(null);
            // ğŸŸ¢ [æ–°å¢] å­˜å‚¨åˆ†ç»„åçš„èšåˆæ•°æ®
            // ğŸŸ¢ [æ–°å¢] MIDI å¼¹çª—çš„æ˜¾ç¤ºæ¨¡å¼: 'tracks' (é»˜è®¤) æˆ– 'groups'
            const midiViewMode = ref('tracks');
            const midiTimeSig = ref([4, 4]); // æ‹å·
            const activeMidiGroupRow = ref(null);
            // [æ–°å¢] å­˜å‚¨ MIDI åˆ†ç»„ä¸‹æ‹‰èœå•çš„åæ ‡ä½ç½®
            const midiGroupPos = reactive({ top: 0, left: 0, width: 0 });
            // ğŸŸ¢ [æ–°å¢] MIDI å¯¼å…¥ç•Œé¢çš„ä¸‹æ‹‰èœå•çŠ¶æ€
            const activeImportMenu = reactive({ rowId: null, type: null }); // type: 'inst' | 'group'
            const importMenuPos = reactive({ top: 0, left: 0, width: 0 });
            const importSearchQuery = ref('');
            // ğŸŸ¢ [æ–°å¢] MIDI Manager åˆ†ç»„ä¸‹æ‹‰èœå•çš„æœç´¢çŠ¶æ€
            const midiGroupSearchQuery = ref('');
            const trackListSearchQuery = ref('');
            // ğŸŸ¢ [æ–°å¢] è®°å½•æœç´¢çŠ¶æ€ï¼Œç”¨äºå›è½¦å¾ªç¯è·³è½¬
            const trackSearchIndex = ref(-1);
            const lastTrackSearchQuery = ref('');
            const lastHighlightedTrackId = ref(null); // ğŸŸ¢ è®°å½•ä¸Šä¸€ä¸ªé«˜å…‰çš„å…ƒç´  ID
            const searchHighlightTimer = ref(null); // ğŸŸ¢ [æ–°å¢] ç”¨äºå­˜å‚¨å®šæ—¶å™¨ID
            // åœ¨ setup() å†…éƒ¨
            const rawCsvRows = ref([]);      // å­˜å‚¨ CSV é™¤å»è¡¨å¤´åçš„æ‰€æœ‰åŸå§‹è¡Œ
            const csvHeadersMap = ref({});   // å­˜å‚¨è¡¨å¤´åˆ—çš„ç´¢å¼• (ä¾‹å¦‚ {project: 0, instName: 2, ...})
            const collapsedProjects = reactive(new Set());
            const activeImportTab = ref('rec');
            const csvSearchQuery = ref('')


            let dividerDragState = null;
            let trackListScrollTimer = null;
            let pickerCallback = null;
            let dragElClone = null;       // æ‹–æ‹½æ—¶çš„å…‹éš†ä½“
            let dragSourceTask = null;    // æºä»»åŠ¡æ•°æ®
            let dragStartDate = null;     // æºæ—¥æœŸ
            let longPressTimeout = null;  // é•¿æŒ‰å®šæ—¶å™¨
            let isDraggingMouse = false;
            let startMouseY = 0;
            let startScrollTop = 0;
            let activeColRef = null; // å½“å‰æ‹–åŠ¨çš„æ»šè½® DOM å¼•ç”¨
            let startX = 0, startY = 0;   // è§¦æ‘¸èµ·å§‹ä½ç½®
            let cloneOffsetX = 0, cloneOffsetY = 0; // æ‰‹æŒ‡åœ¨å…ƒç´ å†…çš„åç§»
            let activeDropSlot = null;    // å½“å‰æ‰‹æŒ‡ä¸‹çš„æ”¾ç½®ç›®æ ‡
            let dragSourceEl = null; // ç”¨äºè®°å½•è¢«æ‹–æ‹½çš„åŸå§‹ DOM å…ƒç´ 
            let touchOffsetMinutes = 0;
            let dragClickOffsetY = 0;
            let dragSourceType = 'schedule';
            let autoScrollInterval = null;
            let monthSwitchTimer = null;
            let trackSaveTimer = null; // ç”¨äºå½•éŸ³æ—¶é—´ä¿å­˜çš„é˜²æŠ–è®¡æ—¶å™¨
            let isScrollingProgrammatically = false;
            let resizeRaf = null; // ç”¨äº requestAnimationFrame é˜²æŠ–
            // --- ğŸŸ¢ æ–°å¢å˜é‡: æ‹–æ‹½å®šæ—¶å™¨ (ç”¨äºæ‰‹æœºé•¿æŒ‰) ---
            // --- ğŸŸ¢ æ–°å¢å˜é‡: æ‹–æ‹½å®šæ—¶å™¨ (ç”¨äºæ‰‹æœºé•¿æŒ‰) ---
            let trackDragTimer = null;
            let trackDragState = null;
            // --- ğŸŸ¢ æ–°å¢ï¼šiOS è§†å›¾åˆ‡æ¢åŒå‡»æ£€æµ‹è¾…åŠ©å˜é‡ ---
            let lastHeaderTap = 0; // è®°å½•å‘¨è§†å›¾è¡¨å¤´ä¸Šæ¬¡ç‚¹å‡»æ—¶é—´
            let lastMonthTap = { time: 0, date: null };




            const toggleProjectCollapse = (pName) => {
                if (collapsedProjects.has(pName)) {
                    collapsedProjects.delete(pName);
                } else {
                    collapsedProjects.add(pName);
                }
            };

            // ä¿®æ”¹ groupedCsvData
            const groupedCsvData = computed(() => {
                // ğŸŸ¢ 1. è·å–å½“å‰æœç´¢è¯
                const query = csvSearchQuery.value.toLowerCase().trim();
                const showSkip = csvImportConfig.showSkipRows; // ğŸŸ¢ è·å–å½“å‰å¼€å…³çŠ¶æ€
                const mode = activeImportTab.value;

                // ğŸŸ¢ 2. é¢„å¤„ç†æ•°æ®ï¼šå¦‚æœæ­£åœ¨æœç´¢ï¼Œå…ˆè¿‡æ»¤ flat list
                let sourceData = csvImportData.value;

                if (query) {
                    sourceData = sourceData.filter(item => {
                        // å®šä¹‰æœç´¢èŒƒå›´ï¼šé¡¹ç›®åã€æ¼”å¥å‘˜ã€ä¹å™¨ã€æ–‡ä»¶å
                        const searchTargets = [
                            item.projectName,
                            item.playerName,
                            item.name_real, // ä¹å™¨å
                            item.name_merge // åˆå¹¶åçš„æ–‡ä»¶å
                        ];
                        // åªè¦æœ‰ä¸€ä¸ªå­—æ®µåŒ…å«æœç´¢è¯å³å¯
                        return searchTargets.some(val => val && String(val).toLowerCase().includes(query));
                    });
                }

                // === ä»¥ä¸‹æ˜¯åŸæœ‰çš„åˆ†ç»„é€»è¾‘ (ä½¿ç”¨ sourceData è€Œä¸æ˜¯ csvImportData.value) ===

                const groups = {};
                const projectOrder = [];

                sourceData.forEach(row => { // âš ï¸ æ³¨æ„è¿™é‡Œæ”¹æˆéå† sourceData
                    // ç¡®ä¿åªæ˜¾ç¤ºå½“å‰ Tab å¯¹åº”çš„æ•°æ® (Rec æˆ– Edit)
                    const isValid = activeImportTab.value === 'rec' ? row.hasRecData : row.hasEditData;
                    if (!isValid) return;

                    // ğŸŸ¢ æ ¸å¿ƒè¿‡æ»¤é€»è¾‘ï¼šå¦‚æœå…³é—­äº†â€œæ˜¾ç¤º SKIPâ€ï¼Œä¸”å½“å‰è¡ŒçŠ¶æ€ä¸º SKIPï¼Œåˆ™è·³è¿‡
                    const status = (mode === 'rec' ? row.recStatusText : row.editStatusText);
                    if (!showSkip && status === 'SKIP') return;

                    const pName = row.projectName || 'Unknown Project';
                    if (!groups[pName]) {
                        groups[pName] = {
                            projectName: pName,
                            rows: [],
                            expanded: !collapsedProjects.has(pName)
                        };
                        projectOrder.push(pName);
                    }
                    groups[pName].rows.push(row);
                });

                return projectOrder
                    .map(pName => groups[pName])
                    .filter(group => group.rows.length > 0);
            });

            // ğŸŸ¢ æ–°å¢ä¾¦å¬å™¨ï¼šæœç´¢è¯å˜åŒ–æ—¶ï¼Œè‡ªåŠ¨åŒæ­¥é€‰æ‹©çŠ¶æ€
            watch(() => [csvSearchQuery.value, activeImportTab.value], ([newQuery, newTab]) => {
                // 1. å¦‚æœæœç´¢æ¡†è¢«æ¸…ç©ºï¼Œæˆ‘ä»¬ä¸åšä»»ä½•æ“ä½œï¼Œä¿ç•™æœ€åä¸€æ¬¡çš„é€‰æ‹©çŠ¶æ€
                // (è¿™æ ·ä½ å¯ä»¥å…ˆæœAï¼Œæ¸…ç©ºï¼Œå†æ‰‹åŠ¨å¾®è°ƒ)
                if (!newQuery || !newQuery.trim()) return;

                const query = newQuery.toLowerCase().trim();

                // 2. éå†æ‰€æœ‰æ•°æ®ï¼Œæ›´æ–°é€‰æ‹©çŠ¶æ€
                csvImportData.value.forEach(row => {
                    // æ­¥éª¤A: åˆ¤æ–­è¯¥è¡Œæ˜¯å¦å±äºå½“å‰æ ‡ç­¾é¡µ (Rec æˆ– Edit)
                    // æˆ‘ä»¬åªä¿®æ”¹å½“å‰èƒ½çœ‹åˆ°çš„ä»»åŠ¡ï¼Œä¸è¦è¯¯ä¼¤å¦ä¸€ä¸ªæ ‡ç­¾é¡µé‡Œå·²é€‰çš„ä»»åŠ¡
                    const isVisibleInTab = newTab === 'rec' ? row.hasRecData : row.hasEditData;

                    if (isVisibleInTab) {
                        // æ­¥éª¤B: åˆ¤æ–­æ˜¯å¦åŒ¹é…æœç´¢è¯
                        const searchTargets = [
                            row.projectName,
                            row.playerName,
                            row.name_real, // ä¹å™¨
                            row.name_merge // æ–‡ä»¶å
                        ];
                        const isMatch = searchTargets.some(val => val && String(val).toLowerCase().includes(query));

                        // æ­¥éª¤C: å¼ºåˆ¶åŒæ­¥çŠ¶æ€
                        // åŒ¹é… = é€‰ä¸­ (true)
                        // ä¸åŒ¹é… = å–æ¶ˆé€‰ä¸­ (false) -> è¿™å°±å®ç°äº†â€œåªå‰©ä¸‹è¿‡æ»¤å‡ºæ¥çš„ä»»åŠ¡â€
                        row.selected = isMatch;
                    }
                });
            });


            // åˆå§‹åŒ–è¡¨å•æ•°æ®
            const projectInfoForm = reactive({
                id: null, // ç”¨äºå®šä½å½“å‰ç¼–è¾‘çš„é¡¹ç›®
                title: '',
                composer: '',
                arranger: '',
                producer: '',
                mixingEngineer: '',
                mixingStudio: '',
                masteringEngineer: '',
                masteringStudio: '',
                dolbyStudio: '',
                publishedBy: '',
                producedBy: ''
            });

            // æ‰“å¼€é¡¹ç›®ä¿¡æ¯å¼¹çª—
            const openProjectInfoModal = (project) => {
                projectInfoForm.id = project.id;
                // å¦‚æœå·²æœ‰æ•°æ®åˆ™å›å¡«ï¼Œå¦åˆ™ä¸ºç©ºï¼›Titleé»˜è®¤å›å¡«é¡¹ç›®åç§°
                projectInfoForm.title = project.title || project.name || '';
                projectInfoForm.composer = project.composer || '';
                projectInfoForm.arranger = project.arranger || '';
                projectInfoForm.producer = project.producer || '';
                projectInfoForm.mixingEngineer = project.mixingEngineer || '';
                projectInfoForm.mixingStudio = project.mixingStudio || '';
                projectInfoForm.masteringEngineer = project.masteringEngineer || '';
                projectInfoForm.masteringStudio = project.masteringStudio || '';
                projectInfoForm.dolbyStudio = project.dolbyStudio || '';
                projectInfoForm.publishedBy = project.publishedBy || '';
                projectInfoForm.producedBy = project.producedBy || '';

                showProjectInfoModal.value = true;
            };

// ä¿å­˜é¡¹ç›®ä¿¡æ¯
            const saveProjectInfo = () => {
                const target = settings.projects.find(p => p.id === projectInfoForm.id);
                if (target) {
                    // å°†è¡¨å•æ•°æ®åˆå¹¶å›é¡¹ç›®å¯¹è±¡
                    Object.assign(target, { ...projectInfoForm });
                    // å¦‚æœæƒ³è®©é¡¹ç›®åˆ—è¡¨æ˜¾ç¤ºçš„åç§°ä¹ŸåŒæ­¥æ›´æ–°ï¼Œå¯ä»¥è§£å¼€ä¸‹é¢è¿™è¡Œï¼š
                    // target.name = projectInfoForm.title;

                    window.triggerTouchHaptic('Success');
                    showProjectInfoModal.value = false;
                }
            };

            // 1. [æ–°å¢] æå–é€šç”¨çš„çŠ¶æ€è®¡ç®—é€»è¾‘
            const calculateRowStatusText = (row) => {
                const config = csvImportConfig.importTypes;

                // æƒ…å†µ A: è¯¥è¡Œæœªå‹¾é€‰ï¼Œæˆ–è€…å…¨å±€å¯¼å…¥å¼€å…³å…¨å…³ -> SKIP
                if (!row.selected || (!config.tasks && !config.time && !config.orch)) {
                    return 'SKIP';
                }

                // æƒ…å†µ B: ä»»åŠ¡å·²å­˜åœ¨ (é‡å¤)
                if (row.isDuplicate) {
                    // åªæœ‰å¼€å¯äº†æ—¶é—´æˆ–ç¼–åˆ¶æ›´æ–°ï¼Œæ‰æ˜¾ç¤º UPDATE
                    if (config.time || config.orch) {
                        return 'UPDATE';
                    } else {
                        // å¦‚æœåªé€‰äº†ä»»åŠ¡å¯¼å…¥ä½†ä»»åŠ¡å·²å­˜åœ¨ï¼Œå®é™…ä¸Šæ²¡å•¥å¯å¹²çš„ï¼Œæ˜¾ç¤º SKIP
                        return 'SKIP';
                    }
                }

                // æƒ…å†µ C: æ–°ä»»åŠ¡
                return 'NEW';
            };

            const refreshCsvStatus = () => {
                const { tasks: isTaskMode, time: isTimeMode, orch: isOrchMode } = csvImportConfig.importTypes;

                csvImportData.value = csvImportData.value.map(row => {
                    const getStatus = () => {
                        // å¦‚æœè¯¥è¡Œåœ¨å½“å‰ Tab ä¸‹æ— æ•°æ®ï¼Œç›´æ¥ SKIP
                        const hasData = activeImportTab.value === 'rec' ? row.hasRecData : row.hasEditData;
                        if (!hasData) return 'SKIP';

                        if (row.isDuplicate) {
                            // --- é‡å¤ä»»åŠ¡é€»è¾‘ ---
                            let shouldUpdate = false;

                            // å‹¾é€‰äº†æ—¶é—´å¯¼å…¥ ä¸” æ—¶é—´/ä¿¡æ¯ç±»æœ‰å·®å¼‚
                            if (isTimeMode && row.hasTimeDiff) shouldUpdate = true;
                            // å‹¾é€‰äº†ç¼–åˆ¶å¯¼å…¥ ä¸” ç¼–åˆ¶æœ‰å·®å¼‚
                            if (isOrchMode && row.hasOrchDiff) shouldUpdate = true;

                            return shouldUpdate ? 'UPDATE' : 'SKIP';
                        } else {
                            // --- æ–°ä»»åŠ¡é€»è¾‘ ---
                            return isTaskMode ? 'NEW' : 'SKIP';
                        }
                    };

                    const finalStatus = getStatus();

                    // æ ¹æ®çŠ¶æ€è®¾ç½®æ˜¾ç¤ºæ–‡å­—
                    if (activeImportTab.value === 'rec') row.recStatusText = finalStatus;
                    else row.editStatusText = finalStatus;

                    // ğŸŸ¢ è‡ªåŠ¨å‹¾é€‰é€»è¾‘ï¼šå¦‚æœæ˜¯ SKIP çŠ¶æ€ï¼Œå–æ¶ˆå‹¾é€‰ä»»åŠ¡
                    row.selected = (finalStatus !== 'SKIP');

                    return row;
                });

                refreshCsvPreview();
            };

            // ä¿®æ”¹ toggleCsvSelection å‡½æ•°
            const toggleCsvSelection = (index, field) => {
                const row = csvImportData.value[index];
                if (!row) return;

                // 1. åˆ‡æ¢é€‰æ‹©çŠ¶æ€ (å¦‚æœæ˜¯é€šè¿‡ toggle è°ƒç”¨)
                // æ³¨æ„ï¼šå¦‚æœæ˜¯ç›´æ¥ç‚¹å‡» checkbox (v-model="row.selected")ï¼Œè¿™è¡Œå¯èƒ½ä¸éœ€è¦ï¼Œ
                // ä½†ä¸ºäº†ç¡®ä¿é€»è¾‘å®Œæ•´ï¼Œå»ºè®®ä½¿ç”¨ calculateRowStatusText é‡æ–°è®¡ç®—
                if (field) {
                    row.selection[field] = !row.selection[field];
                }

                // ğŸŸ¢ 2. ä½¿ç”¨ç»Ÿä¸€çš„ calculateRowStatusText å‡½æ•°é‡æ–°è®¡ç®—çŠ¶æ€
                // (ç¡®ä¿ä½ åœ¨ setup ä¸­å·²ç»å®šä¹‰äº† calculateRowStatusTextï¼Œæˆ–è€…æŠŠé€»è¾‘å¤åˆ¶è¿‡æ¥)
                let newStatus = 'NEW';
                const config = csvImportConfig.importTypes;

                // é€»è¾‘å¤åˆ» calculateRowStatusText:
                if (!row.selected || (!config.tasks && !config.time && !config.orch)) {
                    newStatus = 'SKIP';
                } else if (row.isDuplicate) {
                    if (config.time || config.orch) {
                        newStatus = 'UPDATE';
                    } else {
                        newStatus = 'SKIP';
                    }
                }

                // ğŸŸ¢ 3. å…³é”®ä¿®å¤ï¼šåŒæ—¶æ›´æ–° recStatusText å’Œ editStatusText
                // è¿™æ ·æ— è®º activeImportTab æ˜¯ä»€ä¹ˆï¼Œæ¨¡æ¿éƒ½èƒ½è¯»åˆ°æœ€æ–°å€¼
                row.recStatusText = newStatus;
                row.editStatusText = newStatus;
                row.statusText = newStatus; // ä¿æŒå…¼å®¹

                // 4. å¼ºåˆ¶è§¦å‘å“åº”å¼æ›´æ–°
                csvImportData.value[index] = { ...row };
            };


            const midiManagerExpandedGroups = reactive(new Set())

            // ç›‘å¬å¼¹çª—å…³é—­ï¼Œæ¸…ç©ºæœç´¢è¯
            watch(showTrackList, (val) => {
                if(!val) trackListSearchQuery.value = '';
            });

            const handleTrackListSearchAction = (isEnter = false) => {
                const query = trackListSearchQuery.value.trim().toLowerCase();

                // 1. æ¸…ç†ï¼šæ— è®ºæœæ²¡æœåˆ°ï¼Œå…ˆæ¸…é™¤ä¸Šä¸€æ¬¡çš„å®šæ—¶å™¨å’Œé«˜å…‰
                if (searchHighlightTimer.value) {
                    clearTimeout(searchHighlightTimer.value);
                    searchHighlightTimer.value = null;
                }

                // ç§»é™¤ä¸Šä¸€ä¸ªå…ƒç´ çš„é«˜å…‰æ ·å¼
                if (lastHighlightedTrackId.value) {
                    const prevEl = document.getElementById('track-item-' + lastHighlightedTrackId.value);
                    if (prevEl) {
                        prevEl.classList.remove('ring-2', 'ring-[#007aff]', 'bg-blue-50', 'dark:bg-white/20', 'z-50');
                    }
                    lastHighlightedTrackId.value = null;
                }

                // å¦‚æœæœç´¢æ¡†ä¸ºç©ºï¼Œç›´æ¥è¿”å›
                if (!query) {
                    trackSearchIndex.value = -1;
                    lastTrackSearchQuery.value = '';
                    return;
                }

                // 2. æŸ¥æ‰¾åŒ¹é…é¡¹
                const items = trackListData.value.items;
                const matchedIndices = [];

                items.forEach((item, index) => {
                    const text = [
                        item.name,
                        getNameById(item.musicianId, 'musician'),
                        getNameById(item.instrumentId, 'instrument'),
                        getNameById(item.projectId, 'project'),
                        item.splitTag || '',
                        item.orchestration || ''
                    ].join(' ').toLowerCase();

                    if (text.includes(query)) matchedIndices.push(index);
                });

                if (matchedIndices.length === 0) return;

                // 3. è®¡ç®—ç´¢å¼•
                if (isEnter && query === lastTrackSearchQuery.value) {
                    trackSearchIndex.value = (trackSearchIndex.value + 1) % matchedIndices.length;
                } else {
                    trackSearchIndex.value = 0;
                }
                lastTrackSearchQuery.value = query;

                // 4. é«˜äº®æ–°ç›®æ ‡
                const targetItemIndex = matchedIndices[trackSearchIndex.value];
                const targetItem = items[targetItemIndex];

                if (targetItem) {
                    const el = document.getElementById('track-item-' + targetItem.id);
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        // æ·»åŠ é«˜å…‰
                        el.classList.add('ring-2', 'ring-[#007aff]', 'bg-blue-50', 'dark:bg-white/20', 'z-50');
                        lastHighlightedTrackId.value = targetItem.id;

                        // ğŸŸ¢ è®¾ç½®æ–°çš„å®šæ—¶å™¨ (å…³é”®ä¿®æ­£ï¼šä½¿ç”¨å˜é‡å­˜å‚¨timerï¼Œæ–¹ä¾¿ä¸‹æ¬¡æ¸…é™¤)
                        searchHighlightTimer.value = setTimeout(() => {
                            el.classList.remove('ring-2', 'ring-[#007aff]', 'bg-blue-50', 'dark:bg-white/20', 'z-50');
                            // åªæœ‰å½“å½“å‰è®°å½•çš„IDè¿˜æ˜¯è‡ªå·±æ—¶ï¼Œæ‰ç½®ç©ºID (é˜²æ­¢å¿«é€Ÿåˆ‡æ¢æ—¶çš„ç«æ€)
                            if (lastHighlightedTrackId.value === targetItem.id) {
                                lastHighlightedTrackId.value = null;
                            }
                        }, 2000); // 2ç§’æŒç»­æ—¶é—´

                        if (isMobile.value) window.triggerTouchHaptic('Light');
                    }
                }
            };

            const toggleMidiManagerGroup = (name) => {
                if (midiManagerExpandedGroups.has(name)) {
                    midiManagerExpandedGroups.delete(name);
                } else {
                    midiManagerExpandedGroups.add(name);
                }
            };

            // å°†æ‰å¹³åˆ—è¡¨è½¬æ¢ä¸ºåˆ†ç»„ç»“æ„
            const projectMidiGroups = computed(() => {
                const flatList = projectMidiList.value; // å¤ç”¨å·²æœ‰çš„æ’åºåˆ—è¡¨
                if (flatList.length === 0) return [];

                const groups = {};
                const defaultKey = 'Unassigned';

                flatList.forEach(item => {
                    // å¦‚æœ item.group ä¸ºç©ºï¼Œå½’å…¥ Unassigned
                    const g = (item.group && item.group.trim()) ? item.group : defaultKey;
                    if (!groups[g]) groups[g] = [];
                    groups[g].push(item);
                });

                // æ’åºåˆ†ç»„é”®å (Unassigned æ”¾æœ€å)
                const sortedKeys = Object.keys(groups).sort((a, b) => {
                    if (a === defaultKey) return 1;
                    if (b === defaultKey) return -1;
                    return a.localeCompare(b, 'zh-CN');
                });

                return sortedKeys.map(key => ({
                    name: key,
                    items: groups[key] // items å·²ç»åœ¨ projectMidiList ä¸­æ’å¥½åºäº†
                }));
            });

            // ğŸŸ¢ [è¾…åŠ©] é»˜è®¤å±•å¼€æ‰€æœ‰æœ‰æ•°æ®çš„åˆ†ç»„ (å¯é€‰ï¼Œè¿™é‡Œè®¾ä¸ºé»˜è®¤å…¨å±•å¼€ä½“éªŒæ›´å¥½)
            watch(showMidiManager, (val) => {
                if (val) {
                    // æ¯æ¬¡æ‰“å¼€å¼¹çª—æ—¶ï¼Œé‡ç½®å¹¶å±•å¼€æ‰€æœ‰ç»„
                    midiManagerExpandedGroups.clear();
                    // projectMidiGroups.value.forEach(g => midiManagerExpandedGroups.add(g.name));
                }
            });

            // 1. æ‰©å±•ä¹å™¨åº“ (å¢åŠ å¸¸è§ç¼©å†™å’Œå˜ä½“)
            const instrumentLibrary = {
                "Brass": [
                    "Horn", "French Horn", "Hn", "Trumpet", "Tpt", "Cornet", "Trombone", "Tbn",
                    "Bass Trombone", "B.Tbn", "Tuba", "Tba", "Euphonium", "Brass"
                ],
                "Woodwinds": [
                    "Flute", "Fl", "Piccolo", "Picc", "Oboe", "Ob", "English Horn", "Cor Anglais", "E.H",
                    "Clarinet", "Cl", "Bass Clarinet", "B.Cl", "Bassoon", "Bsn", "Contrabassoon", "C.Bsn",
                    "Saxophone", "Sax", "Recorder", "Woodwinds"
                ],
                "Strings": [
                    "Violin", "Vln", "Viola", "Vla", "Cello", "Violoncello", "Vc",
                    "Double Bass", "Contrabass", "Db", "Cb", "Bass", // æ³¨æ„ï¼šBass åœ¨è¿™é‡Œï¼Œä½†æˆ‘ä»¬ä¼šç”¨æ­£åˆ™é˜²æ­¢ Bassoon è¯¯åˆ¤
                    "Strings", "Str"
                ],
                "Percussion": [
                    "Timpani", "Timp", "Snare", "SD", "Bass Drum", "BD", "Cymbals", "Cym", "Piatti",
                    "Triangle", "Tri", "Tambourine", "Tamb", "Glockenspiel", "Glock", "Xylophone", "Xyl",
                    "Vibraphone", "Vib", "Marimba", "Mar", "Tubular Bells", "Chimes", "Drum", "Percussion", "Perc"
                ],
                "Keys": [
                    "Piano", "Pno", "Celesta", "Cel", "Harpsichord", "Organ", "Accordion"
                ],
                "Plucks": [
                    "Harp", "Hp", "Guitar", "Gtr", "Mandolin", "Lute"
                ],
                "Vocal": [
                    "Soprano", "Alto", "Tenor", "Baritone", "Bass Voice", "Choir", "Voice", "Vocal"
                ]
            };

            // 2. ç”Ÿæˆæ’åºåçš„æœç´¢åˆ—è¡¨ (æŒ‰é•¿åº¦é™åºï¼Œç¡®ä¿ "Bass Trombone" å…ˆäº "Trombone" è¢«åŒ¹é…)
            const sortedLibrary = (() => {
                const list = [];
                for (const [group, names] of Object.entries(instrumentLibrary)) {
                    names.forEach(name => {
                        list.push({ name, group });
                    });
                }
                // æŒ‰å­—ç¬¦ä¸²é•¿åº¦é™åºæ’åº (Longest First)
                return list.sort((a, b) => b.name.length - a.name.length);
            })();

// è¾…åŠ©ï¼šæ ‡å‡†åŒ–å­—ç¬¦ä¸² (ç”¨äºæ¨¡ç³Šæ¯”å¯¹)
// è§£å†³äº† "B Flat" vs "Bb" vs "â™­" çš„é—®é¢˜
            const normalizeForMatch = (str) => {
                if (!str) return "";
                return str.toLowerCase()
                    .replace(/â™­/g, 'b')           // ğŸŸ¢ [æ–°å¢] å°† Unicode é™å·ç¬¦å·è½¬ä¸º b
                    .replace(/\bflat\b/g, 'b')    // ğŸŸ¢ [åŠ å¼º] ç¡®ä¿å•è¯ Flat è½¬ä¸º b (è™½ç„¶ä¸‹é¢ä¹Ÿæœ‰ï¼Œä½†æ”¾å‰é¢æ›´ä¿é™©)
                    .replace(/\./g, ' ')
                    .replace(/_/g, ' ')
                    .replace(/-/g, ' ')
                    .replace(/\d+/g, '')
                    .replace(/[()\[\]]/g, '')
                    .replace(/\bflat\b/g, 'b')    // (åŸæœ‰é€»è¾‘ï¼Œä¿ç•™å³å¯)
                    .replace(/\bsharp\b/g, '#')
                    .replace(/â™¯/g, '#')           // ğŸŸ¢ [å»ºè®®] é¡ºä¾¿æŠŠ Unicode å‡å·ä¹ŸåŠ ä¸Š
                    .replace(/\bin\b/g, '')
                    .trim();
            };

// æ ¸å¿ƒï¼šæŸ¥æ‰¾åˆ†ç»„
            const findGroupSmart = (trackName) => {
                // A. é¢„å¤„ç†è½¨é“å
                const cleanName = normalizeForMatch(trackName);

                // B. éå†åº“
                for (const item of sortedLibrary) {
                    const libName = normalizeForMatch(item.name);

                    // ğŸ”´ æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨æ­£åˆ™å•è¯è¾¹ç•Œ (\b)
                    // è¿™æ„å‘³ç€ "Bass" åªèƒ½åŒ¹é… "Bass" æˆ– "Double Bass"ï¼Œ
                    // è€Œä¸ä¼šåŒ¹é… "Bassoon" (å› ä¸º Bassoon é‡Œçš„ bass åé¢æ²¡æœ‰è¾¹ç•Œ)

                    // è½¬ä¹‰æ­£åˆ™ç‰¹æ®Šå­—ç¬¦ (å¦‚ +)
                    const escapedLibName = libName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

                    // æ„é€ æ­£åˆ™ï¼šå…¨å­—åŒ¹é… æˆ– å•è¯è¾¹ç•ŒåŒ¹é…
                    // ä¾‹å­ï¼š/bass/ ä¼šåŒ¹é… bassoonï¼Œä½† /\bbass\b/ ä¸ä¼šåŒ¹é… bassoon
                    const regex = new RegExp(`\\b${escapedLibName}\\b`, 'i');

                    if (regex.test(cleanName)) {
                        return item.group;
                    }

                    // å…œåº•é€»è¾‘ï¼šå¯¹äºå¾ˆçŸ­çš„ç¼©å†™ (å¦‚ "Fl", "Ob")ï¼Œå¦‚æœæ­£åˆ™å¤±è´¥ï¼Œå°è¯•ç›´æ¥åŒ…å«
                    // å‰ææ˜¯ç¼©å†™é•¿åº¦å°äº3ï¼Œä¸”ä¸æ˜¯å¸¸è§çš„å•è¯å‰ç¼€
                    if (libName.length < 3 && cleanName === libName) {
                        return item.group;
                    }
                }

                // 5. å…œåº•çŒœæµ‹ (å¦‚æœåº“é‡Œæ²¡æ‰¾åˆ°)
                if (cleanName.includes('string') || cleanName.includes('vln') || cleanName.includes('vla') || cleanName.includes('cello')) return 'Strings';
                if (cleanName.includes('brass') || cleanName.includes('horn') || cleanName.includes('tpt')) return 'Brass';
                if (cleanName.includes('wood') || cleanName.includes('flute') || cleanName.includes('oboe')) return 'Woodwinds';
                if (cleanName.includes('perc') || cleanName.includes('drum')) return 'Percussion';

                return "";
            };

            // æ‰“å¼€å¯¼å…¥ç•Œé¢çš„ä¸‹æ‹‰èœå•
            const openImportMenu = (e, rowId, type) => {
                // å¦‚æœç‚¹å‡»åŒä¸€ä¸ªï¼Œåˆ™å…³é—­
                if (activeImportMenu.rowId === rowId && activeImportMenu.type === type) {
                    activeImportMenu.rowId = null;
                    activeImportMenu.type = null;
                    return;
                }

                // è®¡ç®—ä½ç½®
                const rect = e.currentTarget.getBoundingClientRect();
                importMenuPos.top = rect.bottom + 5;
                importMenuPos.left = rect.left;
                importMenuPos.width = rect.width;

                activeImportMenu.rowId = rowId;
                activeImportMenu.type = type;
                importSearchQuery.value = ''; // é‡ç½®æœç´¢

                // è‡ªåŠ¨èšç„¦æœç´¢æ¡†
                nextTick(() => {
                    const input = document.getElementById('midi-import-search');
                    if (input) input.focus();
                });
            };

            // å…³é—­å¯¼å…¥èœå•
            const closeImportMenu = () => {
                activeImportMenu.rowId = null;
                activeImportMenu.type = null;
            };

            // åœ¨å¯¼å…¥ç•Œé¢é€‰æ‹©ä¹å™¨
            const selectImportInst = (track, inst) => {
                track.instrumentId = inst.id;

                // ğŸŸ¢ FIX: åªæœ‰åœ¨éåˆ†ç»„è§†å›¾ä¸‹æ‰è‡ªåŠ¨æ›´æ–°åˆ†ç»„
                // è¿™æ ·åœ¨ 'Group View' ä¸‹ä¿®æ”¹ä¹å™¨æ—¶ï¼Œæ¡ç›®ä¸ä¼šå› ä¸ºåˆ†ç»„å˜åŒ–è€Œç¬é—´è·³èµ°
                if (inst.group && midiViewMode.value !== 'groups') {
                    track.group = inst.group;
                }

                track.createNew = false;
                closeImportMenu();
            };

            // åœ¨å¯¼å…¥ç•Œé¢é€‰æ‹©æ–°å»ºä¹å™¨
            const selectImportNewInst = (track) => {
                track.instrumentId = ""; // ç©º ID ä»£è¡¨æ–°å»º
                track.createNew = true;
                closeImportMenu();
                // è‡ªåŠ¨èšç„¦åå­—è¾“å…¥æ¡† (å¯é€‰ä¼˜åŒ–)
            };

            // åœ¨å¯¼å…¥ç•Œé¢é€‰æ‹©åˆ†ç»„
            const selectImportGroup = (track, groupName) => {
                track.group = groupName;
                closeImportMenu();
            };

            // è·å–å¯¼å…¥èœå•çš„è¿‡æ»¤åˆ—è¡¨
            const filteredImportOptions = computed(() => {
                const search = importSearchQuery.value.toLowerCase();

                if (activeImportMenu.type === 'inst') {
                    // ä¹å™¨åˆ—è¡¨
                    return sortedInstruments.value.filter(i =>
                        i.name.toLowerCase().includes(search) ||
                        (i.group && i.group.toLowerCase().includes(search))
                    );
                } else if (activeImportMenu.type === 'group') {
                    // åˆ†ç»„åˆ—è¡¨
                    return availableInstrumentGroups.value.filter(g =>
                        g.toLowerCase().includes(search)
                    );
                }
                return [];
            });

            // ğŸŸ¢ [ä¿®æ”¹] æ‰“å¼€åˆ†ç»„ä¸‹æ‹‰èœå• (é‡ç½®æœç´¢è¯)
            const openMidiGroupDropdown = (e, instId) => {
                if (activeMidiGroupRow.value === instId) {
                    activeMidiGroupRow.value = null;
                    return;
                }
                const rect = e.currentTarget.getBoundingClientRect();
                midiGroupPos.top = rect.bottom + 5;
                midiGroupPos.left = rect.left;
                midiGroupPos.width = rect.width;

                activeMidiGroupRow.value = instId;
                midiGroupSearchQuery.value = ''; // é‡ç½®æœç´¢

                // è‡ªåŠ¨èšç„¦è¾“å…¥æ¡†
                nextTick(() => {
                    const input = document.getElementById('midi-group-search-input');
                    if (input) input.focus();
                });
            };

            const selectMidiGroup = (instId, groupName) => {
                updateInstrumentGroup(instId, groupName); // è°ƒç”¨ä¹‹å‰çš„æ›´æ–°å‡½æ•°
                activeMidiGroupRow.value = null; // å…³é—­èœå•
            };

            // ğŸŸ¢ [æ–°ç®—æ³•] åˆ¤æ–­ä¸¤ä¸ªåŒºé—´æ˜¯å¦é‡å  (è¾…åŠ©å‡½æ•°)
            // ç”¨äºåˆ¤æ–­éŸ³ç¬¦æ˜¯å¦å‡ºç°åœ¨æŸä¸ªå°èŠ‚å†…
            const isOverlapping = (startA, endA, startB, endB) => {
                return Math.max(startA, startB) < Math.min(endA, endB);
            };

            // ğŸŸ¢ [æ–°ç®—æ³•] è®¡ç®—æœ‰æ•ˆæ—¶é•¿ (åªè®¡ç®—æœ‰éŸ³ç¬¦çš„å°èŠ‚)
            const calculateEffectiveDuration = (midi, track) => {
                // 1. æ‰¾åˆ°è¯¥è½¨é“æœ€åä¸€ä¸ªéŸ³ç¬¦çš„ç»“æŸæ—¶é—´ (Ticks)
                // å¦‚æœæ²¡æœ‰éŸ³ç¬¦ï¼Œç›´æ¥è¿”å› 0
                if (track.notes.length === 0) return { bars: 0, seconds: 0, rawSeconds: 0 };

                let lastNoteOffTick = 0;
                track.notes.forEach(n => {
                    const end = n.ticks + n.durationTicks;
                    if (end > lastNoteOffTick) lastNoteOffTick = end;
                });

                // 2. å‡†å¤‡æ‹å·è¡¨ (Time Signatures)
                let timeSignatures = midi.header.timeSignatures || [];
                if (timeSignatures.length === 0) {
                    timeSignatures = [{ ticks: 0, timeSignature: [4, 4] }];
                }
                timeSignatures.sort((a, b) => a.ticks - b.ticks);

                // 3. å‡†å¤‡åŸºç¡€å‚æ•°
                const ppq = midi.header.ppq || 480;
                let currentTick = 0;
                let sigIndex = 0;

                let validBarsCount = 0; // æœ‰æ•ˆå°èŠ‚æ•°
                let validSeconds = 0;   // æœ‰æ•ˆæ—¶é•¿ (ç§’)

                // 4. [æ ¸å¿ƒå¾ªç¯] é€ä¸ªéå†å°èŠ‚ï¼Œç›´åˆ°è¦†ç›–æœ€åä¸€ä¸ªéŸ³ç¬¦
                while (currentTick < lastNoteOffTick) {
                    // A. è·å–å½“å‰æ—¶åˆ»çš„æ‹å·
                    while (sigIndex + 1 < timeSignatures.length && timeSignatures[sigIndex + 1].ticks <= currentTick) {
                        sigIndex++;
                    }
                    const currentSig = timeSignatures[sigIndex];
                    const [num, den] = currentSig.timeSignature;

                    // B. è®¡ç®—å½“å‰å°èŠ‚çš„é•¿åº¦ (Ticks)
                    // å…¬å¼: (PPQ * 4 / åˆ†æ¯) * åˆ†å­
                    const ticksPerBar = (ppq * 4 / den) * num;
                    const barStartTick = currentTick;
                    const barEndTick = currentTick + ticksPerBar;

                    // C. [å…³é”®æ­¥éª¤] æ£€æŸ¥è¯¥å°èŠ‚å†…æ˜¯å¦æœ‰éŸ³ç¬¦
                    // åªè¦éŸ³ç¬¦çš„æ—¶é—´èŒƒå›´ä¸å½“å‰å°èŠ‚çš„æ—¶é—´èŒƒå›´æœ‰â€œäº¤é›†â€ï¼Œå°±ç®—æœ‰æ•ˆ
                    const hasNote = track.notes.some(n => {
                        const noteStart = n.ticks;
                        const noteEnd = n.ticks + n.durationTicks;
                        return isOverlapping(noteStart, noteEnd, barStartTick, barEndTick);
                    });

                    // D. å¦‚æœæœ‰éŸ³ç¬¦ï¼Œç´¯åŠ æ—¶é•¿
                    if (hasNote) {
                        validBarsCount++;
                        // è®¡ç®—è¯¥å°èŠ‚çš„ç§’æ•°
                        // åˆ©ç”¨ Tone.js çš„ ticksToSeconds è®¡ç®—ç»å¯¹æ—¶é—´å·®ï¼Œè¿™æ ·èƒ½è‡ªåŠ¨å¤„ç†è¯¥å°èŠ‚å†…éƒ¨çš„å˜é€Ÿ(Tempo Change)
                        const startSec = midi.header.ticksToSeconds(barStartTick);
                        const endSec = midi.header.ticksToSeconds(barEndTick);
                        validSeconds += (endSec - startSec);
                    }

                    // E. æ¨è¿›åˆ°ä¸‹ä¸€å°èŠ‚
                    currentTick += ticksPerBar;
                }

                // åŸå§‹ç»å¯¹æ—¶é•¿ (ç”¨äºå¯¹æ¯”)
                const totalRawSeconds = midi.header.ticksToSeconds(lastNoteOffTick);

                // ğŸ›¡ï¸ å…œåº•ï¼šå¦‚æœç®—å‡ºæ¥æ˜¯ 0 ä½†æœ‰éŸ³ç¬¦ (æç½•è§æƒ…å†µ)ï¼Œè‡³å°‘ç»™ 1 ç§’
                if (validSeconds === 0 && track.notes.length > 0) validSeconds = 1;

                return {
                    bars: validBarsCount,       // æœ‰æ•ˆå°èŠ‚æ•°
                    seconds: validSeconds,      // æœ‰æ•ˆæ—¶é•¿ (ç§’)
                    rawSeconds: totalRawSeconds // åŸå§‹æ€»æ—¶é•¿ (åŒ…å«ç©ºå°èŠ‚)
                };
            };

            // ğŸŸ¢ [ä¿®æ”¹] projectMidiList: ä¼˜å…ˆæŒ‰ MIDI åŸå§‹é¡ºåºæ’åº
            const projectMidiList = computed(() => {
                if (!managingProject.value || !managingProject.value.midiData) return [];

                const list = [];
                const map = managingProject.value.midiData;

                for (const [instId, data] of Object.entries(map)) {
                    const inst = settings.instruments.find(i => i.id === instId);
                    const instName = inst ? inst.name : 'æœªçŸ¥ä¹å™¨';
                    const group = inst ? inst.group : '';

                    if (Array.isArray(data)) {
                        data.forEach((subItem, idx) => {
                            list.push({
                                instId: instId,
                                instName: subItem.name || `${instName} #${idx + 1}`,
                                group: group,
                                duration: subItem.duration,
                                isSubItem: true,
                                subIndex: idx,
                                // ğŸŸ¢ è¯»å–ä¿å­˜çš„ orderï¼Œå¦‚æœæ²¡æœ‰åˆ™è®¾ä¸ºæå¤§å€¼(æ²‰åº•)
                                order: subItem.order !== undefined ? subItem.order : 99999
                            });
                        });
                    } else {
                        // æ—§ç‰ˆæœ¬å­—ç¬¦ä¸²æ•°æ®çš„å…¼å®¹
                        list.push({
                            instId: instId,
                            instName: instName,
                            group: group,
                            duration: data,
                            order: 99999
                        });
                    }
                }

                // ğŸŸ¢ æ’åºé€»è¾‘: å…ˆæŒ‰ Order (æ€»è°±é¡ºåº)ï¼ŒOrder ç›¸åŒåˆ™æŒ‰åç§°
                return list.sort((a, b) => {
                    if (a.order !== b.order) {
                        return a.order - b.order;
                    }
                    return a.instName.localeCompare(b.instName, 'zh-CN');
                });
            });

            // æ‰“å¼€ç®¡ç†å™¨
            const openMidiManager = (project) => {
                managingProject.value = project;
                // ğŸŸ¢ Vital: If this project was created before the MIDI update,
                // it won't have midiData. Initialize it now so reactivity works.
                if (!project.midiData) {
                    project.midiData = {};
                }
                showMidiManager.value = true;
            };

// ğŸŸ¢ [é‡æ„] æ›´æ–° MIDI æ—¶é•¿ (åŒæ­¥æ›´æ–°å·²å­˜åœ¨çš„ä»»åŠ¡)
            const updateMidiDuration = (instId, subIndex, newVal) => {
                if (!managingProject.value) return;

                const pid = managingProject.value.id;
                const data = managingProject.value.midiData[instId];

                // 1. æ›´æ–° MIDI Manager çš„æºæ•°æ®
                let updatedDuration = newVal;

                if (Array.isArray(data)) {
                    if (data[subIndex]) {
                        data[subIndex].duration = newVal;
                    }
                } else {
                    // å…¼å®¹æ—§æ•°æ®
                    if (newVal) {
                        managingProject.value.midiData[instId] = newVal;
                    } else {
                        delete managingProject.value.midiData[instId];
                        return; // åˆ é™¤æ“ä½œä¸è§¦å‘åŒæ­¥
                    }
                }

                // ---------------------------------------------------------
                // ğŸŸ¢ 2. é«˜çº§åŠŸèƒ½: å®æ—¶åŒæ­¥åˆ°ä»»åŠ¡æ±  (Task Pool) & æ—¥ç¨‹è¡¨ (Schedule)
                // ---------------------------------------------------------

                // A. æ‰¾åˆ°å½“å‰ Session ä¸‹ï¼Œå±äºè¯¥é¡¹ç›®ã€è¯¥ä¹å™¨çš„æ‰€æœ‰ä»»åŠ¡
                const relatedTasks = itemPool.value.filter(t =>
                    (t.sessionId || 'S_DEFAULT') === currentSessionId.value &&
                    t.projectId === pid &&
                    t.instrumentId === instId
                );

                // B. å®šä½ç›®æ ‡ä»»åŠ¡
                // é€»è¾‘: MIDI é‡Œçš„ç¬¬ subIndex æ¡æ•°æ®ï¼Œå¯¹åº”ä»»åŠ¡æ± é‡Œçš„ç¬¬ subIndex ä¸ªä»»åŠ¡
                // ä¾‹å¦‚: ä¿®æ”¹äº† "Flute 2" (index 1) çš„æ—¶é•¿ -> æ›´æ–°ç¬¬ 2 ä¸ª Flute ä»»åŠ¡
                const targetTask = relatedTasks[subIndex];

                if (targetTask) {
                    // æ›´æ–°è°±é¢æ—¶é•¿
                    targetTask.musicDuration = updatedDuration;

                    // é‡æ–°è®¡ç®—é¢„ä¼°æ—¶é•¿ (ä¿æŒåŸæœ‰å€ç‡)
                    const currentRatio = targetTask.ratio || 20;
                    const newEst = calculateEstTime(updatedDuration, currentRatio);
                    targetTask.estDuration = newEst;

                    // C. åŒæ­¥æ›´æ–°æ—¥ç¨‹è¡¨ (å¦‚æœæœ‰å·²æ’æœŸçš„å—)
                    scheduledTasks.value.forEach(sched => {
                        if (sched.templateId === targetTask.id) {
                            sched.musicDuration = updatedDuration;
                            sched.estDuration = newEst;
                        }
                    });

                    if (isMobile.value) window.triggerTouchHaptic('Light');
                }

                pushHistory();
            };

// ğŸŸ¢ [ä¿®å¤] åˆ é™¤æ˜ å°„ (æ”¯æŒåˆ é™¤æ•°ç»„ä¸­çš„å•é¡¹)
            const removeMidiMapping = (instId, subIndex) => {
                if (!managingProject.value) return;

                const data = managingProject.value.midiData[instId];

                if (Array.isArray(data)) {
                    // 1. ä»æ•°ç»„ä¸­ç§»é™¤æŒ‡å®šé¡¹
                    // subIndex æ˜¯åœ¨ projectMidiList ä¸­ç”Ÿæˆçš„
                    if (subIndex !== undefined && subIndex >= 0) {
                        data.splice(subIndex, 1);
                    }

                    // 2. å¦‚æœæ•°ç»„ç©ºäº†ï¼Œå½»åº•åˆ é™¤è¯¥ Key
                    if (data.length === 0) {
                        delete managingProject.value.midiData[instId];
                    }
                } else {
                    // æ—§ç‰ˆç›´æ¥åˆ é™¤ Key
                    delete managingProject.value.midiData[instId];
                }

                pushHistory();
            };

// æ¸…ç©ºå½“å‰é¡¹ç›®æ‰€æœ‰ MIDI æ•°æ®
            const clearProjectMidi = () => {
                if (!managingProject.value) return;
                openConfirmModal(
                    'æ¸…ç©ºæ˜ å°„',
                    `ç¡®å®šè¦æ¸…ç©ºé¡¹ç›® "${managingProject.value.name}" çš„æ‰€æœ‰ MIDI æ—¶é•¿æ•°æ®å—ï¼Ÿ`,
                    () => {
                        managingProject.value.midiData = {};
                        pushHistory();
                        window.triggerTouchHaptic('Medium');
                    },
                    true
                );
            };

            // ğŸŸ¢ [å¢å¼º] æ›´æ–°ä¹å™¨åˆ†ç»„ (æ ¸å¿ƒé€»è¾‘)
            const updateInstrumentGroup = (instId, newGroup) => {
                const finalGroup = newGroup.trim();
                if (!finalGroup) return;

                const inst = settings.instruments.find(i => i.id === instId);
                if (inst) {
                    inst.group = finalGroup; // æ›´æ–°æºæ•°æ®

                    // 1. è‡ªåŠ¨å±•å¼€è¿™ä¸ªæ–°åˆ†ç»„ (å¦åˆ™è¯¥é¡¹ç§»è¿‡å»åä¼šè¢«æŠ˜å èµ·æ¥çœ‹ä¸åˆ°)
                    midiManagerExpandedGroups.add(finalGroup);

                    // 2. ä¿å­˜å¹¶å…³é—­èœå•
                    pushHistory();
                    activeMidiGroupRow.value = null;

                    if (isMobile.value) window.triggerTouchHaptic('Success');
                }
            };

            // ğŸŸ¢ [æ–°å¢] è¿‡æ»¤åˆ†ç»„åˆ—è¡¨ (ç”¨äºä¸‹æ‹‰èœå•æ˜¾ç¤º)
            const filteredMidiGroups = computed(() => {
                const query = midiGroupSearchQuery.value.toLowerCase().trim();
                // å¤ç”¨å·²æœ‰çš„ availableInstrumentGroups (åœ¨ä¹‹å‰ä»£ç ä¸­å·²å®šä¹‰)
                return availableInstrumentGroups.value.filter(g =>
                    g.toLowerCase().includes(query)
                );
            });

// è§¦å‘å®šå‘å¯¼å…¥ (å¤ç”¨ä¹‹å‰çš„ inputï¼Œä½†è¿™æ¬¡æˆ‘ä»¬å·²ç»çŸ¥é“æ˜¯å“ªä¸ªé¡¹ç›®äº†)
            const triggerMidiImportForProject = () => {
                // å¤ç”¨ä¹‹å‰çš„ input å…ƒç´ 
                const input = document.getElementById('midi-import-input');
                if (input) {
                    input.value = '';
                    input.click();
                }
            };

            // åœ¨ setup() å†…éƒ¨é å‰ä½ç½®æ·»åŠ 

// ... å…¶ä»– refs ...

// ğŸŸ¢ MIDI å¯¼å…¥ç›¸å…³é€»è¾‘
            const triggerMidiImport = () => {
                const input = document.getElementById('midi-import-input');
                if (input) {
                    input.value = '';
                    input.click();
                }
            };

            const handleMidiFile = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // ğŸŸ¢ [ä¿®å¤] è‡ªåŠ¨å…³è”é¡¹ç›®é€»è¾‘è¡¥å…¨
                if (!managingProject.value) {
                    if (settings.projects.length > 0) {
                        // é»˜è®¤å…³è”åˆ°ç¬¬ä¸€ä¸ªé¡¹ç›®ï¼Œå¹¶åˆå§‹åŒ– midiData
                        managingProject.value = settings.projects[0];
                        if (!managingProject.value.midiData) {
                            managingProject.value.midiData = {};
                        }
                        // å¯é€‰ï¼šæç¤ºç”¨æˆ·å…³è”äº†å“ªä¸ªé¡¹ç›®
                        // console.log("Auto-associated with project:", managingProject.value.name);
                    } else {
                        // å¦‚æœè¿ä¸€ä¸ªé¡¹ç›®éƒ½æ²¡æœ‰ï¼Œæ— æ³•å¯¼å…¥ï¼Œå¿…é¡»æŠ¥é”™
                        openAlertModal("æ— æ³•å¯¼å…¥", "è¯·å…ˆè‡³å°‘åˆ›å»ºä¸€ä¸ªé¡¹ç›® (Project) åå†å¯¼å…¥ MIDIã€‚");
                        e.target.value = '';
                        return;
                    }
                }

                processMidiFile(file);
                e.target.value = '';
            };

// ğŸŸ¢ [é‡å†™] processMidiFile - æ»¡è¶³ä¸‰å¤§æ ¸å¿ƒéœ€æ±‚
            const processMidiFile = (file) => {
                // æ£€æŸ¥åº“
                if (typeof JZZ === 'undefined' || typeof JZZ.MIDI.SMF === 'undefined') {
                    openAlertModal('åº“ä¸¢å¤±', 'JZZ MIDI åº“æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚');
                    return;
                }

                // ğŸŸ¢ è¾…åŠ©å‡½æ•°ï¼šè·å–ç”¨äºåŒ¹é… ID çš„åç§°
                // è§„åˆ™ï¼šåªå»é™¤æœ«å°¾çš„é˜¿æ‹‰ä¼¯æ•°å­— (1, 2, 3...)ï¼Œä¿ç•™ç½—é©¬æ•°å­— (I, II, V...)
                const getMatchName = (name) => {
                    if (!name) return "";
                    // è§£é‡Šï¼š
                    // [_\s-]* åŒ¹é…å‰é¢çš„ç©ºæ ¼ã€ä¸‹åˆ’çº¿æˆ–æ¨ªæ 
                    // \d+      åŒ¹é…ä¸€ä¸ªæˆ–å¤šä¸ªæ•°å­—
                    // $        åŒ¹é…å­—ç¬¦ä¸²ç»“å°¾
                    // è¿™æ · "Horn 1" -> "Horn", "Horn 2" -> "Horn"
                    // ä½†æ˜¯ "Violin I" -> "Violin I" (å› ä¸º I ä¸æ˜¯æ•°å­— \d)
                    return name.replace(/[_\s-]*\d+$/, '').trim();
                };

                const reader = new FileReader();
                reader.readAsBinaryString(file);

                reader.onload = async (ev) => {
                    try {
                        const data = ev.target.result;
                        const smf = JZZ.MIDI.SMF(data);

                        const tempoMap = buildTempoMap(smf);
                        const timeSigs = buildTimeSigMap(smf);

                        // ğŸŸ¢ [æ–°å¢] ä¿å­˜åˆ°å…¨å±€ Refï¼Œä¾› Group è®¡ç®—ä½¿ç”¨
                        midiTempoMap.value = tempoMap;
                        midiTimeSigs.value = timeSigs;

                        const firstTempo = tempoMap.events.find(e => e.bpm) || { bpm: 120 };
                        midiBpm.value = Math.round(60000000 / firstTempo.mpb);
                        midiTimeSig.value = timeSigs[0].timeSignature;

                        // ğŸŸ¢ 1. ç‰©ç†åˆå¹¶å®¹å™¨ï¼šKey = è½¨é“åŸå§‹åç§°
                        // è¿™æ · "Piano" å’Œ "Piano" ä¼šè½å…¥åŒä¸€ä¸ª Key (åˆå¹¶)
                        // "Horn 1" å’Œ "Horn 2" ä¼šè½å…¥ä¸åŒ Key (ä¸åˆå¹¶)
                        const mergedMap = {};

                        // ...
                        smf.forEach((track, index) => {
                            // A. è·å–åç§°
                            let rawName = '';
                            track.forEach(e => { if (e.ff === 0x03) rawName = e.dd; });
                            if (!rawName) rawName = `Track ${index + 1}`;

                            // ğŸŸ¢ [ä¿®å¤] åœ¨è¿™é‡Œç»Ÿä¸€æ¸…æ´—æ˜¾ç¤ºåç§°
                            let displayName = rawName.replace(/\0/g, '').trim();

                            displayName = displayName
                                // å¤„ç† " Flat", "-Flat", "Flat" (å¿½ç•¥å¤§å°å†™) -> "b"
                                // ä¾‹å¦‚: "Clarinet (B Flat)" -> "Clarinet (Bb)"
                                .replace(/[\s\-_]?Flat/gi, 'b')

                                // å¤„ç† " Sharp", "-Sharp", "Sharp" (å¿½ç•¥å¤§å°å†™) -> "#"
                                .replace(/[\s\-_]?Sharp/gi, '#')

                                // å¤„ç† Unicode ç¬¦å·
                                .replace(/â™­/g, 'b')
                                .replace(/â™¯/g, '#');

                            // B. æå–éŸ³ç¬¦
                            const trackNotes = extractNotesFromJZZTrack(track);

                            // ç©ºè½¨ä¸”æ— ååˆ™è·³è¿‡
                            if (trackNotes.length === 0 && !displayName) return;

                            // C. å½’å¹¶é€»è¾‘ (å®Œå…¨åŒåæ‰åˆå¹¶)
                            if (!mergedMap[displayName]) {
                                mergedMap[displayName] = {
                                    name: displayName,
                                    notes: [],
                                    firstTrackIndex: index, // è®°å½•æ’åºç”¨
                                    trackCount: 0
                                };
                            }

                            mergedMap[displayName].notes.push(...trackNotes);
                            mergedMap[displayName].trackCount++;
                        });

                        const processedTracks = [];
                        let uniqueIdCounter = 0;

                        // --- ç¬¬äºŒè½®éå†ï¼šç”Ÿæˆæœ€ç»ˆåˆ—è¡¨å¹¶è¿›è¡Œã€æ™ºèƒ½åŒ¹é…ã€‘ ---
                        for (const name in mergedMap) {
                            const groupData = mergedMap[name];
                            const notes = groupData.notes;

                            // ğŸŸ¢ æ ¸å¿ƒåŒ¹é…é€»è¾‘

                            // 1. å‡†å¤‡ä¸¤ä¸ªç”¨äºæŸ¥æ‰¾çš„åå­—
                            // A: åŸå§‹å (ä¾‹å¦‚ "Violin I", "Horn 1")
                            const exactName = normalizeForMatch(groupData.name);
                            // B. å»æ‰æ•°å­—çš„å (ä¾‹å¦‚ "Violin I"->"Violin I", "Horn 1"->"Horn")
                            const strippedName = normalizeForMatch(getMatchName(groupData.name));

                            let matchedInstId = '';
                            let matchedGroup = findGroupSmart(groupData.name); // æ™ºèƒ½çŒœåˆ†ç»„

                            // 2. å°è¯•åœ¨åº“é‡Œæ‰¾
                            // ä¼˜å…ˆçº§ A: ç²¾ç¡®åŒ¹é… (åº“é‡Œæœ‰ "Horn 1" å°±ç”¨ "Horn 1")
                            let found = settings.instruments.find(inst => normalizeForMatch(inst.name) === exactName);

                            // ä¼˜å…ˆçº§ B: å»æ‰æ•°å­—åŒ¹é… (åº“é‡Œæ²¡æœ‰ "Horn 1"ï¼Œä½†æœ‰ "Horn"ï¼Œåˆ™åŒ¹é… "Horn")
                            // æ³¨æ„ï¼šå¯¹äº "Violin I"ï¼ŒstrippedName è¿˜æ˜¯ "Violin I"ï¼Œæ‰€ä»¥å®ƒåªä¼šå»åº“é‡Œæ‰¾ "Violin I"ï¼Œä¸ä¼šåŒ¹é…åˆ° "Violin"
                            if (!found) {
                                found = settings.instruments.find(inst => normalizeForMatch(inst.name) === strippedName);
                            }

                            // ä¼˜å…ˆçº§ C: æ¨¡ç³ŠåŒ…å« (å…œåº•)
                            if (!found) {
                                found = settings.instruments.find(inst => {
                                    const iName = normalizeForMatch(inst.name);
                                    // ç¡®ä¿ä¸æ˜¯ç®€å•çš„åŒ…å« (é˜²æ­¢ "Violin" åŒ¹é…åˆ° "Violin I")
                                    return iName.includes(strippedName) && strippedName.length > 2;
                                });
                            }

                            if (found) {
                                matchedInstId = found.id;
                                // å¦‚æœåº“é‡Œæœ‰å®šä¹‰åˆ†ç»„ï¼Œä¼˜å…ˆç”¨åº“é‡Œçš„
                                if (found.group) matchedGroup = found.group;
                            }

                            // 3. è®¡ç®—æ—¶é•¿
                            let analysis = { seconds: 0, rawSeconds: 0, bars: 0 }; // ğŸŸ¢ åˆå§‹åŒ–å¢åŠ  bars
                            if (notes.length > 0) {
                                analysis = calculateBarQuantizedDuration(notes, tempoMap, timeSigs);
                            }

                            const isTechnicalEmpty = notes.length === 0;

// ğŸŸ¢ [æ–°å¢] æ™ºèƒ½ç”Ÿæˆå»ºè®®åç§°ï¼šå»æ‰æœ«å°¾çš„ç©ºæ ¼å’Œæ•°å­— (ä¾‹å¦‚ "Horn (F) 1" -> "Horn (F)")
// è¿™æ ·åœ¨åˆ›å»ºæ–°ä¹å™¨æ—¶ï¼Œå¤šä¸ªåˆ†è½¨ä¼šè‡ªåŠ¨å½’å¹¶åˆ°åŒä¸€ä¸ªä¹å™¨åä¸‹
                            const cleanNameForCreation = groupData.name.replace(/\s+\d+$/, '').trim();

                            processedTracks.push({
                                id: uniqueIdCounter++,
                                name: groupData.name,
                                originalName: groupData.name,
                                suggestedInstName: cleanNameForCreation,
                                instrumentId: matchedInstId,
                                createNew: !matchedInstId && !isTechnicalEmpty,

                                notes: notes,

                                rawDuration: analysis.rawSeconds,
                                quantizedDuration: analysis.seconds,

                                bars: analysis.bars, // ğŸŸ¢ ä¿®å¤: å°†åŸæ¥çš„ 0 æ”¹ä¸º analysis.bars

                                noteCount: notes.length,
                                group: matchedGroup || 'Unassigned',
                                selected: !isTechnicalEmpty,
                                description: groupData.trackCount > 1 ? `Merged ${groupData.trackCount} duplicate tracks` : '',
                                _sortIndex: groupData.firstTrackIndex
                            });
                        }

                        // ä¿æŒåŸå§‹ MIDI é¡ºåº
                        processedTracks.sort((a, b) => a._sortIndex - b._sortIndex);

                        if (processedTracks.length === 0) {
                            openAlertModal('æ— æ•°æ®', 'æœªè§£æåˆ°ä»»ä½•æœ‰æ•ˆè½¨é“ã€‚');
                            return;
                        }

                        midiImportData.value = processedTracks;
                        showMidiImportModal.value = true;

                    } catch (e) {
                        console.error("JZZ Parse Error:", e);
                        openAlertModal('è§£æé”™è¯¯', 'æ–‡ä»¶è§£æå¤±è´¥: ' + e.message);
                    }
                };
            };

            // --- ğŸŸ¢ MIDI Group çŠ¶æ€ç®¡ç† ---
            const midiGroupExpanded = reactive(new Set()); // å­˜å‚¨å·²å±•å¼€çš„ç»„å

            const toggleMidiGroupExpand = (groupName) => {
                if (midiGroupExpanded.has(groupName)) {
                    midiGroupExpanded.delete(groupName);
                } else {
                    midiGroupExpanded.add(groupName);
                }
            };

// ğŸŸ¢ [æ–°å¢] åˆ¤æ–­æŸç»„æ˜¯å¦å…¨é€‰ (ç”¨äºåˆ†ç»„ Checkbox çŠ¶æ€)
            const isGroupSelected = (rows) => {
                return rows.length > 0 && rows.every(r => r.selected);
            };

            // ğŸŸ¢ [æ–°å¢] åˆ‡æ¢æŸç»„çš„å…¨é€‰çŠ¶æ€
            const toggleGroupSelection = (group, isChecked) => {
                group.rows.forEach(row => {
                    row.selected = isChecked;
                });
            };

            // ğŸŸ¢ [æ–°å¢] å…¨å±€å…¨é€‰çŠ¶æ€ (è®¡ç®—å±æ€§ï¼šæ£€æŸ¥å½“å‰è§†å›¾ä¸‹æ‰€æœ‰å¯è§è¡Œ)
            const isAllSelected = computed(() => {
                if (groupedCsvData.value.length === 0) return false;
                return groupedCsvData.value.every(group =>
                    group.rows.every(r => r.selected)
                );
            });

            // ğŸŸ¢ [ä¿®å¤] å…¨å±€å…¨é€‰åˆ‡æ¢ (åªæ“ä½œå½“å‰è§†å›¾å¯è§çš„è¡Œ)
            const toggleAllRows = (isChecked) => {
                groupedCsvData.value.forEach(group => {
                    group.rows.forEach(row => {
                        row.selected = isChecked;
                    });
                });
            };

// ğŸŸ¢ [ä¿®å¤] midiGroupData: ä¿®å¤ Group è§†å›¾ä¸‹ Bars æ˜¾ç¤ºä¸º 0 çš„é—®é¢˜
            const midiGroupData = computed(() => {
                const tracks = midiImportData.value;
                const groupsMap = {};

                // 1. Grouping (åˆ†ç»„é€»è¾‘ä¿æŒä¸å˜)
                tracks.forEach(t => {
                    if (t.group && t.group.trim() !== '') {
                        if (!groupsMap[t.group]) {
                            groupsMap[t.group] = { name: t.group, items: [] };
                        }
                        groupsMap[t.group].items.push(t);
                    } else {
                        if (!groupsMap['Unassigned']) {
                            groupsMap['Unassigned'] = { name: 'Unassigned', items: [] };
                        }
                        groupsMap['Unassigned'].items.push(t);
                    }
                });

                // 2. Aggregation (èšåˆè®¡ç®—é€»è¾‘)
                return Object.values(groupsMap).map(g => {
                    const selectedItems = g.items.filter(t => t.selected);
                    const hasSelection = selectedItems.length > 0;

                    let finalDuration = 0;
                    let totalNotes = 0;
                    let maxBars = 0; // ğŸŸ¢ åˆå§‹åŒ– maxBars

                    // å¦‚æœæœ‰é€‰ä¸­çš„è½¨é“ï¼Œä¸”å…·å¤‡ Tempo/TimeSig æ•°æ®ï¼Œè¿›è¡Œç²¾ç¡®åˆå¹¶è®¡ç®—
                    if (hasSelection && midiTempoMap.value && midiTimeSigs.value) {
                        let allGroupNotes = [];
                        selectedItems.forEach(t => {
                            totalNotes += t.noteCount;
                            if (t.notes) allGroupNotes.push(...t.notes);
                        });

                        if (allGroupNotes.length > 0) {
                            // å°†æ‰€æœ‰éŸ³ç¬¦æŒ‰æ—¶é—´æ’åº
                            allGroupNotes.sort((a, b) => a.ticks - b.ticks);

                            // è°ƒç”¨ä¹‹å‰ä¿®å¤è¿‡çš„ calculateBarQuantizedDuration å‡½æ•°
                            // å®ƒå¯ä»¥æ­£ç¡®è¿”å›åˆå¹¶åçš„æ€»å°èŠ‚æ•°
                            const analysis = calculateBarQuantizedDuration(allGroupNotes, midiTempoMap.value, midiTimeSigs.value);

                            finalDuration = analysis.seconds;
                            maxBars = analysis.bars; // ğŸŸ¢ å…³é”®ä¿®å¤ 1: ä»åˆ†æç»“æœä¸­è·å– bars
                        }
                    } else {
                        // ç®€å•å›é€€æ¨¡å¼ (å¦‚æœæ²¡æœ‰é€‰ä¸­æˆ–æ²¡æœ‰ Tempo æ•°æ®)
                        selectedItems.forEach(t => {
                            finalDuration = Math.max(finalDuration, t.quantizedDuration);
                            totalNotes += t.noteCount;

                            // ğŸŸ¢ å…³é”®ä¿®å¤ 2: å–æ‰€æœ‰å­è½¨é“ä¸­æœ€å¤§çš„ Bars
                            maxBars = Math.max(maxBars, t.bars || 0);
                        });
                    }

                    const genericInst = settings.instruments.find(i =>
                        i.name.toLowerCase() === g.name.toLowerCase() ||
                        (i.group === g.name && i.name.toLowerCase().includes('section'))
                    );

                    return {
                        id: `GRP_${g.name}`,
                        name: g.name,
                        originalName: g.name,
                        instrumentId: genericInst ? genericInst.id : '',
                        createNew: !genericInst,
                        quantizedDuration: finalDuration,
                        bars: maxBars, // ğŸŸ¢ èµ‹å€¼è®¡ç®—å‡ºçš„å°èŠ‚æ•°
                        noteCount: totalNotes,
                        group: g.name,
                        selected: hasSelection,
                        items: g.items,
                        isGroup: true,
                        description: `${selectedItems.length} / ${g.items.length} tracks`
                    };
                }).sort((a, b) => {
                    if (a.name === 'Unassigned') return 1;
                    if (b.name === 'Unassigned') return -1;
                    return a.name.localeCompare(b.name, 'zh-CN');
                });
            });


            // ğŸŸ¢ [æ–°å¢] æ ¹æ®æ¨¡å¼è¿”å›å½“å‰æ˜¾ç¤ºçš„åˆ—è¡¨
            const currentMidiDisplayList = computed(() => {
                return midiViewMode.value === 'groups' ? midiGroupData.value : midiImportData.value;
            });

            const cleanMidiTrackName = (name) => {
                if (!name) return "";
                return name
                    // 1. ç§»é™¤æœ«å°¾çš„æ•°å­— (å¦‚ "Flute 1", "Violin 2")
                    .replace(/\s*\d+$/, '')
                    // 2. ç§»é™¤æœ«å°¾çš„ç½—é©¬æ•°å­— (å¦‚ "Violin I", "Violin II") - å¯é€‰
                    .replace(/\s+(I{1,3}|IV|V|VI)$/i, '')
                    // 3. ç§»é™¤ç‰¹æ®Šè¿å­—ç¬¦ (å¦‚ "Flute_1" -> "Flute")
                    .replace(/[_\-]\d+$/, '')
                    .trim();
            };

            const findGroupFromLibrary = (cleanName) => {
                const target = cleanName.toLowerCase();

                // éå†æ‰€æœ‰åˆ†ç»„
                for (const [groupName, instruments] of Object.entries(instrumentLibrary)) {
                    // æ£€æŸ¥è¯¥åˆ†ç»„ä¸‹çš„ä¹å™¨æ˜¯å¦åŒ¹é…
                    const match = instruments.find(inst => {
                        const libInst = inst.toLowerCase();
                        // åŒ¹é…é€»è¾‘ï¼š
                        // 1. å…¨å­—åŒ¹é… (æœ€å‡†ç¡®)
                        if (libInst === target) return true;
                        // 2. åŒ…å«åŒ¹é… (å¦‚åº“é‡Œæ˜¯ "Piano", è½¨é“å« "Piano (L)")
                        if (target.includes(libInst)) return true;
                        return false;
                    });

                    if (match) return groupName;
                }
                return "";
            };

            // ğŸŸ¢ è¾…åŠ©ï¼šè®¡ç®—åŸºäº Tick çš„ç²¾ç¡®æ—¶é•¿ (æ ¸å¿ƒç®—æ³•)
            const calculateAccurateDuration = (midi, track) => {
                // 1. è·å–åŸºç¡€ä¿¡æ¯
                const ppq = midi.header.ppq || 480; // é»˜è®¤ 480 ticks per quarter note

                // 2. è·å–æ‹å· (å‡è®¾å¤§éƒ¨åˆ†æƒ…å†µä¸»æ‹å·åœ¨å¼€å¤´ï¼Œå¦‚æœä¸­é—´å˜æ‹å·éœ€è¦æ›´å¤æ‚çš„éå†ï¼Œè¿™é‡Œå–ç¬¬ä¸€ä¸ª)
                const timeSig = midi.header.timeSignatures[0] || { timeSignature: [4, 4] };
                const [num, den] = timeSig.timeSignature;

                // è®¡ç®—ä¸€ä¸ªå°èŠ‚æœ‰å¤šå°‘ Ticks
                // å…¬å¼: (PPQ * 4 / åˆ†æ¯) * åˆ†å­
                // ä¾‹å¦‚ 4/4: (480 * 1) * 4 = 1920 ticks
                const ticksPerBar = (ppq * 4 / den) * num;

                // 3. æ‰¾åˆ°è½¨é“ä¸­æœ€åä¸€ä¸ªéŸ³ç¬¦çš„ç»“æŸä½ç½® (Ticks)
                let maxTick = 0;
                // æ³¨æ„ï¼š@tonejs/midi è§£æåçš„ note.ticks æ˜¯ç»å¯¹ä½ç½®ï¼Œnote.durationTicks æ˜¯é•¿åº¦
                track.notes.forEach(n => {
                    const end = n.ticks + n.durationTicks;
                    if (end > maxTick) maxTick = end;
                });

                // 4. é‡åŒ–ï¼šå‘ä¸Šå–æ•´åˆ°ä¸‹ä¸€ä¸ªå°èŠ‚çº¿
                const totalBars = Math.ceil(maxTick / ticksPerBar);
                const quantizedTotalTicks = totalBars * ticksPerBar;

                // 5. å°†é‡åŒ–åçš„ Ticks è½¬æ¢å›ç§’æ•° (å¿…é¡»éå† Tempo Map)
                const durationSeconds = convertTicksToSeconds(midi, quantizedTotalTicks);

                return {
                    bars: totalBars,
                    seconds: durationSeconds,
                    rawEndTick: maxTick
                };
            };

            // ğŸŸ¢ è¾…åŠ©ï¼šåˆ©ç”¨ Tempo Map å°† Ticks è½¬ä¸º Seconds
            const convertTicksToSeconds = (midi, targetTick) => {
                const tempos = midi.header.tempos || [];
                // å¦‚æœæ²¡æœ‰é€Ÿåº¦å˜åŒ–ï¼Œä½¿ç”¨é»˜è®¤ 120 BPM
                if (tempos.length === 0) {
                    const ppq = midi.header.ppq || 480;
                    const secondsPerTick = 60 / 120 / ppq;
                    return targetTick * secondsPerTick;
                }

                // éå† Tempo Map ç´¯åŠ æ—¶é—´
                let currentTick = 0;
                let currentTime = 0;

                for (let i = 0; i < tempos.length; i++) {
                    const tempo = tempos[i];
                    const nextTempo = tempos[i + 1];

                    // å½“å‰æ®µçš„ç»“æŸ tick (è¦ä¹ˆæ˜¯ä¸‹ä¸€ä¸ªå˜é€Ÿç‚¹ï¼Œè¦ä¹ˆæ˜¯ç›®æ ‡ tick)
                    const segmentEndTick = nextTempo ? Math.min(targetTick, nextTempo.ticks) : targetTick;

                    // å¦‚æœå½“å‰ tempo å¼€å§‹ç‚¹å·²ç»åœ¨ç›®æ ‡ä¹‹åï¼Œåœæ­¢
                    if (tempo.ticks >= targetTick) break;

                    // è®¡ç®—è¿™æ®µåŒºé—´çš„é•¿åº¦ (ticks)
                    // æ³¨æ„ï¼šç¬¬ä¸€ä¸ª tempo é€šå¸¸ä» tick 0 å¼€å§‹ï¼Œå¦‚æœä¸æ˜¯ï¼Œå‰é¢é»˜è®¤ä¸º 120
                    const startTick = Math.max(currentTick, tempo.ticks);
                    const deltaTicks = segmentEndTick - startTick;

                    if (deltaTicks > 0) {
                        const secondsPerTick = 60 / tempo.bpm / midi.header.ppq;
                        currentTime += deltaTicks * secondsPerTick;
                        currentTick += deltaTicks;
                    }

                    // å¦‚æœå·²ç»åˆ°è¾¾ç›®æ ‡ï¼Œé€€å‡º
                    if (currentTick >= targetTick) break;
                }

                // å¦‚æœéå†å®Œæ‰€æœ‰ tempo map è¿˜æ²¡åˆ° targetTick (è¯´æ˜æœ€åä¸€æ®µæ˜¯æ’é€Ÿ)
                if (currentTick < targetTick) {
                    const lastTempo = tempos[tempos.length - 1];
                    const secondsPerTick = 60 / lastTempo.bpm / midi.header.ppq;
                    currentTime += (targetTick - currentTick) * secondsPerTick;
                }

                return currentTime;
            };

            // ğŸŸ¢ æ ¸å¿ƒç®—æ³•ï¼šåŸºäºæ‹å·/é€Ÿåº¦è¡¨çš„å°èŠ‚é‡åŒ–è®¡ç®—
            const calculateQuantizedDuration = (midi, track) => {
                // 1. æ‰¾åˆ°æ‰€æœ‰éŸ³ç¬¦ä¸­ï¼Œæœ€åç»“æŸçš„é‚£ä¸ªæ—¶é—´ç‚¹ (Ticks)
                // è¿™èƒ½æœ‰æ•ˆå¿½ç•¥è½¨é“æœ«å°¾çš„ç©ºç™½æˆ–ééŸ³ç¬¦äº‹ä»¶
                let lastNoteOffTick = 0;
                track.notes.forEach(n => {
                    const end = n.ticks + n.durationTicks;
                    if (end > lastNoteOffTick) lastNoteOffTick = end;
                });

                if (lastNoteOffTick === 0) return { bars: 0, seconds: 0, rawEndTick: 0 };

                // 2. å‡†å¤‡æ‹å·è¡¨ (æŒ‰æ—¶é—´æ’åº)
                // é»˜è®¤ä¸º 4/4 æ‹
                let timeSignatures = midi.header.timeSignatures || [];
                if (timeSignatures.length === 0) {
                    timeSignatures = [{ ticks: 0, timeSignature: [4, 4] }];
                }
                timeSignatures.sort((a, b) => a.ticks - b.ticks);

                // 3. "å°èŠ‚æ­¥è¿›" ç®—æ³•
                // æˆ‘ä»¬ä» 0 å¼€å§‹ï¼Œä¸€å°èŠ‚ä¸€å°èŠ‚åœ°åŠ ï¼Œç›´åˆ°è¶…è¿‡ lastNoteOffTick
                // è¿™æ ·åšå¯ä»¥å®Œç¾å¤„ç†ä¸­é€”å˜æ‹å·çš„æƒ…å†µ (e.g. 4/4 -> 3/4 -> 4/4)
                let currentTick = 0;
                let barCount = 0;
                let sigIndex = 0;
                const ppq = midi.header.ppq || 480;

                while (currentTick < lastNoteOffTick) {
                    // æ£€æŸ¥å½“å‰æ˜¯å¦è¿›å…¥äº†æ–°çš„æ‹å·èŒƒå›´
                    // å¦‚æœä¸‹ä¸€ä¸ªæ‹å·å˜æ›´ç‚¹çš„ ticks <= å½“å‰ ticksï¼Œè¯´æ˜è¦åˆ‡æ¢æ‹å·äº†
                    while (sigIndex + 1 < timeSignatures.length && timeSignatures[sigIndex + 1].ticks <= currentTick) {
                        sigIndex++;
                    }

                    const currentSig = timeSignatures[sigIndex];
                    const [num, den] = currentSig.timeSignature;

                    // è®¡ç®—å½“å‰æ‹å·ä¸‹ä¸€å°èŠ‚çš„é•¿åº¦ (Ticks)
                    // å…¬å¼: (PPQ * 4 / åˆ†æ¯) * åˆ†å­
                    const ticksPerBar = (ppq * 4 / den) * num;

                    currentTick += ticksPerBar;
                    barCount++;
                }

                // 4. æœ€ç»ˆè½¬æ¢ï¼šå°†é‡åŒ–åçš„å°èŠ‚ç»“æŸç‚¹ (currentTick) è½¬ä¸ºç§’
                // midi.header.ticksToSeconds ä¼šåˆ©ç”¨ Tempo Map è‡ªåŠ¨å¤„ç†æ‰€æœ‰å˜é€Ÿ
                const quantizedSeconds = midi.header.ticksToSeconds(currentTick);

                // åŸå§‹éŸ³ç¬¦ç»“æŸæ—¶é—´çš„ç§’æ•° (ç”¨äºå¯¹æ¯”)
                const rawSeconds = midi.header.ticksToSeconds(lastNoteOffTick);

                // ğŸ›¡ï¸ å…œåº•ä¿®å¤ï¼šå¦‚æœ Tone.js ç®—å‡ºæ¥çš„ç§’æ•°æ˜¯ 0 (è§£æå¤±è´¥)ï¼Œæ‰‹åŠ¨ç®—ä¸€ä¸‹
                if (quantizedSeconds === 0 && currentTick > 0) {
                    // å‡è®¾ 120 BPM, 480 PPQ çš„æ ‡å‡†æƒ…å†µè¿›è¡Œä¼°ç®—
                    // 60ç§’ / 120æ‹ = 0.5ç§’/æ‹
                    // 1æ‹ = 480 ticks -> 1 tick = 0.5/480 ç§’
                    const estimatedSecPerTick = 60 / 120 / 480;
                    quantizedSeconds = currentTick * estimatedSecPerTick;
                }

                return {
                    bars: barCount,
                    seconds: quantizedSeconds,
                    rawSeconds: rawSeconds
                };
            };

            // ğŸŸ¢ [ä¿®æ”¹] è·å–æ‰€æœ‰å¯ç”¨åˆ†ç»„ (åˆå¹¶ç³»ç»Ÿè®¾ç½® + å½“å‰å¯¼å…¥ç•Œé¢çš„ä¸´æ—¶åˆ†ç»„)
            const availableInstrumentGroups = computed(() => {
                const groups = new Set(['Unassigned']);

                // 1. æ¥è‡ªç³»ç»Ÿç°æœ‰çš„ä¹å™¨è®¾ç½®
                settings.instruments.forEach(i => {
                    if (i.group) groups.add(i.group);
                });

                // 2. å¸¸ç”¨é¢„è®¾
                ['Strings', 'Brass', 'Woodwinds', 'Percussion', 'Keys', 'Plucks', 'Vocal', 'Synth'].forEach(g => groups.add(g));

                // 3. ğŸŸ¢ [æ–°å¢] å®æ—¶æŠ“å– MIDI å¯¼å…¥ç•Œé¢ä¸­åˆšåˆšè¾“å…¥çš„æ–°åˆ†ç»„
                // è¿™æ ·ä½ åœ¨ Track 1 è¾“å…¥äº† "My New Group"ï¼ŒTrack 2 çš„ä¸‹æ‹‰åˆ—è¡¨é‡Œé©¬ä¸Šå°±èƒ½é€‰åˆ°å®ƒ
                if (showMidiImportModal.value) {
                    midiImportData.value.forEach(t => {
                        if (t.group && t.group.trim()) {
                            groups.add(t.group.trim());
                        }
                    });
                }

                return Array.from(groups).sort();
            });

            // ğŸŸ¢ [æ–°å¢] å½“ç”¨æˆ·æ”¹å˜ä¹å™¨é€‰æ‹©æ—¶ï¼Œè‡ªåŠ¨æ›´æ–° Group
            const onImportInstChange = (track) => {
                track.createNew = false;
                if (track.instrumentId) {
                    const inst = settings.instruments.find(i => i.id === track.instrumentId);
                    if (inst) track.group = inst.group || 'Unassigned';
                }
            };

            const getSmartName = (row) => {
                if (!row) return 'New Instrument';
                // å¦‚æœæ˜¯åˆ†ç»„è¡Œ(Group)ï¼Œç›´æ¥è¿”å›åå­—
                if (row.isGroup) return row.name;

                // å¦‚æœæ˜¯è½¨é“è¡Œ(Track)ï¼Œä¸”ç”¨æˆ·æ”¹è¿‡åå­—ï¼Œæ˜¾ç¤ºæ–°åå­—
                if (row.name !== row.originalName) return row.name;

                // å¦åˆ™æ˜¾ç¤ºå»ºè®®åå­—(å»æ‰æ•°å­—çš„)
                return row.suggestedInstName || row.name;
            };

            // ğŸŸ¢ [ä¿®æ”¹] confirmMidiImport: æ”¯æŒå­˜å‚¨å¤šæ¡è½¨é“æ•°æ® (Flute 1, Flute 2)
            const confirmMidiImport = () => {
                if (!managingProject.value) {
                    openAlertModal("é”™è¯¯", "æœªæ‰¾åˆ°å…³è”çš„é¡¹ç›®ï¼Œæ— æ³•ä¿å­˜æ•°æ®ã€‚");
                    return;
                }
                // åˆå§‹åŒ–
                if (!managingProject.value.midiData) managingProject.value.midiData = {};

                let count = 0;
                const sourceList = midiViewMode.value === 'groups' ? midiGroupData.value : midiImportData.value;

                // 1. ä¸´æ—¶å­˜å‚¨ï¼Œç”¨äºå¤„ç†åŒä¸€ä¸ªä¹å™¨ ID ä¸‹çš„å¤šæ¡æ•°æ®
                const tempMap = {};

                sourceList.forEach(row => {
                    if (!row.selected) return;

                    let targetInstId = row.instrumentId;

                    // æ–°å»ºä¹å™¨é€»è¾‘ (ä¿æŒä¸å˜)
                    if (!targetInstId && row.createNew) {
                        const finalName = (row.name !== row.originalName)
                            ? row.name
                            : (row.suggestedInstName || row.name);

                        const existing = settings.instruments.find(i => i.name === finalName);
                        if (existing) {
                            targetInstId = existing.id;
                        } else {
                            const newId = generateUniqueId('I');
                            const newInst = {
                                id: newId,
                                name: finalName, // ğŸŸ¢ ä¿®å¤ï¼šä½¿ç”¨ finalName æ›¿ä»£ nameToUse
                                group: row.group || 'Unassigned',
                                color: generateRandomHexColor()
                            };
                            settings.instruments.push(newInst);
                            targetInstId = newId;
                        }
                    }

                    if (targetInstId) {
                        // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: ä¸ç›´æ¥è¦†ç›–ï¼Œè€Œæ˜¯æ”¶é›†åˆ°ä¸´æ—¶åˆ—è¡¨
                        if (!tempMap[targetInstId]) tempMap[targetInstId] = [];

                        tempMap[targetInstId].push({
                            name: row.name, // ä¿ç•™åŸå§‹åå­— (e.g. "Flute 1")
                            duration: formatSecs(row.quantizedDuration), // ä¿ç•™ç‰¹å®šæ—¶é•¿
                            // å¯ä»¥åŠ ä¸€ä¸ª sortIndex æ–¹ä¾¿åç»­æ’åº
                            _sortIndex: row._sortIndex || 0
                        });

                        count++;
                    }
                });

                // 2. å°†ä¸´æ—¶åˆ—è¡¨å†™å…¥é¡¹ç›®æ•°æ® (æ›¿æ¢æ—§æ•°æ®ï¼Œæˆ–è€…åˆå¹¶)
                // è¿™é‡Œé‡‡ç”¨ï¼šè¦†ç›–è¯¥ä¹å™¨çš„æ—§æ•°æ® (ä»¥æœ¬æ¬¡å¯¼å…¥ä¸ºå‡†)ï¼Œå¹¶æŒ‰ MIDI é‡Œçš„é¡ºåºæ’åº
                for (const [instId, items] of Object.entries(tempMap)) {
                    // æŒ‰åŸå§‹è½¨é“é¡ºåºæ’åºï¼Œç¡®ä¿ Flute 1 åœ¨ Flute 2 å‰é¢
                    items.sort((a, b) => a._sortIndex - b._sortIndex);

                    // ğŸŸ¢ å…³é”®ä¿®æ”¹: ä¿å­˜æ—¶ä¿ç•™ order å­—æ®µ
                    const cleanItems = items.map(item => ({
                        name: item.name,
                        duration: item.duration,
                        order: item._sortIndex // <--- æ–°å¢è¿™è¡Œï¼ŒæŒä¹…åŒ–ä¿å­˜æ’åºæƒé‡
                    }));

                    managingProject.value.midiData[instId] = cleanItems;
                }

                pushHistory();
                window.triggerTouchHaptic('Success');
                showMidiImportModal.value = false;
                openAlertModal('å¯¼å…¥æˆåŠŸ', `å·²å¯¼å…¥ ${count} æ¡è½¨é“æ•°æ® (æ”¯æŒåˆ†éƒ¨)ã€‚`);
            };

            // 1. å‘¨è§†å›¾ -> æœˆè§†å›¾ (åŒå‡»è¡¨å¤´)
            const handleHeaderDoubleTap = (e) => {
                const now = Date.now();
                // å¦‚æœä¸¤æ¬¡ç‚¹å‡»é—´éš”å°äº 300ms
                if (now - lastHeaderTap < 300) {
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼ˆå¦‚ç¼©æ”¾ï¼‰
                    switchView('month');
                }
                lastHeaderTap = now;
            };

            // 2. æœˆè§†å›¾ -> å‘¨è§†å›¾ (åŒå‡»æ—¥æœŸæ ¼)
            const handleMonthCellDoubleTap = (e, dateStr) => {
                // å¦‚æœç‚¹åˆ°äº†ä»»åŠ¡æ¡(Task)ï¼Œä¸è¦è§¦å‘è§†å›¾åˆ‡æ¢ï¼Œè®©ä»»åŠ¡æ¡è‡ªå·±çš„é€»è¾‘å¤„ç†
                if (e.target.closest('.task-block') || e.target.closest('.text-\\[11px\\]')) {
                    return;
                }

                const now = Date.now();
                // å¿…é¡»æ˜¯åŒä¸€ä¸ªæ—¥æœŸæ ¼å­ï¼Œä¸”é—´éš”å°äº 300ms
                if (now - lastMonthTap.time < 300 && lastMonthTap.date === dateStr) {
                    e.preventDefault();
                    window.triggerTouchHaptic('Light');
                    switchToWeek(dateStr);
                }
                lastMonthTap.time = now;
                lastMonthTap.date = dateStr;
            };

            // ğŸŸ¢ [æ–°å¢] æ— é™æ»šåŠ¨èŒƒå›´æ§åˆ¶
            const renderedRange = reactive({
                past: 6,   // åˆå§‹å¾€å›çœ‹ 6 ä¸ªæœˆ
                future: 18 // åˆå§‹å¾€åçœ‹ 18 ä¸ªæœˆ
            });
            const isLoadingMore = ref(false); // é˜²æŠ–é”

            // è¾…åŠ©ï¼šé…åˆ v-for æ”¶é›† DOM å¼•ç”¨
            const setMonthRef = (el) => {
                if (el) monthRefs.value.push(el);
            };

            const initMonthObserver = () => {
                if (monthObserver.value) monthObserver.value.disconnect();
                monthRefs.value = []; // æ¸…ç©ºæ—§å¼•ç”¨

                const options = {
                    root: document.getElementById('main-content'),
                    rootMargin: '0px 0px -90% 0px', // åˆ¤å®šçº¿è°ƒæ•´åˆ°é¡¶éƒ¨
                    threshold: 0
                };

                monthObserver.value = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // è¯»å–å•å…ƒæ ¼ä¸Šçš„ data-month-start
                            const dateStr = entry.target.dataset.monthStart;
                            if (dateStr) {
                                visibleTopDate.value = new Date(dateStr);
                            }
                        }
                    });
                }, options);

                // ç­‰å¾… DOM æ¸²æŸ“åè§‚å¯Ÿæ‰€æœ‰â€œ1å·â€çš„æ ¼å­
                setTimeout(() => {
                    // monthRefs åœ¨æ¨¡æ¿æ¸²æŸ“æ—¶ä¼šè‡ªåŠ¨å¡«å……
                    monthRefs.value.forEach((el) => {
                        monthObserver.value.observe(el);
                    });
                }, 100);
            };

// ç›‘å¬è§†å›¾æ¨¡å¼åˆ‡æ¢ï¼šåˆ‡åˆ°æ»šåŠ¨æ¨¡å¼æ—¶å¯åŠ¨è§‚å¯Ÿå™¨
            watch(monthViewMode, (newMode) => {
                if (newMode === 'scrolled') {
                    visibleTopDate.value = viewDate.value; // é‡ç½®ä¸ºå½“å‰ viewDate
                    nextTick(() => initMonthObserver());
                } else {
                    if (monthObserver.value) monthObserver.value.disconnect();
                }
            });


            const openCreditModal = () => {
                const sessId = currentSessionId.value;

                // 1. åˆå§‹åŒ–æ•°æ®å®¹å™¨
                const projectDataMap = {};

                const getProjData = (pid) => {
                    if (!projectDataMap[pid]) {
                        projectDataMap[pid] = {
                            name: getNameById(pid, 'project'), // è·å–é¡¹ç›®åŸºç¡€åç§°
                            // --- ç®¡å¼¦ä¹éƒ¨åˆ† ---
                            orch: {
                                strings: new Set(),
                                woodwinds: {},
                                brass: {},
                                percussion: {},
                                others: {}
                            },
                            orchTech: {
                                studios: new Set(), engineers: new Set(),
                                operators: new Set(), assistants: new Set()
                            },
                            // --- æ™®é€šä¹å™¨éƒ¨åˆ† ---
                            solo: {},
                            soloTech: {
                                studios: new Set(), engineers: new Set(),
                                operators: new Set(), assistants: new Set()
                            },
                            editors: new Set()
                        };
                    }
                    return projectDataMap[pid];
                };

                // --- æ ¸å¿ƒå‡½æ•°ï¼šåˆ¤æ–­ä¹å™¨åˆ†ç±» ---
                const getOrchCategory = (instName, musName) => {
                    const i = (instName || '').toLowerCase();
                    const m = (musName || '').toLowerCase();

                    if (/\b(violin|viola|cello|double\s*bass|contrabass)\b/.test(i)) return 'strings';
                    if (/\b(flute|piccolo|oboe|english\s*horn|cor\s*anglais|clarinet|bassoon|contrabassoon)\b/.test(i)) return 'woodwinds';
                    if (/\b(horn|trumpet|trombone|tuba|euphonium)\b/.test(i)) return 'brass';
                    if (/\b(timpani|snare|cymbal|gong|mark\s*tree|glockenspiel|xylophone|marimba|vibraphone|chimes|tubular\s*bells)\b/.test(i)) return 'percussion';
                    if (/\b(harp|celesta|celeste|piano|organ|harpsichord)\b/.test(i)) return 'others';

                    if (m.includes('string')) return 'strings';
                    if (m.includes('woodwind')) return 'woodwinds';
                    if (m.includes('brass')) return 'brass';
                    if (m.includes('percussion') || m.includes('perc ')) return 'percussion';

                    return null;
                };

                // è¾…åŠ©å‡½æ•°
                const addToMap = (targetMap, instrumentLabel, playerName) => {
                    if (!playerName || playerName === 'æœªçŸ¥æ¼”å¥å‘˜' || playerName === 'æœªé€‰æ‹©') return;
                    if (!targetMap[instrumentLabel]) targetMap[instrumentLabel] = new Set();
                    targetMap[instrumentLabel].add(playerName);
                };

                const addTechInfo = (targetTech, info) => {
                    if (!info) return;
                    const splitAndAdd = (str, set) => str && str.split(/[\/,]/).forEach(s => s.trim() && set.add(s.trim()));
                    splitAndAdd(info.studio, targetTech.studios);
                    splitAndAdd(info.engineer, targetTech.engineers);
                    splitAndAdd(info.operator, targetTech.operators);
                    splitAndAdd(info.assistant, targetTech.assistants);
                };

                // 2. éå†æ›²ç›® (ItemPool)
                const sessionItems = itemPool.value.filter(i => (i.sessionId || 'S_DEFAULT') === sessId);

                if (sessionItems.length === 0 && scheduledTasks.value.length === 0) {
                    openAlertModal("æ— æ•°æ®", "å½“å‰æ—¥ç¨‹è¡¨ä¸ºç©ºï¼Œæ— æ³•ç”Ÿæˆåå•ã€‚");
                    return;
                }

                sessionItems.forEach(item => {
                    if (item.isSkipped) return;

                    const pid = item.projectId || 'Unassigned';
                    const pData = getProjData(pid);

                    const instId = item.instrumentId;
                    const systemInstName = getNameById(instId, 'instrument');
                    const musId = item.musicianId;
                    const musName = getNameById(musId, 'musician');

                    const category = getOrchCategory(systemInstName, musName);
                    let hasDetailedInfo = false;

                    if (category) {
                        // Orchestra
                        if (category === 'percussion') {
                            const musicianSettings = settings.musicians.find(m => m.id === musId);
                            if (musicianSettings && musicianSettings.percConfig && musicianSettings.percConfig.tags.length > 0) {
                                musicianSettings.percConfig.tags.forEach(tag => {
                                    if (tag.assignedTo) {
                                        const assignedPlayer = musicianSettings.percConfig.players.find(p => p.id === tag.assignedTo);
                                        if (assignedPlayer) {
                                            addToMap(pData.orch.percussion, tag.name, assignedPlayer.name);
                                            hasDetailedInfo = true;
                                        }
                                    }
                                });
                            }
                        }

                        if (!hasDetailedInfo && item.roster && Object.keys(item.roster).length > 0) {
                            let targetMap = pData.orch[category];
                            Object.entries(item.roster).forEach(([key, playerName]) => {
                                if (!playerName || !playerName.trim()) return;
                                let instrumentLabel = key.split(/[._\d]/)[0].trim();
                                if (!instrumentLabel) instrumentLabel = systemInstName;

                                if (category === 'strings') {
                                    pData.orch.strings.add(playerName.trim());
                                } else {
                                    addToMap(targetMap, instrumentLabel, playerName.trim());
                                }
                                hasDetailedInfo = true;
                            });
                        }

                        if (!hasDetailedInfo) {
                            if (category === 'strings') {
                                if (musName) pData.orch.strings.add(musName);
                            } else {
                                addToMap(pData.orch[category], systemInstName, musName);
                            }
                        }

                    } else {
                        // Solo Instruments
                        addToMap(pData.solo, systemInstName, musName);
                    }
                });

                // 3. éå†æ—¥ç¨‹ (ScheduledTasks)
                const sessionTasks = scheduledTasks.value.filter(t => (t.sessionId || 'S_DEFAULT') === sessId);

                sessionTasks.forEach(task => {
                    // 1. ç¡®å®šé¡¹ç›®å½’å±
                    const currentTaskProjectIds = new Set();
                    if (task.projectId) {
                        currentTaskProjectIds.add(task.projectId);
                    } else {
                        if (task.musicianId) {
                            sessionItems.filter(i => i.musicianId === task.musicianId)
                                .forEach(i => i.projectId && currentTaskProjectIds.add(i.projectId));
                        }
                        if (task.instrumentId) {
                            sessionItems.filter(i => i.instrumentId === task.instrumentId)
                                .forEach(i => i.projectId && currentTaskProjectIds.add(i.projectId));
                        }
                    }

                    // 2. å¤„ç† Edit Info (éŸ³é¢‘ç¼–è¾‘)
                    if (task.editInfo) {
                        const edName = task.editInfo.engineer || task.editInfo.EditEngineer;
                        if (edName) {
                            currentTaskProjectIds.forEach(pid => {
                                const pData = getProjData(pid);
                                const names = edName.split(/[\/,]/);
                                names.forEach(n => {
                                    if (n && n.trim()) pData.editors.add(n.trim());
                                });
                            });
                        }
                    }

                    // 3. å¤„ç† Recording Info (å½•éŸ³æŠ€æœ¯äººå‘˜)
                    const info = task.recordingInfo;
                    if (!info) return;

                    let isOrchTask = false;
                    const relatedItems = sessionItems.filter(i => {
                        if (task.musicianId) return i.musicianId === task.musicianId;
                        if (task.instrumentId) return i.instrumentId === task.instrumentId;
                        return false;
                    });

                    if (relatedItems.length > 0) {
                        isOrchTask = relatedItems.some(i => {
                            const iName = getNameById(i.instrumentId, 'instrument');
                            const mName = getNameById(i.musicianId, 'musician');
                            return !!getOrchCategory(iName, mName);
                        });
                    } else {
                        const iName = getNameById(task.instrumentId, 'instrument');
                        const mName = getNameById(task.musicianId, 'musician');
                        isOrchTask = !!getOrchCategory(iName, mName);
                    }

                    currentTaskProjectIds.forEach(pid => {
                        const pData = getProjData(pid);
                        if (isOrchTask) {
                            addTechInfo(pData.orchTech, info);
                        } else {
                            addTechInfo(pData.soloTech, info);
                        }
                    });
                });

                // 4. ç”Ÿæˆæ–‡æœ¬
                const finalLines = [];
                const sortedPids = Object.keys(projectDataMap).sort((a, b) =>
                    projectDataMap[a].name.localeCompare(projectDataMap[b].name, 'zh-CN')
                );

                // è¾…åŠ©è¾“å‡ºå‡½æ•°
                const printTechBlock = (techData) => {
                    const join = (set) => Array.from(set).join(' / ');
                    if (techData.studios.size > 0) finalLines.push(`å½•éŸ³æ£š Recording Studioï¼š${join(techData.studios)}`);
                    if (techData.engineers.size > 0) finalLines.push(`å½•éŸ³å·¥ç¨‹å¸ˆ Recording Engineerï¼š${join(techData.engineers)}`);
                    if (techData.operators.size > 0) finalLines.push(`å½•éŸ³æ“ä½œå‘˜ Recording Operatorï¼š${join(techData.operators)}`);
                    if (techData.assistants.size > 0) finalLines.push(`å½•éŸ³å¸ˆåŠ©ç† Recording Assistantï¼š${join(techData.assistants)}`);
                };

                const printInstMap = (title, map) => {
                    const keys = Object.keys(map).sort();
                    if (keys.length > 0) {
                        if(title) {
                            finalLines.push("");
                            finalLines.push(`${title}ï¼š`);
                        }
                        keys.forEach(inst => {
                            const names = Array.from(map[inst]).join(' / ');
                            finalLines.push(`${inst}ï¼š${names}`);
                        });
                    }
                };

                sortedPids.forEach(pid => {
                    const d = projectDataMap[pid];

                    // ğŸŸ¢ è·å–é¡¹ç›®è¯¦ç»†å…ƒæ•°æ® (Project Info)
                    const projectMeta = settings.projects.find(p => p.id === pid) || {};

                    // åˆ¤æ–­æ˜¯å¦æœ‰å†…å®¹éœ€è¦è¾“å‡º (å¦‚æœæ˜¯ä¸€ä¸ªç©ºé¡¹ç›®ï¼Œä»€ä¹ˆéƒ½æ²¡å½•ï¼Œä¹Ÿæ²¡æœ‰è®¾ç½®ä¿¡æ¯ï¼Œåˆ™è·³è¿‡)
                    const hasSolo = Object.keys(d.solo).length > 0;
                    const isOrchEmpty = d.orch.strings.size === 0 &&
                        Object.keys(d.orch.woodwinds).length === 0 &&
                        Object.keys(d.orch.brass).length === 0 &&
                        Object.keys(d.orch.percussion).length === 0 &&
                        Object.keys(d.orch.others).length === 0;

                    // å¦‚æœæ˜¯ Unassigned ä¸”æ²¡æœ‰å½•éŸ³å†…å®¹ï¼Œæˆ–è€…æœ‰IDä½†æ²¡å†…å®¹ä¸”æ²¡å…ƒæ•°æ®ï¼Œåˆ™è·³è¿‡
                    if ((pid === 'Unassigned' && !hasSolo && isOrchEmpty) ||
                        (!hasSolo && isOrchEmpty && !projectMeta.title)) {
                        // å…è®¸æœ‰titleä½†æ²¡å½•éŸ³çš„é¡¹ç›®æ˜¾ç¤ºï¼Œä½œä¸ºå ä½
                        if(!projectMeta.title) return;
                    }

                    // --- 1. Header (Title, Composer, Arranger) ---
                    // ä½¿ç”¨ Project Info ä¸­çš„ Titleï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é¡¹ç›®å
                    const displayTitle = projectMeta.title || d.name;
                    finalLines.push(`æ›²ç›®åç§° Titleï¼š${displayTitle}`);
                    finalLines.push("");

                    if (projectMeta.composer) {
                        finalLines.push(`ä½œæ›² Composerï¼š${projectMeta.composer}`);
                        finalLines.push("");
                    }
                    if (projectMeta.arranger) {
                        finalLines.push(`ç¼–æ›² Arrangerï¼š${projectMeta.arranger}`);
                        finalLines.push("");
                    }

                    // --- 2. Orchestra Recording ---
                    if (!isOrchEmpty) {
                        finalLines.push("ç®¡å¼¦ä¹é˜Ÿå½•åˆ¶ï¼ˆOrchestra Recordingï¼‰");
                        finalLines.push("");
                        // è¿™é‡Œç›®å‰æ²¡æœ‰ Orchestra Name å­—æ®µï¼Œå¦‚æœå°†æ¥åŠ äº†å¯ä»¥åœ¨è¿™é‡Œè¾“å‡º
                        // finalLines.push(`ä¹é˜Ÿ Orchestraï¼š${projectMeta.orchestraName || '...'}`);
                        finalLines.push("æŒ‡æŒ¥ Conductorï¼š[è¯·å¡«å†™]");

                        if (d.orch.strings.size > 0) {
                            finalLines.push("");
                            finalLines.push("å¼¦ä¹ç»„ Stringsï¼š");
                            d.orch.strings.forEach(s => finalLines.push(s));
                        }

                        printInstMap("æœ¨ç®¡ç»„ Woodwinds", d.orch.woodwinds);
                        printInstMap("é“œç®¡ç»„ Brass", d.orch.brass);
                        printInstMap("æ‰“å‡»ä¹ç»„ Percussion", d.orch.percussion);
                        printInstMap("è‰²å½©ä¹å™¨ Keyboards & Harp", d.orch.others);

                        finalLines.push("");
                        printTechBlock(d.orchTech);
                        finalLines.push("");
                    }

                    // --- 3. Instruments Recording ---
                    if (hasSolo) {
                        finalLines.push("ä¹å™¨å½•åˆ¶ï¼ˆInstruments Recordingï¼‰");
                        finalLines.push("");
                        printInstMap("", d.solo); // ä¹å™¨åï¼šäººå

                        finalLines.push("");
                        printTechBlock(d.soloTech);
                        finalLines.push("");
                    }

                    // --- 4. Post Production (Mixing, Mastering, Editing) ---
                    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•åæœŸä¿¡æ¯
                    const hasPostInfo = (d.editors && d.editors.size > 0) ||
                        projectMeta.mixingEngineer ||
                        projectMeta.mixingStudio ||
                        projectMeta.masteringEngineer ||
                        projectMeta.masteringStudio ||
                        projectMeta.dolbyStudio;

                    if (hasPostInfo) {
                        finalLines.push(""); // ä¸ä¸Šæ–‡éš”å¼€
                        finalLines.push("å£°éŸ³åæœŸåˆ¶ä½œï¼ˆEditing, Mixing & Masteringï¼‰");
                        finalLines.push("");

                        // éŸ³é¢‘ç¼–è¾‘ (æ¥è‡ª Edit Info å¼¹çª—)
                        if (d.editors && d.editors.size > 0) {
                            finalLines.push(`éŸ³é¢‘ç¼–è¾‘ Audio Editorï¼š${[...d.editors].join(' / ')}`);
                        }

                        // æ··éŸ³ & æ¯å¸¦ (æ¥è‡ª Project Info å¼¹çª—)
                        if (projectMeta.mixingEngineer) finalLines.push(`æ··éŸ³å·¥ç¨‹å¸ˆ Mixing Engineerï¼š${projectMeta.mixingEngineer}`);
                        if (projectMeta.mixingStudio) finalLines.push(`æ··éŸ³å·¥ä½œå®¤ Mixing Studioï¼š${projectMeta.mixingStudio}`);

                        if (projectMeta.masteringEngineer) finalLines.push(`æ¯å¸¦å·¥ç¨‹å¸ˆ Mastering Engineerï¼š${projectMeta.masteringEngineer}`);
                        if (projectMeta.masteringStudio) finalLines.push(`æ¯å¸¦å·¥ä½œå®¤ Mastering Studioï¼š${projectMeta.masteringStudio}`);

                        if (projectMeta.dolbyStudio) finalLines.push(`æœæ¯”å…¨æ™¯å£°æ¯å¸¦å·¥ä½œå®¤ Dolby Atmos Mastering Studioï¼š${projectMeta.dolbyStudio}`);
                    }

                    // --- 5. Production & Publishing ---
                    if (projectMeta.producer) {
                        finalLines.push("");
                        finalLines.push("éŸ³ä¹åˆ¶ä½œäººï¼ˆMusic Producerï¼‰");
                        finalLines.push(projectMeta.producer);
                    }

                    if (projectMeta.publishedBy) {
                        finalLines.push("");
                        finalLines.push("å‘è¡Œï¼ˆPublished byï¼‰");
                        finalLines.push(projectMeta.publishedBy);
                    }

                    if (projectMeta.producedBy) {
                        finalLines.push("");
                        finalLines.push("å‡ºå“ï¼ˆProduced byï¼‰");
                        finalLines.push(projectMeta.producedBy);
                    }

                    finalLines.push("------------------------------------------------");
                    finalLines.push("");
                });

                generatedCreditText.value = finalLines.join('\n');
                showCreditModal.value = true;
            };

            const copyCreditText = () => {
                if (!generatedCreditText.value) return;
                navigator.clipboard.writeText(generatedCreditText.value).then(() => {
                    window.triggerTouchHaptic('Success');
                    // æŒ‰é’®æ–‡å­—å˜ä¸€ä¸‹åé¦ˆ (å¯é€‰)
                    const btn = document.querySelector('.modal-window button i.fa-copy')?.parentNode;
                    if(btn) {
                        const originalText = btn.innerHTML;
                        btn.innerHTML = '<i class="fa-solid fa-check"></i> å·²å¤åˆ¶';
                        setTimeout(() => btn.innerHTML = originalText, 2000);
                    }
                });
            };

            // ğŸŸ¢ [æ–°å¢] æ£€æŸ¥æ˜¯å¦å…è®¸åˆ é™¤ (åªå…è®¸åˆ é™¤é“¾æ¡çš„æœ«ç«¯)
            const checkCanDeleteSplit = (item) => {
                // 1. æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•ä»»åŠ¡çš„ splitFromId æŒ‡å‘å½“å‰ä»»åŠ¡
                // å¦‚æœæœ‰ï¼Œè¯´æ˜å½“å‰ä»»åŠ¡æ˜¯"çˆ¶çº§" (ä¾‹å¦‚å®ƒæ˜¯ Part 2ï¼Œä¸”å­˜åœ¨ Part 3)ï¼Œåˆ™ä¸èƒ½åˆ 
                const directChild = itemPool.value.find(t => t.splitFromId === item.id);

                if (directChild) {
                    const childName = directChild.splitTag || 'åç»­éƒ¨åˆ†';
                    openAlertModal(
                        'æ— æ³•åˆ é™¤',
                        `æ£€æµ‹åˆ°åç»­ä»»åŠ¡ ${childName} å­˜åœ¨ã€‚\n\nä¸ºäº†ä¿è¯æ—¶é—´è®¡ç®—æ­£ç¡®ï¼Œè¯·åŠ¡å¿…æŒ‰é¡ºåºå…ˆåˆ é™¤æœ€åä¸€ä¸ª Partï¼Œæ‰èƒ½é€çº§å½’è¿˜æ—¶é—´ã€‚`
                    );
                    window.triggerTouchHaptic('Error');
                    return false; // ç¦æ­¢åˆ é™¤
                }

                return true; // å…è®¸åˆ é™¤
            };



            // ğŸŸ¢ [æ–°å¢] è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æŸä¸ªä»»åŠ¡åŠå…¶æ‰€æœ‰åˆ†èº«çš„æ€»æ—¶é•¿
            const getFamilyTotalDuration = (targetItem) => {
                // 1. æ‰¾åˆ°æ ¹èŠ‚ç‚¹ ID (å¦‚æœæ˜¯å­ä»»åŠ¡ï¼Œå– splitFromIdï¼›å¦‚æœæ˜¯æ ¹ä»»åŠ¡ï¼Œå–è‡ªèº« ID)
                const rootId = targetItem.splitFromId || targetItem.id;

                // 2. åœ¨ä»»åŠ¡æ± ä¸­æ‰¾åˆ°æ•´ä¸ªå®¶æ— (æ ¹èŠ‚ç‚¹ + æ‰€æœ‰å­èŠ‚ç‚¹)
                // æ³¨æ„ï¼šè¿™é‡Œåªç­›é€‰ ID åŒ¹é…ï¼Œä¸ç­›é€‰ Sessionï¼Œå› ä¸º splitFromId æ˜¯è·¨ Session å”¯ä¸€çš„
                const familyMembers = itemPool.value.filter(i => i.id === rootId || i.splitFromId === rootId);

                // 3. ç´¯åŠ æ‰€æœ‰æˆå‘˜çš„ musicDuration
                const totalSeconds = familyMembers.reduce((sum, item) => {
                    return sum + parseTime(item.musicDuration || '00:00');
                }, 0);

                return totalSeconds;
            };

            // ğŸŸ¢ [ä¿®æ”¹] ç¼–åˆ¶é¢„è®¾ (æ”¹ä¸ºæ˜¾å¼åç§°æ ¼å¼)
            const activeOrchPresets = computed(() => {
                const instId = editingItem.value.instrumentId;
                // é»˜è®¤æœ¨ç®¡é…ç½®
                if (!instId) return { full: '2 Fl, 2 Ob, 2 Cl, 2 Bsn', std: '1 Fl, 1 Ob, 1 Cl, 1 Bsn' };

                const inst = settings.instruments.find(i => i.id === instId);
                const text = inst ? `${inst.name} ${inst.group || ''}`.toLowerCase() : '';

                // 1. Strings (å¼¦ä¹)
                if (/string|str|vln|vla|vc|db|violin|cello|viola/.test(text)) {
                    return {
                        full: '12 Vln1, 10 Vln2, 8 Vla, 8 Vc, 6 Db',
                        std: '8 Vln1, 6 Vln2, 4 Vla, 4 Vc, 3 Db'
                    };
                }

                // 2. Brass (é“œç®¡)
                if (/brass|hn|tpt|tbn|tba|horn|trumpet|trombone|tuba/.test(text)) {
                    return {
                        full: '4 Hn, 3 Tpt, 3 Tbn, 1 Tba',
                        std: '4 Hn, 2 Tpt, 2 Tbn'
                    };
                }

                // 3. Woodwinds (æœ¨ç®¡ - é»˜è®¤)
                return {
                    full: '3 Fl, 3 Ob, 3 Cl, 3 Bsn',
                    std: '2 Fl, 2 Ob, 2 Cl, 2 Bsn'
                };
            });


            const orchTemplates = {
                'Brass': ['Hn', 'Tpt', 'Tbn', 'B. Tbn', 'Tba'],
                'Woodwinds':['Fl', 'Picc', 'Ob', 'E. H.', 'Cl', 'B. Cl', 'Bsn', 'C. Bsn'],
                'Strings': ['Vln1', 'Vln2', 'Vla', 'Vc', 'Db']
            };

            // ğŸŸ¢ [ä¿®æ”¹] è§£æç¼–åˆ¶å­—ç¬¦ä¸² (åŠ¨æ€æ¨¡å¼)
            // è¾“å…¥: "4 Fl, 2 Ob, 12 Vln1"
            // è¾“å‡º: åŠ¨æ€ç”Ÿæˆå¯¹åº”æ•°é‡çš„è¾“å…¥æ¡†
            const parsedRoster = computed(() => {
                const code = editingItem.value.orchestration || '';

                // 1. åˆ†å‰²å­—ç¬¦ä¸²ï¼šæ”¯æŒé€—å·(,) åŠ å·(+) æˆ–åˆ†å·(;) åˆ†éš”
                // è¿‡æ»¤æ‰ç©ºå­—ç¬¦ä¸²
                const parts = code.split(/[,+;]/).map(s => s.trim()).filter(s => s);

                const result = [];

                parts.forEach((part, index) => {
                    // 2. æ­£åˆ™åŒ¹é…ï¼šä»¥æ•°å­—å¼€å¤´ï¼Œåé¢è·Ÿç€åç§°
                    // æ•è·ç»„ 1: æ•°å­— (\d+)
                    // æ•è·ç»„ 2: åç§° (å‰©ä¸‹çš„éƒ¨åˆ†)
                    const match = part.match(/^(\d+)\s*(.*)$/);

                    if (match) {
                        const count = parseInt(match[1], 10);
                        // å¦‚æœæ²¡æœ‰å†™åå­—(ä¾‹å¦‚åªå†™äº†"4")ï¼Œåˆ™ä½¿ç”¨é»˜è®¤åç§° "Player"
                        const label = match[2].trim() || 'Player';

                        if (count > 0) {
                            result.push({
                                label: label,
                                count: count,
                                // ä½¿ç”¨ label ä½œä¸ºå‰ç¼€ï¼Œç¡®ä¿ rosters å¯¹è±¡ä¸­çš„ key å”¯ä¸€
                                // ä¾‹å¦‚: "Fl._1", "Fl._2"
                                startIndex: 0
                            });
                        }
                    }
                });

                return result;
            });

            // åˆå§‹åŒ–/è·å–äººå‘˜åå•å¯¹è±¡
            const getRosterName = (sectionLabel, index) => {
                if (!editingItem.value.roster) editingItem.value.roster = {};
                const key = `${sectionLabel}_${index + 1}`;
                return editingItem.value.roster[key] || '';
            };

            // æ›´æ–°äººå‘˜åå•
            const updateRosterName = (sectionLabel, index, value) => {
                if (!editingItem.value.roster) editingItem.value.roster = {};
                const key = `${sectionLabel}_${index + 1}`;
                editingItem.value.roster[key] = value;
            };

            // --- ğŸŸ¢ æ–°å¢ï¼šåˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºç¼–åˆ¶/åå•è¾“å…¥æ¡† ---
            const showOrchestrationField = computed(() => {
                const instId = editingItem.value.instrumentId;
                if (!instId) return false;

                // 1. æ‰¾åˆ°å½“å‰ä¹å™¨å¯¹è±¡
                const inst = settings.instruments.find(i => i.id === instId);
                if (!inst) return false;

                // 2. æ‹¼æ¥ åç§° å’Œ åˆ†ç»„ (è½¬å°å†™)
                const text = `${inst.name} ${inst.group || ''}`.toLowerCase();

                // 3. å…³é”®è¯åŒ¹é… (æ”¯æŒ Brass, Woodwind, String, Wind, Str ç­‰)
                // åªè¦åç§°æˆ–åˆ†ç»„é‡ŒåŒ…å«è¿™äº›è¯ï¼Œå°±æ˜¾ç¤º
                return /brass|woodwind|string|str|wind/.test(text);
            });

            // --- ğŸ¥ æ™ºèƒ½æ‰“å‡»ä¹å¤„ç†é€»è¾‘ (Smart Percussion) ---

            // 1. å®šä¹‰æ‰“å‡»ä¹å…³é”®è¯æ˜ å°„è¡¨ (æ ¹æ®ä½ çš„æˆªå›¾å¤§å¹…æ‰©å……)
            const percKeywords = {
                // åŸºç¡€ç±»
                'Snare': 'SD', 'Drum': 'Dr', 'Bass': 'BD', 'Kick': 'BD',
                'Cymbal': 'Cym', 'Piatti': 'Piatti', 'Crash': 'Cym', 'Sus': 'SusCym',
                'Timpani': 'Timp', 'Gong': 'Gong', 'Tam': 'Tam', 'Tubular':'TB',

                // ä½ çš„æˆªå›¾ç‰¹å®šä¹å™¨
                'Anvil': 'Anv',       // é“ç §
                'Cabasa': 'Cab',      // å¡å·´è¨
                'Castanets': 'Cast',  // å“æ¿
                'Bell': 'Bell',       // å„ç§é“ƒ (China Bell, LP Bell, SL Bell)
                'Cowbell': 'CB',      // ç‰›é“ƒ
                'Guiro': 'Guiro',     // åˆ®ç“œ
                'Mark Tree': 'Tree',  // éŸ³æ ‘
                'Ratchet': 'Ratch',   // æ£˜è½®
                'Whistle': 'Whis',    // å“¨å­ (Samba Whistle)
                'Shaker': 'Shk',      // æ²™é”¤ (Plastic, Metal, Wooden)
                'Shells': 'Shells',   // è´å£³é£é“ƒ
                'Sleigh': 'SlBell',   // é›ªæ©‡é“ƒ
                'Whip': 'Whip',       // é­å“
                'Wood Block': 'WB',   // æœ¨é±¼/æœ¨ç›’
                'Block': 'Blk',
                'Tamb': 'Tamb',       // é“ƒé¼“
                'Tri': 'Tri',         // ä¸‰è§’é“
                'Vib': 'Vib', 'Xylo': 'Xyl', 'Glock': 'Glk', 'Chime': 'Chm',
                'Crot': 'Crot', 'Stick': 'Stk', 'Clap': 'Clap'
            };

            // 1. çŠ¶æ€å˜é‡
            const percState = reactive({
                tags: [],
                players: [],
                selectedTagIndices: new Set()
            });

            // 3. åˆ¤æ–­å½“å‰æ˜¯å¦ä¸ºæ‰“å‡»ä¹ç¼–è¾‘æ¨¡å¼ (ä¿®æ­£: æ£€æŸ¥èŒƒå›´æ›´å¹¿)
            const isPercussionMode = computed(() => {
                const instName = getNameById(editingItem.value.instrumentId, 'instrument').toLowerCase();
                const musicianName = getNameById(editingItem.value.musicianId, 'musician').toLowerCase();
                const groupName = (settings.instruments.find(i => i.id === editingItem.value.instrumentId)?.group || '').toLowerCase();

                // è§¦å‘è¯ï¼šåªè¦å‘½ä¸­è¿™äº›è¯ï¼Œå°±è§†ä¸ºæ‰“å‡»ä¹ä»»åŠ¡ï¼Œå¼€å¯åˆ†éƒ¨é¢æ¿
                // åŒ…å«äº† "Percussion" (åŒ¹é…ä½ çš„ SPO Percussion Player)
                const triggers = ['perc'];

                return triggers.some(t => instName.includes(t) || musicianName.includes(t) || groupName.includes(t));
            });

            // 4. æ ¸å¿ƒï¼šæ‰«æå¹¶ç”Ÿæˆ/æ¢å¤æ ‡ç­¾ (ä¿®å¤: è¯»å–æ¼”å¥å‘˜å­˜æ¡£å®ç°æŒä¹…åŒ–)
            const scanPercussionTags = () => {
                // 1. è·å–å½“å‰æ¼”å¥å‘˜å¯¹è±¡ (ä½œä¸ºé…ç½®çš„å­˜å‚¨è½½ä½“)
                const musician = settings.musicians.find(m => m.id === editingItem.value.musicianId);

                // åˆå§‹åŒ–ä¸´æ—¶åˆ—è¡¨
                let currentTags = [];
                let currentPlayers = [];

                // 2. å°è¯•è¯»å–è¯¥æ¼”å¥å‘˜å·²ä¿å­˜çš„é…ç½®
                if (musician && musician.percConfig) {
                    // æ·±æ‹·è´ä»¥æ–­å¼€å¼•ç”¨ï¼Œé˜²æ­¢ä¿®æ”¹æœªä¿å­˜æ—¶æ±¡æŸ“æºæ•°æ®
                    currentTags = JSON.parse(JSON.stringify(musician.percConfig.tags));
                    currentPlayers = JSON.parse(JSON.stringify(musician.percConfig.players));
                } else {
                    // å¦‚æœæ²¡æœ‰å­˜æ¡£ï¼Œåˆå§‹åŒ–é»˜è®¤æ¼”å¥å‘˜
                    currentPlayers = [{ id: 1, name: 'Perc 1', tags: [] }];
                }

                // 3. æ‰«æå½“å‰ Session ä¸‹è¯¥äººçš„æ‰€æœ‰ä»»åŠ¡ï¼Œæ‰¾å‡ºæ‰€æœ‰æ¶‰åŠçš„ä¹å™¨
                // (ç›®çš„æ˜¯å‘ç°æ–°æ·»åŠ çš„ä»»åŠ¡/ä¹å™¨ï¼Œå¹¶åˆå¹¶åˆ°ç°æœ‰é…ç½®ä¸­)
                let relatedItems = [];
                if (sidebarTab.value === 'musician' && editingItem.value.musicianId) {
                    relatedItems = itemPool.value.filter(i => i.musicianId === editingItem.value.musicianId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                } else if (editingItem.value.instrumentId) {
                    relatedItems = itemPool.value.filter(i => i.instrumentId === editingItem.value.instrumentId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                }

                relatedItems.forEach(item => {
                    const rawName = getNameById(item.instrumentId, 'instrument');

                    // æ£€æŸ¥è¿™ä¸ªä¹å™¨æ˜¯å¦å·²ç»åœ¨ tags é‡Œäº†
                    // ğŸŸ¢ ä¿®å¤: åªæœ‰å½“å®ƒæ˜¯æ–°ä¹å™¨æ—¶æ‰æ·»åŠ 
                    if (rawName && !currentTags.some(t => t.fullName === rawName)) {
                        currentTags.push({
                            name: rawName,
                            fullName: rawName,
                            assignedTo: null // æ–°ä¹å™¨é»˜è®¤æœªåˆ†é…
                        });
                    }
                });

                // 4. æ’åº (è®©ç•Œé¢æ•´æ´)
                currentTags.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

                // 5. èµ‹å€¼ç»™å“åº”å¼çŠ¶æ€
                percState.tags = currentTags;
                percState.players = currentPlayers;
                percState.selectedTagIndices.clear();
            };

            // 5. æ·»åŠ æ¼”å¥å‘˜
            const addPercPlayer = () => {
                const id = percState.players.length + 1;
                percState.players.push({
                    id: id,
                    name: `Perc ${id}`,
                    tags: []
                });
            };

            // 6. ç§»é™¤æ¼”å¥å‘˜
            const removePercPlayer = (idx) => {
                const player = percState.players[idx];
                // æŠŠè¯¥äººçš„æ ‡ç­¾é‡Šæ”¾å›æœªåˆ†é…çŠ¶æ€
                percState.tags.forEach(t => {
                    if (t.assignedTo === player.id) t.assignedTo = null;
                });
                percState.players.splice(idx, 1);

                // ğŸŸ¢ è§¦å‘ä¿å­˜å’ŒåŒæ­¥
                updatePercOrchestration();
            };

            // 7. åˆ†é…é€»è¾‘ï¼šç‚¹å‡»æ ‡ç­¾
            const togglePercTagSelect = (index) => {
                if (percState.selectedTagIndices.has(index)) {
                    percState.selectedTagIndices.delete(index);
                } else {
                    percState.selectedTagIndices.add(index);
                }
            };

            // 8. åˆ†é…é€»è¾‘ï¼šç‚¹å‡»æ¼”å¥å‘˜ (å°†é€‰ä¸­çš„æ ‡ç­¾ç»™è¿™ä¸ªäºº)
            const assignTagsToPlayer = (playerId) => {
                if (percState.selectedTagIndices.size === 0) return;

                percState.selectedTagIndices.forEach(idx => {
                    const tag = percState.tags[idx];
                    tag.assignedTo = playerId;
                });

                percState.selectedTagIndices.clear(); // æ¸…ç©ºé€‰æ‹©
                window.triggerTouchHaptic('Medium');
                updatePercOrchestration();
            };

            // 9. æ›´æ–°æœ€ç»ˆå­—ç¬¦ä¸²å¹¶åŒæ­¥ç»™åŒç»„æ‰€æœ‰ä»»åŠ¡ (ä¿®å¤: æŒä¹…åŒ–å­˜å‚¨ + å…¨å±€åŒæ­¥)
            const updatePercOrchestration = () => {
                // A. ç”Ÿæˆ Roster å¯¹è±¡å’Œæ‘˜è¦å­—ç¬¦ä¸²
                const newRoster = {};
                const summaryParts = [];

                percState.players.forEach(p => {
                    // æ‰¾åˆ°å½’å±è¯¥äººçš„æ ‡ç­¾
                    const myTags = percState.tags
                        .filter(t => t.assignedTo === p.id)
                        .map(t => t.name);

                    const uniqueTags = [...new Set(myTags)];
                    const tagStr = uniqueTags.length > 0 ? ` (${uniqueTags.join(', ')})` : '';

                    newRoster[`Player_${p.id}`] = p.name;
                    summaryParts.push(`${p.name}${tagStr}`);
                });

                const finalOrchString = summaryParts.join(', ');

                // B. æ›´æ–°å½“å‰æ­£åœ¨ç¼–è¾‘çš„ä»»åŠ¡ (UIæ˜¾ç¤º)
                editingItem.value.roster = newRoster;
                editingItem.value.orchestration = finalOrchString;

                // C. ğŸŸ¢ æ ¸å¿ƒä¿®å¤: ä¿å­˜é…ç½®åˆ°æ¼”å¥å‘˜å¯¹è±¡ (æŒä¹…åŒ–)
                const musician = settings.musicians.find(m => m.id === editingItem.value.musicianId);
                if (musician) {
                    musician.percConfig = {
                        tags: JSON.parse(JSON.stringify(percState.tags)),
                        players: JSON.parse(JSON.stringify(percState.players))
                    };
                }

                // D. ğŸŸ¢ æ ¸å¿ƒä¿®å¤: åŒæ­¥æ›´æ–°è¯¥æ¼”å¥å‘˜çš„æ‰€æœ‰ä»»åŠ¡ (åŒæ­¥åŒ–)
                // è¿™æ ·ä½ åœ¨ä¸€ä¸ªä»»åŠ¡é‡Œåˆ†å¥½äº†ï¼Œå…¶ä»–ä»»åŠ¡å¡ç‰‡ä¸Šçš„æ–‡å­—ä¹Ÿä¼šè·Ÿç€å˜
                if (musician) {
                    // 1. æ›´æ–°ä»»åŠ¡æ± 
                    itemPool.value.forEach(item => {
                        if (item.musicianId === musician.id && (item.sessionId || 'S_DEFAULT') === currentSessionId.value) {
                            item.orchestration = finalOrchString;
                            item.roster = JSON.parse(JSON.stringify(newRoster));
                        }
                    });

                    // 2. æ›´æ–°æ—¥ç¨‹è¡¨
                    scheduledTasks.value.forEach(task => {
                        if (task.musicianId === musician.id && (task.sessionId || 'S_DEFAULT') === currentSessionId.value) {
                            // æ³¨æ„: æ—¥ç¨‹è¡¨é‡Œçš„ä»»åŠ¡å¯èƒ½æ²¡æœ‰ roster å­—æ®µç»“æ„ï¼Œä¸»è¦æ›´æ–° orchestration ç”¨äºæ˜¾ç¤º
                            task.orchestration = finalOrchString;
                            // task.roster = ... (å¦‚æœéœ€è¦çš„è¯ä¹Ÿå¯ä»¥å­˜)
                        }
                    });
                }

                // E. ä¿å­˜å†å²
                // (æ³¨æ„ï¼šè¿™é‡Œå¦‚æœé¢‘ç¹è§¦å‘å¯èƒ½ä¼šå¯¼è‡´å†å²è®°å½•è¿‡å¤šï¼Œå¯ä»¥è€ƒè™‘åŠ ä¸ªé˜²æŠ–ï¼Œæˆ–è€…åªåœ¨å…³é—­å¼¹çª—æ—¶ pushHistory)
                // pushHistory();
            };

            // 10. ç›‘å¬ Modal æ‰“å¼€ï¼Œå¦‚æœæ˜¯æ‰“å‡»ä¹ä¸”æ²¡æœ‰æ•°æ®ï¼Œè‡ªåŠ¨æ‰«æ
            watch(() => showEditor.value, (val) => {
                if (val && isPercussionMode.value) {
                    // å¦‚æœ Orchestration æ˜¯ç©ºçš„ï¼Œæˆ–è€…çœ‹èµ·æ¥ä¸åƒå·²ç»æ‰‹åŠ¨ç¼–è¾‘è¿‡çš„ï¼Œå°±è‡ªåŠ¨æ‰«æ
                    if (!editingItem.value.orchestration) {
                        scanPercussionTags();
                    }
                }
            });

            // ğŸŸ¢ [è¾…åŠ©å‡½æ•°] è·å–å¸¦åˆ†ç»„çš„å®Œæ•´åç§° (ç”¨äºæœç´¢)
            const getNameWithGroup = (id, type) => {
                if (!id) return '';
                let list = [];
                // æ ¹æ®ç±»å‹è·å–å¯¹åº”åˆ—è¡¨
                if (type === 'project') list = settings.projects;
                else if (type === 'instrument') list = settings.instruments;
                else list = settings.musicians;

                // ä½¿ç”¨ loose equality (==) å…¼å®¹å­—ç¬¦ä¸²/æ•°å­— ID
                const item = list.find(i => i.id == id);
                // è¿”å› "åç§° + åˆ†ç»„"
                return item ? `${item.name} ${item.group || ''}` : '';
            };

            // --- ğŸŸ¢ æœç´¢è¾…åŠ©å‡½æ•° (æ”¾åœ¨ setup å†…éƒ¨é å‰çš„ä½ç½®) ---
            const smartMatch = (text, keyword) => {
                if (!text) return false;
                const lowerText = text.toLowerCase();
                // 1. åŸæ–‡åŒ…å«
                if (lowerText.includes(keyword)) return true;
                // 2. å»ç©ºæ ¼åŒ…å« (åŒ¹é…è‹±æ–‡åå¦‚ "Yi Li" -> "yili")
                if (lowerText.replace(/\s/g, '').includes(keyword)) return true;
                // 3. æ‹¼éŸ³åŒ¹é…
                if (window.pinyinPro && window.pinyinPro.match) {
                    return !!window.pinyinPro.match(text, keyword, { continuous: true });
                }
                return false;
            };

            // ğŸŸ¢ [ä¿®æ”¹] è·å–ç”¨äºæœç´¢çš„ç»„åˆæ–‡æœ¬ (åŠ å…¥åˆ†ç»„ä¿¡æ¯)
            const getFullSearchText = (task, groupName) => {
                // åŸä»£ç ï¼š
                // const mText = getNameById(task.musicianId, 'musician');
                // const pText = getNameById(task.projectId, 'project');
                // const iText = getNameById(task.instrumentId, 'instrument');

                // ğŸŸ¢ ä¿®æ”¹åï¼šä½¿ç”¨ getNameWithGroup è·å–å¸¦åˆ†ç»„çš„æ–‡æœ¬
                const mText = getNameWithGroup(task.musicianId, 'musician');
                const pText = getNameWithGroup(task.projectId, 'project');
                const iText = getNameWithGroup(task.instrumentId, 'instrument');

                // è·å–å½•éŸ³ä¿¡æ¯
                const info = task.recordingInfo || {};
                const infoText = [
                    info.studio, info.engineer, info.operator,
                    info.assistant, info.notes
                ].join(' ');

                // ç»„åˆæ‰€æœ‰ç›¸å…³æ–‡æœ¬
                return `${groupName} ${mText} ${pText} ${iText} ${task.splitTag || ''} ${infoText}`;
            };

            // æ·»åŠ ä¸€ä¸ªå¤„ç†å¤±ç„¦çš„å‡½æ•° (åŠ ä¸€ç‚¹å»¶è¿Ÿï¼Œé˜²æ­¢ç‚¹å‡»"æ¸…é™¤"æŒ‰é’®æ—¶è¿˜æ²¡è§¦å‘å°±è·‘äº†)
            const handleSearchBlur = () => {
                // å»¶è¿Ÿ 100msï¼Œå¦‚æœåªæ˜¯ç‚¹äº†æ¸…é™¤æŒ‰é’®ï¼Œä¸è¦ç«‹åˆ»æ”¶å›å»
                setTimeout(() => {
                    // åªæœ‰å½“ globalSearchQuery ä¸ºç©ºæ—¶ï¼Œæ‰æ”¶å›åº•éƒ¨
                    // æˆ–è€…ä½ å¯ä»¥é€‰æ‹©ï¼šåªè¦å¤±ç„¦å°±æ”¶å› (æ ¹æ®ä½ çš„å–œå¥½ï¼Œè¿™é‡Œæ¨èåªè¦å¤±ç„¦å°±æ”¶å›)
                    isSearchFocused.value = false;

                    // å¤±ç„¦æ—¶å¼ºåˆ¶æ”¶èµ·é”®ç›˜
                    if (document.activeElement instanceof HTMLElement) {
                        document.activeElement.blur();
                    }
                }, 100);
            };

            const onSearchFocus = () => {
                isSearchFocused.value = true;

                // âš¡ï¸ å¼ºåŠ›ä¿®æ­£: å»¶è¿Ÿä¸€ä¸‹ï¼Œç­‰é”®ç›˜å¼¹å‡ºæ¥é‚£ä¸€åˆ»ï¼ŒæŠŠé¡µé¢æŒ‰å›å»
                setTimeout(() => {
                    window.scrollTo(0, 0);
                    document.body.scrollTop = 0;
                }, 100);

                // åŒé‡ä¿é™©: 300ms åå†æŒ‰ä¸€æ¬¡ (å¯¹åº”æŸäº›æ…¢é€ŸåŠ¨ç”»)
                setTimeout(() => {
                    window.scrollTo(0, 0);
                }, 300);
            };

            // 1. å¼€å§‹æ‹–æ‹½ä»»åŠ¡ (ä¿®å¤ç‰ˆ: åˆ†å‰²æ¡ä¹Ÿä¼šé¿è®©)
            const startTrackDrag = (e, item) => {
                // A. ğŸ›¡ï¸ é˜²è¯¯è§¦æ£€æµ‹
                if (e.target.closest('input, button, select, i.fa-trash-can, i.fa-scissors, i.fa-eraser, .cursor-pointer')) {
                    return;
                }

                if (trackDragState || dividerDragState) return;

                const isTouch = e.type === 'touchstart';
                const triggerEl = e.currentTarget; // è¢«æ‹–æ‹½çš„å¡ç‰‡
                const touch = isTouch ? e.touches[0] : e;

                const executeDrag = () => {
                    // 1. è§†è§‰åé¦ˆï¼šåŸå…ƒç´ å½»åº•é€æ˜
                    triggerEl.style.setProperty('opacity', '0', 'important');

                    const rect = triggerEl.getBoundingClientRect();
                    const container = trackListContainerRef.value;
                    const initialScrollTop = container ? container.scrollTop : 0;

                    // ğŸŸ¢ å…³é”®ä¿®æ”¹ 1: è·å–æ‰€æœ‰â€œå¯ç§»åŠ¨å…ƒç´ â€ (åŒ…å«å¡ç‰‡ å’Œ åˆ†å‰²æ¡)
                    // æ³¨æ„: Tailwind çš„ group/divider ç±»åä¸­æœ‰æ–œæ ï¼Œéœ€è¦è½¬ä¹‰
                    const allMovableEls = Array.from(container.querySelectorAll('.track-card, .group\\/divider'));

                    // æ‰¾åˆ°è‡ªå·±åœ¨ DOM ä¸­çš„ç´¢å¼• (Visual Index)
                    const domStartIndex = allMovableEls.indexOf(triggerEl);
                    if (domStartIndex === -1) return;

                    // æ‰¾åˆ°è‡ªå·±åœ¨ Data æ•°ç»„ä¸­çš„ç´¢å¼• (Data Index)
                    const dataStartIndex = trackListData.value.items.findIndex(i => i.id === item.id);

                    // è®¡ç®—æ‰€æœ‰å…ƒç´ çš„é«˜åº¦ (å«margin)
                    const elementHeights = allMovableEls.map(el => {
                        const style = window.getComputedStyle(el);
                        return el.offsetHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
                    });

                    // 2. åˆ›å»ºæ›¿èº«
                    const ghost = triggerEl.cloneNode(true);
                    ghost.style.opacity = '1';
                    ghost.classList.remove('hover:border-white/10', 'group');
                    Object.assign(ghost.style, {
                        position: 'fixed', top: `${rect.top}px`, left: `${rect.left}px`,
                        width: `${rect.width}px`, height: `${rect.height}px`,
                        zIndex: '10000',
                        backgroundColor: isDark.value ? '#2c2c2e' : '##F4F4F5',
                        boxShadow: '0 10px 25px rgba(0,0,0,0.3)',
                        transform: 'scale(1.02)',
                        transition: 'none',
                        pointerEvents: 'none',
                        borderRadius: '8px'
                    });
                    document.body.appendChild(ghost);

                    // 3. åˆå§‹åŒ–çŠ¶æ€
                    trackDragState = {
                        item,
                        targetEl: triggerEl,
                        ghost,

                        allMovableEls,      // ğŸŸ¢ å­˜å‚¨æ‰€æœ‰å…ƒç´ (å¡ç‰‡+åˆ†å‰²æ¡)
                        elementHeights,     // ğŸŸ¢ å­˜å‚¨æ‰€æœ‰é«˜åº¦
                        itemHeight: elementHeights[domStartIndex], // å½“å‰è¢«æ‹–å…ƒç´ çš„é«˜åº¦

                        fingerOffset: touch.clientY - rect.top,
                        lastClientY: touch.clientY,
                        lastScrollTop: initialScrollTop,
                        cumulativeDelta: 0,

                        domStartIndex,      // åˆå§‹ DOM ç´¢å¼•
                        virtualDomIndex: domStartIndex, // å½“å‰è§†è§‰æ‰€åœ¨çš„ DOM ç´¢å¼•

                        dataStartIndex,     // åˆå§‹æ•°æ®ç´¢å¼• (ç”¨äºæœ€ç»ˆ splice)
                        virtualDataIndex: dataStartIndex // å½“å‰æ•°æ®æ‰€åœ¨çš„ç´¢å¼•
                    };

                    window.triggerTouchHaptic('Medium');
                };

                if (isTouch) {
                    trackDragTimer = setTimeout(() => executeDrag(), 300);
                    trackDragState = { preStartX: touch.clientX, preStartY: touch.clientY };
                    window.addEventListener('touchmove', onTrackDragMove, {passive: false});
                    window.addEventListener('touchend', onTrackDragEnd);
                    window.addEventListener('touchcancel', onTrackDragEnd);
                } else {
                    e.preventDefault();
                    executeDrag();
                    window.addEventListener('mousemove', onTrackDragMove);
                    window.addEventListener('mouseup', onTrackDragEnd);
                }
            };

            // 2. æ‹–æ‹½è¿‡ç¨‹ (ä¿®å¤ç‰ˆ: é€»è¾‘é€šç”¨åŒ–)
            const onTrackDragMove = (e) => {
                if (!trackDragState || !trackDragState.ghost) {
                    if (trackDragTimer && e.type === 'touchmove') {
                        const touch = e.touches[0];
                        const moveY = Math.abs(touch.clientY - trackDragState.preStartY);
                        if (moveY > 10) {
                            clearTimeout(trackDragTimer);
                            trackDragTimer = null;
                            trackDragState = null;
                        }
                    }
                    return;
                }

                if (e.cancelable) e.preventDefault();

                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                // è§£æ„æ–°çŠ¶æ€å˜é‡
                const { ghost, fingerOffset, lastClientY, lastScrollTop, itemHeight, elementHeights, allMovableEls } = trackDragState;

                // A. ç§»åŠ¨æ›¿èº«
                ghost.style.top = `${clientY - fingerOffset}px`;

                // B. è®¡ç®—æ»šåŠ¨å¢é‡
                const container = trackListContainerRef.value;
                const currentScrollTop = container ? container.scrollTop : 0;
                const dy = clientY - lastClientY;
                const dScroll = currentScrollTop - lastScrollTop;

                trackDragState.lastClientY = clientY;
                trackDragState.lastScrollTop = currentScrollTop;
                trackDragState.cumulativeDelta += (dy + dScroll);

                let indexChanged = false;

                // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: ä½¿ç”¨ virtualDomIndex å’Œ allMovableEls è¿›è¡Œåˆ¤æ–­
                // è¿™æ ·æ— è®ºæ˜¯å¡ç‰‡è¿˜æ˜¯åˆ†å‰²æ¡ï¼Œåªè¦é«˜åº¦ç¬¦åˆé˜ˆå€¼ï¼Œéƒ½ä¼šè§¦å‘äº¤æ¢é€»è¾‘

                // å‘ä¸‹ç§»åŠ¨
                while (trackDragState.cumulativeDelta > 0) {
                    // åˆ°åº•äº†
                    if (trackDragState.virtualDomIndex >= elementHeights.length - 1) break;

                    const nextDomIndex = trackDragState.virtualDomIndex + 1;
                    const threshold = elementHeights[nextDomIndex] / 2 + itemHeight / 2;

                    if (trackDragState.cumulativeDelta > threshold) {
                        trackDragState.cumulativeDelta -= elementHeights[nextDomIndex]; // å‡å»è¢«è·¨è¶Šå…ƒç´ çš„é«˜åº¦
                        trackDragState.virtualDomIndex++;

                        // ğŸŸ¢ åªæœ‰è·¨è¶Šçš„æ˜¯å¡ç‰‡æ—¶ï¼Œæ•°æ®ç´¢å¼•æ‰+1ï¼›è·¨è¶Šåˆ†å‰²æ¡æ—¶ï¼Œæ•°æ®ç´¢å¼•ä¸å˜
                        if (allMovableEls[nextDomIndex].classList.contains('track-card')) {
                            trackDragState.virtualDataIndex++;
                        }

                        indexChanged = true;
                    } else break;
                }

                // å‘ä¸Šç§»åŠ¨
                while (trackDragState.cumulativeDelta < 0) {
                    if (trackDragState.virtualDomIndex <= 0) break;

                    const prevDomIndex = trackDragState.virtualDomIndex - 1;
                    // è®¡ç®—é˜ˆå€¼æ—¶ä½¿ç”¨ä¸Šä¸€ä¸ªå…ƒç´ çš„é«˜åº¦
                    const threshold = elementHeights[prevDomIndex] / 2 + itemHeight / 2;

                    if (trackDragState.cumulativeDelta < -threshold) {
                        trackDragState.cumulativeDelta += elementHeights[prevDomIndex];
                        trackDragState.virtualDomIndex--;

                        // ğŸŸ¢ åªæœ‰è·¨è¶Šçš„æ˜¯å¡ç‰‡æ—¶ï¼Œæ•°æ®ç´¢å¼•æ‰-1
                        if (allMovableEls[prevDomIndex].classList.contains('track-card')) {
                            trackDragState.virtualDataIndex--;
                        }

                        indexChanged = true;
                    } else break;
                }

                // C. åº”ç”¨è§†è§‰å˜æ¢ (å¯¹æ‰€æœ‰ allMovableEls ç”Ÿæ•ˆ)
                if (indexChanged || true) {
                    if (indexChanged) window.triggerTouchHaptic('Light');

                    const vDomIdx = trackDragState.virtualDomIndex;
                    const domStartIdx = trackDragState.domStartIndex;

                    trackDragState.allMovableEls.forEach((el, i) => {
                        // è·³è¿‡è‡ªå·±
                        if (i === domStartIdx) return;

                        let translateY = 0;
                        // é€»è¾‘ä¸ä¹‹å‰ç›¸åŒï¼Œåªæ˜¯ç°åœ¨ i ä»£è¡¨ DOM ç´¢å¼•
                        if (domStartIdx < vDomIdx) {
                            // å‘ä¸‹æ‹–ï¼šä¸­é—´çš„å…ƒç´ å‘ä¸Šç§»
                            if (i > domStartIdx && i <= vDomIdx) translateY = -itemHeight;
                        } else if (domStartIdx > vDomIdx) {
                            // å‘ä¸Šæ‹–ï¼šä¸­é—´çš„å…ƒç´ å‘ä¸‹ç§»
                            if (i >= vDomIdx && i < domStartIdx) translateY = itemHeight;
                        }

                        el.style.transform = translateY !== 0 ? `translate3d(0, ${translateY}px, 0)` : '';
                        el.style.transition = 'transform 0.2s cubic-bezier(0.2, 0, 0, 1)';
                    });
                }

                handleTrackListAutoScroll(clientY);
            };

            // 3. æ‹–æ‹½ç»“æŸ (ä¿®å¤ç‰ˆ: å®Œç¾æ”¯æŒåˆ†å‰²æ¡è·¨è¶Šæ£€æµ‹)
            const onTrackDragEnd = () => {
                if (trackDragTimer) {
                    clearTimeout(trackDragTimer);
                    trackDragTimer = null;
                }

                if (!trackDragState || !trackDragState.ghost) {
                    trackDragState = null;
                    window.removeEventListener('touchmove', onTrackDragMove);
                    window.removeEventListener('touchend', onTrackDragEnd);
                    window.removeEventListener('touchcancel', onTrackDragEnd);
                    return;
                }

                const { targetEl, ghost, allMovableEls, dataStartIndex, virtualDataIndex, domStartIndex, virtualDomIndex, item } = trackDragState;

                // 1. æ¢å¤æ˜¾ç¤º & æ¸…ç†
                if (targetEl) targetEl.style.opacity = '';
                if (ghost && document.body.contains(ghost)) document.body.removeChild(ghost);

                allMovableEls.forEach(el => {
                    el.style.transform = '';
                    el.style.transition = '';
                });
                stopTrackListAutoScroll();

                // ğŸŸ¢ å…³é”®ä¿®æ”¹: åªè¦è§†è§‰ä½ç½®å˜äº†(è·¨è¶Šäº†åˆ†å‰²æ¡) OR æ•°æ®ä½ç½®å˜äº†ï¼Œéƒ½è¦å¤„ç†
                if (domStartIndex !== virtualDomIndex || dataStartIndex !== virtualDataIndex) {
                    const items = trackListData.value.items;

                    // A. æ‰§è¡Œæ•°æ®ç§»åŠ¨ (å¦‚æœè·¨è¶Šäº†å…¶ä»–ä»»åŠ¡)
                    // æ³¨æ„ï¼šå¦‚æœåªè·¨è¶Šäº†åˆ†å‰²æ¡ï¼ŒvirtualDataIndex å¯èƒ½ç­‰äº dataStartIndexï¼Œæ­¤æ—¶æ•°ç»„ä¸éœ€å˜åŠ¨
                    if (dataStartIndex !== virtualDataIndex) {
                        items.splice(dataStartIndex, 1);
                        items.splice(virtualDataIndex, 0, item);
                    }

                    // B. è®¡ç®—æ–°çš„ SectionIndex (æ ¸å¿ƒä¿®å¤é€»è¾‘)
                    // æˆ‘ä»¬éœ€è¦æ¨¡æ‹Ÿä¸€ä¸‹ DOM ç§»åŠ¨åçš„çŠ¶æ€ï¼Œçœ‹çœ‹â€œæˆ‘çš„å¤´ä¸Šæ˜¯è°â€
                    const tempDomArray = [...allMovableEls];
                    const movedEl = tempDomArray.splice(domStartIndex, 1)[0];
                    tempDomArray.splice(virtualDomIndex, 0, movedEl);

                    const prevEl = tempDomArray[virtualDomIndex - 1]; // æˆ‘ä¸Šé¢çš„å…ƒç´ 

                    if (prevEl && prevEl.id && prevEl.id.startsWith('sec-divider-')) {
                        // ğŸŸ¢ æƒ…å†µ1: å¤´ä¸Šæ˜¯åˆ†å‰²æ¡ -> è¯´æ˜æˆ‘è¢«æ‹–åˆ°äº†è¯¥åˆ†å‰²æ¡çš„ä¸‹æ–¹ -> ç»§æ‰¿è¯¥åˆ†å‰²æ¡çš„ Section
                        // ID æ ¼å¼ä¸º "sec-divider-2"ï¼Œå–å‡ºæœ€åçš„æ•°å­—
                        const newSection = parseInt(prevEl.id.replace('sec-divider-', ''));
                        item.sectionIndex = newSection;
                    } else {
                        // ğŸŸ¢ æƒ…å†µ2: å¤´ä¸Šæ˜¯æ™®é€šä»»åŠ¡ æˆ– æ²¡ä¸œè¥¿(åœ¨é¡¶éƒ¨) -> èµ°æ ‡å‡†ç»§æ‰¿é€»è¾‘
                        if (items.length > 1) {
                            let newSectionIndex = 0;

                            if (virtualDataIndex === 0) {
                                // å¦‚æœæ’åœ¨é˜Ÿé¦–ï¼Œå°è¯•ç»§æ‰¿åŸæ¥é˜Ÿé¦–(ç°åœ¨æ˜¯è€äºŒ)çš„ section
                                // (é˜²æ­¢é˜Ÿé¦–å°±æ˜¯ section 0 çš„æƒ…å†µ)
                                newSectionIndex = items[1].sectionIndex;
                            } else {
                                // å¦åˆ™ç»§æ‰¿å‰ä¸€ä¸ªä»»åŠ¡çš„ section
                                newSectionIndex = items[virtualDataIndex - 1].sectionIndex;
                            }
                            item.sectionIndex = newSectionIndex;
                        }
                    }

                    // ä¿å­˜ & åé¦ˆ
                    pushHistory();
                    window.triggerTouchHaptic('Success');

                    // å¼ºåˆ¶é‡æ–°æ’åºä»¥åˆ·æ–°åˆ†å‰²æ¡ä½ç½® (Vue å“åº”å¼æœ‰æ—¶å€™éœ€è¦è¿™ä¸€ä¸‹)
                    // autoSortTrackList();
                }

                trackDragState = null;

                window.removeEventListener('touchmove', onTrackDragMove);
                window.removeEventListener('touchend', onTrackDragEnd);
                window.removeEventListener('touchcancel', onTrackDragEnd);
                window.removeEventListener('mousemove', onTrackDragMove);
                window.removeEventListener('mouseup', onTrackDragEnd);
            };

            // ğŸŸ¢ [é‡å†™] è¿‡æ»¤æ—¥ç¨‹ (ä¿®å¤æœç´¢å®šä½é—®é¢˜)
            const filteredScheduledTasks = computed(() => {
                const rawQuery = globalSearchQuery.value.trim().toLowerCase();
                if (!rawQuery) return scheduledTasks.value;

                const statusDefinitions = {
                    'å®Œæˆ': ['completed'], 'finished': ['completed'],
                    'è¿›è¡Œä¸­': ['in-progress'], 'ing': ['in-progress'],
                    'ç¼ºæ—¶': ['insufficient'], 'missing': ['insufficient'],
                    'å·²æ’': ['full', 'completed'], 'full': ['full', 'completed']
                };

                const textKeywords = [];
                const statusFilters = new Set();

                // è§£ææœç´¢è¯ (åˆ†ç¦»çŠ¶æ€å…³é”®è¯å’Œæ–‡æœ¬å…³é”®è¯)
                rawQuery.split(/\s+/).filter(k => k).forEach(inputWord => {
                    let isStatus = false;
                    for (const [key, statuses] of Object.entries(statusDefinitions)) {
                        if (key.includes(inputWord) || inputWord.includes(key)) {
                            statuses.forEach(s => statusFilters.add(s));
                            isStatus = true;
                            break;
                        }
                    }
                    if (!isStatus) textKeywords.push(inputWord);
                });

                // æ™ºèƒ½åŒ¹é…å‡½æ•°
                const smartMatch = (text, keyword) => {
                    if (!text) return false;
                    const lowerText = text.toLowerCase();
                    if (lowerText.includes(keyword)) return true;
                    if (lowerText.replace(/\s/g, '').includes(keyword)) return true;
                    if (window.pinyinPro && window.pinyinPro.match) {
                        return !!window.pinyinPro.match(text, keyword, { continuous: true });
                    }
                    return false;
                };

                // ğŸŸ¢ [æ ¸å¿ƒä¿®å¤] çŠ¶æ€æ£€æŸ¥é€»è¾‘
                const checkTaskStatus = (task) => {
                    // 1. å¦‚æœæ²¡æœ‰æŒ‡å®šçŠ¶æ€è¿‡æ»¤ (åªæœæ–‡å­—)ï¼Œç›´æ¥æ”¾è¡Œï¼
                    // è¿™æ ·é¿å…äº†"åœ¨é¡¹ç›®è§†å›¾æœä¸åˆ°ä¹å™¨ä»»åŠ¡"çš„é—®é¢˜
                    if (statusFilters.size === 0) return true;

                    // 2. å¦‚æœæœ‰çŠ¶æ€è¿‡æ»¤ï¼Œæ‰å»æ£€æŸ¥ä¾§è¾¹æ çš„ç»Ÿè®¡çŠ¶æ€
                    let targetList = musicianStats.value;
                    let targetId = task.musicianId;

                    if (sidebarTab.value === 'project') {
                        targetList = projectStats.value;
                        targetId = task.projectId;
                    }
                    else if (sidebarTab.value === 'instrument') {
                        targetList = instrumentStats.value;
                        targetId = task.instrumentId;
                    }

                    if (!targetId) return false;
                    const statItem = targetList.find(s => s.id === targetId);
                    if (!statItem) return false;

                    return statusFilters.has(statItem.statusKey);
                };

                const scheduleSectionMap = new Map();
                const groups = {};
                // ... (åˆ†ç»„é€»è¾‘ä¿æŒä¸å˜) ...
                scheduledTasks.value.forEach(t => {
                    const sess = t.sessionId || 'S_DEFAULT';
                    let key = '';
                    if (t.musicianId) key = `M|${t.musicianId}`;
                    else if (t.projectId) key = `P|${t.projectId}`;
                    else if (t.instrumentId) key = `I|${t.instrumentId}`;
                    const fullKey = `${sess}|${key}`;
                    if (!groups[fullKey]) groups[fullKey] = [];
                    groups[fullKey].push(t);
                });
                Object.values(groups).forEach(group => {
                    group.sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));
                    group.forEach((t, index) => {
                        scheduleSectionMap.set(t.scheduleId, index);
                    });
                });

                return scheduledTasks.value.filter(task => {
                    const sess = task.sessionId || 'S_DEFAULT';

                    // 1. æ£€æŸ¥çŠ¶æ€è¿‡æ»¤å™¨
                    if (!checkTaskStatus(task)) return false;

                    // 2. å¦‚æœæ²¡æœ‰æ–‡æœ¬å…³é”®è¯ï¼Œç›´æ¥è¿”å›
                    if (textKeywords.length === 0) return true;

                    // ğŸŸ¢ [æ ¸å¿ƒä¿®å¤] ä½¿ç”¨å…¨å±€ getNameWithGroup è·å–æ‰€æœ‰ç›¸å…³æ–‡æœ¬
                    // ç¡®ä¿é¡¹ç›®åã€ä¹å™¨åã€äººå‘˜åéƒ½è¢«çº³å…¥æœç´¢èŒƒå›´
                    const selfText = [
                        getNameWithGroup(task.musicianId, 'musician'),
                        getNameWithGroup(task.projectId, 'project'),
                        getNameWithGroup(task.instrumentId, 'instrument'),
                        task.recordingInfo?.studio,
                        task.recordingInfo?.engineer,
                        task.recordingInfo?.notes
                    ].join(' ');

                    // è‡ªèº«åŒ¹é…
                    if (textKeywords.every(k => smartMatch(selfText, k))) return true;

                    // å­é¡¹åŒ¹é… (èšåˆä»»åŠ¡)
                    let subItems = [];
                    if (task.templateId) {
                        const exactItem = itemPool.value.find(i => i.id === task.templateId);
                        if (exactItem) subItems.push(exactItem);
                    } else {
                        const mySectionIndex = scheduleSectionMap.get(task.scheduleId);
                        subItems = itemPool.value.filter(i => {
                            if ((i.sessionId || 'S_DEFAULT') !== sess) return false;
                            let idMatch = false;
                            if (task.musicianId) idMatch = (i.musicianId === task.musicianId);
                            else if (task.projectId) idMatch = (i.projectId === task.projectId);
                            else if (task.instrumentId) idMatch = (i.instrumentId === task.instrumentId);
                            if (!idMatch) return false;
                            const itemIdx = i.sectionIndex !== undefined ? i.sectionIndex : 0;
                            return itemIdx === mySectionIndex;
                        });
                    }

                    return subItems.some(sub => {
                        const itemText = [
                            getNameWithGroup(sub.projectId, 'project'),
                            getNameWithGroup(sub.instrumentId, 'instrument'),
                            getNameWithGroup(sub.musicianId, 'musician'),
                            sub.splitTag,
                            sub.recordingInfo?.notes
                        ].join(' ');
                        const combinedText = itemText + ' ' + selfText;
                        return textKeywords.every(k => smartMatch(combinedText, k));
                    });
                });
            });

            // ğŸŸ¢ [ç®€åŒ–] ä¾§è¾¹æ åˆ—è¡¨ (è¿‡æ»¤é€»è¾‘å·²ç§»è‡³ core stats calculation)
            const filteredSidebarList = computed(() => {
                // ç›´æ¥è¿”å›è®¡ç®—å¥½çš„ç»“æœï¼Œå®ƒä»¬å·²ç»æ˜¯å“åº”å¼ä¸”è¿‡æ»¤è¿‡çš„äº†
                if (sidebarTab.value === 'project') return projectStats.value;
                if (sidebarTab.value === 'instrument') return instrumentStats.value;
                return musicianStats.value;
            });

            // ğŸŸ¢ [ä¿®æ”¹] æœç´¢å›è½¦è·³è½¬é€»è¾‘ (æ”¯æŒå¾ªç¯å®šä½)
            const handleSearchEnter = () => {
                const tasks = filteredScheduledTasks.value; // è·å–æ‰€æœ‰åŒ¹é…çš„ä»»åŠ¡

                if (tasks.length > 0) {
                    // 1. ç¡®ä¿æŒ‰æ—¶é—´é¡ºåºæ’åˆ— (ä»æ—©åˆ°æ™šï¼Œè·¨å¤©ä¼˜å…ˆæŒ‰æ—¥æœŸ)
                    const sorted = [...tasks].sort((a, b) => {
                        if (a.date !== b.date) return a.date.localeCompare(b.date);
                        return a.startTime.localeCompare(b.startTime);
                    });

                    // 2. å®‰å…¨æ£€æŸ¥: é˜²æ­¢ç´¢å¼•è¶Šç•Œ (æ¯”å¦‚åˆšæ‰åˆ äº†ä¸€ä¸ªä»»åŠ¡)
                    if (currentSearchIndex.value >= sorted.length) {
                        currentSearchIndex.value = 0;
                    }

                    // 3. è·å–ç›®æ ‡ä»»åŠ¡
                    const target = sorted[currentSearchIndex.value];

                    // 4. æ‰§è¡Œè·³è½¬
                    smartScrollToTask(target);
                    window.triggerTouchHaptic('Success');

                    // 5. è®¡ç®—ä¸‹ä¸€æ¬¡çš„ç´¢å¼• (å–æ¨¡å®ç°å¾ªç¯: 0 -> 1 -> 2 -> 0 ...)
                    const nextIndex = (currentSearchIndex.value + 1) % sorted.length;
                    currentSearchIndex.value = nextIndex;

                    // (å¯é€‰) å¯ä»¥åœ¨æ§åˆ¶å°æ‰“å°ä¸€ä¸‹ï¼Œæ–¹ä¾¿è°ƒè¯•
                    // console.log(`Searching: Jumping to ${currentSearchIndex.value + 1} / ${sorted.length}`);

                } else {
                    // å¦‚æœæ—¥ç¨‹è¡¨é‡Œæ²¡æœ‰ï¼Œæ£€æŸ¥ä¸€ä¸‹ä¾§è¾¹æ æœ‰æ²¡æœ‰
                    const sidebarItems = filteredSidebarList.value;
                    if (sidebarItems.length > 0) {
                        openAlertModal("æŸ¥æ‰¾ç»“æœ", "æ—¥ç¨‹è¡¨ä¸­æœªæ‰¾åˆ°åŒ¹é…é¡¹ï¼Œä½†åœ¨ä»»åŠ¡æ± (Sidebar)ä¸­æ‰¾åˆ°äº†ç›¸å…³ä»»åŠ¡ã€‚");
                    } else {
                        window.triggerTouchHaptic('Error');
                    }
                }
            };

            const showRecInfoModal = ref(false);
            const recInfoForm = reactive({
                studio: '',
                engineer: '',
                operator: '',
                assistant: '', // ğŸŸ¢ æ–°å¢
                notes: ''
            });

            const openRecInfoModal = () => {
                const task = trackListData.value.taskRef;
                if (!task) return;

                // åˆ¤æ–­å½“å‰æ¨¡å¼ (æ ¹æ®ä¾§è¾¹æ  Tab)
                const isEditMode = sidebarTab.value === 'project';

                // å¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œè¯» editInfoï¼›å¦åˆ™è¯» recordingInfo
                const info = isEditMode ? (task.editInfo || {}) : (task.recordingInfo || {});

                recInfoForm.studio = info.studio || '';
                recInfoForm.engineer = info.engineer || ''; // è¿™é‡Œå¯èƒ½æ˜¯ Edit Engineer
                recInfoForm.operator = info.operator || '';
                recInfoForm.assistant = info.assistant || '';
                recInfoForm.notes = info.notes || '';

                showRecInfoModal.value = true;
            };

            // ä¿å­˜å½•éŸ³ä¿¡æ¯
            const saveRecInfo = () => {
                const task = trackListData.value.taskRef;
                if (!task) return;

                const isEditMode = sidebarTab.value === 'project';

                const newData = {
                    studio: recInfoForm.studio.trim(),
                    engineer: recInfoForm.engineer.trim(),
                    operator: recInfoForm.operator.trim(),
                    assistant: recInfoForm.assistant.trim(),
                    notes: recInfoForm.notes.trim()
                };

                if (isEditMode) {
                    task.editInfo = newData; // âœ… å­˜å…¥ç¼–è¾‘ä¿¡æ¯
                } else {
                    task.recordingInfo = newData; // âœ… å­˜å…¥å½•éŸ³ä¿¡æ¯
                }

                // å¼ºåˆ¶æ›´æ–°è§†å›¾
                const idx = scheduledTasks.value.findIndex(t => t.scheduleId === task.scheduleId);
                if (idx !== -1) {
                    scheduledTasks.value[idx] = { ...task };
                }

                pushHistory();
                window.triggerTouchHaptic('Success');
                showRecInfoModal.value = false;
            };

            watch(globalSearchQuery, () => {
                currentSearchIndex.value = 0;
            });

            const savedSidebarState = localStorage.getItem('musche_sidebar_open');
            // ğŸŸ¢ ä¿®æ”¹: é»˜è®¤ä¸º true (æ‰“å¼€çŠ¶æ€)
            const isSidebarOpen = ref(savedSidebarState !== null ? JSON.parse(savedSidebarState) : true);
            // 3. ç›‘å¬å˜åŒ–å¹¶è‡ªåŠ¨ä¿å­˜ (è®°å¿†åŠŸèƒ½)
            watch([isSidebarOpen, sidebarWidth], ([open, width]) => {
                localStorage.setItem('musche_sidebar_open', open);
                localStorage.setItem('musche_sidebar_width', width);
            });

            // ğŸŸ¢ æ–°å¢: å½“é¼ æ ‡è¿›å…¥è¾“å…¥æ¡†ï¼Œä¸´æ—¶ç¦æ­¢çˆ¶çº§æ‹–æ‹½ (è§£å†³æ— æ³•é€‰ä¸­æ–‡æœ¬çš„é—®é¢˜)
            const disableRowDrag = (e) => {
                const row = e.target.closest('.group\\/item'); // æŸ¥æ‰¾çˆ¶çº§è¡Œ
                if (row) {
                    row.setAttribute('draggable', 'false');
                    row.style.cursor = 'text'; // å¼ºåˆ¶æ˜¾ç¤ºæ–‡æœ¬å…‰æ ‡
                }
            };

            // ğŸŸ¢ æ–°å¢: å½“é¼ æ ‡ç¦»å¼€è¾“å…¥æ¡†ï¼Œæ¢å¤çˆ¶çº§æ‹–æ‹½
            const enableRowDrag = (e) => {
                const row = e.target.closest('.group\\/item');
                if (row) {
                    row.setAttribute('draggable', 'true');
                    row.style.cursor = ''; // æ¢å¤é»˜è®¤å…‰æ ‡
                }
            };

            // ----------------------------------------------------------------
            // ğŸŸ¢ æ–°å¢: 1. å®šä¹‰ç”µè„‘ç«¯å¼•å¯¼æ­¥éª¤
            // ----------------------------------------------------------------
            const desktopSteps = [
                {
                    // 1. æ¬¢è¿
                    popover: {
                        title: 'æ¬¢è¿ä½¿ç”¨ Musche',
                        description: 'è¿™æ˜¯ä¸€æ¬¾ä¸“ä¸ºéŸ³ä¹äººè®¾è®¡çš„æ™ºèƒ½æ’ç¨‹å·¥å…·ã€‚<br>å·²ä¸ºæ‚¨é¢„è®¾äº†æ¼”ç¤ºæ•°æ®ï¼Œè®©æˆ‘ä»¬èŠ± 1 åˆ†é’Ÿäº†è§£æ ¸å¿ƒæµç¨‹ã€‚',
                        align: 'center'
                    }
                },
                {
                    // 2. Session
                    element: '#tour-session-select',
                    popover: {
                        title: 'æ—¥ç¨‹åˆ‡æ¢ (Session)',
                        description: 'è¿™æ˜¯â€œæ¡£æœŸç®¡ç†å™¨â€ã€‚<br>æ‚¨å¯ä»¥æ–°å»ºä¸åŒçš„å½•éŸ³æ¡£æœŸï¼ˆå¦‚â€œ2025æ˜¥å­£å½•éŸ³â€ï¼‰ï¼Œå¹¶åœ¨æ­¤åˆ‡æ¢ã€‚',
                        side: "bottom"
                    }
                },
                {
                    // 3. ä¾§è¾¹æ æ•´ä½“
                    element: '#sidebar',
                    popover: {
                        title: 'ä»»åŠ¡æ±  (Pool)',
                        description: 'è¿™é‡Œå­˜æ”¾æ‰€æœ‰å¾…æ’ç¨‹çš„èµ„æºã€‚<br>ç‚¹å‡»é¡¶éƒ¨çš„ <b>äººå‘˜/é¡¹ç›®/ä¹å™¨</b> æ ‡ç­¾å¯åˆ‡æ¢ä¸åŒç»´åº¦çš„åˆ†ç»„æ˜¾ç¤ºã€‚',
                        side: "right",
                        align: 'start'
                    }
                },
                {
                    // 4. å…·ä½“çš„ç»Ÿè®¡å¡ç‰‡ (åŸä¾§è¾¹æ Guideçš„å†…å®¹)
                    element: '#tour-first-stat-card',
                    popover: {
                        title: 'ä»»åŠ¡å¡ç‰‡',
                        description: `
                    è¿™æ˜¯å…·ä½“çš„å¾…æ’ç¨‹å¯¹è±¡ï¼ˆå¦‚ Musician Aï¼‰ã€‚
                    <br>ğŸŸ¢ <b>ç»¿è‰²</b>ï¼šå·²æ’æœŸ
                    <br>ğŸ”´ <b>çº¢è‰²</b>ï¼šç¼ºæ—¶ (éœ€å¢åŠ æ’æœŸ)
                    <br>ğŸ”µ <b>è“è‰²</b>ï¼šå½•åˆ¶å®Œæˆ
                    <br>ğŸŸ  <b>æ©™è‰²</b>ï¼šè¿›è¡Œä¸­
                    <hr style="margin:8px 0; opacity:0.2">
                    <b>é•¿æŒ‰æ‹–æ‹½</b>ï¼šç›´æ¥å°†å¡ç‰‡æ‹–åˆ°å³ä¾§æ—¥ç¨‹è¡¨ä¸­ã€‚
                    <br><b>ç‚¹å‡»å¡ç‰‡</b>ï¼šå±•å¼€æŸ¥çœ‹å…·ä½“çš„æ›²ç›®åˆ—è¡¨ã€‚
                `,
                        side: "right",
                        align: 'center'
                    }
                },
                {
                    // 5. æ–°å»ºæŒ‰é’®
                    element: '#tour-new-task',
                    popover: {
                        title: 'æ·»åŠ ä»»åŠ¡',
                        description: 'ç‚¹å‡»è¿™é‡Œå½•å…¥æ–°çš„äººå‘˜ã€ä¹å™¨æˆ–é¡¹ç›®ã€‚<br>æ”¯æŒæ‰‹åŠ¨è¾“å…¥æˆ– CSV æ‰¹é‡å¯¼å…¥ã€‚',
                        side: "bottom"
                    }
                },
                {
                    // 6. ä¸»æ—¥ç¨‹
                    element: '#main-content',
                    popover: {
                        title: 'æ—¥ç¨‹è¡¨ (Schedule)',
                        description: `
                    ä¸»å·¥ä½œå°ï¼Œæ”¯æŒ<b>å‘¨/æœˆ</b>è§†å›¾åˆ‡æ¢ã€‚
                    <br>å·²ä¸ºæ‚¨åœ¨â€œä»Šå¤©â€åˆ›å»ºäº†ä¸€ä¸ªæ¼”ç¤ºæ—¥ç¨‹ã€‚
                    <hr style="margin:8px 0; opacity:0.2">
                    <b>åŒå‡»æ—¥ç¨‹å—</b>ï¼šæ‰“å¼€ TrackList è¯¦æƒ…é¡µï¼Œå¯è®°å½•å®é™…å½•éŸ³æ—¶é—´ã€æ‹†åˆ†ä»»åŠ¡æˆ–è‡ªåŠ¨è®¡ç®—æ•ˆç‡å€ç‡ã€‚
                `,
                        side: "left",
                        align: 'center'
                    }
                },
                {
                    // 7. è§†å›¾åˆ‡æ¢
                    element: '#tour-view-switch',
                    popover: {
                        title: 'è§†å›¾åˆ‡æ¢',
                        description: '<b>å‘¨è§†å›¾</b>ï¼šç²¾ç¡®åˆ°åˆ†é’Ÿçš„æ’ç¨‹æ“ä½œã€‚<br><b>æœˆè§†å›¾</b>ï¼šå®è§‚æŸ¥çœ‹æ¯æ—¥å®‰æ’å’Œç©ºæ¡£ã€‚',
                        side: "bottom"
                    }
                },
                {
                    // 8. åŒæ­¥
                    element: '#tour-sync-btn',
                    popover: {
                        title: 'äº‘ç«¯åŒæ­¥',
                        description: 'ç™»å½•è´¦å·åï¼Œæ•°æ®å°†è‡ªåŠ¨ä¿å­˜åˆ°äº‘ç«¯ï¼Œæ”¯æŒå¤šè®¾å¤‡åä½œã€‚',
                        side: "bottom"
                    }
                }
            ];

            // ----------------------------------------------------------------
            // ğŸŸ¢ æ–°å¢: 2. å®šä¹‰æ‰‹æœºç«¯å¼•å¯¼æ­¥éª¤ (é€‚é… Mobile UI)
            // ----------------------------------------------------------------
            const mobileSteps = [
                {
                    popover: {
                        title: 'æ¬¢è¿ä½¿ç”¨ Musche',
                        description: 'ä¸“ä¸ºç§»åŠ¨ç«¯ä¼˜åŒ–çš„æ’ç¨‹ä½“éªŒã€‚<br>æ”¯æŒæ‰‹åŠ¿æ“ä½œå’Œå¿«é€Ÿè®°å½•ã€‚',
                        align: 'center'
                    }
                },
                {
                    element: '#tour-session-select',
                    popover: {
                        title: 'åˆ‡æ¢æ¡£æœŸ',
                        description: 'ç‚¹å‡»é¡¶éƒ¨åˆ‡æ¢ä¸åŒçš„å½•éŸ³ Sessionã€‚',
                        side: "bottom"
                    }
                },
                {
                    element: '#main-content',
                    popover: {
                        title: 'æ—¥ç¨‹è¡¨ä¸æ‰‹åŠ¿',
                        description: `
                            <b>é•¿æŒ‰</b>ï¼šè¿›å…¥æ‹–æ‹½æ¨¡å¼ã€‚
                            <br><b>åŒå‡»</b>ï¼šæ‰“å¼€è¯¦æƒ…é¡µè®°å½•æ—¶é—´ã€‚
                            <br><b>å·¦å³æ»‘åŠ¨</b>ï¼šåˆ‡æ¢æ—¥æœŸ (æ—¥ç¨‹è¡¨) æˆ– åˆ‡æ¢åˆ†ç±» (ä»»åŠ¡æ± )ã€‚
                        `,
                        align: 'center'
                    }
                },
                {
                    element: '.mobile-header-nav',
                    popover: {
                        title: 'æ—¥æœŸå¯¼èˆª',
                        description: 'å·¦å³æ»‘åŠ¨å±å¹•ï¼Œæˆ–ç‚¹å‡»è¿™é‡Œåˆ‡æ¢æ—¥æœŸã€‚',
                        side: "bottom"
                    }
                },
                {
                    // 7. è§†å›¾åˆ‡æ¢
                    element: '#tour-view-switch',
                    popover: {
                        title: 'è§†å›¾åˆ‡æ¢',
                        description: '<b>å‘¨è§†å›¾</b>ï¼šç²¾ç¡®åˆ°åˆ†é’Ÿçš„æ’ç¨‹æ“ä½œã€‚<br><b>æœˆè§†å›¾</b>ï¼šå®è§‚æŸ¥çœ‹æ¯æ—¥å®‰æ’å’Œç©ºæ¡£ã€‚',
                        side: "bottom"
                    }
                },
                {
                    element: '.mobile-tab-bar',
                    popover: {
                        title: 'åº•éƒ¨å¯¼èˆª',
                        description: '<b>æ ¸å¿ƒåŠŸèƒ½åŒº</b>ï¼š<br><b>ä»»åŠ¡æ± </b>ï¼šæŸ¥çœ‹å¾…æ’ä»»åŠ¡<br><b>æ·»åŠ </b>ï¼šå¿«é€Ÿæ–°å»º<br><b>æ—¥ç¨‹è¡¨</b>ï¼šæŸ¥çœ‹å½“å‰å®‰æ’',
                        side: "top"
                    }
                },
                // --- ğŸŸ¢ ä¿®æ”¹ç‚¹ï¼šæ’å…¥ä»»åŠ¡æ± ä»‹ç»æ­¥éª¤ï¼Œå¹¶è‡ªåŠ¨åˆ‡æ¢è§†å›¾ ---
                {
                    element: '#sidebar', // ç›®æ ‡å…ƒç´ ï¼šä¾§è¾¹æ å®¹å™¨
                    popover: {
                        title: 'ä»»åŠ¡æ±  (Task Pool)',
                        description: 'è¿™é‡Œå­˜æ”¾æ‰€æœ‰å¾…æ’ç¨‹çš„èµ„æºã€‚<br>ç‚¹å‡»ä¸Šæ–¹æ ‡ç­¾å¯åˆ‡æ¢ <b>äººå‘˜/é¡¹ç›®/ä¹å™¨</b>ã€‚<br><b>é•¿æŒ‰å¡ç‰‡</b>å³å¯æ‹–æ‹½åˆ°æ—¥ç¨‹è¡¨ä¸­ã€‚',
                        side: "top",
                        align: 'center'
                    },
                    // ğŸš€ æ ¸å¿ƒé€»è¾‘ï¼šè¿›å…¥æ­¤æ­¥éª¤æ—¶ï¼Œå¼ºåˆ¶åˆ‡æ¢åˆ° Pool è§†å›¾
                    onHighlightStarted: () => {
                        mobileTab.value = 'pool';
                        showMobileTaskInput.value = false; // ç¡®ä¿æ·»åŠ å¼¹çª—å…³é—­
                        // ç¨å¾®æ»šåŠ¨ä¸€ä¸‹ä¾§è¾¹æ ç¡®ä¿æœ‰åŠ¨æ„Ÿ (å¯é€‰)
                        if(sidebarScrollRef.value) sidebarScrollRef.value.scrollTop = 0;
                    }
                },
                {
                    // 4. å…·ä½“çš„ç»Ÿè®¡å¡ç‰‡ (åŸä¾§è¾¹æ Guideçš„å†…å®¹)
                    element: '#tour-first-stat-card',
                    popover: {
                        title: 'ä»»åŠ¡å¡ç‰‡',
                        description: `
                    è¿™æ˜¯å…·ä½“çš„å¾…æ’ç¨‹å¯¹è±¡ï¼ˆå¦‚ Musician Aï¼‰ã€‚
                    <br>ğŸŸ¢ <b>ç»¿è‰²</b>ï¼šå·²æ’æœŸ
                    <br>ğŸ”´ <b>çº¢è‰²</b>ï¼šç¼ºæ—¶ (éœ€å¢åŠ æ’æœŸ)
                    <br>ğŸ”µ <b>è“è‰²</b>ï¼šå½•åˆ¶å®Œæˆ
                    <br>ğŸŸ  <b>æ©™è‰²</b>ï¼šè¿›è¡Œä¸­
                    <hr style="margin:8px 0; opacity:0.2">
                    <b>é•¿æŒ‰æ‹–æ‹½</b>ï¼šç›´æ¥å°†å¡ç‰‡æ‹–åˆ°å³ä¾§æ—¥ç¨‹è¡¨ä¸­ã€‚
                    <br><b>ç‚¹å‡»å¡ç‰‡</b>ï¼šå±•å¼€æŸ¥çœ‹å…·ä½“çš„æ›²ç›®åˆ—è¡¨ã€‚
                `,
                        side: "right",
                        align: 'center'
                    }
                },
                {
                    // 5. æ–°å»ºæŒ‰é’®
                    element: '#tour-new-task',
                    popover: {
                        title: 'æ·»åŠ ä»»åŠ¡',
                        description: 'ç‚¹å‡»è¿™é‡Œå½•å…¥æ–°çš„äººå‘˜ã€ä¹å™¨æˆ–é¡¹ç›®ã€‚<br>æ”¯æŒæ‰‹åŠ¨è¾“å…¥æˆ– CSV æ‰¹é‡å¯¼å…¥ã€‚',
                        side: "bottom"
                    }
                },
                // ----------------------------------------------------
                {
                    // 8. åŒæ­¥
                    element: '#tour-sync-btn',
                    popover: {
                        title: 'äº‘ç«¯åŒæ­¥',
                        description: 'ç™»å½•è´¦å·åï¼Œæ•°æ®å°†è‡ªåŠ¨ä¿å­˜åˆ°äº‘ç«¯ï¼Œæ”¯æŒå¤šè®¾å¤‡åä½œã€‚',
                        side: "bottom"
                    },
                    // ğŸš€ æ ¸å¿ƒé€»è¾‘ï¼šç¦»å¼€ä»»åŠ¡æ± ä»‹ç»åï¼Œåˆ‡å›æ—¥ç¨‹è¡¨è§†å›¾ï¼Œä»¥ä¾¿æ­£ç¡®é«˜äº® #main-content
                    onHighlightStarted: () => {
                        mobileTab.value = 'schedule';
                    }
                }
            ];

            // ----------------------------------------------------------------
            // ğŸŸ¢ æ–°å¢: 3. åˆå§‹åŒ– Driver å®ä¾‹ (ç©ºé…ç½®)
            // ----------------------------------------------------------------
            const driverObj = window.driver.js.driver({
                showProgress: true,
                animate: true,
                allowClose: true,
                doneBtnText: 'å¼€å§‹ä½¿ç”¨',
                nextBtnText: 'ä¸‹ä¸€æ­¥',
                prevBtnText: 'ä¸Šä¸€æ­¥',
            });

            // ----------------------------------------------------------------
            // ğŸŸ¢ æ–°å¢: 4. æ™ºèƒ½å¯åŠ¨å‡½æ•° (æ ¹æ®å±å¹•åˆ¤æ–­)
            // ----------------------------------------------------------------
            const startTour = () => {
                // ç¡®ä¿ä¹‹å‰å¯èƒ½å­˜åœ¨çš„ä¾§è¾¹æ å¼•å¯¼æ ‡è®°ä¸å¹²æ‰°
                localStorage.removeItem('musche_sidebar_tour_seen');

                if (window.innerWidth < 800) {
                    // === ğŸ“± æ‰‹æœºæ¨¡å¼ ===

                    // 1. å¼ºåˆ¶åˆ‡æ¢åˆ°åº•éƒ¨å¯¼èˆªçš„â€œæ—¥ç¨‹è¡¨â€è§†å›¾ï¼Œç¡®ä¿ç•Œé¢æ•´æ´
                    mobileTab.value = 'schedule';
                    showMobileTaskInput.value = false;

                    // 2. è®¾ç½®æ‰‹æœºç‰ˆå‰§æœ¬
                    driverObj.setConfig({ steps: mobileSteps });

                    // 3. ç›´æ¥æ’­æ”¾
                    driverObj.drive();
                } else {
                    // === ğŸ’» ç”µè„‘æ¨¡å¼ ===

                    // 1. å¼ºåˆ¶å±•å¼€ä¾§è¾¹æ ï¼Œç¡®ä¿å…ƒç´ å¯è§
                    isSidebarOpen.value = true;

                    // 2. è®¾ç½®ç”µè„‘ç‰ˆå‰§æœ¬
                    driverObj.setConfig({ steps: desktopSteps });

                    // 3. å»¶è¿Ÿæ’­æ”¾ï¼Œç­‰å¾…ä¾§è¾¹æ åŠ¨ç”»å±•å¼€
                    setTimeout(() => {
                        driverObj.drive();
                    }, 400);
                }

                // æ ‡è®°å·²è¯»
                localStorage.setItem('musche_tour_seen', 'true');
            };

            // ğŸŸ¢ ä¿®å¤: ç®€åŒ–çš„ä¾§è¾¹æ åˆ‡æ¢ (ä¸å†åŒ…å«å¼•å¯¼é€»è¾‘)
            const toggleSidebar = () => {
                isSidebarOpen.value = !isSidebarOpen.value;
            };

            const splitState = reactive({
                task: null,        // ç›®æ ‡ä»»åŠ¡
                totalSec: 0,       // æ€»æ—¶é•¿(ç§’)
                splitPoint: 0,     // åˆ†å‰²ç‚¹(ç§’)ï¼Œå³ Part 1 çš„æ—¶é•¿
                part1Str: '00:00', // æ˜¾ç¤ºç”¨
                part2Str: '00:00'  // æ˜¾ç¤ºç”¨
            });

            // ğŸŸ¢ [å¢å¼ºç‰ˆ] æ£€æŸ¥æ˜¯å¦å…è®¸æ‹†åˆ† (è‡ªåŠ¨å¯»æ‰¾å¹¶æç¤ºæœ€åä¸€ä¸ª Part)
            const checkCanSplit = (item) => {
                // 1. æ£€æŸ¥æ˜¯å¦æœ‰ç›´æ¥å­èŠ‚ç‚¹
                const directChild = itemPool.value.find(t => t.splitFromId === item.id);

                if (directChild) {
                    // 2. å¦‚æœæœ‰å­©å­ï¼Œè¯´æ˜å½“å‰ä¸æ˜¯æœ«ç«¯ã€‚å¼€å§‹é¡ºè—¤æ‘¸ç“œæ‰¾â€œå­™å­â€...ç›´åˆ°æ‰¾åˆ°æœ€åä¸€ä»£
                    let lastNode = directChild;
                    // ä¸ºäº†é˜²æ­¢æ­»å¾ªç¯ï¼ˆè™½ç„¶é€»è¾‘ä¸Šä¸åº”è¯¥å‡ºç°ï¼‰ï¼ŒåŠ ä¸ªæœ€å¤§æ·±åº¦çš„å®‰å…¨é™åˆ¶
                    let safeGuard = 0;

                    while (safeGuard < 100) {
                        const nextChild = itemPool.value.find(t => t.splitFromId === lastNode.id);
                        if (nextChild) {
                            lastNode = nextChild; // è¿˜æœ‰ä¸‹ä¸€ä»£ï¼Œç»§ç»­å¾€ä¸‹æ‰¾
                        } else {
                            break; // æ²¡æœ‰ä¸‹ä¸€ä»£äº†ï¼ŒlastNode å°±æ˜¯é“¾æ¡æœ«ç«¯
                        }
                        safeGuard++;
                    }

                    // 3. è·å–æœ«ç«¯èŠ‚ç‚¹çš„åç§° (ä¼˜å…ˆæ˜¾ç¤º splitTagï¼Œå¦‚ "Part 3")
                    const targetName = lastNode.splitTag || 'æœ€åä¸€ä¸ªéƒ¨åˆ†';

                    openAlertModal(
                        'ç¦æ­¢æ‹†åˆ†',
                        `å½“å‰ä»»åŠ¡å·²è¿›è¡Œè¿‡æ‹†åˆ†ï¼ˆå­˜åœ¨åç»­ Partï¼‰ï¼Œ\nè¯·å¯»æ‰¾ã€${targetName}ã€‘è¿›è¡Œæ‹†åˆ†ã€‚`
                    );
                    window.triggerTouchHaptic('Error');
                    return false;
                }
                return true;
            };

            // ğŸŸ¢ [ä¿®æ”¹ç‰ˆ] æ‰“å¼€æ‹†åˆ†æ»‘å—
            const openSplitSlider = (item) => {
                // 1. ğŸ” æ–°å¢ï¼šçˆ¶çº§æ£€æŸ¥
                if (!checkCanSplit(item)) return;

                const totalMusicStr = item.musicDuration;
                if (!totalMusicStr || totalMusicStr === '00:00') {
                    return openAlertModal('æ— æ³•æ‹†åˆ†', 'è¯¥æ›²ç›®æ²¡æœ‰è®¾ç½®è°±é¢æ—¶é•¿ã€‚');
                }

                splitState.task = item;
                splitState.totalSec = parseTime(totalMusicStr);

                // é»˜è®¤ä»ä¸€åŠå¼€å§‹
                splitState.splitPoint = Math.floor(splitState.totalSec / 2);

                updateSplitStrings();
                showSplitModal.value = true;
            };

            // 2. æ»‘å—æ‹–åŠ¨æ—¶æ›´æ–°æ–‡å­—
            const onSplitSliderInput = () => {
                updateSplitStrings();
                // æ‹–åŠ¨æ—¶ç»™ä¸€ç‚¹è½»å¾®éœ‡åŠ¨åé¦ˆ (èŠ‚æµ)
                window.triggerTouchHaptic('Light');
            };

            const updateSplitStrings = () => {
                const p1 = splitState.splitPoint;
                const p2 = splitState.totalSec - splitState.splitPoint;
                splitState.part1Str = formatSecs(p1);
                splitState.part2Str = formatSecs(p2);
            };

            // ğŸŸ¢ [ä¿®å¤ç‰ˆ] ç¡®è®¤æ‹†åˆ† (ä¿®å¤ï¼šå»ºç«‹é“¾å¼çˆ¶å­å…³ç³»ï¼Œæ”¯æŒé€çº§å½’è¿˜)
            const confirmSplitSlider = () => {
                const item = splitState.task;
                const doneStr = splitState.part1Str;
                const remainingStr = splitState.part2Str;

                if (splitState.splitPoint <= 0 || splitState.splitPoint >= splitState.totalSec) {
                    return openAlertModal('æ— æ•ˆæ‹†åˆ†', 'è¯·æ‹–åŠ¨æ»‘å—é€‰æ‹©ä¸€ä¸ªä¸­é—´çš„æ—¶é—´ç‚¹ã€‚');
                }

                // 1. æ™ºèƒ½è®¡ç®— Part ç¼–å·
                let baseNum = 1;
                if (item.splitTag) {
                    const match = String(item.splitTag).match(/Part\s*(\d+)/i);
                    if (match && match[1]) baseNum = parseInt(match[1], 10);
                }

                // A. æ›´æ–°å½“å‰ä»»åŠ¡ (å˜ä¸ºçˆ¶çº§)
                item.musicDuration = doneStr;
                item.splitTag = `Part ${baseNum}`;

                // B. åˆ›å»ºæ–°ä»»åŠ¡ (å˜ä¸ºå­çº§)
                const newRatio = item.ratio || 20;
                const newEst = calculateEstTime(remainingStr, newRatio);

                const newTask = {
                    id: generateUniqueId('T'),

                    // ğŸš© æ ¸å¿ƒä¿®å¤ï¼šå§‹ç»ˆæŒ‡å‘å½“å‰ item ä¸ºçˆ¶çº§ï¼Œå»ºç«‹ Part 1 -> Part 2 -> Part 3 çš„é“¾æ¡
                    // åŸä»£ç çš„ `|| item.splitFromId` ä¼šå¯¼è‡´æ‰å¹³åŒ–ï¼Œè·³è¿‡ä¸­é—´å±‚çº§
                    splitFromId: item.id,

                    splitTag: `Part ${baseNum + 1}`,
                    sessionId: item.sessionId || currentSessionId.value,
                    projectId: item.projectId,
                    instrumentId: item.instrumentId,
                    musicianId: item.musicianId,
                    musicDuration: remainingStr,
                    ratio: newRatio,
                    estDuration: newEst,
                    group: item.group || '',
                    recordingInfo: item.recordingInfo ? JSON.parse(JSON.stringify(item.recordingInfo)) : {},
                    // ğŸŸ¢ã€åœ¨æ­¤å¤„æ·»åŠ ä¿®å¤ä»£ç ã€‘å¤åˆ¶ç¼–åˆ¶å’Œåå•
                    orchestration: item.orchestration || '',
                    roster: item.roster ? JSON.parse(JSON.stringify(item.roster)) : {}
                };

                ensureItemRecords(newTask);
                itemPool.value.push(newTask);

                // --- C. è‡ªåŠ¨æ’æœŸé€»è¾‘ ---
                if (showTrackList.value && trackListData.value.schedules) {
                    const currentIdx = trackListData.value.currentSectionIndex;
                    const currentSchedule = trackListData.value.schedules[currentIdx];
                    const nextSchedule = trackListData.value.schedules[currentIdx + 1];

                    // 1. å­˜åœ¨ä¸‹ä¸€ä¸ªæ—¥ç¨‹ -> ç›´æ¥åŠ å…¥
                    if (nextSchedule) {
                        newTask.sectionIndex = currentIdx + 1;
                    }
                    // 2. æ²¡æœ‰ä¸‹ä¸€ä¸ªæ—¥ç¨‹ -> ç´§æ¥å½“å‰æ—¥ç¨‹æ–°å»ºä¸€ä¸ª
                    else if (currentSchedule) {
                        const startMins = timeToMinutes(currentSchedule.startTime);
                        const durMins = parseTime(currentSchedule.estDuration) / 60;
                        const endMins = startMins + durMins;

                        const h = Math.floor(endMins / 60);
                        const m = Math.floor(endMins % 60);
                        const newStartStr = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

                        const scheduleEntry = {
                            scheduleId: Date.now(),
                            templateId: newTask.id,
                            sessionId: currentSessionId.value,
                            musicianId: currentSchedule.musicianId ? newTask.musicianId : '',
                            projectId: currentSchedule.projectId ? newTask.projectId : '',
                            instrumentId: currentSchedule.instrumentId ? newTask.instrumentId : '',
                            date: currentSchedule.date,
                            startTime: newStartStr,
                            estDuration: newTask.estDuration,
                            trackCount: 0,
                            ratio: newTask.ratio,
                            musicDuration: newTask.musicDuration,
                            reminderMinutes: 15,
                            sound: 'default'
                        };
                        scheduledTasks.value.push(scheduleEntry);
                        newTask.sectionIndex = currentIdx + 1;
                        trackListData.value.schedules.push(scheduleEntry);
                        trackListData.value.totalSections++;
                    } else {
                        newTask.sectionIndex = 0;
                    }

                    trackListData.value.items.push(newTask);
                    autoSortTrackList();
                }

                pushHistory();
                window.triggerTouchHaptic('Success');
                if (item.musicianId) autoUpdateEfficiency(item.musicianId, 'musician', false);

                showSplitModal.value = false;
            };

            // ğŸŸ¢ [ä¿®æ”¹ç‰ˆ] æ‹†åˆ†ä»»åŠ¡ (è¾“å…¥æ—¶é•¿ç‰ˆ - å¦‚æœä½ è¿˜ä¿ç•™ç€è¿™ä¸ªå¤‡ç”¨å‡½æ•°çš„è¯)
            const splitTrack = (item) => {
                // 1. ğŸ” æ–°å¢ï¼šçˆ¶çº§æ£€æŸ¥
                if (!checkCanSplit(item)) return;

                const totalMusicStr = item.musicDuration;
                if (!totalMusicStr || totalMusicStr === '00:00') {
                    return openAlertModal('æ— æ³•æ‹†åˆ†', 'è¯¥æ›²ç›®æ²¡æœ‰è®¾ç½®è°±é¢æ—¶é•¿ã€‚');
                }

                openInputModal(
                    'æ‹†åˆ†ä»»åŠ¡ (ç•™å¾…ä¸‹æ¬¡)',
                    '',
                    'è¯·è¾“å…¥ å‰©ä½™ è°±é¢æ—¶é•¿ (ä¾‹å¦‚ 01:30)',
                    (remainingStr) => {
                        // ... (åŸæœ‰çš„ç¡®è®¤é€»è¾‘ä¿æŒä¸å˜)
                        if (!/^\d{1,2}:\d{2}$/.test(remainingStr)) {
                            return openAlertModal('æ ¼å¼é”™è¯¯', 'è¯·è¾“å…¥æ­£ç¡®çš„æ—¶é—´æ ¼å¼ (MM:SS)');
                        }

                        // ... (åç»­ä»£ç ä¸ç”¨åŠ¨ï¼Œåªè¦å¼€å¤´æ‹¦ä½å³å¯)
                        // ...

                        // æ—¢ç„¶ä½ åœ¨è¿™ä¸ªå‡½æ•°é‡Œæœ‰ä¸€å¤§æ®µé€»è¾‘ï¼Œä¸ºäº†å®Œæ•´æ€§ï¼Œè¿™é‡Œç®€ç•¥è¡¨ç¤ºï¼š
                        // è¿™é‡Œç›´æ¥è°ƒç”¨ confirmSplitSlider çš„æ ¸å¿ƒé€»è¾‘æˆ–è€…ä¿ç•™ä½ ä¹‹å‰çš„é€»è¾‘
                        // é‡ç‚¹æ˜¯ä¸Šé¢çš„ if (!checkCanSplit(item)) return;

                        // ä¸‹é¢æ˜¯åŸæœ‰çš„æ ¸å¿ƒé€»è¾‘å¤è¿°ï¼Œç¡®ä¿ä½ æ›¿æ¢æ—¶ä¸ä¼šä¸¢ä»£ç ï¼š
                        const totalSec = parseTime(totalMusicStr);
                        const remainSec = parseTime(remainingStr);

                        if (remainSec <= 0 || remainSec >= totalSec) {
                            return openAlertModal('æ•°å€¼é”™è¯¯', 'å‰©ä½™æ—¶é•¿å¿…é¡»å°äºæ€»æ—¶é•¿ä¸”å¤§äº0ã€‚');
                        }

                        const doneSec = totalSec - remainSec;
                        const doneStr = formatSecs(doneSec);

                        let baseNum = 1;
                        if (item.splitTag) {
                            const match = String(item.splitTag).match(/Part\s*(\d+)/i);
                            if (match && match[1]) baseNum = parseInt(match[1], 10);
                        }

                        item.musicDuration = doneStr;
                        item.splitTag = `Part ${baseNum}`;

                        const newRatio = item.ratio || 20;
                        const newEst = calculateEstTime(remainingStr, newRatio);

                        const newTask = {
                            id: generateUniqueId('T'),
                            splitFromId: item.id, // é“¾å¼æŒ‡å‘
                            splitTag: `Part ${baseNum + 1}`,
                            sessionId: item.sessionId || currentSessionId.value,
                            projectId: item.projectId,
                            instrumentId: item.instrumentId,
                            musicianId: item.musicianId,
                            musicDuration: remainingStr,
                            ratio: newRatio,
                            estDuration: newEst,
                            group: item.group || '',
                            recordingInfo: item.recordingInfo ? JSON.parse(JSON.stringify(item.recordingInfo)) : {},
                            // ğŸŸ¢ã€åœ¨æ­¤å¤„æ·»åŠ ä¿®å¤ä»£ç ã€‘
                            orchestration: item.orchestration || '',
                            roster: item.roster ? JSON.parse(JSON.stringify(item.roster)) : {}
                        };
                        ensureItemRecords(newTask);
                        itemPool.value.push(newTask);

                        // è‡ªåŠ¨æ’æœŸé€»è¾‘
                        if (showTrackList.value && trackListData.value.schedules) {
                            const currentIdx = trackListData.value.currentSectionIndex;
                            const currentSchedule = trackListData.value.schedules[currentIdx];
                            const nextSchedule = trackListData.value.schedules[currentIdx + 1];
                            if (nextSchedule) {
                                newTask.sectionIndex = currentIdx + 1;
                            } else if (currentSchedule) {
                                const startMins = timeToMinutes(currentSchedule.startTime);
                                const durMins = parseTime(currentSchedule.estDuration) / 60;
                                const endMins = startMins + durMins;
                                const h = Math.floor(endMins / 60);
                                const m = Math.floor(endMins % 60);
                                const newStartStr = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                                const scheduleEntry = {
                                    scheduleId: Date.now(),
                                    templateId: newTask.id,
                                    sessionId: currentSessionId.value,
                                    musicianId: currentSchedule.musicianId ? newTask.musicianId : '',
                                    projectId: currentSchedule.projectId ? newTask.projectId : '',
                                    instrumentId: currentSchedule.instrumentId ? newTask.instrumentId : '',
                                    date: currentSchedule.date,
                                    startTime: newStartStr,
                                    estDuration: newTask.estDuration,
                                    trackCount: 0,
                                    ratio: newTask.ratio,
                                    musicDuration: newTask.musicDuration
                                };
                                scheduledTasks.value.push(scheduleEntry);
                                newTask.sectionIndex = currentIdx + 1;
                                trackListData.value.schedules.push(scheduleEntry);
                                trackListData.value.totalSections++;
                            } else {
                                newTask.sectionIndex = 0;
                            }
                            trackListData.value.items.push(newTask);
                            autoSortTrackList();
                        }

                        pushHistory();
                        window.triggerTouchHaptic('Success');
                        if (item.musicianId) autoUpdateEfficiency(item.musicianId, 'musician', false);
                    },
                    `æ€»é•¿ ${totalMusicStr}ã€‚`
                );
            };

            // ğŸŸ¢ [é‡å†™] å½’è¿˜æ—¶é—´ (æ— é™é“¾å¼ç‰ˆï¼šé€çº§å½’è¿˜ + æ ‡ç­¾æ™ºèƒ½æ¸…ç†)
            const restoreSplitTime = (taskInput) => {
                // 1. è·å–æœ€æ–°çš„ Live å¯¹è±¡ (å› ä¸ºä¼ å…¥çš„å¯èƒ½æ˜¯å¼¹çª—é‡Œçš„å‰¯æœ¬)
                const taskToDelete = itemPool.value.find(i => i.id === taskInput.id);

                // å¦‚æœæ‰¾ä¸åˆ°çˆ¶çº§ï¼Œè¯´æ˜å®ƒæ˜¯æ ¹èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
                if (!taskToDelete || !taskToDelete.splitFromId) return;

                // 2. æ‰¾åˆ°ç›´æ¥çˆ¶çº§ (ä¸Šä¸€ç¯)
                const parent = itemPool.value.find(i => i.id === taskToDelete.splitFromId);
                if (!parent) return;

                // 3. æ‰§è¡Œæ—¶é—´å½’è¿˜ (åˆå¹¶æ—¶é•¿)
                const parentSec = parseTime(parent.musicDuration);
                const childSec = parseTime(taskToDelete.musicDuration);

                if (parentSec > 0 && childSec > 0) {
                    const newTotal = formatSecs(parentSec + childSec);
                    parent.musicDuration = newTotal;

                    // ğŸŸ¢ 4. é“¾æ¡ä¿®è¡¥ (æŠŠå­™å­è¿‡ç»§ç»™çˆ·çˆ·)
                    // å¦‚æœæˆ‘åˆ çš„æ˜¯ Part 2ï¼Œä¸” Part 2 åé¢è¿˜æœ‰ Part 3
                    // æˆ‘ä»¬å¿…é¡»æŠŠ Part 3 çš„çˆ¶äº²æ”¹æˆ Part 1 (å³å½“å‰çš„ parent)
                    const orphans = itemPool.value.filter(i => i.splitFromId === taskToDelete.id);
                    if (orphans.length > 0) {
                        orphans.forEach(orphan => {
                            orphan.splitFromId = parent.id;
                        });
                    }

                    // ğŸŸ¢ 5. æ ‡ç­¾æ¸…ç†é€»è¾‘
                    // è§„åˆ™ï¼šåªæœ‰å½“çˆ¶çº§æ˜¯ã€ç»å¯¹æ ¹èŠ‚ç‚¹ã€‘ä¸”ã€æ²¡æœ‰å…¶ä»–å­©å­ã€‘æ—¶ï¼Œæ‰æ¸…é™¤æ ‡ç­¾ã€‚
                    // å¦‚æœçˆ¶çº§æœ¬èº«ä¹Ÿæ˜¯ä¸ª Part (æœ‰ splitFromId)ï¼Œè¯´æ˜æˆ‘ä»¬åœ¨åˆå¹¶ä¸­é—´å±‚çº§ï¼Œçˆ¶çº§æ ‡ç­¾å¿…é¡»ä¿ç•™ã€‚

                    const isParentAlsoChild = !!parent.splitFromId;

                    if (isParentAlsoChild) {
                        // === æƒ…å†µ A: çˆ¶çº§æ˜¯ä¸­é—´èŠ‚ç‚¹ (å¦‚ Part 2) ===
                        // åˆå¹¶åå®ƒè¿˜æ˜¯ Part 2ï¼Œåªæ˜¯æ—¶é—´å˜é•¿äº†ï¼Œæ ‡ç­¾ä¿ç•™
                        openAlertModal(
                            'æ—¶é—´å·²å½’è¿˜',
                            `å½“å‰ä»»åŠ¡å·²é€çº§åˆå¹¶å›ä¸Šä¸€å±‚ (${parent.splitTag})ã€‚`
                        );
                    } else {
                        // === æƒ…å†µ B: çˆ¶çº§æ˜¯æ ¹èŠ‚ç‚¹ (Part 1 / Source) ===
                        // æ£€æŸ¥æ ¹èŠ‚ç‚¹åä¸‹æ˜¯å¦è¿˜æœ‰å…¶ä»–åˆ†èº«
                        const hasChildren = itemPool.value.some(i =>
                            i.id !== taskToDelete.id && // æ’é™¤å½“å‰æ­£åœ¨åˆ çš„
                            i.splitFromId === parent.id // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–å­©å­
                        );

                        if (!hasChildren) {
                            // çœŸçš„æ²¡å­©å­äº†ï¼Œå½»åº•è‡ªç”±ï¼Œæ¸…é™¤ Part 1 æ ‡ç­¾
                            delete parent.splitTag;
                            openAlertModal(
                                'åˆå¹¶å®Œæˆ',
                                `æ‹†åˆ†ä»»åŠ¡å·²å…¨éƒ¨åˆå¹¶å›åŸä»»åŠ¡ã€‚\nç°æœ‰æ—¶é•¿: ${newTotal}`
                            );
                        } else {
                            // è¿˜æœ‰å­©å­ (æ¯”å¦‚åˆ äº† Part 2ï¼Œä½† Part 3 è¢«è¿‡ç»§è¿‡æ¥äº†)
                            // æ­¤æ—¶æ ¹èŠ‚ç‚¹ä»éœ€ä¿ç•™ "Part 1" æ ‡ç­¾
                            openAlertModal(
                                'æ—¶é—´å·²å½’è¿˜',
                                `æ—¶é—´å·²åˆå¹¶å› Part 1ã€‚\n(æ ‡ç­¾ä¿ç•™ï¼Œå› ä¸ºä»æœ‰åç»­éƒ¨åˆ†å­˜åœ¨)`
                            );
                        }
                    }

                    window.triggerTouchHaptic('Success');
                }
            };

            // --- ğŸŸ¢ æ–°å¢ï¼šè‡ªå®šä¹‰é¢œè‰²é€‰æ‹©å™¨é€»è¾‘ ---
            const showColorPickerModal = ref(false);
            const colorPickerTarget = ref(null); // å½“å‰æ­£åœ¨ç¼–è¾‘çš„å¯¹è±¡ { item, type }
            const tempColor = ref('');           // ä¸´æ—¶é¢œè‰²ï¼Œç¡®è®¤åæ‰åº”ç”¨

            // ğŸŸ¢ ä¿®å¤: éš”ç¦»åæ ‡çŠ¶æ€ï¼Œé˜²æ­¢åˆ‡æ¢æ—¶ä½ç½®è·³åŠ¨
            const inputRects = reactive({
                name: { top: 0, left: 0, width: 0, height: 0 },
                group: { top: 0, left: 0, width: 0, height: 0 }
            });

            // æ›´æ–°åæ ‡ (å¢åŠ  kind å‚æ•°: 'name' | 'group')
            const updateInputRect = (e, kind) => {
                const wrapperClass = kind === 'name' ? '.settings-name-wrapper' : '.settings-group-wrapper';
                const el = e.target.closest(wrapperClass);
                if (el) {
                    const r = el.getBoundingClientRect();
                    inputRects[kind] = { top: r.top, left: r.left, width: r.width, height: r.height };
                }
            };

            // ğŸŸ¢ åŠ¨æ€è®¡ç®—æ ·å¼ (æ ¹æ® kind è·å–å„è‡ªçš„åæ ‡)
            const getFloatingStyle = (kind) => {
                const rect = inputRects[kind]; // è·å–å„è‡ªç‹¬ç«‹çš„åæ ‡
                const windowHeight = window.innerHeight;

                const inputBottom = rect.top + rect.height;
                const spaceBelow = windowHeight - inputBottom;
                const menuHeight = 220;
                const isDropUp = spaceBelow < menuHeight;

                const style = {
                    position: 'fixed',
                    left: `${rect.left}px`,
                    width: `${rect.width}px`,
                    margin: 0,
                    zIndex: 99999,
                };

                if (isDropUp) {
                    style.top = 'auto';
                    style.bottom = `${windowHeight - rect.top + 5}px`;
                    style.transformOrigin = 'bottom center';
                } else {
                    style.top = `${inputBottom + 5}px`;
                    style.bottom = 'auto';
                    style.transformOrigin = 'top center';
                }

                return style;
            };

            // ğŸŸ¢ å…³é”®ï¼šæ»šåŠ¨æ—¶å…³é—­èœå• (é˜²æ­¢èœå•æ‚¬æµ®åœ¨ç©ºä¸­ä¸åŠ¨)
            const onSettingsScroll = () => {
                if (settingsNameFocus.value || settingsGroupFocus.value) {
                    settingsNameFocus.value = null;
                    settingsGroupFocus.value = null;
                }
            };

            // ğŸŸ¢ æ–°å¢ï¼šåç§°è¾“å…¥æ¡†çš„ç„¦ç‚¹çŠ¶æ€
            const settingsNameFocus = ref(null);

            // ğŸŸ¢ æ–°å¢ï¼šè·å–å½“å‰ç±»å‹ä¸‹â€œæœªåˆ†ç»„â€çš„é¡¹ç›®
            const getUngroupedItems = (type) => {
                let list = [];
                if (type === 'instrument') list = settings.instruments;
                else if (type === 'musician') list = settings.musicians;
                else if (type === 'project') list = settings.projects;

                // ç­›é€‰æ¡ä»¶ï¼šæ²¡æœ‰ group æˆ–è€… group æ˜¯ç©ºå­—ç¬¦ä¸²
                return list.filter(i => !i.group || !i.group.trim())
                    .sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));
            };

            // å®šä¹‰ä¸€å¥—ç¬¦åˆ App é£æ ¼çš„é¢„è®¾é¢œè‰²
            const presetColors = [
                '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16',
                '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9',
                '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef',
                '#ec4899', '#f43f5e', '#64748b', '#71717a', '#000000'
            ];

            // æ‰“å¼€é¢œè‰²é€‰æ‹©å™¨
            const openColorPicker = (item, type) => {
                colorPickerTarget.value = { item, type };
                tempColor.value = item.color || getDefaultColorByType(type);
                showColorPickerModal.value = true;
            };

            // è·å–é»˜è®¤é¢œè‰² (ç”¨äºé‡ç½®)
            const getDefaultColorByType = (type) => {
                if (type === 'project') return '#eab308';    // é»„
                if (type === 'instrument') return '#3b82f6'; // è“
                if (type === 'musician') return '#a855f7';   // ç´«
                return '#9ca3af';
            };

            // é‡ç½®é¢œè‰²
            const resetColorPicker = () => {
                if (colorPickerTarget.value) {
                    tempColor.value = getDefaultColorByType(colorPickerTarget.value.type);
                }
            };

            // ç¡®è®¤ä¿å­˜
            const saveColorPicker = () => {
                if (colorPickerTarget.value && tempColor.value) {
                    // æ›´æ–°å¯¹è±¡é¢œè‰²
                    colorPickerTarget.value.item.color = tempColor.value;
                    pushHistory(); // ä¿å­˜å†å²
                }
                showColorPickerModal.value = false;
            };

            // 1. åˆ‡æ¢å•ä¸ªåˆ†ç»„ (ä¿®æ”¹ï¼šå¢åŠ  type å‚æ•°ï¼Œä½¿ç”¨å¤åˆé”®)
            const toggleSettingsGroup = (type, groupName) => {
                const key = type + '|' + groupName; // ğŸŸ¢ ç”Ÿæˆå”¯ä¸€ Key
                if (settingsExpandedGroups.has(key)) {
                    settingsExpandedGroups.delete(key);
                } else {
                    settingsExpandedGroups.add(key);
                }
            };

            // 2. åˆ¤æ–­å…¨å±•å¼€ (ä¿®æ”¹ï¼šä½¿ç”¨å¤åˆé”®æ£€æŸ¥)
            const isAllGroupsExpanded = (type) => {
                const groups = getSettingsGroupedList(type);
                if (groups.length === 0) return false;

                // æ£€æŸ¥æ˜¯å¦æ¯ä¸ªåˆ†ç»„çš„ Key éƒ½åœ¨ Set é‡Œ
                return groups.every(g => settingsExpandedGroups.has(type + '|' + g.name));
            };

            // 3. æ‰¹é‡åˆ‡æ¢ (ä¿®æ”¹ï¼šä½¿ç”¨å¤åˆé”®æ“ä½œ)
            const toggleAllGroups = (type) => {
                const groups = getSettingsGroupedList(type);
                const isAllOpen = isAllGroupsExpanded(type);

                if (isAllOpen) {
                    // å…¨å…³
                    groups.forEach(g => settingsExpandedGroups.delete(type + '|' + g.name));
                } else {
                    // å…¨å¼€
                    groups.forEach(g => settingsExpandedGroups.add(type + '|' + g.name));
                }
            };

            // --- ğŸŸ¢ æ–°å¢: è§†å›¾åˆ‡æ¢åŠ¨ç”»ä¸æ‰‹åŠ¿é€»è¾‘ ---
            const viewTransitionName = ref('view-slide-left'); // é»˜è®¤åŠ¨ç”»æ–¹å‘
            const touchStartX = ref(0);
            const touchStartY = ref(0);

            // --- ğŸŸ¢ æ–°å¢: ä¾§è¾¹æ (ä»»åŠ¡æ± ) æ»‘åŠ¨åˆ‡æ¢ Tab ---
            const sidebarTouchStartX = ref(0);
            const sidebarTouchStartY = ref(0);
            const sidebarTabsOrder = ['musician', 'project', 'instrument']; // å®šä¹‰åˆ‡æ¢é¡ºåº

            const onSidebarTouchStart = (e) => {
                // å¦‚æœæ­£åœ¨æ‹–æ‹½ä»»åŠ¡ï¼Œä¸è®°å½•èµ·ç‚¹ï¼Œé˜²æ­¢è¯¯è§¦
                if (dragElClone) return;

                sidebarTouchStartX.value = e.touches[0].clientX;
                sidebarTouchStartY.value = e.touches[0].clientY;
            };

            // 1. å®šä¹‰åŠ¨ç”»çŠ¶æ€å’Œ Scroll å¼•ç”¨
            const sidebarTransitionName = ref('slide-next');
            const sidebarScrollRef = ref(null);

            // ... (åŸæœ‰çš„ sidebarTouchStartX ç­‰å˜é‡ä¿æŒä¸å˜) ...

            // ğŸŸ¢ æ–°å¢ï¼šæ™ºèƒ½åˆ‡æ¢ Tab å‡½æ•° (å¤„ç†åŠ¨ç”»æ–¹å‘)
            const switchSidebarTab = (targetTab) => {
                if (sidebarTab.value === targetTab) return;

                const order = ['musician', 'project', 'instrument'];
                const oldIdx = order.indexOf(sidebarTab.value);
                const newIdx = order.indexOf(targetTab);

                // åˆ¤æ–­æ–¹å‘ï¼šæ–°ç´¢å¼• > æ—§ç´¢å¼• ? å‘å·¦æ¨(Next) : å‘å³æ¨(Prev)
                sidebarTransitionName.value = newIdx > oldIdx ? 'slide-next' : 'slide-prev';

                // åˆ‡æ¢æ•°æ®
                sidebarTab.value = targetTab;

                // åˆ‡æ¢åè‡ªåŠ¨æ»šå›é¡¶éƒ¨ï¼Œä½“éªŒæ›´å¥½
                if (sidebarScrollRef.value) {
                    sidebarScrollRef.value.scrollTop = 0;
                }
            };

            // ğŸŸ¢ æ›´æ–°ï¼šè§¦æ‘¸ç»“æŸå¤„ç†å‡½æ•° (é›†æˆåŠ¨ç”»é€»è¾‘)
            const onSidebarTouchEnd = (e) => {
                if (dragElClone || !isMobile.value) return;

                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                const diffX = endX - sidebarTouchStartX.value;
                const diffY = endY - sidebarTouchStartY.value;

                if (Math.abs(diffX) > Math.abs(diffY) * 1.5 && Math.abs(diffX) > 50) {
                    const currentIndex = sidebarTabsOrder.indexOf(sidebarTab.value);
                    if (currentIndex === -1) return;

                    let nextIndex = currentIndex;
                    let direction = '';

                    if (diffX < 0) {
                        // å·¦æ»‘ -> ä¸‹ä¸€ä¸ª
                        if (currentIndex < sidebarTabsOrder.length - 1) {
                            nextIndex++;
                            direction = 'next';
                        }
                    } else {
                        // å³æ»‘ -> ä¸Šä¸€ä¸ª
                        if (currentIndex > 0) {
                            nextIndex--;
                            direction = 'prev';
                        }
                    }

                    if (nextIndex !== currentIndex) {
                        // ğŸŸ¢ æ‰‹åŠ¨è®¾ç½®åŠ¨ç”»æ–¹å‘
                        sidebarTransitionName.value = direction === 'next' ? 'slide-next' : 'slide-prev';

                        sidebarTab.value = sidebarTabsOrder[nextIndex];
                        window.triggerTouchHaptic('Light');

                        // æ»šå›é¡¶éƒ¨
                        if (sidebarScrollRef.value) sidebarScrollRef.value.scrollTop = 0;
                    }
                }
                sidebarTouchStartX.value = 0;
                sidebarTouchStartY.value = 0;
            };

            // ğŸŸ¢ [ä¿®æ”¹] è‡ªåŠ¨åˆ†é…ï¼šä¿®æ­£å·²å½•éŸ³ä»»åŠ¡å ç”¨ç©ºé—´è®¡ç®— (ä¼˜å…ˆè¯»å– Actual Duration)
            const autoDistributeSections = () => {
                const listData = trackListData.value;
                const viewType = listData.viewType || 'musician';

                if (!listData.items || !listData.schedules || listData.schedules.length === 0) return;

                // 1. è·å–æ‰€æœ‰æ—¥ç¨‹å—çš„æ€»å®¹é‡ (ç§’)
                const capacities = listData.schedules.map(s => parseTime(s.estDuration));
                const totalScheduleCapacity = capacities.reduce((a, b) => a + b, 0);

                if (totalScheduleCapacity === 0) {
                    openAlertModal('æ— æ³•åˆ†é…', 'æ—¥ç¨‹å—çš„æ€»æ—¶é•¿ä¸º 0ã€‚');
                    return;
                }

                // --- é˜¶æ®µ A: ç­›é€‰ä¸åˆ†ç¦» ---
                const lockedItems = [];
                const movableItems = [];

                const usedTimePerSection = new Array(capacities.length).fill(0);
                let totalLockedDuration = 0;

                listData.items.forEach(item => {
                    if (item.isSkipped) return;

                    const rec = item.records?.[viewType];
                    const hasRecord = rec && (
                        (rec.actualDuration && rec.actualDuration !== '00:00') ||
                        (rec.recStart && rec.recStart !== '')
                    );

                    if (hasRecord) {
                        lockedItems.push(item);

                        // ğŸŸ¢ æ ¸å¿ƒä¿®å¤ï¼šè®¡ç®—å ç”¨ç©ºé—´æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨ã€å®é™…å½•éŸ³æ—¶é•¿ã€‘
                        // å¦‚æœå®é™…æ—¶é•¿æ˜¯ 60mï¼Œé¢„è®¡æ˜¯ 50mï¼Œæˆ‘ä»¬å¿…é¡»æŒ‰ 60m æ‰£é™¤ç©ºé—´ï¼Œé˜²æ­¢æ’è½¦
                        let occupiedSec = 0;
                        if (rec.actualDuration && rec.actualDuration !== '00:00') {
                            occupiedSec = parseTime(rec.actualDuration);
                        } else {
                            // å…œåº•ï¼šå¦‚æœæ²¡æœ‰ç®—å¥½ actualDurationï¼Œå°±ç”¨ estDuration
                            occupiedSec = parseTime(item.estDuration);
                        }

                        totalLockedDuration += occupiedSec;

                        if (item.sectionIndex >= 0 && item.sectionIndex < usedTimePerSection.length) {
                            usedTimePerSection[item.sectionIndex] += occupiedSec;
                        }
                    } else {
                        movableItems.push(item);
                    }
                });

                if (movableItems.length === 0) return;

                // --- é˜¶æ®µ B: è®¡ç®—â€œå®Œç¾å¡«å……â€çš„æ—¶é—´é…é¢ ---
                const totalRemainingCapacity = Math.max(0, totalScheduleCapacity - totalLockedDuration);

                // 2. è®¡ç®—å¯ç§»åŠ¨ä»»åŠ¡çš„æ€»è°±é¢æ—¶é•¿
                let totalMovableMusicSec = 0;
                movableItems.forEach(item => {
                    totalMovableMusicSec += parseTime(item.musicDuration || '00:00');
                });

                // 3. åº”ç”¨é…é¢
                movableItems.forEach(item => {
                    let allocatedSec = 0;
                    const itemMusicSec = parseTime(item.musicDuration || '00:00');

                    if (totalMovableMusicSec > 0 && totalRemainingCapacity > 0) {
                        allocatedSec = (itemMusicSec / totalMovableMusicSec) * totalRemainingCapacity;
                    } else {
                        // å…œåº•ï¼šå¦‚æœæ²¡ç©ºé—´äº†æˆ–è€…æ²¡è°±é¢ï¼Œç»™ä¸ªæœ€å°æ—¶é—´
                        allocatedSec = 30;
                    }

                    allocatedSec = Math.max(30, Math.floor(allocatedSec));
                    item.estDuration = formatSecs(allocatedSec);

                    if (itemMusicSec > 0) {
                        item.ratio = (allocatedSec / itemMusicSec).toFixed(1);
                    }
                });

                // --- é˜¶æ®µ C: æ’åº (ç¼–åˆ¶ä¼˜å…ˆ) ---
                movableItems.sort((a, b) => {
                    const sizeA = isOrchestraGroup(a) ? getOrchSize(a.orchestration) : 0;
                    const sizeB = isOrchestraGroup(b) ? getOrchSize(b.orchestration) : 0;
                    return sizeB - sizeA;
                });

                // --- é˜¶æ®µ D: å¡«ç©ºåˆ†é… ---
                let currentSection = 0;

                movableItems.forEach(item => {
                    const itemDuration = parseTime(item.estDuration);

                    while (currentSection < capacities.length - 1) {
                        const capacity = capacities[currentSection];
                        const used = usedTimePerSection[currentSection];

                        // ğŸŸ¢ å®¹é”™ä¼˜åŒ–ï¼šå…è®¸ 5ç§’ è¯¯å·®ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜å¯¼è‡´æœ€åä¸€ç‚¹å¡ä¸è¿›
                        if (used + itemDuration <= capacity + 5) {
                            break;
                        } else {
                            currentSection++;
                        }
                    }

                    item.sectionIndex = currentSection;

                    if (currentSection < usedTimePerSection.length) {
                        usedTimePerSection[currentSection] += itemDuration;
                    }
                });

                pushHistory();
                window.triggerTouchHaptic('Success');
            };

            // ä¿®æ”¹ switchView å‡½æ•°
            const switchView = (targetView) => {
                if (targetView === currentView.value) return;

                if (targetView === 'month') {
                    viewTransitionName.value = 'zoom-out';
                    currentView.value = targetView;

                    // ğŸŸ¢ [æ–°å¢] å¦‚æœæ˜¯åˆ‡åˆ°æ»šåŠ¨æ¨¡å¼ï¼Œè‡ªåŠ¨å®šä½åˆ°å½“å‰æœˆä»½
                    if (monthViewMode.value === 'scrolled') {
                        scrollToMonthDate(viewDate.value);
                    }
                } else {
                    viewTransitionName.value = 'zoom-in';
                    currentView.value = targetView;
                    // åˆ‡å›å‘¨è§†å›¾æ—¶å¯èƒ½ä¹Ÿéœ€è¦ç±»ä¼¼çš„å®šä½é€»è¾‘ï¼Œè¿™é‡Œæš‚ç•¥
                }
                window.triggerTouchHaptic('Light');
            };

            const resetAutoHide = () => {
                // å¼ºåˆ¶æ˜¾ç¤º
                showMobileSlider.value = true;

                // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                if (idleTimer) clearTimeout(idleTimer);

                // è™½ç„¶æ˜¯"ä¿æŒæ˜¾ç¤º"ï¼Œä½†æˆ‘ä»¬è¿˜æ˜¯é‡ç½®ä¸€ä¸ªå®šæ—¶å™¨ï¼Œ
                // ç¡®ä¿å¦‚æœç”¨æˆ·æ‰‹æŒ‡åœåœ¨æ»‘å—ä¸Šä¸åŠ¨ï¼Œå®ƒä¾ç„¶ä¿æŒæ˜¾ç¤ºçŠ¶æ€
                idleTimer = setTimeout(() => {
                    showMobileSlider.value = true;
                }, 1000);
            };

            // --- ğŸŸ¢ æ–°å¢: ç”µè„‘ç«¯é¼ æ ‡æ»‘åŠ¨ç¿»é¡µ (æ¨¡æ‹Ÿè§¦æ‘¸ä½“éªŒ) ---
            const isMouseViewDrag = ref(false);
            const mouseStartX = ref(0);
            const mouseStartY = ref(0);

            const onMainMouseDown = (e) => {
                // 1. å¦‚æœæ˜¯æ‰‹æœºç«¯ï¼Œç›´æ¥å¿½ç•¥ (äº¤ç»™ Touch äº‹ä»¶å¤„ç†)
                if (isMobile.value) return;

                // 2. åªå“åº”é¼ æ ‡å·¦é”®
                if (e.button !== 0) return;

                // 3. æ™ºèƒ½é¿è®©: å¦‚æœç‚¹åˆ°äº†ä»»åŠ¡å—ã€è°ƒæ•´æ‰‹æŸ„æˆ–æ»šåŠ¨æ¡ï¼Œä¸è§¦å‘ç¿»é¡µ
                if (e.target.closest('.task-block') || e.target.closest('.resize-handle')) return;

                isMouseViewDrag.value = true;
                mouseStartX.value = e.clientX;
                mouseStartY.value = e.clientY;
            };

            const onMainMouseUp = (e) => {
                if (!isMouseViewDrag.value) return;
                isMouseViewDrag.value = false;

                const diffX = e.clientX - mouseStartX.value;
                const diffY = e.clientY - mouseStartY.value;

                // 4. åˆ¤å®šé˜ˆå€¼ (é€»è¾‘åŒæ‰‹æœºç«¯: æ°´å¹³è·ç¦» > å‚ç›´è·ç¦»çš„1.5å€ ä¸” è·ç¦» > 50px)
                if (Math.abs(diffX) > Math.abs(diffY) * 1.5 && Math.abs(diffX) > 50) {
                    const dir = diffX < 0 ? 1 : -1; // å·¦æ»‘=ä¸‹ç¿»(1), å³æ»‘=ä¸Šç¿»(-1)
                    changeDate(dir);
                }
            };

            // --- ğŸŸ¢ æ–°å¢: è§¦æ§æ¿å·¦å³æ»‘åŠ¨åˆ‡æ¢ (é˜²æŠ–åŠ¨å¤„ç†) ---
            let isWheelLocked = false; // é”å®šçŠ¶æ€ï¼Œé˜²æ­¢è¿ç»­è§¦å‘

            const onMainWheel = (e) => {
                // 1. å¦‚æœæ­£åœ¨åŠ¨ç”»é”å®šä¸­ï¼Œæˆ–è€…æŒ‰ä½äº† Ctrl/Cmd (å¯èƒ½æ˜¯ç¼©æ”¾)ï¼Œåˆ™å¿½ç•¥
                if (isWheelLocked || e.ctrlKey || e.metaKey) return;

                // 2. åˆ¤æ–­æ˜¯å¦ä¸ºæ°´å¹³æ»‘åŠ¨ (Xè½´ç§»åŠ¨é‡ > Yè½´ç§»åŠ¨é‡)
                // ä¸”ç§»åŠ¨åŠ›åº¦è¶³å¤Ÿå¤§ (é˜ˆå€¼è®¾ä¸º 30ï¼Œé¿å…è½»å¾®è¯¯è§¦)
                if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && Math.abs(e.deltaX) > 30) {

                    // 3. é˜»æ­¢æµè§ˆå™¨é»˜è®¤çš„â€œå‰è¿›/åé€€â€æ‰‹åŠ¿
                    e.preventDefault();

                    // 4. åˆ¤æ–­æ–¹å‘
                    // deltaX > 0 é€šå¸¸ä»£è¡¨å‘å³æ»šåŠ¨(çœ‹å³è¾¹çš„å†…å®¹) -> ä¸‹ä¸€å‘¨
                    // deltaX < 0 é€šå¸¸ä»£è¡¨å‘å·¦æ»šåŠ¨(çœ‹å·¦è¾¹çš„å†…å®¹) -> ä¸Šä¸€å‘¨
                    const dir = e.deltaX > 0 ? 1 : -1;

                    // 5. æ‰§è¡Œåˆ‡æ¢
                    changeDate(dir);

                    // 6. ä¸Šé” (800ms å†…ä¸æ¥å—æ–°çš„åˆ‡æ¢ï¼Œç­‰å¾…åŠ¨ç”»å®Œæˆ)
                    isWheelLocked = true;
                    setTimeout(() => {
                        isWheelLocked = false;
                    }, 800);
                }
            };

            // è§¦æ‘¸å¼€å§‹ (è®°å½•èµ·ç‚¹)
            const onMainTouchStart = (e) => {
                // å¦‚æœæ­£åœ¨æ‹–æ‹½ä»»åŠ¡ï¼Œä¸è§¦å‘æ»‘å±åˆ‡æ¢
                if (dragElClone || isResizingMobile.value) return;

                touchStartX.value = e.touches[0].clientX;
                touchStartY.value = e.touches[0].clientY;
            };

            // ğŸŸ¢ ä¿®å¤: è§¦æ‘¸ç»“æŸ (åˆ¤å®šæ›´å®½æ¾ï¼ŒX > Y * 1.5 å³å¯)
            const onMainTouchEnd = (e) => {
                // å¦‚æœæ­£åœ¨æ‹–æ‹½ä»»åŠ¡æˆ–è°ƒæ•´å¤§å°ï¼Œä¸è§¦å‘è§†å›¾åˆ‡æ¢
                if (dragElClone || isResizingMobile.value) return;

                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;

                const diffX = endX - touchStartX.value;
                const diffY = endY - touchStartY.value;

                // ä¼˜åŒ–: æ°´å¹³è·ç¦» > å‚ç›´è·ç¦»çš„ 1.5 å€ (æ¯”ä¹‹å‰çš„ 2 å€æ›´çµæ•) ä¸”è·ç¦» > 50px
                if (Math.abs(diffX) > Math.abs(diffY) * 1.5 && Math.abs(diffX) > 50) {

                    let dir = 0;
                    if (diffX < 0) dir = 1;  // å·¦åˆ’ -> ä¸‹ä¸€å‘¨
                    if (diffX > 0) dir = -1; // å³åˆ’ -> ä¸Šä¸€å‘¨

                    if (dir !== 0) {
                        // A. å‘¨è§†å›¾ (ä»…çª„å±æ¨¡å¼ä¸‹å…è®¸)
                        if (currentView.value === 'week') {
                            if (dayColWidth.value < 60) {
                                changeDate(dir);
                            }
                        }
                        // B. æœˆè§†å›¾ (å§‹ç»ˆå…è®¸)
                        else if (currentView.value === 'month') {
                            changeDate(dir);
                        }
                    }
                }

                // å½’é›¶
                touchStartX.value = 0;
                touchStartY.value = 0;
            };

            const currentScrollSpeed = {x: 0, y: 0};

            // ğŸŸ¢ [ä¿®æ”¹] å›¾æ ‡é€»è¾‘ï¼šæ ¹æ®è§†å›¾ç±»å‹æ˜¾ç¤ºä¸åŒå›¾æ ‡
            const widthIcon = computed(() => {
                // 1. æœˆè§†å›¾ï¼šæ˜¾ç¤º ç¿»é¡µ vs æ»šåŠ¨ å›¾æ ‡
                if (currentView.value === 'month') {
                    // å¦‚æœå½“å‰æ˜¯åˆ†é¡µï¼Œæ˜¾ç¤º"åˆ‡æ¢åˆ°æµå¼"å›¾æ ‡ï¼›åä¹‹äº¦ç„¶
                    return monthViewMode.value === 'paged' ? 'fa-scroll' : 'fa-table-cells';
                }

                // 2. å‘¨è§†å›¾ï¼šä¿æŒåŸæœ‰å®½çª„åˆ‡æ¢å›¾æ ‡
                if (dayColWidth.value >= 100) return 'fa-compress';
                return 'fa-expand';
            });

// ğŸŸ¢ [ä¿®æ”¹] æŒ‰é’®ç‚¹å‡»é€»è¾‘
            const cycleDayWidth = () => {
                // åœ¨ cycleDayWidth å‡½æ•°å†…
                if (currentView.value === 'month') {
                    monthViewMode.value = monthViewMode.value === 'paged' ? 'scrolled' : 'paged';
                    window.triggerTouchHaptic('Medium');

                    // ğŸŸ¢ [ä¿®æ”¹] åˆ‡æ¢åˆ°æ»šåŠ¨æ¨¡å¼æ—¶ï¼Œå®šä½åˆ°å½“å‰æœˆï¼Œè€Œä¸æ˜¯å•çº¯å›åˆ°é¡¶éƒ¨
                    if (monthViewMode.value === 'scrolled') {
                        scrollToMonthDate(viewDate.value);
                    } else {
                        // åˆ‡å›åˆ†é¡µæ¨¡å¼ï¼Œå›åˆ°é¡¶éƒ¨
                        const main = document.getElementById('main-content');
                        if (main) main.scrollTop = 0;
                    }
                    return;
                }

                // 2. å‘¨è§†å›¾é€»è¾‘ (ä¿æŒä¸å˜)
                if (dayColWidth.value >= 100) {
                    dayColWidth.value = window.innerWidth < 400 ? 45 : 52;
                } else {
                    dayColWidth.value = 100;
                }
                localStorage.setItem('musche_day_width', dayColWidth.value);
                window.triggerTouchHaptic('Medium');
            };

            // ğŸŸ¢ ä¿®å¤: ç»ˆæä¿®æ­£ç‰ˆæ¸…ç†å‡½æ•°
            // ä¿®å¤äº† S_DEFAULT å«ä¸‹åˆ’çº¿å¯¼è‡´çš„åˆ†ç»„è§£æé”™è¯¯ï¼Œé˜²æ­¢è¯¯åˆ æ‰€æœ‰æ—¥ç¨‹
            const cleanupEmptySchedules = () => {
                const activePoolIds = new Set(itemPool.value.map(i => i.id));
                const originalLength = scheduledTasks.value.length;

                // 1. æŒ‰ "Session | ç±»å‹ | ID" åˆ†ç»„æ—¥ç¨‹å—
                // ğŸ”´ ä¿®å¤: ä½¿ç”¨ "|" ä½œä¸ºåˆ†éš”ç¬¦ï¼Œå› ä¸º S_DEFAULT å«æœ‰ä¸‹åˆ’çº¿ï¼Œä¼šå¯¼è‡´ split å‡ºé”™
                const groups = {};
                const getGroupKey = (t) => {
                    const sess = t.sessionId || 'S_DEFAULT';
                    if (t.musicianId) return `${sess}|M|${t.musicianId}`;
                    if (t.projectId) return `${sess}|P|${t.projectId}`;
                    if (t.instrumentId) return `${sess}|I|${t.instrumentId}`;
                    return null;
                };

                scheduledTasks.value.forEach(t => {
                    if (!t.templateId) { // ä»…å¤„ç†èšåˆå—
                        const k = getGroupKey(t);
                        if (k) {
                            if (!groups[k]) groups[k] = [];
                            groups[k].push(t);
                        }
                    }
                });

                const schedulesKeepSet = new Set();

                // 2. éå†æ¯ä¸€ç»„
                Object.entries(groups).forEach(([key, scheduleBlocks]) => {
                    // A. æ’åº
                    scheduleBlocks.sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));

                    // ğŸ”´ ä¿®å¤: æ­£ç¡®è§£æ Key (ä½¿ç”¨ | åˆ†å‰²)
                    const [sess, type, id] = key.split('|');

                    // B. ç­›é€‰ä»»åŠ¡æ± 
                    const poolItems = itemPool.value.filter(i => {
                        if ((i.sessionId || 'S_DEFAULT') !== sess) return false;
                        if (type === 'M') return i.musicianId === id;
                        if (type === 'P') return i.projectId === id;
                        if (type === 'I') return i.instrumentId === id;
                        return false;
                    });

                    // C. å»ºç«‹æ˜ å°„: SectionIndex -> ä»»åŠ¡åˆ—è¡¨
                    const taskMap = new Map();
                    poolItems.forEach(t => {
                        let idx = parseInt(t.sectionIndex);
                        if (isNaN(idx)) idx = 0;

                        if (!taskMap.has(idx)) taskMap.set(idx, []);
                        taskMap.get(idx).push(t);
                    });

                    // D. æ ¸å¿ƒ: ç´¢å¼•å¯¹é½ä¸ä¿ç•™é€»è¾‘
                    let newBlockIndex = 0;

                    scheduleBlocks.forEach((block, oldIndex) => {
                        const relatedTasks = taskMap.get(oldIndex);

                        if (relatedTasks && relatedTasks.length > 0) {
                            // âœ… å‘½ä¸­ï¼šä¿ç•™è¯¥å—
                            schedulesKeepSet.add(block.scheduleId);

                            // âš¡ï¸ ä¿®æ­£ç´¢å¼•ï¼šå¦‚æœå‰é¢æœ‰å—è¢«åˆ äº†ï¼Œä¿®æ­£å½“å‰ä»»åŠ¡çš„ index
                            if (oldIndex !== newBlockIndex) {
                                relatedTasks.forEach(t => {
                                    t.sectionIndex = newBlockIndex;
                                });
                            }
                            newBlockIndex++;
                        }
                        // âŒ æœªå‘½ä¸­ï¼šè¯¥å—å¯¹åº”ä»»åŠ¡å·²ç©ºï¼Œä¸åŠ å…¥ KeepSet (å³åˆ é™¤)
                    });
                });

                // 3. æ‰§è¡Œç‰©ç†åˆ é™¤
                scheduledTasks.value = scheduledTasks.value.filter(task => {
                    if ((task.sessionId || 'S_DEFAULT') !== currentSessionId.value) return true;

                    // éèšåˆå— (æœ‰å…·ä½“ templateId)ï¼Œæ£€æŸ¥ ID æ˜¯å¦å­˜åœ¨
                    if (task.templateId) return activePoolIds.has(task.templateId);

                    // èšåˆå—ï¼Œæ£€æŸ¥æ˜¯å¦åœ¨ä¿ç•™åå•é‡Œ
                    return schedulesKeepSet.has(task.scheduleId);
                });

                if (scheduledTasks.value.length < originalLength) {
                    window.triggerTouchHaptic('Medium');
                }
            };

            // ğŸŸ¢ æ–°å¢: å¼ºåŠ›æ‰«æå¹¶æ¸…ç†å½“å‰å¼¹çª—å†…çš„ç©ºæ—¥ç¨‹å—
            const pruneEmptySchedules = () => {
                const listData = trackListData.value;
                if (!listData.schedules || listData.schedules.length === 0) return;

                // å€’åºéå†ï¼Œé˜²æ­¢åˆ é™¤å…ƒç´ æ—¶ç´¢å¼•é”™ä½
                for (let i = listData.schedules.length - 1; i >= 0; i--) {
                    // æ£€æŸ¥å±äºå½“å‰ sectionIndex (i) çš„ä»»åŠ¡è¿˜æœ‰å‡ ä¸ª
                    const itemsInSection = listData.items.filter(item => item.sectionIndex === i);

                    // å¦‚æœä¸€ä¸ªéƒ½æ²¡æœ‰äº†ï¼Œè¯´æ˜è¿™ä¸ªæ—¥ç¨‹å—æ˜¯ä¸ªç©ºå£³
                    if (itemsInSection.length === 0) {
                        const scheduleToRemove = listData.schedules[i];

                        // 1. ä»ä¸»æ•°æ®åº“ scheduledTasks ä¸­å½»åº•åˆ é™¤è¯¥æ—¥ç¨‹
                        scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== scheduleToRemove.scheduleId);

                        // 2. ä»å¼¹çª— UI æ•°æ®ä¸­ç§»é™¤
                        listData.schedules.splice(i, 1);

                        // 3. å…³é”®: ä¿®æ­£æ‰€æœ‰åç»­ä»»åŠ¡çš„ sectionIndex
                        // å› ä¸ºç¬¬ i ä¸ªæ—¥ç¨‹æ²¡äº†ï¼Œé‚£ä¹ˆæ‰€æœ‰ sectionIndex > i çš„ä»»åŠ¡ï¼Œç´¢å¼•éƒ½è¦å‡ 1
                        listData.items.forEach(item => {
                            if (item.sectionIndex > i) {
                                item.sectionIndex--;
                            }
                        });
                    }
                }

                // æ›´æ–°æ€»æ®µæ•°
                listData.totalSections = listData.schedules.length;

                // å¦‚æœå…¨éƒ¨åˆ å…‰äº†ï¼Œå…³é—­å¼¹çª—
                if (listData.totalSections === 0) {
                    showTrackList.value = false;
                } else {
                    // ä¿®æ­£å½“å‰æ˜¾ç¤ºçš„ç´¢å¼•ï¼Œé˜²æ­¢è¶Šç•Œ
                    if (listData.currentSectionIndex >= listData.totalSections) {
                        listData.currentSectionIndex = listData.totalSections - 1;
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: æ ¹æ®å½•éŸ³è®°å½•è‡ªåŠ¨è°ƒæ•´æ—¥ç¨‹å— (ç²¾ç¡®å¸é™„ç‰ˆ)
            // ä¿®æ”¹ç‚¹ï¼šç§»é™¤äº† snapToGrid çš„ 30åˆ†é’Ÿå¼ºåˆ¶å¸é™„ï¼Œç°åœ¨ä¼šç²¾ç¡®è´´åˆå½•éŸ³æ—¶é—´çš„è¾¹ç¼˜
            const autoResizeScheduleByRecords = (isSilent = false, shouldPushHistory = true) => {
                // 1. è·å–å½“å‰å¼¹çª—ç®¡ç†çš„æ‰€æœ‰æ—¥ç¨‹å— (Sections)
                const sections = trackListData.value.schedules;
                const items = trackListData.value.items;
                const viewType = trackListData.value.viewType || 'musician';

                let hasUpdate = false;

                // 2. éå†æ¯ä¸ªæ—¥ç¨‹å— (Section)
                sections.forEach((scheduleRef, sectionIndex) => {
                    if (!scheduleRef) return;

                    // æ‰¾åˆ°å±äºè¯¥ Section çš„æ‰€æœ‰ Tracks
                    const sectionItems = items.filter(t => (t.sectionIndex || 0) === sectionIndex);

                    if (sectionItems.length === 0) return;

                    let minMins = Infinity;
                    let maxMins = -Infinity;

                    // 3. æ‰¾å‡ºè¯¥æ®µè½å†… æœ€æ—©å¼€å§‹ å’Œ æœ€æ™šç»“æŸ çš„åˆ†é’Ÿæ•°
                    sectionItems.forEach(item => {
                        const rec = item.records[viewType];
                        if (!rec) return;

                        if (rec.recStart) {
                            const [h, m] = rec.recStart.split(':').map(Number);
                            const startVal = h * 60 + m;
                            if (startVal < minMins) minMins = startVal;
                        }
                        if (rec.recEnd) {
                            const [h, m] = rec.recEnd.split(':').map(Number);
                            let endVal = h * 60 + m;
                            // å¤„ç†è·¨å¤©
                            if (rec.recStart) {
                                const [sh, sm] = rec.recStart.split(':').map(Number);
                                if (endVal < (sh * 60 + sm)) endVal += 24 * 60;
                            }
                            // å¦‚æœç»“æŸæ—¶é—´æ­£å¥½ç­‰äºå¼€å§‹æ—¶é—´(æ¯”å¦‚0æ—¶é•¿)ï¼Œä¸åº”è¯¥æ¨å¤§ maxMinsï¼Œé™¤éå®ƒæ˜¯å”¯ä¸€çš„è®°å½•
                            if (endVal > maxMins) maxMins = endVal;
                        }
                    });

                    // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ—¶é—´è®°å½•ï¼Œè·³è¿‡
                    if (minMins === Infinity || maxMins === -Infinity) return;

                    // 4. [ä¿®æ”¹ç‚¹] ç²¾ç¡®å¸é™„ï¼šä¸å†å¼ºåˆ¶å¸é™„åˆ° 00/30 ç½‘æ ¼
                    // ç›´æ¥ä½¿ç”¨è®¡ç®—å‡ºçš„æœ€æ—©/æœ€æ™šæ—¶é—´ä½œä¸ºæ—¥ç¨‹å—çš„è¾¹ç•Œ
                    const newStartMins = minMins;
                    const newEndMins = maxMins;

                    // è®¡ç®—æ–°æ—¶é•¿
                    const durationMins = newEndMins - newStartMins;

                    // å®‰å…¨æ£€æŸ¥ï¼šæ—¶é•¿å¿…é¡»å¤§äº0 (é˜²æ­¢è¯¯æ“ä½œå¯¼è‡´æ—¥ç¨‹å—æ¶ˆå¤±)
                    if (durationMins <= 0) return;

                    // 5. æ›´æ–°ä¸»æ•°æ® scheduledTasks
                    const taskInMainArray = scheduledTasks.value.find(t => t.scheduleId === scheduleRef.scheduleId);

                    if (taskInMainArray) {
                        // è½¬æ¢å› HH:MM æ ¼å¼
                        const sh = Math.floor(newStartMins / 60);
                        const sm = newStartMins % 60;
                        const newStartTimeStr = `${String(sh).padStart(2, '0')}:${String(sm).padStart(2, '0')}`;

                        // è½¬æ¢æ—¶é•¿ä¸º HH:MM:SS
                        const newDurationStr = formatSecs(durationMins * 60);

                        // æ£€æŸ¥æ˜¯å¦æœ‰å˜æ›´ï¼Œé¿å…æ— æ•ˆæ›´æ–°
                        if (taskInMainArray.startTime !== newStartTimeStr || taskInMainArray.estDuration !== newDurationStr) {
                            taskInMainArray.startTime = newStartTimeStr;
                            taskInMainArray.estDuration = newDurationStr;
                            hasUpdate = true;
                        }
                    }
                });

                if (hasUpdate) {
                    // ğŸŸ¢ åªæœ‰æ˜¾å¼è¦æ±‚æ—¶æ‰ä¿å­˜
                    // if (shouldPushHistory) {
                    //     pushHistory();
                    // }
                    // è‡ªåŠ¨æ¨¡å¼ä¸‹ä¸å¼¹çª—ï¼Œä½†å¯ä»¥ç»™ä¸ªè½»å¾®éœ‡åŠ¨åé¦ˆ
                    if (!isSilent) {
                        window.triggerTouchHaptic('Success');
                        // æç¤ºè¯­å¾®è°ƒ
                        openAlertModal('è‡ªåŠ¨è°ƒæ•´å®Œæˆ', 'æ—¥ç¨‹å—å·²æ ¹æ®å®é™…å½•éŸ³æ—¶é—´ç²¾ç¡®è°ƒæ•´ã€‚');
                    }
                } else {
                    if (!isSilent) {
                        openAlertModal('æ— éœ€è°ƒæ•´', 'æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ—¶é—´è®°å½•ï¼Œæˆ–å½“å‰æ—¥ç¨‹å·²åŒ¹é…ã€‚');
                    }
                }
            };


            // ğŸŸ¢ ä¿®å¤ç‰ˆ: æ™ºèƒ½è·³è½¬ (é€‚é…é•¿åŠ¨ç”»)
            const smartScrollToTask = (targetTask) => {
                if (!targetTask) return;

                // 1. å¼ºåˆ¶åˆ‡æ¢åˆ°æ—¥ç¨‹è¡¨ (æ‰‹æœºç«¯)
                if (isMobile.value) {
                    mobileTab.value = 'schedule';
                }

                // 2. å‡†å¤‡ç›®æ ‡æ—¥æœŸ
                const targetDateObj = new Date(targetTask.date.replace(/-/g, '/'));

                // åˆ¤æ–­åŠ¨ç”»æ–¹å‘
                if (targetDateObj.getTime() > viewDate.value.getTime()) {
                    dateTransitionName.value = 'slide-next';
                } else if (targetDateObj.getTime() < viewDate.value.getTime()) {
                    dateTransitionName.value = 'slide-prev';
                }

                // 3. åˆ‡æ¢è§†å›¾ & è®¾ç½®æ—¥æœŸ
                currentView.value = 'week';
                viewDate.value = targetDateObj;

                // 4. è§¦å‘é«˜äº®
                flashingTaskId.value = targetTask.scheduleId;
                setTimeout(() => {
                    if (flashingTaskId.value === targetTask.scheduleId) flashingTaskId.value = null;
                }, 2500);

                // ğŸŸ¢ 5. æ ¸å¿ƒä¼˜åŒ–: å»¶è¿Ÿæ‰§è¡Œæ»šåŠ¨
                // CSS åŠ¨ç”»æ—¶é•¿æ˜¯ 400msï¼Œè¿™é‡Œè®¾ç½® 450ms ç¡®ä¿ DOM ç¨³å®šåå†æ»šåŠ¨
                setTimeout(() => {
                    const container = weekContainer.value;
                    if (container) {
                        const pxPerMinVal = pxPerMin.value; // è·å–å½“å‰ç¼©æ”¾æ¯”ä¾‹

                        // --- A. å‚ç›´å®šä½ ---
                        const startMins = timeToMinutes(targetTask.startTime);
                        const offsetMins = startMins - settings.startHour * 60;
                        // ç¨å¾®å‘ä¸Šåä¸€ç‚¹ (-50px)ï¼Œè®©ä»»åŠ¡ä¸è¦è´´ç€å±å¹•é¡¶è¾¹ï¼Œè§†è§‰æ›´èˆ’é€‚
                        const targetTopPixel = (offsetMins * pxPerMinVal);
                        const scrollTop = Math.max(0, targetTopPixel - 50);

                        // --- B. æ°´å¹³å®šä½ ---
                        const dayIndex = targetDateObj.getDay();
                        const timeColW = isMobile.value ? 40 : 70;
                        // åŠ¨æ€è®¡ç®—åˆ—å®½
                        const totalW = container.scrollWidth - timeColW;
                        const singleDayW = totalW / 7;

                        const targetCenterX = timeColW + (dayIndex * singleDayW) + (singleDayW / 2);
                        const scrollLeft = Math.max(0, targetCenterX - (container.clientWidth / 2));

                        // æ‰§è¡Œå¹³æ»‘æ»šåŠ¨
                        container.scrollTo({
                            top: scrollTop,
                            left: scrollLeft,
                            behavior: 'smooth'
                        });

                        // ğŸŸ¢ åŒé‡ä¿é™©:
                        // æœ‰æ—¶ smooth æ»šåŠ¨ä¼šè¢«å¹¶æœªå®Œå…¨ç»“æŸçš„æ¸²æŸ“æ‰“æ–­
                        // 100ms åæ£€æŸ¥ä½ç½®ï¼Œå¾®è°ƒä¸€æ¬¡ (è¿™æ¬¡ç”¨ auto ç¬é—´å¯¹é½ï¼Œé˜²æ­¢ç”¨æˆ·æ²¡æ„Ÿè§‰)
                        setTimeout(() => {
                            if (Math.abs(container.scrollTop - scrollTop) > 10) {
                                container.scrollTo({top: scrollTop, left: scrollLeft, behavior: 'auto'});
                            }
                        }, 600);
                    }
                }, 1000); // â³ å»¶è¿Ÿå¢åŠ åˆ° 450ms
            };

            // 1. é¼ æ ‡æŒ‰ä¸‹ (å¼€å§‹æ‹–æ‹½)
            const onDragStart = (e, type) => {
                // ä»…å“åº”é¼ æ ‡å·¦é”® (e.button === 0)
                if (e.button !== 0) return;

                e.preventDefault();
                isDraggingMouse = true;
                startMouseY = e.clientY;

                // ç¡®å®šå½“å‰æ“ä½œçš„æ»šè½®å¼•ç”¨
                activeColRef = type === 'm' ? pickerMinRef.value : pickerSecRef.value;
                startScrollTop = activeColRef.scrollTop;

                // åœ¨å…¨å±€æ·»åŠ ç›‘å¬ï¼Œé˜²æ­¢é¼ æ ‡ç§»å‡ºæ»šè½®åŒºåŸŸåæ‹–æ‹½ä¸­æ–­
                window.addEventListener('mousemove', onDragMove);
                window.addEventListener('mouseup', onDragEnd);
            };

            // 2. é¼ æ ‡ç§»åŠ¨ (æ‰‹åŠ¨æ»šåŠ¨)
            const onDragMove = (e) => {
                if (!isDraggingMouse) return;
                e.preventDefault();

                const deltaY = e.clientY - startMouseY;
                // é¼ æ ‡å‘ä¸‹ç§»åŠ¨ï¼Œæ»šè½®åº”è¯¥å‘ä¸Šæ»šåŠ¨ï¼ˆscrollTop å¢å¤§ï¼‰ï¼Œæ‰€ä»¥æ˜¯å‡æ³•
                activeColRef.scrollTop = startScrollTop - deltaY;

                // NOTE: @scroll äº‹ä»¶ä¼šè´Ÿè´£æ›´æ–° tempDuration
            };

            // 3. é¼ æ ‡æŠ¬èµ· (ç»“æŸæ‹–æ‹½)
            const onDragEnd = () => {
                if (!isDraggingMouse) return;

                isDraggingMouse = false;
                // æ¸…ç†å…¨å±€ç›‘å¬å™¨
                window.removeEventListener('mousemove', onDragMove);
                window.removeEventListener('mouseup', onDragEnd);

                // è§¦å‘ä¸€æ¬¡ @scroll äº‹ä»¶ï¼Œç¡®ä¿æœ€åçš„å€¼è¢«å¸é™„åˆ°ä½
                activeColRef.dispatchEvent(new Event('scroll'));
            };


            // 1. æ‰“å¼€é€‰æ‹©å™¨
            // è°ƒç”¨æ–¹å¼: openDurationPicker(item, 'musicDuration')
            const openDurationPicker = (event, targetObj, key) => {
                // --- A. è®¡ç®—åæ ‡ ---
                const targetEl = event.target; // è·å–è¢«ç‚¹å‡»çš„è¾“å…¥æ¡†
                const rect = targetEl.getBoundingClientRect();

                // æ°”æ³¡å®½é«˜ (ä¸ CSS å¯¹åº”)
                const boxWidth = 280;
                const boxHeight = 320;

                // è®¡ç®— Left: å±…ä¸­å¯¹é½è¾“å…¥æ¡†ï¼Œä½†é˜²æ­¢è¶…å‡ºå±å¹•å·¦å³è¾¹ç•Œ
                let left = rect.left + (rect.width / 2) - (boxWidth / 2);
                // è¾¹ç•Œä¿æŠ¤ (å·¦è¾¹ä¸å°äº 10pxï¼Œå³è¾¹ä¸è¶…å±å¹•)
                left = Math.max(10, Math.min(window.innerWidth - boxWidth - 10, left));

                // è®¡ç®— Top: é»˜è®¤æ˜¾ç¤ºåœ¨è¾“å…¥æ¡†ä¸Šæ–¹ (å‡å»æ°”æ³¡é«˜åº¦å’Œä¸€ç‚¹é—´è·)
                let top = rect.top - boxHeight - 15;

                // å¦‚æœä¸Šæ–¹ç©ºé—´ä¸å¤Ÿ (æ¯”å¦‚è¾“å…¥æ¡†åœ¨å±å¹•æœ€é¡¶ç«¯)ï¼Œåˆ™æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                if (top < 10) {
                    top = rect.bottom + 15;
                    // æ³¨æ„ï¼šå¦‚æœæ˜¾ç¤ºåœ¨ä¸‹æ–¹ï¼Œç†è®ºä¸Š CSS çš„å°ä¸‰è§’åº”è¯¥è½¬æ–¹å‘ï¼Œè¿™é‡Œä¸ºç®€åŒ–æš‚ä¸å¤„ç†
                    // æˆ–è€…ä½ å¯ä»¥ç»™ box åŠ ä¸ª class æ¥ç¿»è½¬ ::after
                }

                pickerPos.top = top;
                pickerPos.left = left;

                // --- B. åˆå§‹åŒ–æ•°æ® ---
                const currentVal = targetObj[key] || '';
                let m = 0, s = 0;
                if (currentVal.includes(':')) {
                    const parts = currentVal.split(':');
                    m = parseInt(parts[0]) || 0;
                    s = parseInt(parts[1]) || 0;
                }
                tempDuration.m = m;
                tempDuration.s = s;
                showDurationPicker.value = true;

                // --- C. è®¾ç½®å›è°ƒ ---
                pickerCallback = (isReset = false) => {
                    const finalStr = isReset ? '' : `${String(tempDuration.m).padStart(2, '0')}:${String(tempDuration.s).padStart(2, '0')}`;
                    targetObj[key] = finalStr;

                    if (targetObj.ratio && targetObj.estDuration !== undefined) {
                        if (typeof calculateEstTime === 'function') {
                            targetObj.estDuration = calculateEstTime(finalStr, targetObj.ratio);
                        }
                    }
                    pushHistory(); // ä¿å­˜å†å²
                };

                // --- D. æ»šåŠ¨åˆ°ä½ ---
                Vue.nextTick(() => {
                    scrollToValue(pickerMinRef.value, m);
                    scrollToValue(pickerSecRef.value, s);
                });
            };

            const closePicker = () => {
                showDurationPicker.value = false;
            };

            const scrollToValue = (el, val) => {
                if (el) el.scrollTop = val * 44; // æ³¨æ„: CSSé‡Œæ”¹æˆäº† 44px é«˜
            };

            let scrollTimeout = null;
            const onScroll = (e, type) => {
                clearTimeout(scrollTimeout);
                const el = e.target;

                // 1. è®¡ç®—å½“å‰æ»šåˆ°äº†ç¬¬å‡ æ ¼ (44px æ˜¯ CSS ä¸­å®šä¹‰çš„æ ¼é«˜)
                // Math.round ç¡®ä¿è¿‡åŠå°±å¸é™„åˆ°ä¸‹ä¸€ä¸ªæ•°å­—
                const newIndex = Math.round(el.scrollTop / 44);

                // 2. è·å–æ—§çš„ç´¢å¼• (ä¸Šä¸€æ¬¡çš„çŠ¶æ€)
                const oldIndex = (type === 'm' ? tempDuration.m : tempDuration.s);

                // ğŸŸ¢ å…³é”®ä¿®æ”¹: åªæœ‰å½“æ•°å­—å‘ç”Ÿå˜åŒ–æ—¶ (è·³æ ¼)ï¼Œæ‰è§¦å‘é€»è¾‘
                if (newIndex !== oldIndex) {

                    // A. æ›´æ–°æ•°æ®
                    if (type === 'm') tempDuration.m = newIndex;
                    if (type === 's') tempDuration.s = newIndex;

                    // B. è§¦å‘éœ‡åŠ¨ ğŸ“³
                    // ä½¿ç”¨ 'Light' æ¡£ä½ï¼Œè¿™ç§è½»å¾®çš„æ•²å‡»æ„Ÿæœ€é€‚åˆæ¨¡æ‹Ÿæ»šè½®çš„é½¿æ„Ÿ
                    window.triggerTouchHaptic('Light');
                }
                // ä»…ç”¨äºæ»šåŠ¨ç»“æŸåçš„å¸é™„ä¿®æ­£ (å¯é€‰)

                scrollTimeout = setTimeout(() => {
                    // æ­¤å¤„å¯ä»¥åŠ é€»è¾‘
                }, 100);

            };

            // è¾…åŠ©ï¼šç²¾ç¡®è®¡ç®—å…ƒç´ å æ®çš„ç‰©ç†ç©ºé—´ (å« margin)
            const getOuterHeight = (el) => {
                if (!el) return 0;
                const style = window.getComputedStyle(el);
                const h = el.offsetHeight;
                const mt = parseFloat(style.marginTop) || 0;
                const mb = parseFloat(style.marginBottom) || 0;
                // å¤„ç† margin collapse (é€šå¸¸å– maxï¼Œä½†åœ¨ space-y å¸ƒå±€ä¸­å¾€å¾€æ˜¯å åŠ æˆ–å›ºå®šé—´è·ï¼Œè¿™é‡Œç®€å•ç›¸åŠ é€šå¸¸è¶³å¤Ÿç²¾ç¡®ï¼Œ
                // å› ä¸ºæˆ‘ä»¬æ˜¯ä¸ºäº†è®¡ç®—"è·¨è¶Šè¿™ä¸ªå…ƒç´ éœ€è¦èµ°å¤šè¿œ")
                // åœ¨ flex/block å¸ƒå±€ä¸­ï¼Œä¸ºäº†é˜²æ­¢ collapse è®¡ç®—å¤æ‚ï¼Œç›´æ¥å–å¤–è¾¹è·æ€»å’Œé€šå¸¸æ›´ç¬¦åˆç›´è§‰æ‰‹æ„Ÿ
                return h + Math.max(mt, mb);
            };

            // 1. å¼€å§‹æ‹–æ‹½
            const startDividerDrag = (e, sectionIndex) => {
                if (dividerDragState) return;
                const isTouch = e.type === 'touchstart';
                if (e.cancelable) e.preventDefault();

                // ğŸŸ¢ å…³é”®ä¿®æ”¹: è™½ç„¶ç‚¹å‡»çš„æ˜¯èƒ¶å›Šï¼Œä½†æˆ‘ä»¬è¦æ“ä½œçš„æ˜¯æ•´è¡Œåˆ†å‰²æ¡
                const triggerEl = e.currentTarget;
                const targetEl = triggerEl.closest('.group\\/divider'); // æŸ¥æ‰¾å¸¦æœ‰ group/divider ç±»çš„çˆ¶å®¹å™¨

                // å¦‚æœæ‰¾ä¸åˆ°çˆ¶å®¹å™¨(ç†è®ºä¸Šä¸ä¼š)ï¼Œå°±å›é€€åˆ°å½“å‰å…ƒç´ 
                const actualTarget = targetEl || triggerEl;

                // éšè—åŸå§‹å…ƒç´ 
                actualTarget.style.opacity = '0';

                const rect = actualTarget.getBoundingClientRect();
                const clientY = isTouch ? e.touches[0].clientY : e.clientY;
                const container = trackListContainerRef.value;
                const initialScrollTop = container ? container.scrollTop : 0;

                // è·å–æ‰€æœ‰å¡ç‰‡ DOM
                const taskEls = Array.from(container.querySelectorAll('.track-card'));
                // ğŸŸ¢ 2. è®¡ç®—é«˜åº¦æ—¶åŒ…å« margin (æ›´ç²¾ç¡®)
                const taskHeights = taskEls.map(el => {
                    const style = window.getComputedStyle(el);
                    return el.offsetHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
                });

                // è®¡ç®—åˆ†å‰²æ¡çš„çœŸå®å æ®é«˜åº¦ (åŒ…å« margin)
                const dividerStyle = window.getComputedStyle(targetEl);
                const ghostHeight = targetEl.offsetHeight + parseFloat(dividerStyle.marginTop) + parseFloat(dividerStyle.marginBottom);

                let startIndex = trackListData.value.items.findIndex(item => item.sectionIndex === sectionIndex);
                if (startIndex === -1) startIndex = trackListData.value.items.length;

                // åˆ›å»ºæ›¿èº«
                const ghost = actualTarget.cloneNode(true);
                Object.assign(ghost.style, {
                    position: 'fixed', top: `${rect.top}px`, left: `${rect.left}px`,
                    width: `${rect.width}px`, height: `${rect.height}px`,
                    zIndex: '9999', opacity: '0.95',
                    boxShadow: '0 4px 15px rgba(0,0,0,0.1)',
                    transform: 'none', transition: 'none', pointerEvents: 'none',
                    // æ›¿èº«å¿…é¡»æ˜¯å¯è§çš„
                    opacity: '1'
                });
                document.body.appendChild(ghost);

                draggingSectionIndex.value = sectionIndex;

                dividerDragState = {
                    targetEl: actualTarget, // ğŸŸ¢ ä¿å­˜å¼•ç”¨ä»¥ä¾¿æ¢å¤
                    ghost: ghost,
                    ghostHeight: ghostHeight,
                    taskEls: taskEls,
                    fingerOffset: clientY - rect.top,
                    lastClientY: clientY,
                    lastScrollTop: initialScrollTop,
                    cumulativeDelta: 0,
                    taskHeights: taskHeights,
                    virtualIndex: startIndex,
                    startIndex: startIndex,
                    sectionIndex: sectionIndex
                };

                window.triggerTouchHaptic('Medium');

                if (isTouch) {
                    window.addEventListener('touchmove', onDividerDragMove, {passive: false});
                    window.addEventListener('touchend', onDividerDragEnd);
                    window.addEventListener('touchcancel', onDividerDragEnd);
                } else {
                    window.addEventListener('mousemove', onDividerDragMove);
                    window.addEventListener('mouseup', onDividerDragEnd);
                }
            };

            // 2. æ‹–æ‹½è¿‡ç¨‹ (ä¿æŒä¸å˜ï¼Œç¡®è®¤é€»è¾‘æ— è¯¯)
            const onDividerDragMove = (e) => {
                if (!dividerDragState) return;
                if (e.cancelable) e.preventDefault();

                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                // A. ç§»åŠ¨æ›¿èº«
                const newTop = clientY - dividerDragState.fingerOffset;
                dividerDragState.ghost.style.top = `${newTop}px`;

                const container = trackListContainerRef.value;
                const currentScrollTop = container ? container.scrollTop : 0;
                const dy = clientY - dividerDragState.lastClientY;
                const dScroll = currentScrollTop - dividerDragState.lastScrollTop;

                dividerDragState.lastClientY = clientY;
                dividerDragState.lastScrollTop = currentScrollTop;
                dividerDragState.cumulativeDelta += (dy + dScroll);

                const {taskHeights, startIndex, ghostHeight, taskEls} = dividerDragState;
                let indexChanged = false;

                // è®¡ç®— Virtual Index
                while (dividerDragState.cumulativeDelta < 0) {
                    if (dividerDragState.virtualIndex <= 0) break;
                    const targetIndex = dividerDragState.virtualIndex - 1;
                    const threshold = taskHeights[targetIndex];
                    if (!threshold || threshold < 10) break;

                    if (dividerDragState.cumulativeDelta < -threshold) {
                        dividerDragState.cumulativeDelta += threshold;
                        dividerDragState.virtualIndex--;
                        indexChanged = true;
                    } else break;
                }

                while (dividerDragState.cumulativeDelta > 0) {
                    if (dividerDragState.virtualIndex >= taskHeights.length) break;
                    const targetIndex = dividerDragState.virtualIndex;
                    const threshold = taskHeights[targetIndex];
                    if (!threshold || threshold < 10) break;

                    if (dividerDragState.cumulativeDelta > threshold) {
                        dividerDragState.cumulativeDelta -= threshold;
                        dividerDragState.virtualIndex++;
                        indexChanged = true;
                    } else break;
                }

                if (indexChanged || isMobile.value) {
                    const vIdx = dividerDragState.virtualIndex;
                    if (indexChanged) window.triggerTouchHaptic('Light');

                    taskEls.forEach((el, i) => {
                        let translateY = 0;
                        // å‘ä¸‹æ‹–ï¼šä¸­é—´çš„å¡ç‰‡å‘ä¸Šç§»
                        if (vIdx > startIndex) {
                            if (i >= startIndex && i < vIdx) translateY = -ghostHeight;
                        }
                        // å‘ä¸Šæ‹–ï¼šä¸­é—´çš„å¡ç‰‡å‘ä¸‹ç§»
                        else if (vIdx < startIndex) {
                            if (i >= vIdx && i < startIndex) translateY = ghostHeight;
                        }

                        if (translateY !== 0) {
                            el.style.transform = `translateY(${translateY}px)`;
                            el.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1)';
                        } else {
                            el.style.transform = '';
                            el.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1)';
                        }
                    });
                }

                handleTrackListAutoScroll(clientY);
            };

            // 3. ç»“æŸæ‹–æ‹½ (ä¿®å¤ç‰ˆï¼šå½»åº•æ¸…é™¤æ ·å¼æ®‹ç•™)
            const onDividerDragEnd = () => {
                if (dividerDragState) {
                    const {sectionIndex, startIndex, virtualIndex, taskEls, targetEl} = dividerDragState;

                    // ğŸŸ¢ 1. ç«‹å³æ¸…é™¤æ‰€æœ‰è§†è§‰åç§» (é˜²æ­¢ Vue å¤ç”¨å¸¦åç§»æ ·å¼çš„ DOM)
                    taskEls.forEach(el => {
                        el.style.transform = '';
                        el.style.transition = 'none'; // ç¦ç”¨åŠ¨ç”»ï¼Œç«‹å³å¤ä½
                    });

                    // ğŸŸ¢ 2. æ¢å¤åŸå§‹åˆ†å‰²æ¡æ˜¾ç¤º
                    if (targetEl) targetEl.style.opacity = '';

                    // 3. ç§»é™¤æ›¿èº«
                    if (dividerDragState.ghost && document.body.contains(dividerDragState.ghost)) {
                        document.body.removeChild(dividerDragState.ghost);
                    }

                    // ğŸŸ¢ 4. å»¶è¿Ÿä¸€å¸§æ‰§è¡Œæ•°æ®æ›´æ–°
                    // è¿™æ ·å¯ä»¥ç¡®ä¿ä¸Šé¢çš„ style.transform = '' å·²ç»ç”Ÿæ•ˆ
                    // å¦åˆ™ Vue å¯èƒ½ä¼šå¤ç”¨ä¸€ä¸ªè¿˜å¸¦æœ‰ translateY çš„å…ƒç´ ï¼Œå¯¼è‡´ä½ç½®å åŠ é”™è¯¯
                    requestAnimationFrame(() => {
                        if (virtualIndex !== startIndex) {
                            const diff = virtualIndex - startIndex;
                            const direction = diff > 0 ? 'down' : 'up';
                            const moves = Math.abs(diff);

                            // æ‰¹é‡ä¿®æ”¹æ•°æ®
                            for (let i = 0; i < moves; i++) {
                                moveDivider(sectionIndex, direction, false);
                            }
                            pushHistory();
                        }
                    });
                }

                dividerDragState = null;
                draggingSectionIndex.value = null;
                stopTrackListAutoScroll();

                window.removeEventListener('touchmove', onDividerDragMove);
                window.removeEventListener('touchend', onDividerDragEnd);
                window.removeEventListener('touchcancel', onDividerDragEnd);
                window.removeEventListener('mousemove', onDividerDragMove);
                window.removeEventListener('mouseup', onDividerDragEnd);
                window.removeEventListener('mousemove', onDividerDragMove);
                window.removeEventListener('mouseup', onDividerDragEnd);
            };

            // ğŸŸ¢ æ–°å¢: åŒæ­¥çŠ¶æ€
            const isSyncing = ref(false);

// ğŸŸ¢ æ–°å¢: æ‰‹åŠ¨åŒæ­¥å‡½æ•°
            const handleManualSync = async () => {
                if (!user.value) {
                    return openAlertModal("è¯·å…ˆç™»å½•", "åªæœ‰ç™»å½•åæ‰èƒ½åŒæ­¥äº‘ç«¯æ•°æ®ã€‚");
                }

                if (isSyncing.value) return; // é˜²æ­¢é‡å¤ç‚¹å‡»

                isSyncing.value = true;
                window.triggerTouchHaptic('Medium'); // éœ‡åŠ¨åé¦ˆ

                try {
                    // å¤ç”¨å·²æœ‰çš„ loadCloudData å‡½æ•°
                    await loadCloudData();

                    // ç¨å¾®å»¶è¿Ÿä¸€ç‚¹ï¼Œè®©åŠ¨ç”»è½¬å®Œï¼Œç»™ç”¨æˆ·ä¸€ç§"å·²å®Œæˆ"çš„å®æ„Ÿ
                    setTimeout(() => {
                        isSyncing.value = false;
                        window.triggerTouchHaptic('Success');
                        // å¯é€‰ï¼šå¦‚æœä¸å¸Œæœ›æ¯æ¬¡éƒ½å¼¹çª—ï¼Œå¯ä»¥åªç”¨éœ‡åŠ¨åé¦ˆï¼Œæˆ–è€…ç”¨ä¸€ä¸ªå°Toast
                        // openAlertModal("åŒæ­¥å®Œæˆ", "å·²æ‹‰å–æœ€æ–°çš„äº‘ç«¯æ•°æ®ã€‚");
                    }, 500);

                } catch (e) {
                    isSyncing.value = false;
                    window.triggerTouchHaptic('Error');
                    openAlertModal("åŒæ­¥å¤±è´¥", "ç½‘ç»œè¿æ¥å¼‚å¸¸æˆ–æœåŠ¡ä¸å¯ç”¨ã€‚");
                }
            };

            // 4. è‡ªåŠ¨æ»šåŠ¨é€»è¾‘ (ç¨å¾®è°ƒæ•´äº†ä¸€ä¸‹å‚æ•°ä»¥é…åˆ fixed å®šä½çš„ ghost)
            const handleTrackListAutoScroll = (clientY) => {
                const container = trackListContainerRef.value;
                if (!container) return;

                const rect = container.getBoundingClientRect();
                const edgeSize = 60;
                const maxSpeed = 15;

                stopTrackListAutoScroll();

                let scrollSpeed = 0;
                // åªæœ‰å½“æ›¿èº«åœ¨å®¹å™¨èŒƒå›´å†…æ—¶æ‰è§¦å‘æ»šåŠ¨ï¼Œé˜²æ­¢æ— é™æ»š
                if (clientY < rect.top + edgeSize && clientY > rect.top - 50) {
                    const intensity = Math.max(0, (rect.top + edgeSize - clientY) / edgeSize);
                    scrollSpeed = -maxSpeed * intensity;
                } else if (clientY > rect.bottom - edgeSize && clientY < rect.bottom + 50) {
                    const intensity = Math.max(0, (clientY - (rect.bottom - edgeSize)) / edgeSize);
                    scrollSpeed = maxSpeed * intensity;
                }

                if (scrollSpeed !== 0) {
                    trackListScrollTimer = requestAnimationFrame(function scrollLoop() {
                        if (scrollSpeed !== 0 && container) {
                            container.scrollTop += scrollSpeed;
                            // æ³¨æ„ï¼šå› ä¸º Ghost æ˜¯ fixed å®šä½ï¼Œå®ƒä¸å—å®¹å™¨ scroll å½±å“ï¼Œ
                            // æ‰€ä»¥è¿™é‡Œä¸éœ€è¦åƒä¹‹å‰é‚£æ ·è¡¥å¿ startYï¼Œè§†è§‰ä¸Šæ˜¯è§£è€¦çš„ã€‚
                            trackListScrollTimer = requestAnimationFrame(scrollLoop);
                        }
                    });
                }
            };

            const stopTrackListAutoScroll = () => {
                if (trackListScrollTimer) {
                    cancelAnimationFrame(trackListScrollTimer);
                    trackListScrollTimer = null;
                }
            };

            const confirmDurationPicker = () => {
                if (pickerCallback) pickerCallback(false);
                showDurationPicker.value = false;
            };

            // ğŸŸ¢ æ–°å¢: é‡ç½®åŠŸèƒ½
            const resetDuration = () => {
                if (pickerCallback) pickerCallback(true); // ä¼  true æ¸…ç©º
                showDurationPicker.value = false;
            };

            // 1. è§¦æ‘¸å¼€å§‹ (ä¿®æ”¹ä¸ºè®°å½•åƒç´ åç§»)
            const handleTouchStart = (e, task, dateStr) => {
                if (!isMobile.value) return;

                dragSourceType = 'schedule';

                const touch = e.touches[0];
                const targetEl = e.currentTarget;

                startX = touch.clientX;
                startY = touch.clientY;
                dragSourceTask = task;
                dragStartDate = dateStr;

                const rect = targetEl.getBoundingClientRect();
                cloneOffsetX = touch.clientX - rect.left;
                cloneOffsetY = touch.clientY - rect.top;
                dragClickOffsetY = touch.clientY - rect.top;

                longPressTimeout = setTimeout(() => {
                    // ğŸŸ¢ ä¿®æ”¹: åªæœ‰éå¹½çµä»»åŠ¡æ‰å…è®¸æ‹–æ‹½
                    // å¹½çµä»»åŠ¡è™½ç„¶ä¸èƒ½æ‹–æ‹½ï¼Œä½†å‰é¢çš„ä»£ç å·²ç»è®°å½•äº† dragSourceTask
                    // æ‰€ä»¥ touchend é‡Œçš„åŒå‡»æ£€æµ‹ä¾ç„¶æœ‰æ•ˆ
                    if (!isTaskGhost(task)) {
                        startMobileDrag(targetEl, touch);
                    }
                }, 300);
            };

            // ğŸŸ¢ ä¿®å¤: è§¦æ‘¸å¼€å§‹ (é˜²è¯¯è§¦ + æ™ºèƒ½çŠ¶æ€åˆ¤æ–­)
            const handlePoolTouchStart = (e, item, type = 'pool') => {
                if (!isMobile.value) return;

                // ğŸ›‘ 1. å½»åº•ç¦æ­¢å°å¡ç‰‡æ‹–åŠ¨ (é˜²æ­¢åˆ—è¡¨æ»‘åŠ¨è¯¯è§¦)
                if (type === 'pool') return;

                // ğŸ›‘ 2. å¤§å¡ç‰‡ (aggregate) çŠ¶æ€æ£€æŸ¥
                if (type === 'aggregate') {
                    // å¦‚æœå·²å®Œæˆæˆ–å·²æ’æ»¡ -> ç¦æ­¢æ‹–åŠ¨ï¼Œåªç»™æ‹’ç»åé¦ˆ
                    if (item.statusKey === 'completed' || item.statusKey === 'full' || item.statusKey === 'in-progress') {
                        // ğŸ“³ éœ‡åŠ¨ä¸¤ä¸‹ï¼Œæç¤ºç”¨æˆ·â€œæ­¤äººå·²æå®šï¼Œæ— éœ€å®‰æ’â€
                        //window.triggerTouchHaptic('Medium');
                        //setTimeout(() => window.triggerTouchHaptic('Medium'), 150);
                        return;
                    }
                }

                // --- ä»¥ä¸‹æ˜¯å…è®¸æ‹–åŠ¨çš„æƒ…å†µ (å¤§å¡ç‰‡ && æ—¶é—´ä¸è¶³/æœªæ’æœŸ) ---
                dragSourceType = type;

                const touch = e.touches[0];
                const targetEl = e.currentTarget;

                startX = touch.clientX;
                startY = touch.clientY;
                dragSourceTask = item;

                const rect = targetEl.getBoundingClientRect();
                cloneOffsetX = touch.clientX - rect.left;
                cloneOffsetY = touch.clientY - rect.top;
                dragClickOffsetY = touch.clientY - rect.top;

                // å¯åŠ¨é•¿æŒ‰è®¡æ—¶å™¨
                longPressTimeout = setTimeout(() => {
                    startMobileDrag(targetEl, touch);

                    mobileTab.value = 'schedule'; // è·³è½¬åˆ°æ—¥ç¨‹è¡¨
                    window.triggerTouchHaptic('Heavy'); // æˆåŠŸè§¦å‘éœ‡åŠ¨
                }, 300);
            };

            // ğŸŸ¢ ä¿®æ”¹: handleTouchMove (å¢åŠ å‘¨è§†å›¾è¾¹ç¼˜ç¿»é¡µåŠŸèƒ½)
            const handleTouchMove = (e) => {
                const touch = e.touches[0];

                // A. å¦‚æœè¿˜åœ¨é•¿æŒ‰æ£€æµ‹é˜¶æ®µ
                if (longPressTimeout && !dragElClone) {
                    const deltaX = Math.abs(touch.clientX - startX);
                    const deltaY = Math.abs(touch.clientY - startY);

                    // å¦‚æœæ‰‹æŒ‡ç§»åŠ¨è¶…è¿‡ 10pxï¼Œè§†ä¸ºç”¨æˆ·æƒ³æ»šåŠ¨å±å¹•ï¼Œå–æ¶ˆé•¿æŒ‰
                    if (deltaX > 10 || deltaY > 10) {
                        clearTimeout(longPressTimeout);
                        longPressTimeout = null;
                    }
                    return;
                }

                // B. å¦‚æœå·²ç»å¼€å§‹æ‹–æ‹½
                if (dragElClone) {
                    // ç¦ç”¨å±å¹•æ»šåŠ¨
                    if (e.cancelable) e.preventDefault();

                    // 1. ç§»åŠ¨å…‹éš†ä½“
                    const x = touch.clientX - cloneOffsetX;
                    const y = touch.clientY - cloneOffsetY;
                    dragElClone.style.transform = `translate3d(${x}px, ${y}px, 0)`;

                    // 2. è§†å›¾è‡ªåŠ¨æ»šåŠ¨ä¸ç¿»é¡µæ£€æµ‹
                    const scrollContainer = weekContainer.value;

                    // --- å‘¨è§†å›¾é€»è¾‘ ---
                    if (currentView.value === 'week' && scrollContainer) {
                        // [Part A] ç°æœ‰çš„å…¨å‘è‡ªåŠ¨æ»šåŠ¨ (ä¿æŒä¸å˜)
                        let vx = 0, vy = 0;
                        if (isMobile.value) {
                            const topZone = 500;
                            const bottomZone = window.innerHeight - 150;
                            const leftZone = 60;
                            const rightZone = window.innerWidth - 60;
                            const ramp = 80;

                            if (touch.clientY < topZone) vy = -Math.min(1, (topZone - touch.clientY) / ramp);
                            else if (touch.clientY > bottomZone) vy = Math.min(1, (touch.clientY - bottomZone) / ramp);

                            if (touch.clientX < leftZone) vx = -Math.min(1, (leftZone - touch.clientX) / ramp);
                            else if (touch.clientX > rightZone) vx = Math.min(1, (touch.clientX - rightZone) / ramp);
                        }

                        if (Math.abs(vx) > 0.05 || Math.abs(vy) > 0.05) {
                            if (!autoScrollInterval) startAutoScroll(vx, vy, scrollContainer, scrollContainer);
                            else updateAutoScrollDirection(vx, vy);
                        } else {
                            stopAutoScroll();
                        }

                        // [Part B] æ–°å¢: å‘¨è§†å›¾è¾¹ç¼˜ç¿»é¡µ (ä»¿æœˆè§†å›¾é€»è¾‘)
                        const edgeThreshold = 50; // è¾¹ç¼˜è§¦å‘åŒºåŸŸå¤§å°
                        let switchDir = 0;

                        // æ£€æµ‹å·¦å³è¾¹ç¼˜
                        if (touch.clientX < edgeThreshold) {
                            switchDir = -1; // ä¸Šä¸€å‘¨
                        } else if (touch.clientX > window.innerWidth - edgeThreshold) {
                            switchDir = 1;  // ä¸‹ä¸€å‘¨
                        }

                        if (switchDir !== 0) {
                            // å¦‚æœæ‰‹æŒ‡åœ¨è¾¹ç¼˜ï¼Œä¸”æ²¡æœ‰æ­£åœ¨ç­‰å¾…çš„ç¿»é¡µå®šæ—¶å™¨
                            if (!monthSwitchTimer) {
                                monthSwitchTimer = setTimeout(() => {
                                    changeDate(switchDir); // æ‰§è¡Œç¿»é¡µ (changeDate ä¼šè‡ªåŠ¨å¤„ç† +7/-7 å¤©)
                                    window.triggerTouchHaptic('Medium'); // éœ‡åŠ¨åé¦ˆ

                                    // ç¿»é¡µåé‡ç½®å®šæ—¶å™¨ï¼Œå…è®¸è¿ç»­ç¿»é¡µ
                                    monthSwitchTimer = null;
                                }, 800); // åœç•™ 800ms åè§¦å‘
                            }
                        } else {
                            // ç¦»å¼€è¾¹ç¼˜ï¼Œå–æ¶ˆå®šæ—¶å™¨
                            if (monthSwitchTimer) {
                                clearTimeout(monthSwitchTimer);
                                monthSwitchTimer = null;
                            }
                        }
                    }

                    // --- æœˆè§†å›¾é€»è¾‘ (ä¿æŒä¸å˜) ---
                    else if (currentView.value === 'month' && isMobile.value) {
                        const edgeThreshold = 50;
                        let switchDir = 0;
                        if (touch.clientX < edgeThreshold) switchDir = -1;
                        else if (touch.clientX > window.innerWidth - edgeThreshold) switchDir = 1;

                        if (switchDir !== 0) {
                            if (!monthSwitchTimer) {
                                monthSwitchTimer = setTimeout(() => {
                                    changeDate(switchDir);
                                    window.triggerTouchHaptic('Medium');
                                    monthSwitchTimer = null;
                                }, 800);
                            }
                        } else {
                            if (monthSwitchTimer) {
                                clearTimeout(monthSwitchTimer);
                                monthSwitchTimer = null;
                            }
                        }
                    }

                    // 3. é«˜äº®æ˜¾ç¤ºä¸‹æ–¹çš„æ ¼å­
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (activeDropSlot) activeDropSlot.classList.remove('drag-over');
                    activeDropSlot = null;

                    if (target) {
                        const slot = target.closest('.grid-slot, .droppable-slot');
                        if (slot) {
                            activeDropSlot = slot;
                            activeDropSlot.classList.add('drag-over');
                        }
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: handleTouchEnd
            const handleTouchEnd = (e) => {
                if (longPressTimeout) {
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;

                    // --- åŒå‡»æ£€æµ‹é€»è¾‘ START ---
                    if (!dragElClone && dragSourceType === 'schedule' && dragSourceTask) {
                        const now = Date.now();

                        // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªä»»åŠ¡ï¼Œä¸”é—´éš”å°äº 300ms (åˆ¤å®šä¸ºåŒå‡»)
                        if (lastTapState.id === dragSourceTask.scheduleId && (now - lastTapState.time) < 300) {

                            // ğŸŸ¢ æ ¸å¿ƒä¿®å¤: é˜»æ­¢æµè§ˆå™¨ç»§ç»­è§¦å‘åŸç”Ÿçš„ click/dblclick
                            // å¦åˆ™åŸç”Ÿ dblclick ä¼šåœ¨ Session åˆ‡æ¢å®Œæˆåå†æ¬¡è§¦å‘ï¼Œå¯¼è‡´è¯¯åˆ¤ä¸ºéå¹½çµä»»åŠ¡ä»è€Œæ‰“å¼€å¼¹çª—
                            if (e.cancelable) e.preventDefault();

                            // ğŸŸ¢ ä¿®å¤: æ‰‹æœºç«¯åŒå‡»å¹½çµä»»åŠ¡æ—¶ï¼Œå¼ºåˆ¶æ‰§è¡Œè·³è½¬é€»è¾‘ï¼Œä¸æ‰“å¼€è¯¦æƒ…é¡µ
                            if (isTaskGhost(dragSourceTask)) {
                                jumpToGhostContext(dragSourceTask);
                            } else {
                                handleTaskDblClick(e, dragSourceTask);
                            }

                            lastTapState.id = null;
                            lastTapState.time = 0;
                        } else {
                            // ç¬¬ä¸€æ¬¡ç‚¹å‡» (åˆ¤å®šä¸ºå•å‡»)
                            lastTapState.id = dragSourceTask.scheduleId;
                            lastTapState.time = now;

                            // ğŸŸ¢ æ ¸å¿ƒä¿®å¤: åœ¨è¿™é‡Œæ‰‹åŠ¨è§¦å‘é€‰ä¸­ï¼
                            selectTask(dragSourceTask.scheduleId, 'schedule');
                        }
                    }
                    // --- ğŸŸ¢ æ–°å¢: åŒå‡»æ£€æµ‹é€»è¾‘ END ---
                }

                stopAutoScroll();

                if (monthSwitchTimer) {
                    clearTimeout(monthSwitchTimer);
                    monthSwitchTimer = null;
                }

                if (dragElClone) {
                    document.body.removeChild(dragElClone);
                    dragElClone = null;
                    if (activeDropSlot) activeDropSlot.classList.remove('drag-over');

                    const touch = e.changedTouches[0];
                    const targetEl = document.elementFromPoint(touch.clientX, touch.clientY);

                    const dropColumn = targetEl ? targetEl.closest('[data-date-str]') : null;
                    const dropMonthCell = targetEl ? targetEl.closest('[data-date]') : null;

                    // --- æƒ…å†µ A: æ”¾ç½®åœ¨å‘¨è§†å›¾ ---
                    if (dropColumn) {
                        const dateStr = dropColumn.dataset.dateStr;
                        const timeGridContainer = dropColumn.querySelector('.relative[style*="min-height"]');

                        if (timeGridContainer && dragSourceTask) {
                            // 1. è®¡ç®—ç›®æ ‡æ—¶é—´
                            const gridRect = timeGridContainer.getBoundingClientRect();
                            const touchYInContainer = touch.clientY - gridRect.top;
                            const taskTopPixel = touchYInContainer - dragClickOffsetY;
                            const minsFromStart = taskTopPixel / pxPerMin.value;
                            let totalMins = (settings.startHour * 60) + minsFromStart;
                            const snappedMins = Math.round(totalMins / 30) * 30;
                            const minMins = settings.startHour * 60;
                            const maxMins = settings.endHour * 60 - 30;
                            const finalMins = Math.max(minMins, Math.min(maxMins, snappedMins));
                            const h = Math.floor(finalMins / 60);
                            const m = finalMins % 60;
                            const newTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

                            // 2. å‡†å¤‡æ£€æµ‹å‚æ•°
                            let checkType = 'musician';
                            let checkDuration = '';
                            let excludeId = null;

                            // åˆ¤æ–­ç±»å‹å’Œæ—¶é•¿
                            if (dragSourceType === 'aggregate') {
                                checkType = sidebarTab.value;
                                const item = dragSourceTask;
                                const remainingSecs = item.totalSeconds - item.scheduledSeconds;
                                if (remainingSecs <= 0) return; // æ²¡æ—¶é—´äº†ï¼Œç›´æ¥é€€å‡º
                                let remainingMins = Math.ceil(remainingSecs / 1800) * 30;
                                if (remainingMins === 0) remainingMins = 30;
                                checkDuration = formatSecs(remainingMins * 60);
                            } else if (dragSourceType === 'pool') {
                                const item = dragSourceTask;
                                if (item.projectId) checkType = 'project';
                                else if (item.instrumentId) checkType = 'instrument';
                                else checkType = 'musician';
                                checkDuration = item.estDuration;
                            } else {
                                // schedule
                                const item = dragSourceTask;
                                if (item.projectId) checkType = 'project';
                                else if (item.instrumentId) checkType = 'instrument';
                                else checkType = 'musician';
                                checkDuration = item.estDuration;
                                excludeId = item.scheduleId; // æ’é™¤è‡ªå·±ï¼Œç§»åŠ¨æ—¶ä¸ç®—å†²çª
                            }

                            // 3. æ‰§è¡Œå†²çªæ£€æµ‹
                            if (checkOverlap(dateStr, newTime, checkDuration, excludeId, checkType)) {
                                openAlertModal('æ—¶é—´å†²çª', 'è¯¥æ—¶é—´æ®µå·²æœ‰é‡å çš„å®‰æ’ã€‚');
                                window.triggerTouchHaptic('Error');
                                if (dragSourceEl) dragSourceEl.style.opacity = '';
                                dragSourceEl = null;
                                activeDropSlot = null;
                                return; // â›”ï¸ å‘ç”Ÿå†²çªï¼Œç»ˆæ­¢æ“ä½œ
                            }

                            // 4. é€šè¿‡æ£€æµ‹ï¼Œæ‰§è¡Œæ”¾ç½®
                            if (dragSourceType === 'aggregate') {
                                const item = dragSourceTask;
                                // æ—¶é•¿é€»è¾‘ä¸Šé¢å·²ç»ç®—è¿‡ä¸€æ¬¡ï¼Œè¿™é‡Œå¤ç”¨
                                const remainingSecs = item.totalSeconds - item.scheduledSeconds;
                                let remainingMins = Math.ceil(remainingSecs / 1800) * 30;
                                if (remainingMins === 0) remainingMins = 30;

                                const nt = {
                                    scheduleId: Date.now(),
                                    sessionId: currentSessionId.value,
                                    musicianId: sidebarTab.value === 'musician' ? item.id : '',
                                    projectId: sidebarTab.value === 'project' ? item.id : '',
                                    instrumentId: sidebarTab.value === 'instrument' ? item.id : '',
                                    date: dateStr,
                                    startTime: newTime,
                                    estDuration: formatSecs(remainingMins * 60),
                                    trackCount: item.trackCount,
                                    ratio: item.defaultRatio || 20,
                                    reminderMinutes: 15,
                                    sound: 'default'
                                };
                                scheduledTasks.value.push(nt);
                                window.triggerTouchHaptic('Success');
                                pushHistory();
                            } else if (dragSourceType === 'pool') {
                                const newTask = {
                                    scheduleId: Date.now(),
                                    sessionId: currentSessionId.value,
                                    projectId: dragSourceTask.projectId,
                                    instrumentId: dragSourceTask.instrumentId,
                                    musicianId: dragSourceTask.musicianId,
                                    musicDuration: dragSourceTask.musicDuration,
                                    ratio: dragSourceTask.ratio,
                                    estDuration: dragSourceTask.estDuration,
                                    date: dateStr,
                                    startTime: newTime,
                                    reminderMinutes: 15,
                                    sound: 'default'
                                };
                                scheduledTasks.value.push(newTask);
                                window.triggerTouchHaptic('Success');
                                pushHistory();
                            } else {
                                // æ—¥ç¨‹å†…éƒ¨ç§»åŠ¨
                                if (dragSourceTask.startTime !== newTime || dragSourceTask.date !== dateStr) {
                                    dragSourceTask.startTime = newTime;
                                    dragSourceTask.date = dateStr;
                                    window.triggerTouchHaptic('Success');
                                    pushHistory();
                                }
                            }
                        }
                    }
                    // --- æƒ…å†µ B: æ”¾ç½®åœ¨æœˆè§†å›¾ ---
                    else if (dropMonthCell && dragSourceTask) {
                        const dateStr = dropMonthCell.dataset.date;

                        if (dragSourceType === 'schedule') {
                            if (dragSourceTask.date !== dateStr) {
                                dragSourceTask.date = dateStr;
                                window.triggerTouchHaptic('Success');
                                pushHistory();
                            }
                        } else if (dragSourceType === 'aggregate' || dragSourceType === 'pool') {
                            const item = dragSourceTask;
                            let mId = '', pId = '', iId = '';
                            let ratio = 20;
                            let estDur = '00:30';
                            let tCount = 0;
                            let musDur = '';
                            let checkType = 'musician';

                            if (dragSourceType === 'pool') {
                                mId = item.musicianId;
                                pId = item.projectId;
                                iId = item.instrumentId;
                                ratio = item.ratio;
                                estDur = item.estDuration;
                                musDur = item.musicDuration;
                                if (pId) checkType = 'project'; else if (iId) checkType = 'instrument';
                            } else {
                                if (sidebarTab.value === 'musician') mId = item.id;
                                else if (sidebarTab.value === 'project') {
                                    pId = item.id;
                                    checkType = 'project';
                                } else if (sidebarTab.value === 'instrument') {
                                    iId = item.id;
                                    checkType = 'instrument';
                                }
                                ratio = item.defaultRatio || 20;
                                estDur = item.estDuration || '00:30';
                                tCount = item.trackCount || 0;
                            }

                            // é»˜è®¤æ’åœ¨å¼€å¤´ï¼Œæ£€æµ‹å†²çª
                            const defaultStart = settings.startHour + ':00';
                            if (checkOverlap(dateStr, defaultStart, estDur, null, checkType)) {
                                openAlertModal('å†²çª', 'è¯¥æ—¥æœŸå·²æœ‰å®‰æ’ï¼Œè¯·åˆ‡æ¢åˆ°å‘¨è§†å›¾æŸ¥çœ‹è¯¦æƒ…ã€‚');
                                window.triggerTouchHaptic('Error');
                            } else {
                                const nt = {
                                    scheduleId: Date.now(),
                                    sessionId: currentSessionId.value,
                                    musicianId: mId, projectId: pId, instrumentId: iId,
                                    date: dateStr, startTime: defaultStart,
                                    estDuration: estDur, trackCount: tCount, ratio: ratio, musicDuration: musDur
                                };
                                scheduledTasks.value.push(nt);
                                window.triggerTouchHaptic('Success');
                                pushHistory();
                            }
                        }
                    }
                }

                if (dragSourceEl) {
                    dragSourceEl.style.opacity = '';
                    dragSourceEl = null;
                }
                activeDropSlot = null;
            };

            // 1. å¯åŠ¨æ»šåŠ¨
            const startAutoScroll = (vx, vy, xContainer, yContainer) => {
                if (autoScrollInterval) return;

                currentScrollSpeed.x = vx;
                currentScrollSpeed.y = vy;

                // ğŸŸ¢ æœ€å¤§æé€Ÿ (åƒç´ /å¸§)
                // å› ä¸º vx/vy ç°åœ¨æ˜¯ 0~1 çš„å°æ•°ï¼Œè¿™é‡Œè®¾å¤§ä¸€ç‚¹ï¼Œæ¯”å¦‚ 20
                const maxSpeed = 25;

                autoScrollInterval = setInterval(() => {
                    isScrollingProgrammatically = true;

                    // --- å‚ç›´æ»šåŠ¨ (Y) ---
                    // é€Ÿåº¦ = å‘é‡å€¼ * æœ€å¤§æé€Ÿ
                    if (Math.abs(currentScrollSpeed.y) > 0 && yContainer) {
                        yContainer.scrollTop += currentScrollSpeed.y * maxSpeed;
                    }

                    // --- æ°´å¹³æ»šåŠ¨ (X) ---
                    if (Math.abs(currentScrollSpeed.x) > 0 && xContainer) {
                        xContainer.scrollLeft += currentScrollSpeed.x * maxSpeed;
                    }

                    setTimeout(() => {
                        isScrollingProgrammatically = false;
                    }, 50);

                }, 16); // çº¦ 60fps
            };

            const updateAutoScrollDirection = (vx, vy) => {
                currentScrollSpeed.x = vx;
                currentScrollSpeed.y = vy;
            };

            // stopAutoScroll ä¿æŒä¸å˜
            const stopAutoScroll = () => {
                if (autoScrollInterval) {
                    clearInterval(autoScrollInterval);
                    autoScrollInterval = null;
                    currentScrollSpeed.x = 0;
                    currentScrollSpeed.y = 0;
                    isScrollingProgrammatically = false;
                }
            };

            // 1. åˆå§‹åŒ–æ‹–åŠ¨
            const initMobileResize = (e, task) => {
                if (!isMobile.value) return;

                // é˜»æ­¢å†’æ³¡
                e.stopPropagation();
                // éœ‡åŠ¨åé¦ˆ
                window.triggerTouchHaptic('Heavy');

                const touch = e.touches[0];
                const taskEl = e.target.closest('.task-block');
                const rect = taskEl.getBoundingClientRect();

                // åˆå§‹åŒ–çŠ¶æ€
                isResizingMobile.value = true;
                mobileResizeState.task = task;
                mobileResizeState.taskEl = taskEl;
                mobileResizeState.startY = touch.clientY;
                mobileResizeState.startHeight = rect.height; // è®°å½•åˆå§‹é«˜åº¦
                mobileResizeState.originalDuration = task.estDuration; // è®°å½•åŸå§‹æ—¶é•¿

                // ç»‘å®šäº‹ä»¶
                // ğŸŸ¢ å…³é”®ä¿®æ”¹ï¼šä¸éœ€è¦ captureï¼Œå› ä¸º touchmove æ²¡æœ‰è¢«é˜»æ­¢
                window.addEventListener('touchmove', handleMobileResizeMove, { passive: false });

                // ğŸŸ¢ æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ  true (ä½¿ç”¨æ•è·æ¨¡å¼)
                // è¿™æ ·å³ä½¿åº•ä¸‹çš„å…ƒç´ æœ‰ @touchend.stopï¼Œwindow ä¹Ÿèƒ½å…ˆæ”¶åˆ°é€šçŸ¥ï¼
                window.addEventListener('touchend', handleMobileResizeEnd, true);
                window.addEventListener('touchcancel', handleMobileResizeEnd, true);
            };

            // ğŸŸ¢ ä¿®æ”¹: æ‰‹æœºç«¯æ‹–åŠ¨è¿‡ç¨‹ (å¸é™„åˆ° Grid ç»å¯¹æ—¶é—´åˆ»åº¦)
            const handleMobileResizeMove = (e) => {
                if (!isResizingMobile.value) return;

                if (e.cancelable) e.preventDefault();

                const touch = e.touches[0];
                const deltaY = touch.clientY - mobileResizeState.startY;

                // 1. è®¡ç®—ç›®æ ‡é«˜åº¦
                const targetHeight = Math.max(5, mobileResizeState.startHeight + deltaY);

                // 2. è½¬æ¢ä¸ºåˆ†é’Ÿ
                const rawDurationMins = targetHeight / pxPerMin.value;

                // 3. è®¡ç®—ç»å¯¹æ—¶é—´å¹¶å¸é™„
                const startMins = timeToMinutes(mobileResizeState.task.startTime);
                const rawEndMins = startMins + rawDurationMins;

                // å¸é™„åˆ° 30 åˆ†é’Ÿç½‘æ ¼
                const snappedEndMins = Math.round(rawEndMins / 30) * 30;

                // 4. è®¡ç®—æ–°æ—¶é•¿
                let newDurationMins = snappedEndMins - startMins;
                if (newDurationMins < 5) newDurationMins = 5;

                const newDurationStr = formatSecs(newDurationMins * 60);

                if (mobileResizeState.task.estDuration !== newDurationStr) {
                    mobileResizeState.task.estDuration = newDurationStr;
                    window.triggerTouchHaptic('Light'); // åªæœ‰æ•°å€¼å˜åŒ–æ—¶æ‰éœ‡åŠ¨
                }
            };

            // 3. æ‹–åŠ¨ç»“æŸ (æ ¸å¿ƒä¿®æ­£)
            const handleMobileResizeEnd = (e) => {
                // å¼ºåˆ¶ç«‹å³é‡ç½®çŠ¶æ€ (å¿…é¡»æ˜¯ç¬¬ä¸€æ­¥ï¼Œä»¥æœ€é«˜ä¼˜å…ˆçº§æ¸…é™¤æ ‡å¿—ä½)
                const wasResizing = isResizingMobile.value;
                isResizingMobile.value = false;

                // å¼ºåˆ¶æ— æ¡ä»¶ç§»é™¤ç›‘å¬å™¨ (å¿…é¡»æ˜¯ç¬¬äºŒæ­¥)
                window.removeEventListener('touchmove', handleMobileResizeMove);

                // ğŸŸ¢ æ ¸å¿ƒä¿®å¤ï¼šç§»é™¤æ—¶ä¹Ÿè¦å¸¦ä¸Š true (æ•è·æ¨¡å¼)
                window.removeEventListener('touchend', handleMobileResizeEnd, true);
                window.removeEventListener('touchcancel', handleMobileResizeEnd, true);

                if (resizeRaf) cancelAnimationFrame(resizeRaf);

                // å»¶è¿Ÿä¸€å°æ®µæ—¶é—´ï¼Œæ‰§è¡Œä¸€æ¬¡ DOM/CSS çº§åˆ«çš„é‡ç»˜æ“ä½œ
                requestAnimationFrame(() => {
                    document.body.style.display = 'none';
                    document.body.offsetHeight; // å¼ºåˆ¶æµè§ˆå™¨è®¡ç®—
                    document.body.style.display = '';

                    const taskEl = mobileResizeState.taskEl;
                    if (taskEl) {
                        taskEl.style.opacity = '';
                        taskEl.style.transition = '';
                    }
                });

                // åªæœ‰ç¡®å®šæ˜¯æ‹–æ‹½æ“ä½œæ—¶ï¼Œæ‰æ‰§è¡Œè€—æ—¶çš„å†²çªæ£€æµ‹å’Œæ•°æ®ä¿å­˜
                if (wasResizing) {
                    setTimeout(() => {
                        const t = mobileResizeState.task;
                        // ğŸŸ¢ é˜²å¾¡æ€§ç¼–ç¨‹ï¼šé˜²æ­¢ t ä¸ºç©ºå¯¼è‡´æŠ¥é”™
                        if (!t) return;

                        const newDurationStr = t.estDuration;
                        let type = 'musician';
                        if (t.projectId) type = 'project';
                        else if (t.instrumentId) type = 'instrument';

                        // æ‰§è¡Œå†²çªæ£€æµ‹
                        if (checkOverlap(t.date, t.startTime, newDurationStr, t.scheduleId, type)) {
                            t.estDuration = mobileResizeState.originalDuration; // å†²çªå›é€€
                            openAlertModal('å†²çª', 'è°ƒæ•´åçš„æ—¶é—´ä¸ç°æœ‰ä»»åŠ¡å†²çª');
                            window.triggerTouchHaptic('Error');
                        } else {
                            // æ— å†²çªåˆ™ä¿å­˜
                            const m = parseTime(t.musicDuration);
                            const r = parseTime(t.estDuration);
                            if (m > 0) t.ratio = (r / m).toFixed(1);
                            pushHistory();
                            window.triggerTouchHaptic('Success');
                        }

                        // ç¡®ä¿æ¸…é™¤å¼•ç”¨
                        mobileResizeState.task = null;
                    }, 0);
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: calcTrackDiff æ”¯æŒå¤šç»´åº¦
            const calcTrackDiff = (item) => {
                // 1. è·å–å½“å‰è§†å›¾ç±»å‹
                const viewType = trackListData.value.viewType || 'musician';

                // 2. è·å–å¯¹åº”è®°å½•å¯¹è±¡
                const record = item.records[viewType];
                if (!record) return;

                if (record.recStart && record.recEnd) {
                    const [sh, sm] = record.recStart.split(':').map(Number);
                    const [eh, em] = record.recEnd.split(':').map(Number);

                    let startMins = sh * 60 + sm;
                    let endMins = eh * 60 + em;

                    if (endMins < startMins) endMins += 24 * 60;

                    let diffMins = endMins - startMins;

                    if (record.breakMinutes && record.breakMinutes > 0) {
                        diffMins -= parseInt(record.breakMinutes);
                    }

                    if (diffMins < 0) diffMins = 0;
                    const diffSecs = diffMins * 60;

                    // 3. å†™å…¥å¯¹åº”è®°å½•
                    record.actualDuration = formatSecs(diffSecs);

                    // è§¦å‘ä¿å­˜ (æ³¨æ„ saveTrackRecord ä¹Ÿéœ€è¦ä¿®æ”¹)
                    saveTrackRecord(item);

                    autoResizeScheduleByRecords(true);

                    // 3. ğŸŸ¢ åœ¨è¿™é‡Œç»Ÿä¸€ä¿å­˜ä¸€æ¬¡å†å² (è¿™æ˜¯å”¯ä¸€çš„ä¸€æ¬¡)
                    // pushHistory();
                }
            };

            const setTrackBreak = (item) => {
                const viewType = trackListData.value.viewType || 'musician';
                const record = item.records[viewType]; // è·å–å¯¹åº”è®°å½•

                openInputModal(
                    'è®¾ç½®ä¸­æ–­/ä¼‘æ¯æ—¶é•¿',
                    record.breakMinutes ? String(record.breakMinutes) : '',
                    'è¯·è¾“å…¥åˆ†é’Ÿæ•°',
                    (val) => {
                        const mins = parseInt(val);
                        record.breakMinutes = (isNaN(mins) || mins < 0) ? 0 : mins;
                        calcTrackDiff(item);
                        pushHistory();
                    },
                    'è¿™æ®µæ—¶é—´å°†ä»æ€»å½•åˆ¶æ—¶é•¿ä¸­æ‰£é™¤'
                );
            };

            // 4. è¾…åŠ©å‡½æ•°ï¼šå¯åŠ¨æ‹–æ‹½æ¨¡å¼
            const startMobileDrag = (originalEl, touch) => {
                // 1. è®°å½•å¹¶å˜æ·¡åŸå…ƒç´ 
                dragSourceEl = originalEl;
                dragSourceEl.style.opacity = '0.3'; // å˜æ·¡ï¼Œæç¤ºç”¨æˆ·å®ƒè¢«â€œæ‹¿â€èµ·æ¥äº†

                window.triggerTouchHaptic('Medium');

                // 2. åˆ›å»ºå…‹éš†ä½“ (ä¿æŒä¹‹å‰çš„é€»è¾‘ä¸å˜)
                dragElClone = originalEl.cloneNode(true);

                // è®¾ç½®å…‹éš†ä½“æ ·å¼ (å›ºå®šå®šä½ï¼Œæµ®åœ¨æœ€ä¸Šå±‚)
                Object.assign(dragElClone.style, {
                    position: 'fixed',
                    top: '0',
                    left: '0',
                    width: `${originalEl.offsetWidth}px`,
                    height: `${originalEl.offsetHeight}px`,
                    zIndex: '9999',
                    opacity: '0.9',
                    pointerEvents: 'none', // å…³é”®ï¼šè®©è§¦æ‘¸äº‹ä»¶ç©¿é€å…‹éš†ä½“
                    transform: `translate3d(${touch.clientX - cloneOffsetX}px, ${touch.clientY - cloneOffsetY}px, 0)`,
                    boxShadow: '0 10px 20px rgba(0,0,0,0.3)',
                    transition: 'none' // ç¦æ­¢è¿‡æ¸¡åŠ¨ç”»ï¼Œä¿è¯è·Ÿéšæ‰‹æŒ‡æ— å»¶è¿Ÿ
                });
                dragElClone.style.opacity = '0.9';

                // æ·»åŠ åˆ° Body
                document.body.appendChild(dragElClone);
            };


            // ğŸŸ¢ å­˜å‚¨è§¦æ‘¸æ—¶çš„èµ·å§‹ç‚¹ï¼Œç”¨äºè®¡ç®—åç§»é‡
            const initialTouchCoords = reactive({x: 0, y: 0});

            // ğŸŸ¢ å­˜å‚¨è¢«æ‹–æ‹½å…ƒç´ çš„åŸå§‹ DOM å¼•ç”¨ (å¯é€‰ï¼Œä½†æœ‰åŠ©äºæŸäº›å¤æ‚æ“ä½œ)
            const draggingTaskElement = ref(null);

            // --- ğŸŸ¢ æ–°å¢ï¼šè·å– Capacitor æ’ä»¶å¼•ç”¨ ---
            // æ³¨æ„ï¼šè¿™é‡Œä¸èƒ½ç”¨ importï¼Œå¿…é¡»ä»å…¨å±€å¯¹è±¡å–
            const LocalNotifications = window.Capacitor ? window.Capacitor.Plugins.LocalNotifications : null;
            const Haptics = window.Capacitor ? window.Capacitor.Plugins.Haptics : null;

            // --- ğŸŸ¢ æ–°å¢ï¼šéœ‡åŠ¨ä¸é€šçŸ¥åŠŸèƒ½å‡½æ•° ---
            const scheduleReminder = async (title, body, delaySeconds = 5) => {
                // 1. å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœåœ¨æµè§ˆå™¨é‡Œè¿è¡Œï¼Œæ²¡æœ‰ Capacitor ç¯å¢ƒï¼Œç›´æ¥è¿”å›
                if (!LocalNotifications || !Haptics) {
                    console.log("é App ç¯å¢ƒï¼Œè·³è¿‡é€šçŸ¥");
                    return;
                }

                try {
                    // 2. è¯·æ±‚æƒé™
                    let perm = await LocalNotifications.checkPermissions();
                    if (perm.display === 'prompt') {
                        perm = await LocalNotifications.requestPermissions();
                    }
                    if (perm.display !== 'granted') {
                        openAlertModal("è¯·æˆæƒé€šçŸ¥æƒé™ï¼Œå¦åˆ™æ— æ³•æé†’ï¼");
                        return;
                    }

                    // 3. å®‰æ’é€šçŸ¥
                    const triggerTime = new Date(Date.now() + delaySeconds * 1000);
                    await LocalNotifications.schedule({
                        notifications: [{
                            title: title,
                            body: body,
                            id: Math.floor(Math.random() * 100000),
                            schedule: {at: triggerTime},
                            sound: 'default'
                        }]
                    });

                    // 4. éœ‡åŠ¨åé¦ˆ
                    await Haptics.impact({style: 'MEDIUM'}); // æ³¨æ„è¿™é‡Œç”¨å­—ç¬¦ä¸² 'MEDIUM'

                    // 5. (å¯é€‰) å¼¹ä¸ªæç¤º
                    // alert(`å·²è®¾ç½®æé†’ï¼š${delaySeconds}ç§’å`);

                } catch (e) {
                    console.error("é€šçŸ¥è®¾ç½®å¤±è´¥", e);
                    openAlertModal("é€šçŸ¥è®¾ç½®å‡ºé”™ï¼š" + e.message);
                }
            };

            // ğŸŸ¢ [ä¿®æ”¹] è®¡ç®—å•æ›²æ•ˆç‡ (ä¾èµ– sidebarTab)
            const calculateSingleRatio = (item) => {
                // ä¼˜å…ˆä½¿ç”¨å¼¹çª—çš„ viewTypeï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ä¾§è¾¹æ çš„å½“å‰ Tab
                let type = 'musician';
                if (trackListData.value && showTrackList.value) {
                    type = trackListData.value.viewType;
                } else {
                    type = sidebarTab.value || 'musician';
                }

                // è¯»å–å¯¹åº”ç»´åº¦çš„è®°å½•
                const record = item.records?.[type];
                if (!record || !record.actualDuration || !item.musicDuration) return '-';

                const actualSec = parseTime(record.actualDuration);
                const musicSec = parseTime(item.musicDuration);
                if (musicSec === 0) return '-';
                return (actualSec / musicSec).toFixed(1);
            };

            // --- V11.7 Session çŠ¶æ€ ---
            const currentSessionId = ref('');

            // --- V11.9 Session UI è¾…åŠ©é€»è¾‘ ---

            // 1. è·å–å½“å‰ Session åç§° (ç”¨äºæ˜¾ç¤ºåœ¨æŒ‰é’®ä¸Š)
            const currentSessionName = computed(() => {
                const s = settings.sessions.find(x => x.id === currentSessionId.value);
                return s ? s.name : 'æœªå‘½åæ—¥ç¨‹';
            });

            // 2. åˆ‡æ¢ Session
            const switchSession = (id) => {
                currentSessionId.value = id;
                activeDropdown.value = null; // é€‰å®Œå…³é—­èœå•
            };

            // ğŸŸ¢ ä¿®æ”¹åçš„ handleSessionAction
            const handleSessionAction = (action) => {
                if (action === 'new') {
                    // æ›¿æ¢ prompt
                    openInputModal('æ–°å»ºæ—¥ç¨‹', '', 'è¯·è¾“å…¥æ—¥ç¨‹åç§° (ä¾‹å¦‚: 2026 æ˜¥å­£å½•éŸ³)', (name) => {
                        if (name) {
                            const newId = generateUniqueId('S');
                            settings.sessions.push({id: newId, name: name});
                            currentSessionId.value = newId;
                            pushHistory();
                        }
                    });
                } else if (action === 'rename') {
                    const current = settings.sessions.find(s => s.id === currentSessionId.value);
                    // æ›¿æ¢ prompt
                    openInputModal('é‡å‘½åæ—¥ç¨‹', current.name, 'è¯·è¾“å…¥æ–°åç§°', (name) => {
                        if (name) {
                            current.name = name;
                            pushHistory();
                        }
                    });
                    // ğŸŸ¢ ä¿®æ”¹éƒ¨åˆ†
                } else if (action === 'delete') {
                    if (settings.sessions.length <= 1) {
                        openAlertModal('æ— æ³•åˆ é™¤', 'è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªæ—¥ç¨‹ã€‚');
                        return;
                    }

                    // æ›¿æ¢ confirm
                    openConfirmModal(
                        'åˆ é™¤æ—¥ç¨‹',
                        'ç¡®å®šåˆ é™¤å½“å‰æ—¥ç¨‹ï¼Ÿ\nï¼ˆå±äºè¯¥æ—¥ç¨‹çš„ä»»åŠ¡ä»ç„¶ä¼šä¿ç•™åœ¨æ—¥ç¨‹è¡¨ä¸­ï¼‰',
                        () => {
                            const idx = settings.sessions.findIndex(s => s.id === currentSessionId.value);
                            settings.sessions.splice(idx, 1);
                            currentSessionId.value = settings.sessions[0].id;
                            pushHistory();
                            window.triggerTouchHaptic('Success');
                        },
                        true // isDestructive = true (çº¢è‰²æŒ‰é’®)
                    );
                }
                activeDropdown.value = null;
            };

            // --- ğŸŸ¢ é¡¶éƒ¨èœå•ä¸ä¸»é¢˜é€»è¾‘ ---
            const showMobileMenu = ref(false);

            // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: å¼•å…¥ä¸‰æ€ä¸»é¢˜ç®¡ç† (Auto / Light / Dark)

            // 1. å®šä¹‰çŠ¶æ€: ä¼˜å…ˆè¯»å–æœ¬åœ°å­˜å‚¨ï¼Œæ²¡æœ‰åˆ™é»˜è®¤ä¸º 'auto'
            const themeMode = ref(localStorage.getItem('theme_mode') || 'auto');

            // isDark ä¾ç„¶ä¿ç•™ï¼Œä½œä¸º"å½“å‰å®é™…ç”Ÿæ•ˆé¢œè‰²"çš„è®¡ç®—ç»“æœï¼Œä¾›ç•Œé¢å…¶ä»–éƒ¨åˆ†(å¦‚å›¾è¡¨é¢œè‰²)ä½¿ç”¨
            const isDark = ref(document.documentElement.classList.contains('dark'));

            // 2. åº”ç”¨ä¸»é¢˜çš„æ ¸å¿ƒå‡½æ•°
            const applyTheme = () => {
                let shouldBeDark = false;

                if (themeMode.value === 'auto') {
                    // å¦‚æœæ˜¯è‡ªåŠ¨æ¨¡å¼ï¼ŒæŸ¥è¯¢ç³»ç»Ÿåå¥½
                    shouldBeDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                } else {
                    // å¦åˆ™ç›´æ¥æ ¹æ®è®¾å®šå€¼
                    shouldBeDark = themeMode.value === 'dark';
                }

                // æ“ä½œ DOM
                const html = document.documentElement;
                if (shouldBeDark) {
                    html.classList.add('dark');
                    isDark.value = true;
                } else {
                    html.classList.remove('dark');
                    isDark.value = false;
                }
            };

            // 3. åˆ‡æ¢æŒ‰é’®ç‚¹å‡»äº‹ä»¶ (Auto -> Light -> Dark -> Auto å¾ªç¯)
            const toggleTheme = () => {
                const modes = ['auto', 'light', 'dark'];
                const nextIndex = (modes.indexOf(themeMode.value) + 1) % modes.length;

                themeMode.value = modes[nextIndex];

                // ä¿å­˜åˆ°æœ¬åœ°
                localStorage.setItem('theme_mode', themeMode.value);

                applyTheme();
            };

            // 4. è·å–å½“å‰æ¨¡å¼çš„æ˜¾ç¤ºåç§°å’Œå›¾æ ‡ (ä¾› HTML ä½¿ç”¨)
            const getThemeLabel = computed(() => {
                if (themeMode.value === 'auto') return {text: 'è·Ÿéšç³»ç»Ÿ', icon: 'fa-desktop'};
                if (themeMode.value === 'dark') return {text: 'æ·±è‰²æ¨¡å¼', icon: 'fa-moon'};
                return {text: 'æµ…è‰²æ¨¡å¼', icon: 'fa-sun'};
            });

            // --- ğŸŸ¢ å¤´åƒè£å‰ªä¸ä¸Šä¼ é€»è¾‘ ---
            const showCropModal = ref(false);
            const cropImgSrc = ref('');
            const cropImgRef = ref(null); // ç»‘å®šåˆ° <img> æ ‡ç­¾
            let cropper = null; // å­˜æ”¾ Cropper å®ä¾‹

            // --- ğŸŸ¢ é€šç”¨ç¡®è®¤/æç¤ºå¼¹çª—çŠ¶æ€ (Universal Confirm/Alert) ---
            const showConfirmModal = ref(false);
            const confirmModalConfig = reactive({
                title: '',
                content: '',
                confirmText: 'ç¡®å®š',
                cancelText: 'å–æ¶ˆ',
                isAlert: false,      // true=åªæœ‰ç¡®å®šæŒ‰é’®, false=æœ‰ç¡®å®šå’Œå–æ¶ˆ
                isDestructive: false,// true=æŒ‰é’®å˜çº¢(ç”¨äºåˆ é™¤ç­‰å±é™©æ“ä½œ)
                onConfirm: null,
                onCancel: null // <--- ğŸŸ¢ æ–°å¢è¿™ä¸€è¡Œ
            });



            // 1. æ‰“å¼€æç¤ºæ¡† (æ›¿ä»£ alert)
            const openAlertModal = (title, content, callback) => {
                confirmModalConfig.title = title;
                confirmModalConfig.content = content;
                confirmModalConfig.isAlert = true;
                confirmModalConfig.isDestructive = false;
                confirmModalConfig.confirmText = 'æˆ‘çŸ¥é“äº†';
                confirmModalConfig.onConfirm = callback;
                showConfirmModal.value = true;
                window.triggerTouchHaptic('Light'); // è½»å¾®éœ‡åŠ¨
            };

            // 2. æ‰“å¼€ç¡®è®¤æ¡† (æ›¿ä»£ confirm)
            const openConfirmModal = (title, content, onConfirm, isDestructive = false, confirmText = 'ç¡®å®š', cancelText = 'å–æ¶ˆ') => {
                confirmModalConfig.title = title;
                confirmModalConfig.content = content;
                confirmModalConfig.isAlert = false;
                confirmModalConfig.isDestructive = isDestructive;
                confirmModalConfig.confirmText = confirmText;
                confirmModalConfig.cancelText = cancelText;
                confirmModalConfig.onConfirm = onConfirm;
                showConfirmModal.value = true;
                window.triggerTouchHaptic('Medium'); // è­¦å‘Šéœ‡åŠ¨
            };

            const closeConfirmModal = () => {
                // ğŸŸ¢ å¦‚æœå®šä¹‰äº† onCancel å›è°ƒï¼Œåˆ™æ‰§è¡Œ (ç”¨äºå¤„ç†äºŒé€‰ä¸€çš„æƒ…å†µ)
                if (confirmModalConfig.onCancel) {
                    confirmModalConfig.onCancel();
                }

                showConfirmModal.value = false;
                // å»¶è¿Ÿæ¸…ç†å›è°ƒ
                setTimeout(() => {
                    confirmModalConfig.onConfirm = null;
                    confirmModalConfig.onCancel = null; // ğŸŸ¢ æ¸…ç† onCancel
                }, 300);
            };

            const handleConfirmAction = () => {
                // 1. æ‰§è¡Œç¡®è®¤å›è°ƒ (ä¿ç•™åŸå)
                if (confirmModalConfig.onConfirm) {
                    confirmModalConfig.onConfirm();
                }

                // ğŸŸ¢ æ ¸å¿ƒä¿®å¤: æ‰§è¡Œå®Œç¡®è®¤åï¼Œå¿…é¡»æ‰‹åŠ¨æ¸…ç©º onCancel
                // è¿™æ ·åœ¨è°ƒç”¨ closeConfirmModal æ—¶ï¼Œå°±ä¸ä¼šå†æ¬¡è§¦å‘â€œå–æ¶ˆ/è‡ªåŠ¨åˆå¹¶â€çš„é€»è¾‘äº†
                confirmModalConfig.onCancel = null;

                // 2. å…³é—­å¼¹çª—
                closeConfirmModal();
            };

            // --- ğŸŸ¢ é€šç”¨è¾“å…¥å¼¹çª—çŠ¶æ€ (Universal Input Modal) ---
            const showInputModal = ref(false);
            const universalInputRef = ref(null);
            const inputModalConfig = reactive({
                title: '',
                value: '',
                placeholder: '',
                hint: '',
                callback: null // å­˜å‚¨ç‚¹å‡»ç¡®å®šåçš„å›è°ƒå‡½æ•°
            });

            // æ‰“å¼€å¼¹çª—çš„é€šç”¨æ–¹æ³•
            const openInputModal = (title, initialValue, placeholder, callback, hint = '') => {
                inputModalConfig.title = title;
                inputModalConfig.value = initialValue;
                inputModalConfig.placeholder = placeholder;
                inputModalConfig.callback = callback;
                inputModalConfig.hint = hint;
                showInputModal.value = true;

                // è‡ªåŠ¨èšç„¦è¾“å…¥æ¡†
                Vue.nextTick(() => {
                    if (universalInputRef.value) universalInputRef.value.focus();
                    if (universalInputRef.value) universalInputRef.value.select(); // å…¨é€‰æ–‡æœ¬æ–¹ä¾¿ä¿®æ”¹
                });
            };

            const closeInputModal = () => {
                showInputModal.value = false;
                inputModalConfig.callback = null; // æ¸…ç†å›è°ƒ
            };

            const confirmInputModal = () => {
                if (!inputModalConfig.value.trim()) {
                    // å¦‚æœæ˜¯å¿…å¡«é¡¹ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ‹¦æˆªï¼Œæˆ–è€…å…è®¸ç©ºå€¼ç”±å›è°ƒå‡½æ•°è‡ªå·±åˆ¤æ–­
                    // è¿™é‡Œæˆ‘ä»¬ç®€å•å¤„ç†ï¼šå¦‚æœæ˜¯ç©ºçš„ä¸”ä¸æ˜¯æ–‡ä»¶åå¯¼å‡ºï¼Œç»™ä¸ªéœ‡åŠ¨åé¦ˆæˆ–ä¸åšååº”
                }

                if (inputModalConfig.callback) {
                    inputModalConfig.callback(inputModalConfig.value.trim());
                }
                closeInputModal();
            };

            // ğŸŸ¢ æ–°å¢: å¿«é€Ÿæ·»åŠ å¼¹çª—çš„çŠ¶æ€
            const showQuickAddModal = ref(false);
            const quickAddType = ref(''); // 'project', 'instrument', 'musician'
            const quickAddForm = reactive({name: '', group: '', defaultRatio: 20});

            // ğŸŸ¢ æ–°å¢: è®¡ç®—å±æ€§ï¼Œä¸“é—¨ç”¨äº Quick Add å¼¹çª—çš„åˆ†ç»„åˆ—è¡¨
            // è¿™èƒ½ç¡®ä¿å½“ quickAddType å˜åŒ–æˆ– settings æ•°æ®å˜åŒ–æ—¶ï¼Œåˆ—è¡¨èƒ½è‡ªåŠ¨æ›´æ–°
            const currentQuickAddGroups = computed(() => {
                // æ˜¾å¼è®¿é—® .valueï¼Œç¡®ä¿ä¾èµ–è¢«è¿½è¸ª
                const type = quickAddType.value;
                // å¤ç”¨å·²æœ‰çš„è·å–é€»è¾‘
                return getExistingGroups(type);
            });

            // ğŸŸ¢ æ–°å¢: æ‰“å¼€å¿«é€Ÿæ·»åŠ å¼¹çª—
            const openQuickAdd = (type) => {
                quickAddType.value = type;
                quickAddForm.name = '';
                quickAddForm.group = '';
                quickAddForm.defaultRatio = 20;
                showQuickAddModal.value = true;

                // è‡ªåŠ¨èšç„¦è¾“å…¥æ¡†
                setTimeout(() => {
                    const input = document.getElementById('quick-add-name');
                    if (input) input.focus();
                }, 100);
            };

            // ğŸŸ¢ [ä¿®æ”¹] confirmQuickAdd: ç»Ÿä¸€ä¸ºæ‰€æœ‰ç±»å‹æ·»åŠ  defaultRatio
            const confirmQuickAdd = () => {
                const nameStr = quickAddForm.name.trim();
                if (!nameStr) return openAlertModal("åç§°ä¸èƒ½ä¸ºç©º");

                const type = quickAddType.value;

                // 1. è·å–å¯¹åº”åˆ—è¡¨
                let list = [];
                let label = '';
                if (type === 'instrument') {
                    list = settings.instruments;
                    label = 'ä¹å™¨';
                } else if (type === 'musician') {
                    list = settings.musicians;
                    label = 'æ¼”å¥å‘˜';
                } else if (type === 'project') {
                    list = settings.projects;
                    label = 'é¡¹ç›®';
                }

                // ğŸŸ¢ 2. æ ¸å¿ƒä¿®å¤: æ£€æŸ¥é‡å (ä¸åŒºåˆ†å¤§å°å†™)
                if (list.some(i => i.name.toLowerCase() === nameStr.toLowerCase())) {
                    window.triggerTouchHaptic('Error');
                    return openAlertModal('æ— æ³•æ·»åŠ ', `è¯¥${label}åç§° "${nameStr}" å·²å­˜åœ¨ï¼`);
                }

                // 3. æ‰§è¡Œæ·»åŠ 
                const idPrefix = type === 'project' ? 'P' : (type === 'instrument' ? 'I' : 'M');
                const newId = generateUniqueId(idPrefix);

                const newItemObj = {
                    id: newId,
                    name: nameStr,
                    group: quickAddForm.group.trim(),
                    color: generateRandomHexColor(),
                    defaultRatio: quickAddForm.defaultRatio || 20 // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: æ‰€æœ‰ç±»å‹éƒ½èµ‹äºˆé»˜è®¤å€ç‡
                };

                if (type === 'project') {
                    settings.projects.push(newItemObj);
                    newItem.projectId = newId;
                } else if (type === 'instrument') {
                    settings.instruments.push(newItemObj);
                    newItem.instrumentId = newId;
                } else if (type === 'musician') {
                    settings.musicians.push(newItemObj);
                    newItem.musicianId = newId;
                    onMusicianSelect();
                }

                pushHistory();
                showQuickAddModal.value = false;
                activeDropdown.value = null;
                window.triggerTouchHaptic('Success');
            };



            // 1. ç”¨æˆ·é€‰æ‹©æ–‡ä»¶ -> æ‰“å¼€è£å‰ªå¼¹çª—
            const onFileSelect = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // æ”¾å®½å¤§å°é™åˆ¶åˆ° 20MB
                if (file.size > 20 * 1024 * 1024) return openAlertModal("å›¾ç‰‡å¤ªå¤§äº†ï¼Œè¯·é€‰æ‹© 20MB ä»¥ä¸‹çš„å›¾ç‰‡");

                const reader = new FileReader();
                reader.onload = (e) => {

                    const arrayBuffer = e.target.result;

                    // æ‰“å°åˆ°æ§åˆ¶å°æˆ–æ˜¾ç¤ºåœ¨é¡µé¢ä¸Š
                    console.log("è§£æç»“æœï¼š", cleanNames);
                    // é‡ç½®çŠ¶æ€
                    cropImgSrc.value = e.target.result;
                    showCropModal.value = true;

                    Vue.nextTick(() => {
                        // 1. å…ˆå½»åº•é”€æ¯æ—§å®ä¾‹
                        if (cropper) {
                            cropper.destroy();
                            cropper = null;
                        }

                        const imgEl = cropImgRef.value;
                        if (!imgEl) return;

                        // 2. å®šä¹‰åˆå§‹åŒ–å‡½æ•° (å¢åŠ é˜²æŠ–ï¼Œé˜²æ­¢è·‘ä¸¤æ¬¡)
                        let isInitialized = false;
                        const initCropper = () => {
                            if (isInitialized) return; // å¦‚æœå·²ç»è·‘è¿‡ï¼Œç›´æ¥åœæ­¢
                            isInitialized = true;

                            cropper = new Cropper(imgEl, {
                                aspectRatio: 1,
                                viewMode: 1,
                                dragMode: 'move',
                                autoCropArea: 1,
                                background: false,
                                checkCrossOrigin: false,
                                ready() {
                                    // å¯ä»¥åœ¨è¿™é‡ŒåŠ ä¸ª console.log ç¡®è®¤åªæ‰“å°äº†ä¸€æ¬¡
                                    // console.log('Cropper ready');
                                }
                            });
                        };

                        // 3. æ™ºèƒ½åˆ¤æ–­åŠ è½½çŠ¶æ€
                        // å¦‚æœå›¾ç‰‡å·²ç»åœ¨ç¼“å­˜é‡ŒåŠ è½½å¥½äº†ï¼Œç›´æ¥åˆå§‹åŒ–
                        if (imgEl.complete && imgEl.naturalWidth > 0) {
                            initCropper();
                        } else {
                            // å¦åˆ™ç›‘å¬ load äº‹ä»¶ï¼Œä¸”åªç›‘å¬ä¸€æ¬¡
                            imgEl.addEventListener('load', initCropper, {once: true});
                        }
                    });
                };
                reader.readAsDataURL(file);

                event.target.value = '';
            };

            // 2. å–æ¶ˆè£å‰ª
            const cancelCrop = () => {
                showCropModal.value = false;
                if (cropper) {
                    cropper.destroy();
                    cropper = null;
                }
            };

            // 3. ç¡®è®¤è£å‰ªå¹¶ä¸Šä¼ 
            const confirmCrop = () => {
                if (!cropper) return;

                // å°è¯•è·å–è£å‰ªåçš„ Canvas
                const canvas = cropper.getCroppedCanvas({
                    width: 300,
                    height: 300
                });

                // ğŸŸ¢ å…³é”®ä¿®å¤ï¼šå¦‚æœ canvas æ˜¯ nullï¼Œè¯´æ˜è£å‰ªå™¨è¿˜æ²¡å‡†å¤‡å¥½ï¼Œæˆ–è€… CSS æ²¡åŠ è½½
                if (!canvas) {
                    return openAlertModal("è£å‰ªå¤±è´¥ï¼šæœªèƒ½è·å–åˆ°å›¾ç‰‡å†…å®¹ã€‚\nè¯·æ£€æŸ¥æ˜¯å¦å·²å¼•å…¥ cropper.min.css æ ·å¼æ–‡ä»¶ã€‚");
                }

                authLoading.value = true;

                // ğŸŸ¢ ä¿®æ”¹: ä½¿ç”¨ 'image/webp' æ ¼å¼ï¼Œå¹¶å°†è´¨é‡é™ä¸º 0.6
                canvas.toBlob(async (blob) => {
                    if (!blob) {
                        authLoading.value = false;
                        return openAlertModal("ç”Ÿæˆå›¾ç‰‡æ–‡ä»¶å¤±è´¥");
                    }

                    try {
                        const fileName = `${user.value.id}-${Date.now()}.webp`;
                        const filePath = `${fileName}`;
                        const {error: uploadError} = await supabaseClient.storage
                            .from('avatars')
                            .upload(filePath, blob, {
                                contentType: 'image/webp', // æ˜¾å¼æŒ‡å®šç±»å‹
                                upsert: true
                            });

                        if (uploadError) throw uploadError;

                        // è·å– URL
                        const {data} = supabaseClient.storage.from('avatars').getPublicUrl(filePath);
                        const publicUrl = data.publicUrl;

                        // æ›´æ–°ç”¨æˆ·èµ„æ–™
                        const {error: updateError} = await supabaseClient.auth.updateUser({
                            data: {avatar_url: publicUrl}
                        });

                        if (updateError) throw updateError;

                        // æ›´æ–°æˆåŠŸ
                        user.value = (await supabaseClient.auth.getUser()).data.user;

                        // å…³é—­å¼¹çª—
                        cancelCrop();
                        openAlertModal("å¤´åƒæ›´æ–°æˆåŠŸï¼");

                    } catch (error) {
                        console.error(error);
                        openAlertModal("ä¸Šä¼ å¤±è´¥: " + error.message);
                    } finally {
                        authLoading.value = false;
                    }

                }, 'image/webp', 0.6); // ä½¿ç”¨ webp æ ¼å¼å’Œ 0.6 è´¨é‡
            };

            // ğŸŸ¢ ä¿®æ”¹: åˆ é™¤åˆ—è¡¨ä»»åŠ¡
            const deleteTrackFromList = (itemToDelete) => {
                // ğŸ›¡ï¸ 1. [æ–°å¢] æ£€æŸ¥æ˜¯å¦ä¸ºæœ«ç«¯ä»»åŠ¡
                if (!checkCanDeleteSplit(itemToDelete)) return;

                // ğŸŸ¢ 2. å°è¯•å½’è¿˜æ—¶é—´
                restoreSplitTime(itemToDelete);

                // 3. ä»å…¨å±€ä»»åŠ¡æ± ä¸­åˆ é™¤
                itemPool.value = itemPool.value.filter(i => i.id !== itemToDelete.id);

                // 4. ä»å½“å‰å¼¹çª—åˆ—è¡¨ä¸­åˆ é™¤
                trackListData.value.items = trackListData.value.items.filter(i => i.id !== itemToDelete.id);

                // 5. å¦‚æœå¼¹çª—è¿˜å¼€ç€ï¼Œä¿å­˜å†å²
                if (showTrackList.value) {
                    pushHistory();
                }

                // éœ‡åŠ¨åé¦ˆ
                window.triggerTouchHaptic('Medium');
            };

            // ğŸŸ¢ æ–°å¢: ç›‘å¬ TrackList å¼¹çª—å…³é—­
            // å½“å¼¹çª—å…³é—­æ—¶ï¼Œç»Ÿä¸€æ‰§è¡Œä¸€æ¬¡å…¨å±€æ¸…ç†ï¼Œç§»é™¤é‚£äº›å˜ç©ºçš„æ—¥ç¨‹å—
            watch(showTrackList, (isOpen) => {
                if (!isOpen) {
                    // å¼¹çª—åˆšå…³é—­ -> æ‰§è¡Œæ¸…ç†
                    cleanupEmptySchedules();

                    // å¯é€‰ï¼šä¿å­˜ä¸€æ¬¡å†å²ï¼Œç¡®ä¿æ¸…ç†åçš„çŠ¶æ€è¢«è®°å½•
                    // pushHistory();
                }
            });


            // ğŸŸ¢ æ–°å¢: è‡ªåŠ¨è®¡ç®—æ—¶é—´å·®
            const autoCalcDuration = () => {
                const start = trackListData.value.actualStart;
                const end = trackListData.value.actualEnd;

                if (start && end) {
                    const [sh, sm] = start.split(':').map(Number);
                    const [eh, em] = end.split(':').map(Number);

                    let startMins = sh * 60 + sm;
                    let endMins = eh * 60 + em;

                    // å¦‚æœç»“æŸæ—¶é—´å°äºå¼€å§‹æ—¶é—´ï¼Œå‡è®¾æ˜¯è·¨å¤© (åŠ 24å°æ—¶)
                    if (endMins < startMins) endMins += 24 * 60;

                    const diffSecs = (endMins - startMins) * 60;
                    trackListData.value.actualDuration = formatSecs(diffSecs);
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: ä¿å­˜å½•éŸ³æ—¶é—´å¹¶å¼ºåˆ¶æ›´æ–°è§†å›¾
            const saveScheduleActualTime = () => {
                const currentScheduleId = trackListData.value.taskRef.scheduleId;

                if (!currentScheduleId) return;

                // 1. æ›´æ–°æ•°æ®
                // ä½¿ç”¨ map åˆ›å»ºæ–°æ•°ç»„ï¼Œç¡®ä¿è§¦å‘ Vue çš„å“åº”å¼æ›´æ–°
                scheduledTasks.value = scheduledTasks.value.map(task => {
                    if (task.scheduleId === currentScheduleId) {
                        return {
                            ...task, // å¤åˆ¶åŸå¯¹è±¡
                            actualStartTime: trackListData.value.actualStart,
                            actualEndTime: trackListData.value.actualEnd,
                            actualDuration: trackListData.value.actualDuration
                        };
                    }
                    return task;
                });

                pushHistory();

                // 2. æç¤ºç”¨æˆ·
                openAlertModal("âœ… å½•éŸ³æ—¶é—´å·²ä¿å­˜ï¼\nè¯¥æ¼”å¥å‘˜çš„ã€ŒçœŸå®å¹³å‡æ¯”å€¼ã€å·²åœ¨ä¾§è¾¹æ è‡ªåŠ¨æ›´æ–°ã€‚");


            };

            // ğŸŸ¢ æ–°å¢: ä¿å­˜å•æ›²å®é™…ç”¨æ—¶
            const saveTrackActual = (item) => {
                // æ‰¾åˆ°æºæ•°æ®å¹¶æ›´æ–°
                const task = scheduledTasks.value.find(t => t.scheduleId === item.scheduleId);
                if (task) {
                    task.actualDuration = item.actualDuration;
                    // å¼ºåˆ¶æ›´æ–°æ•°ç»„ä»¥è§¦å‘ computed é‡æ–°è®¡ç®—
                    scheduledTasks.value = [...scheduledTasks.value];

                    // ä¿å­˜åˆ°å†å²
                    // pushHistory(); // å¯é€‰ï¼šå¦‚æœä¸å¸Œæœ›æ¯æ¬¡è¾“å…¥å­—ç¬¦éƒ½å­˜å†å²ï¼Œå¯ä»¥ä¸åŠ 
                }
            };

            // ğŸŸ¢ æ–°å¢: æ£€æŸ¥ä»»åŠ¡å½’å±çš„èµ„æºæ˜¯å¦å·²å®Œæˆ (ç”¨äºä¿æŠ¤å·²å®Œæˆä»»åŠ¡ä¸è¢«è¯¯åˆ )
            const isResourceCompleted = (task) => {
                if (!task) return false;

                const currentTab = sidebarTab.value;
                let stat = null;
                let list = [];

                // æ ¹æ®å½“å‰ä¾§è¾¹æ è§†å›¾ï¼Œè·å–å¯¹åº”çš„ç»Ÿè®¡åˆ—è¡¨å’Œ ID
                if (currentTab === 'project') {
                    list = projectStats.value;
                    if (task.projectId) stat = list.find(i => i.id === task.projectId);
                } else if (currentTab === 'instrument') {
                    list = instrumentStats.value;
                    if (task.instrumentId) stat = list.find(i => i.id === task.instrumentId);
                } else {
                    // é»˜è®¤ä¸º musician
                    list = musicianStats.value;
                    if (task.musicianId) stat = list.find(i => i.id === task.musicianId);
                }

                // å¦‚æœæ‰¾åˆ°äº†å¯¹åº”ç»Ÿè®¡å¯¹è±¡ï¼Œä¸”çŠ¶æ€ä¸º completed (è“è‰²å®Œæˆæ€)ï¼Œåˆ™è¿”å› true
                return stat && stat.statusKey === 'completed';
            };

            // ğŸŸ¢ [é‡å†™] åˆ é™¤å½“å‰æ—¥ç¨‹å— (ä¿®å¤èšåˆä»»åŠ¡çŠ¶æ€ä¸æ›´æ–°çš„é—®é¢˜)
            const deleteCurrentSchedule = () => {
                const taskToDelete = trackListData.value.taskRef;
                if (!taskToDelete) return;

                // ğŸŸ¢ æ–°å¢: æ‹¦æˆªå·²å®Œæˆä»»åŠ¡
                if (isResourceCompleted(taskToDelete)) {
                    window.triggerTouchHaptic('Error');
                    return openAlertModal("æ— æ³•åˆ é™¤", "å½“å‰å½’å±å¯¹è±¡ï¼ˆäººå‘˜/é¡¹ç›®/ä¹å™¨ï¼‰å·²æ ‡è®°ä¸ºã€å®Œæˆã€‘ã€‚\n\nä¸ºé˜²æ­¢è¯¯æ“ä½œï¼Œè¯·å…ˆæ¸…é™¤è¯¥å¯¹è±¡ä¸‹éƒ¨åˆ†æ›²ç›®çš„å½•éŸ³æ•°æ®ï¼Œä½¿å…¶å›åˆ°â€œè¿›è¡Œä¸­â€çŠ¶æ€åå†å°è¯•åˆ é™¤ã€‚");
                }

                // --- 1. å°è¯•æ¸…ç†å…³è”çš„å½•éŸ³æ•°æ® ---
                if (taskToDelete.templateId) {
                    // æƒ…å†µ A: å•æ›²ä»»åŠ¡ (æœ‰æ˜ç¡® ID) -> ç›´æ¥æ¸…ç†è¯¥ ID
                    clearPoolRecord(taskToDelete.templateId);
                } else {
                    // æƒ…å†µ B: èšåˆä»»åŠ¡ (æ²¡æœ‰ ID) -> åˆ©ç”¨ Section åŒ¹é…æ¸…ç†
                    // é€»è¾‘ï¼šå½“å‰å¼¹çª—æ˜¾ç¤ºçš„ç¬¬ X æ®µ (currentSectionIndex)ï¼Œå¯¹åº”çš„å°±æ˜¯æˆ‘ä»¬è¦åˆ çš„è¿™ä¸ªæ—¥ç¨‹å—

                    const currentIdx = trackListData.value.currentSectionIndex;
                    const viewType = trackListData.value.viewType || 'musician';

                    // éå†å¼¹çª—å†…çš„æ‰€æœ‰æ¡ç›®
                    if (trackListData.value.items) {
                        let hasCleared = false;
                        let targetId = null;

                        trackListData.value.items.forEach(item => {
                            // ğŸŸ¢ æ ¸å¿ƒä¿®å¤: åªæœ‰å±äºå½“å‰åˆ†æ®µ (sectionIndex) çš„ä»»åŠ¡æ‰ä¼šè¢«æ¸…ç†
                            // è¿™æ ·ä¸ä¼šè¯¯åˆ åŒä¸€ä¸ªäººåœ¨å…¶ä»–æ—¥ç¨‹å—é‡Œçš„å½•éŸ³æ•°æ®
                            if (item.sectionIndex === currentIdx) {

                                // æ‰§è¡Œæ¸…ç†
                                if (item.records && item.records[viewType]) {
                                    // åªæœ‰å½“æœ‰æ•°æ®æ—¶æ‰æ¸…ç†ï¼Œé¿å…æ— æ•ˆæ“ä½œ
                                    if (item.records[viewType].actualDuration || item.records[viewType].recStart) {
                                        item.records[viewType].actualDuration = '';
                                        item.records[viewType].recStart = '';
                                        item.records[viewType].recEnd = '';
                                        item.records[viewType].breakMinutes = 0;
                                        hasCleared = true;
                                    }

                                    // è®°å½•ä¸€ä¸ª ID ç”¨äºè§¦å‘æ•ˆç‡æ›´æ–° (å–ç¬¬ä¸€ä¸ªå³å¯)
                                    if (!targetId) {
                                        if (viewType === 'project') targetId = item.projectId;
                                        else if (viewType === 'instrument') targetId = item.instrumentId;
                                        else targetId = item.musicianId;
                                    }
                                }
                            }
                        });

                        // å¦‚æœæœ‰æ•°æ®è¢«æ¸…ç†ï¼Œè§¦å‘ä¸€æ¬¡æ•ˆç‡æ›´æ–°ï¼Œç¡®ä¿å·¦ä¾§å¤§å¡ç‰‡è¿›åº¦æ¡å›é€€
                        if (hasCleared && targetId) {
                            autoUpdateEfficiency(targetId, viewType, false);
                        }
                    }
                }

                // --- 2. ä»æ—¥ç¨‹æ•°ç»„ä¸­ç‰©ç†åˆ é™¤ ---
                scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== taskToDelete.scheduleId);

                // --- 3. å…³é—­å¹¶ä¿å­˜ ---
                showTrackList.value = false;
                pushHistory();
                window.triggerTouchHaptic('Medium');

                // æç¤ºç”¨æˆ·
                // openAlertModal("åˆ é™¤æˆåŠŸ", "æ—¥ç¨‹åŠå…¶åŒ…å«çš„å½•éŸ³æ•°æ®å·²æ¸…é™¤ã€‚");
            };

            // ğŸŸ¢ [æ–°å¢] æ¸…ç†ä»»åŠ¡æ± æœ¬ä½“çš„å½•éŸ³è®°å½•
            const clearPoolRecord = (templateId) => {
                if (!templateId) return;

                const poolItem = itemPool.value.find(i => i.id === templateId);
                if (poolItem && poolItem.records) {
                    // éå†æ‰€æœ‰è§†å›¾ç±»å‹ï¼Œå½»åº•æ¸…é™¤è¯¥ä»»åŠ¡çš„â€œå®é™…å½•éŸ³æ•°æ®â€
                    ['musician', 'project', 'instrument'].forEach(type => {
                        if (poolItem.records[type]) {
                            poolItem.records[type].actualDuration = '';
                            poolItem.records[type].recStart = '';
                            poolItem.records[type].recEnd = '';
                            poolItem.records[type].breakMinutes = 0;
                        }
                    });

                    // åŒæ—¶ä¹Ÿå°è¯•è§¦å‘ä¸€æ¬¡æ•ˆç‡æ›´æ–°ï¼Œä»¥é˜²è¿™ä¸ªåˆ é™¤å½±å“äº†å¹³å‡å€¼
                    // (è™½ç„¶ calculateGroupStats ä¼šè‡ªåŠ¨é‡ç®—ï¼Œä½†è¿™é‡Œç¡®ä¿æ•°æ®å±‚åŒæ­¥)
                    if (poolItem.musicianId) autoUpdateEfficiency(poolItem.musicianId, 'musician', false);
                    if (poolItem.projectId) autoUpdateEfficiency(poolItem.projectId, 'project', false);
                }
            };

            // ğŸŸ¢ æ–°å¢ï¼šåœ¨ TrackList å¼¹çª—ä¸­ä¿®æ”¹æé†’æ—¶é—´
            const onTrackListReminderChange = (task) => {
                if (!task) return;

                // 1. è°ƒç”¨ä¹‹å‰å†™å¥½çš„æ›´æ–°é€šçŸ¥å‡½æ•°
                // (ç¡®ä¿ä½ ä¹‹å‰å·²ç»æ·»åŠ äº† updateTaskNotification å‡½æ•°)
                if (typeof updateTaskNotification === 'function') {
                    updateTaskNotification(task);
                }

                // 2. ä¿å­˜æ•°æ®åˆ°å†å²è®°å½•
                pushHistory();

                // 3. (å¯é€‰) ç»™ä¸ªè½»å¾®éœ‡åŠ¨åé¦ˆ
                const Haptics = window.Capacitor?.Plugins?.Haptics;
                if (Haptics) {
                    Haptics.impact({style: 'LIGHT'});
                }
            };

            // --- V9.7.4: settings.projects å–ä»£ settings.projectColors ---
            const settings = reactive({
                startHour: 10, endHour: 22,
                sessions: [
                    {id: 'S_DEFAULT', name: 'é»˜è®¤å½•éŸ³æ—¥ç¨‹'} // åˆå§‹é»˜è®¤ Session
                ],
                instruments: [
                    {id: 'Imi7d0318nsj', name: 'æ›²ç¬› Qudi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d1wio42g', name: 'å¤§ç¬› Dadi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d1zhnrin', name: 'ç®« Xiao', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d22qbj3x', name: 'ç®¡å­ Guanzi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d25hgyts', name: 'è‘«èŠ¦ä¸ Hulusi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d28dmhcu', name: 'å˜Ÿå˜Ÿå…‹ Duduk', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d2czbme5', name: 'å¥ˆä¼Šç¬› Ney', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d2fipt2s', name: 'å¤ç­ Guzheng', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2irx4rn', name: 'çµç¶ Pipa', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2lzuq1k', name: 'ä¸­é˜® Zhongruan', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2okw95k', name: 'å¤§é˜® Daruan', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2usilyh', name: 'æ‰¬ç´ Yangqin', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2ypsa3n', name: 'ä¸‰å¼¦ Sanxian', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d321n3ff', name: 'äºŒèƒ¡ Erhu', color: '#60a5fa', group: 'Ethnic Strings'},
                    {id: 'Imi7d35n8ore', name: 'é©¬å¤´ç´ Matouqin', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d38kux53', name: 'è¨å¡”å°” Sataer', color: '#60a5fa', group: 'Ethnic Strings'},
                    {id: 'Imi7d3b4omfr', name: 'å¤å…¸å‰ä»– Classical Guitar', color: '#60a5fa', group: 'Plucks'},
                    {id: 'Imi7d3drxrgi', name: 'é’¢å¼¦å‰ä»– Acoustic Guitar', color: '#60a5fa', group: 'Plucks'},
                    {id: 'Imi7d3gz35vm', name: 'è¨å…¹ç´ Saz', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d3jqoe3p', name: 'è¥¿å¡”å°” Sitar', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d3lxykzm', name: 'ç¬™ Sheng', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d3pcnpbh', name: 'å°ºå…« Shakuhachi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d3s0hrcp', name: 'äººå£° Vocal', color: '#60a5fa', group: 'Vocal'},
                    {
                        id: 'tmi8ygljxuqkaatv',
                        name: 'ä½éŸ³é©¬å¤´ç´ Diyin Matouqin',
                        color: '#60a5fa',
                        group: 'Ethnic Strings'
                    },
                    {id: 'tmifto6q9igynzmf', name: 'é’¢ç´ Piano', color: '#60a5fa', group: 'Keys'}
                ],
                musicians: [],
                // V9.7.4: æ–°å¢ Projects åˆ—è¡¨
                projects: [],
                // ğŸŸ¢ [æ–°å¢] å½•éŸ³ä¿¡æ¯å…ƒæ•°æ®åˆ—è¡¨
                studios: [],
                engineers: [],
                operators: [],
                assistants: []
            });

            // ğŸŸ¢ [æ–°å¢] å½•éŸ³ä¿¡æ¯å¼¹çª—çš„ä¸‹æ‹‰èœå•çŠ¶æ€
            const activeRecDropdown = ref(null); // 'studio', 'engineer', 'operator', 'assistant'
            const recDropdownSearch = ref('');

            // ğŸŸ¢ [æ–°å¢] è·å–å½“å‰ä¸‹æ‹‰èœå•çš„å¯é€‰åˆ—è¡¨ (æ”¯æŒæœç´¢)
            const filteredRecOptions = computed(() => {
                const type = activeRecDropdown.value;
                const search = recDropdownSearch.value.toLowerCase().trim();
                let list = [];

                if (type === 'studio') list = settings.studios;
                else if (type === 'engineer') list = settings.engineers;
                else if (type === 'operator') list = settings.operators;
                else if (type === 'assistant') list = settings.assistants;

                if (!list) return [];

                // è¿‡æ»¤
                let result = list.filter(item => item.name.toLowerCase().includes(search));

                // æ’åº (æŒ‰åç§°)
                result.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN', { numeric: true }));
                return result;
            });

            // ğŸŸ¢ [æ–°å¢] é€‰ä¸­ä¸‹æ‹‰é¡¹
            const selectRecOption = (item) => {
                // å°†é€‰ä¸­çš„åå­—å¡«å…¥ form
                if (activeRecDropdown.value) {
                    recInfoForm[activeRecDropdown.value] = item.name;
                }
                // å…³é—­èœå•
                activeRecDropdown.value = null;
                recDropdownSearch.value = '';
            };

            // ğŸŸ¢ [æ–°å¢] åœ¨ä¸‹æ‹‰ä¸­æ–°å»ºæ¡ç›®
            const createRecOption = () => {
                const name = recDropdownSearch.value.trim();
                const type = activeRecDropdown.value;
                if (!name || !type) return;

                // 1. å­˜å…¥ settings
                let list = null;
                if (type === 'studio') list = settings.studios;
                else if (type === 'engineer') list = settings.engineers;
                else if (type === 'operator') list = settings.operators;
                else if (type === 'assistant') list = settings.assistants;

                if (list) {
                    // æŸ¥é‡
                    const exists = list.some(i => i.name.toLowerCase() === name.toLowerCase());
                    if (!exists) {
                        list.push({
                            id: generateUniqueId('REC'), // ç®€å•ç”Ÿæˆä¸€ä¸ªID
                            name: name
                        });
                        pushHistory(); // ä¿å­˜å†å²
                    }
                }

                // 2. å¡«å…¥è¾“å…¥æ¡†
                recInfoForm[type] = name;

                // 3. å…³é—­
                activeRecDropdown.value = null;
                recDropdownSearch.value = '';
                window.triggerTouchHaptic('Success');
            };

            currentSessionId.value = 'S_DEFAULT';

            // ğŸŸ¢ æ–°å¢: é€šç”¨æ’åºå‡½æ•° (ä¼˜å…ˆæŒ‰ Group æ’åºï¼Œåˆ†ç»„ç›¸åŒçš„æŒ‰ Name æ‹¼éŸ³æ’åº)
            const sortSettingsList = (list) => {
                return [...list].sort((a, b) => {
                    const gA = (a.group || '').trim();
                    const gB = (b.group || '').trim();

                    // 1. åˆ†ç»„é€»è¾‘: æœ‰åˆ†ç»„çš„æ’å‰é¢ï¼Œæ²¡åˆ†ç»„(ç©º)çš„æ’åé¢
                    if (gA && !gB) return -1;
                    if (!gA && gB) return 1;

                    // 2. å¦‚æœéƒ½æœ‰åˆ†ç»„ï¼ŒæŒ‰åˆ†ç»„åç§°æ‹¼éŸ³æ’åº
                    if (gA !== gB) return gA.localeCompare(gB, 'zh-CN');

                    // 3. åˆ†ç»„ç›¸åŒï¼ŒæŒ‰åç§°æ‹¼éŸ³æ’åº
                    return (a.name || '').localeCompare(b.name || '', 'zh-CN');
                });
            };

            // ğŸŸ¢ æ–°å¢: ä¸‰ä¸ªæ’åºåçš„è®¡ç®—å±æ€§ (ä¾› HTML æ¸²æŸ“ä½¿ç”¨)
            const sortedInstruments = computed(() => sortSettingsList(settings.instruments));
            const sortedMusicians = computed(() => sortSettingsList(settings.musicians));
            const sortedProjects = computed(() => sortSettingsList(settings.projects));

            const removeInstrument = (id) => {
                openConfirmModal(
                    'åˆ é™¤ä¹å™¨',
                    'ç¡®å®šåˆ é™¤è¯¥ä¹å™¨å—ï¼Ÿ\nâš  è­¦å‘Šï¼šæ‰€æœ‰å…³è”çš„ä»»åŠ¡ï¼ˆä»»åŠ¡æ± åŠæ—¥ç¨‹ï¼‰éƒ½å°†è¢«æ°¸ä¹…åˆ é™¤ï¼',
                    () => {
                        // 1. ä»è®¾ç½®ä¸­åˆ é™¤
                        settings.instruments = settings.instruments.filter(i => i.id !== id);

                        // 2. ä»ä»»åŠ¡æ± åˆ é™¤å…³è”ä»»åŠ¡
                        itemPool.value = itemPool.value.filter(item => item.instrumentId !== id);

                        // 3. ä»æ—¥ç¨‹è¡¨åˆ é™¤å…³è”ä»»åŠ¡
                        scheduledTasks.value = scheduledTasks.value.filter(task => task.instrumentId !== id);

                        // 4. æ¸…ç†å¯èƒ½å˜ç©ºçš„æ—¥ç¨‹å—
                        cleanupEmptySchedules();

                        pushHistory();
                        window.triggerTouchHaptic('Medium');
                    },
                    true // çº¢è‰²æŒ‰é’®
                );
            };

            const removeMusician = (id) => {
                openConfirmModal(
                    'åˆ é™¤æ¼”å¥å‘˜',
                    'ç¡®å®šåˆ é™¤è¯¥æ¼”å¥å‘˜å—ï¼Ÿ\nâš  è­¦å‘Šï¼šæ‰€æœ‰å…³è”çš„ä»»åŠ¡ï¼ˆä»»åŠ¡æ± åŠæ—¥ç¨‹ï¼‰éƒ½å°†è¢«æ°¸ä¹…åˆ é™¤ï¼',
                    () => {
                        // 1. ä»è®¾ç½®ä¸­åˆ é™¤
                        settings.musicians = settings.musicians.filter(m => m.id !== id);

                        // 2. ä»ä»»åŠ¡æ± åˆ é™¤å…³è”ä»»åŠ¡
                        itemPool.value = itemPool.value.filter(item => item.musicianId !== id);

                        // 3. ä»æ—¥ç¨‹è¡¨åˆ é™¤å…³è”ä»»åŠ¡
                        scheduledTasks.value = scheduledTasks.value.filter(task => task.musicianId !== id);

                        // 4. æ¸…ç†å¯èƒ½å˜ç©ºçš„æ—¥ç¨‹å—
                        cleanupEmptySchedules();

                        pushHistory();
                        window.triggerTouchHaptic('Medium');
                    },
                    true
                );
            };

            const deleteProject = (projectId) => {
                openConfirmModal(
                    'åˆ é™¤é¡¹ç›®',
                    'ç¡®å®šåˆ é™¤è¯¥é¡¹ç›®å—ï¼Ÿ\nâš  è­¦å‘Šï¼šæ‰€æœ‰å…³è”çš„ä»»åŠ¡ï¼ˆä»»åŠ¡æ± åŠæ—¥ç¨‹ï¼‰éƒ½å°†è¢«æ°¸ä¹…åˆ é™¤ï¼',
                    () => {
                        // 1. ä»è®¾ç½®ä¸­åˆ é™¤
                        settings.projects = settings.projects.filter(p => p.id !== projectId);

                        // 2. ä»ä»»åŠ¡æ± åˆ é™¤å…³è”ä»»åŠ¡
                        itemPool.value = itemPool.value.filter(item => item.projectId !== projectId);

                        // 3. ä»æ—¥ç¨‹è¡¨åˆ é™¤å…³è”ä»»åŠ¡
                        scheduledTasks.value = scheduledTasks.value.filter(task => task.projectId !== projectId);

                        // 4. æ¸…ç†å¯èƒ½å˜ç©ºçš„æ—¥ç¨‹å—
                        cleanupEmptySchedules();

                        pushHistory();
                        window.triggerTouchHaptic('Medium');
                    },
                    true
                );
            };


            // V9.7.4: newItem ç°åœ¨ç»‘å®š projectId
            const newItem = reactive({projectId: '', instrumentId: '', musicianId: '', musicDuration: '', ratio: 20});

            // ğŸŸ¢ [ä¿®å¤] è‡ªåŠ¨è®¤é¢†é€»è¾‘ (å¢åŠ é‡ç½®æœºåˆ¶)
            const autoFillMidiDuration = () => {
                const newPid = newItem.projectId;
                const newIid = newItem.instrumentId;

                if (!newPid || !newIid) return;

                const proj = settings.projects.find(p => p.id === newPid);

                // 1. å°è¯•è·å–è¯¥ä¹å™¨çš„ MIDI æ•°æ®
                let midiList = [];

                if (proj && proj.midiData) {
                    const midiEntry = proj.midiData[newIid];
                    if (midiEntry) {
                        if (Array.isArray(midiEntry)) {
                            midiList = midiEntry;
                        } else if (typeof midiEntry === 'string') {
                            midiList = [{ name: getNameById(newIid, 'instrument'), duration: midiEntry }];
                        }
                    }
                }

                // ğŸŸ¢ 2. æ ¸å¿ƒä¿®å¤: å¦‚æœæ²¡æœ‰æ‰¾åˆ° MIDI æ•°æ®ï¼Œå¿…é¡»æ˜¾å¼é‡ç½®ï¼
                if (midiList.length === 0) {
                    newItem.musicDuration = '';       // æ¸…ç©ºæ—¶é•¿
                    newItem.estDuration = '00:00:00'; // é‡ç½®é¢„ä¼°
                    newItem._autoSuggestedName = null;// æ¸…é™¤è‡ªåŠ¨å‘½åå»ºè®®
                    return;
                }

                // --- ä»¥ä¸‹æ˜¯æœ‰æ•°æ®æ—¶çš„é€»è¾‘ (ä¿æŒä¸å˜) ---

                // å®æ—¶è®¡ç®—å·²å­˜åœ¨çš„ä»»åŠ¡æ•°é‡ (è®¤é¢† Guzheng 1 / 2)
                const existingTasks = itemPool.value.filter(t =>
                    (t.sessionId || 'S_DEFAULT') === currentSessionId.value &&
                    t.projectId === newPid &&
                    t.instrumentId === newIid
                );

                let targetIndex = existingTasks.length;
                if (targetIndex >= midiList.length) {
                    targetIndex = midiList.length - 1;
                }

                const targetData = midiList[targetIndex];

                // å¡«å……æ•°æ®
                newItem.musicDuration = targetData.duration;

                const baseInstName = getNameById(newIid, 'instrument');
                if (targetData.name && targetData.name !== baseInstName) {
                    newItem._autoSuggestedName = targetData.name;
                } else {
                    newItem._autoSuggestedName = null;
                }

                let ratio = 20;
                if (newItem.musicianId) {
                    const mus = settings.musicians.find(m => m.id === newItem.musicianId);
                    if (mus && mus.defaultRatio) ratio = mus.defaultRatio;
                }
                newItem.ratio = ratio;
                newItem.estDuration = calculateEstTime(newItem.musicDuration, ratio);
            };

            // ğŸŸ¢ [ä¿®æ”¹] ç›‘å¬å™¨ 1: å½“ç”¨æˆ·åœ¨ä¸‹æ‹‰èœå•æ”¹å˜é€‰æ‹©æ—¶è§¦å‘
            watch(() => [newItem.projectId, newItem.instrumentId], () => {
                autoFillMidiDuration();
            });

            // ğŸŸ¢ [æ–°å¢] ç›‘å¬å™¨ 2: å½“æ–°å»ºå¼¹çª—æ‰“å¼€æ—¶ï¼Œå¼ºåˆ¶é‡æ–°æ£€æŸ¥ä¸€é
            // è§£å†³åœºæ™¯ï¼šåˆ›å»ºå®Œ Guzheng 1 åå…³é—­å¼¹çª—ï¼Œå†æ‰“å¼€å¼¹çª—æƒ³åˆ›å»º Guzheng 2ï¼Œ
            // æ­¤æ—¶ instrumentId æ²¡å˜ï¼Œå¦‚æœä¸å¼ºåˆ¶æ£€æŸ¥ï¼Œæ—¶é•¿è¿˜æ˜¯ 1 çš„ã€‚
            watch(showMobileTaskInput, (isOpen) => {
                if (isOpen) {
                    autoFillMidiDuration();
                }
            });

            // ğŸŸ¢ ä¿®æ”¹: çº¯ç²¹çš„ç™»å½•é€»è¾‘ (ä¸å†è‡ªåŠ¨è·³è½¬æ³¨å†Œ)
            const handleLogin = async () => {
                if (!authForm.email || !authForm.password) return openAlertModal("è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ");
                authLoading.value = true;

                // 1. å°è¯•ç™»å½•
                const {data, error} = await supabaseClient.auth.signInWithPassword({
                    email: authForm.email, password: authForm.password
                });

                if (error) {
                    // ğŸŸ¢ å…³é”®ä¿®æ”¹: ç™»å½•å¤±è´¥å°±æ˜¯å¤±è´¥ï¼Œä¸å†è‡ªåŠ¨å°è¯•æ³¨å†Œ
                    // è¿™æ ·è¾“é”™å¯†ç æ—¶ï¼Œå°±ä¼šæ˜ç¡®æç¤º "Invalid login credentials" (è´¦å·æˆ–å¯†ç é”™è¯¯)
                    if (error.message.includes("Invalid login credentials")) {
                        openAlertModal("ç™»å½•å¤±è´¥ï¼šè´¦å·æˆ–å¯†ç é”™è¯¯");
                    } else {
                        openAlertModal("ç™»å½•å¤±è´¥: " + error.message);
                    }
                } else {
                    user.value = data.user;
                    showAuthModal.value = false;
                    await loadCloudData(); // åŠ è½½æ•°æ®
                }
                authLoading.value = false;
            };

            // ğŸŸ¢ æ–°å¢: ç‹¬ç«‹çš„æ³¨å†Œé€»è¾‘
            const handleRegister = async () => {
                if (!authForm.email || !authForm.password) return openAlertModal("è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ");
                authLoading.value = true;

                const {data, error} = await supabaseClient.auth.signUp({
                    email: authForm.email, password: authForm.password
                });

                if (error) {
                    openAlertModal("æ³¨å†Œå¤±è´¥: " + error.message);
                } else {
                    // Supabase é»˜è®¤è¡Œä¸ºï¼šå¦‚æœè¯¥é‚®ç®±å·²æ³¨å†Œï¼ŒsignUp ä¸ä¼šæŠ¥é”™ï¼Œä½†è¿”å›çš„ user ä¸º null (æˆ–å‡æ•°æ®)
                    // æˆ‘ä»¬æç¤ºç”¨æˆ·å»ç¡®è®¤é‚®ä»¶æˆ–ç›´æ¥ç™»å½•
                    if (data.user && data.user.identities && data.user.identities.length === 0) {
                        openAlertModal("è¯¥é‚®ç®±å·²è¢«æ³¨å†Œï¼Œè¯·ç›´æ¥ç™»å½• (è‹¥å¿˜è®°å¯†ç è¯·ç‚¹å‡»æ‰¾å›)ã€‚");
                    } else {
                        openAlertModal("æ³¨å†ŒæˆåŠŸï¼\nè¯·æ£€æŸ¥æ‚¨çš„é‚®ç®±è¿›è¡ŒéªŒè¯ï¼ŒéªŒè¯åå³å¯ç™»å½•ã€‚");
                    }
                }
                authLoading.value = false;
            };

            // --- ğŸŸ¢ æ–°å¢ï¼šè®¾ç½®å•ä¸ªä»»åŠ¡çš„ç³»ç»Ÿé€šçŸ¥ ---
            const updateTaskNotification = async (task) => {
                // 1. å¦‚æœæ²¡æœ‰ Capacitor ç¯å¢ƒï¼Œç›´æ¥è·³è¿‡
                const LocalNotifications = window.Capacitor?.Plugins?.LocalNotifications;
                if (!LocalNotifications) return;

                // 2. ç”Ÿæˆä¸€ä¸ªå®‰å…¨çš„ 32ä½ æ•´æ•° ID (Android é™åˆ¶ ID ä¸èƒ½å¤ªå¤§)
                // æˆ‘ä»¬ç”¨ä»»åŠ¡ ID (æ—¶é—´æˆ³) å¯¹ 21äº¿ å–æ¨¡ï¼Œç¡®ä¿å®ƒæ˜¯å”¯ä¸€çš„ä¸”ç¬¦åˆæ•´æ•°èŒƒå›´
                const notifId = task.scheduleId % 2147483647;

                // 3. å…ˆå–æ¶ˆæ—§çš„é€šçŸ¥ (é˜²æ­¢é‡å¤æˆ–ä¿®æ”¹æ—¶é—´åæ—§çš„è¿˜åœ¨)
                try {
                    await LocalNotifications.cancel({notifications: [{id: notifId}]});
                } catch (e) { /* å¿½ç•¥é”™è¯¯ */
                }

                // 4. å¦‚æœç”¨æˆ·é€‰æ‹©äº†â€œæ— æé†’â€ (0) æˆ–è€…æ²¡æœ‰è®¾ç½®æ—¶é—´ï¼Œå°±ç»“æŸ
                if (!task.reminderMinutes || task.reminderMinutes <= 0) return;

                // 5. è®¡ç®—è§¦å‘æ—¶é—´
                // æ ¼å¼è§£æ: "2025-11-27" + "10:30"
                const dateStr = task.date.replace(/-/g, '/'); // å…¼å®¹ iOS æ—¥æœŸæ ¼å¼
                const taskTime = new Date(`${dateStr} ${task.startTime}:00`);

                // å‡å»æå‰çš„åˆ†é’Ÿæ•°
                const triggerTime = new Date(taskTime.getTime() - task.reminderMinutes * 60 * 1000);

                // å¦‚æœè§¦å‘æ—¶é—´å·²ç»è¿‡å»äº†ï¼Œå°±ä¸è®¾äº†
                if (triggerTime.getTime() < Date.now() - 60 * 1000) {
                    console.warn(`âš ï¸ é€šçŸ¥è·³è¿‡: æé†’æ—¶é—´ ${triggerTime.toLocaleTimeString()} å‘ç”Ÿåœ¨ 1 åˆ†é’Ÿå‰æˆ–æ›´æ—©ï¼Œå·²æ”¾å¼ƒè®¾ç½®ã€‚`);
                    return;
                }

                // 6. å®‰æ’æ–°é€šçŸ¥
                try {
                    // ç¡®ä¿æœ‰æƒé™
                    let perm = await LocalNotifications.checkPermissions();
                    if (perm.display !== 'granted') perm = await LocalNotifications.requestPermissions();
                    if (perm.display !== 'granted') return;

                    await LocalNotifications.schedule({
                        notifications: [{
                            title: `å‡†å¤‡å½•éŸ³: ${getNameById(task.musicianId, 'musician')}`,
                            body: `${task.startTime} å¼€å§‹ (${getNameById(task.projectId, 'project')})`,
                            id: notifId,
                            schedule: {at: triggerTime},
                            sound: 'default', // æˆ– 'beep.wav'
                            smallIcon: 'ic_stat_icon', // Android å›¾æ ‡
                        }]
                    });

                    console.log(`âœ… é€šçŸ¥å·²è®¾å®š: ${triggerTime.toLocaleTimeString()}`);

                } catch (e) {
                    console.error("è®¾ç½®é€šçŸ¥å¤±è´¥:", e);
                }
            };

            // ğŸŸ¢ æ–°å¢: æ‰¾å›å¯†ç é€»è¾‘
            const handleResetPwd = async () => {
                if (!authForm.email) return openAlertModal("è¯·å…ˆåœ¨ä¸Šæ–¹è¾“å…¥æ‚¨çš„é‚®ç®±åœ°å€");

                authLoading.value = true;
                const {data, error} = await supabaseClient.auth.resetPasswordForEmail(authForm.email, {
                    redirectTo: window.location.origin, // é‡ç½®åè·³å›å½“å‰é¡µé¢
                });

                if (error) {
                    openAlertModal("å‘é€å¤±è´¥: " + error.message);
                } else {
                    openAlertModal(`é‡ç½®é‚®ä»¶å·²å‘é€è‡³ ${authForm.email}\nè¯·æŸ¥æ”¶é‚®ä»¶å¹¶ç‚¹å‡»é“¾æ¥é‡è®¾å¯†ç ã€‚`);
                }
                authLoading.value = false;
            };

            // ğŸŸ¢ æ–°å¢: ä¸ªäººä¸­å¿ƒé€»è¾‘

            // è®¡ç®—å½“å‰æ˜¾ç¤ºçš„å¤´åƒ (ä¼˜å…ˆè¯»å– user_metadata)
            const userAvatar = computed(() => {
                if (user.value && user.value.user_metadata && user.value.user_metadata.avatar_url) {
                    return user.value.user_metadata.avatar_url;
                }
                return null;
            });

            // --- ğŸŸ¢ æ–°å¢: æ˜µç§°ç®¡ç†é€»è¾‘ ---
            const tempNickname = ref('');

            // è®¡ç®—æ˜¾ç¤ºåç§° (ä¼˜å…ˆæ˜¾ç¤º full_nameï¼Œå¦åˆ™æ˜¾ç¤ºé‚®ç®±å‰ç¼€)
            const userDisplayName = computed(() => {
                if (user.value && user.value.user_metadata && user.value.user_metadata.full_name) {
                    return user.value.user_metadata.full_name;
                }
                return user.value ? user.value.email.split('@')[0] : 'Guest';
            });

            // æ›´æ–°æ˜µç§°åˆ° Supabase
            const updateNickname = async () => {
                if (!user.value) return;
                if (!tempNickname.value.trim()) return openAlertModal("æ˜µç§°ä¸èƒ½ä¸ºç©º");

                authLoading.value = true;
                try {
                    const {data, error} = await supabaseClient.auth.updateUser({
                        data: {full_name: tempNickname.value.trim()}
                    });

                    if (error) throw error;

                    user.value = data.user; // æ›´æ–°æœ¬åœ°ç”¨æˆ·æ•°æ®ä»¥åˆ·æ–° UI
                    // alert("æ˜µç§°å·²æ›´æ–°ï¼"); // å¯é€‰ï¼šä¸å–œæ¬¢å¼¹çª—å¯ä»¥æ³¨é‡Šæ‰
                    // è¿™é‡Œæˆ‘ä»¬ä¸å…³é—­èœå•ï¼Œæ–¹ä¾¿ç”¨æˆ·çœ‹åˆ°å˜åŒ–
                } catch (error) {
                    openAlertModal("æ›´æ–°å¤±è´¥: " + error.message);
                } finally {
                    authLoading.value = false;
                }
            };

            // ğŸš©ğŸš©ğŸš© æ›¿æ¢ factoryReset å‡½æ•°çš„å®Œæ•´å®šä¹‰ ğŸš©ğŸš©ğŸš©

            const factoryReset = () => {
                openConfirmModal(
                    'æ¢å¤å‡ºå‚è®¾ç½®',
                    'âš ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿ\n\nå¦‚æœå½“å‰ä¸ºç™»å½•çŠ¶æ€ï¼Œäº‘ç«¯æ•°æ®ä¹Ÿå°†è¢«æ°¸ä¹…æ¸…é™¤ã€‚æ­¤æ“ä½œä¸å¯é€†ï¼',
                    // ç¡®è®¤æ‰§è¡Œçš„å¼‚æ­¥å›è°ƒå‡½æ•°
                    async () => {
                        // 1. å¦‚æœå·²ç™»å½•ï¼Œæ¸…ç©ºäº‘ç«¯æ•°æ® (æ ¸å¿ƒä¿®æ”¹ç‚¹)
                        if (user.value) {
                            // åˆ é™¤ Supabase ä¸­ user_data è¡¨ä¸­ä¸å½“å‰ç”¨æˆ· ID åŒ¹é…çš„è¡Œ
                            const { error } = await supabaseClient
                                .from('user_data')
                                .delete()
                                .eq('user_id', user.value.id);

                            if (error) {
                                console.error("Cloud data deletion failed:", error);
                                // å³ä½¿äº‘ç«¯åˆ é™¤å¤±è´¥ï¼Œä¹Ÿè¦ç»§ç»­è¿›è¡Œæœ¬åœ°æ¸…ç†å’Œåˆ·æ–°
                                openAlertModal('äº‘ç«¯æ¸…ç†å¤±è´¥', 'æ— æ³•åˆ é™¤äº‘ç«¯æ•°æ®ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ç¨åé‡è¯•ã€‚');
                            } else {
                                // äº‘ç«¯åˆ é™¤æˆåŠŸåï¼Œç»™ç”¨æˆ·ä¸€ä¸ªæ˜ç¡®æç¤º (æ³¨æ„ï¼šåˆ·æ–°åè¿™ä¸ªå¼¹çª—ä¼šæ¶ˆå¤±)
                                openAlertModal('äº‘ç«¯æ•°æ®å·²æ¸…é™¤', 'æ‚¨çš„æ‰€æœ‰æ•°æ®å·²ä»äº‘ç«¯æ°¸ä¹…æ¸…é™¤ã€‚');
                            }
                        }

                        // 2. æ¸…ç†æœ¬åœ°æ•°æ®
                        localStorage.removeItem('v9_data');
                        // 3. æ¸…é™¤å¼•å¯¼è®°å½•
                        localStorage.removeItem('musche_tour_seen');

                        localDataVersion.value = 0;

                        // 4. åˆ·æ–°é¡µé¢
                        window.location.reload();
                    },
                    true, // isDestructive: çº¢è‰²æŒ‰é’®
                    'å½»åº•æ¸…ç©º',
                    'å†æƒ³æƒ³'
                );
            };

            // å¤„ç†é¡¶éƒ¨æŒ‰é’®ç‚¹å‡»
            // ğŸ”´ ä¿®æ”¹: åŠ å…¥äº’æ–¥é€»è¾‘
            // ğŸ”´ ä¿®æ”¹: å¤„ç†é¡¶éƒ¨å¤´åƒæŒ‰é’®ç‚¹å‡» (åˆå¹¶äº†ä¹‹å‰çš„äº’æ–¥é€»è¾‘å’Œæ˜µç§°å¡«å……)
            const handleUserBtnClick = () => {
                if (user.value) {
                    const wasOpen = showProfileMenu.value;

                    // 1. å¼ºåˆ¶å…³é—­å…¶ä»–èœå• (äº’æ–¥)
                    activeDropdown.value = null;
                    showMobileMenu.value = false;

                    // 2. åˆ‡æ¢è‡ªå·±
                    showProfileMenu.value = !wasOpen;

                    // 3. å¦‚æœæ‰“å¼€äº†ï¼Œåˆå§‹åŒ–æ•°æ®
                    if (showProfileMenu.value) {
                        // å¡«å……å¤´åƒ URL
                        tempAvatarUrl.value = userAvatar.value || '';
                        // å¡«å……å½“å‰æ˜µç§° (å¦‚æœæœ‰)
                        tempNickname.value = userDisplayName.value;
                    }
                } else {
                    showAuthModal.value = true;
                }
            };

            // æ›´æ–°å¤´åƒåˆ° Supabase
            const updateAvatar = async () => {
                if (!user.value) return;

                const url = tempAvatarUrl.value.trim();

                // è°ƒç”¨ Supabase æ›´æ–°ç”¨æˆ·å…ƒæ•°æ®
                const {data, error} = await supabaseClient.auth.updateUser({
                    data: {avatar_url: url}
                });

                if (error) {
                    openAlertModal("æ›´æ–°å¤±è´¥: " + error.message);
                } else {
                    // æ›´æ–°æœ¬åœ° user å¯¹è±¡ä»¥ç«‹å³åˆ·æ–° UI
                    user.value = data.user;
                    openAlertModal("å¤´åƒå·²æ›´æ–°ï¼");
                }
            };

            // ğŸŸ¢ æ–°å¢: åˆ¤æ–­æ˜¯å¦ä¸ºé»˜è®¤å€ç‡ (ç”¨äºéšè—å¡ç‰‡ä¸Šçš„å€ç‡æ ‡ç­¾)
            const isDefaultRatio = (item) => {
                // 1. å¦‚æœæ²¡æœ‰å€ç‡ï¼Œè§†ä½œé»˜è®¤ï¼ˆéšè—ï¼‰
                if (!item.ratio) return true;

                const val = Number(item.ratio);

                // 2. å°è¯•æ‰¾åˆ°å¯¹åº”æ¼”å¥å‘˜çš„é»˜è®¤å€ç‡é…ç½®
                if (item.musicianId) {
                    const m = settings.musicians.find(u => u.id === item.musicianId);
                    // å¦‚æœè¯¥æ¼”å¥å‘˜æœ‰ç‰¹å®šçš„é»˜è®¤å€ç‡ï¼Œåˆ™ä¸è¯¥å€¼æ¯”è¾ƒ
                    if (m && m.defaultRatio) {
                        return val === Number(m.defaultRatio);
                    }
                }

                // 3. å¦‚æœæ‰¾ä¸åˆ°ç‰¹å®šé…ç½®ï¼Œåˆ™å…œåº•æ¯”è¾ƒå…¨å±€é»˜è®¤å€¼ 20
                return val === 20;
            };


            // ğŸŸ¢ [é‡å†™] ç‹¬ç«‹ç»´åº¦çš„æ•ˆç‡æ›´æ–° (ä¿®å¤: è®¾ä¸º null ä»¥ä¿æŒè‡ªåŠ¨è·Ÿéš)
            const autoUpdateEfficiency = (targetId, viewType, shouldPushHistory = true) => {
                if (!targetId || !viewType) return;

                // 1. ç¡®å®š ID åŒ¹é…é”®
                let idKey = 'musicianId';
                let list = settings.musicians;
                if (viewType === 'project') {
                    idKey = 'projectId';
                    list = settings.projects;
                } else if (viewType === 'instrument') {
                    idKey = 'instrumentId';
                    list = settings.instruments;
                }

                // 2. ç­›é€‰ä»»åŠ¡ (åªè®¡ç®—å½“å‰ Session)
                const items = itemPool.value.filter(i => i[idKey] === targetId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);

                let totalActual = 0;
                let totalMusic = 0;

                items.forEach(item => {
                    ensureItemRecords(item);
                    // åªè¯»å–å½“å‰ç»´åº¦ (viewType) çš„å½•éŸ³è®°å½•
                    const rec = item.records[viewType];
                    if (rec && rec.actualDuration && item.musicDuration) {
                        const act = parseTime(rec.actualDuration);
                        const mus = parseTime(item.musicDuration);
                        if (act > 0 && mus > 0) {
                            totalActual += act;
                            totalMusic += mus;
                        }
                    }
                });

                // 3. è®¡ç®—æ–°çš„å¹³å‡å€ç‡
                // ğŸŸ¢ ä¿®å¤: å¦‚æœæ²¡æœ‰å½•éŸ³æ•°æ®(totalMusic=0)ï¼Œä¸è¦å¼ºåˆ¶é‡ç½®ä¸º 20
                // è€Œæ˜¯åº”è¯¥å›é€€ä½¿ç”¨è¯¥å¯¹è±¡çš„ defaultRatio (å¦‚æœè®¾ç½®è¿‡)ï¼Œå¦åˆ™æ‰ç”¨ 20
                let newRatio = 0;

                if (totalMusic > 0) {
                    newRatio = parseFloat((totalActual / totalMusic).toFixed(1));
                }

                // 4. æ›´æ–°è®¾ç½®é‡Œçš„ defaultRatio
                const settingItem = list.find(i => i.id === targetId);
                let oldDefaultRatio = 20;

                if (settingItem) {
                    oldDefaultRatio = settingItem.defaultRatio || 20;

                    if (newRatio > 0) {
                        // æœ‰çœŸå®æ•°æ®ï¼Œæ›´æ–°è®¾ç½®
                        settingItem.defaultRatio = newRatio;
                    } else {
                        // æ— çœŸå®æ•°æ®ï¼Œä½¿ç”¨ç°æœ‰çš„è®¾ç½®å€¼ä½œä¸ºâ€œæ–°å€ç‡â€å»æ›´æ–°ä»»åŠ¡
                        newRatio = oldDefaultRatio;
                    }
                } else {
                    if (newRatio === 0) newRatio = 20;
                }

                // 5. æ›´æ–°æ‰€æœ‰ç›¸å…³ä»»åŠ¡ (åŒ…æ‹¬ä»»åŠ¡æ± å’Œæ—¥ç¨‹è¡¨)
                const updateTaskLogic = (task) => {
                    if (task[idKey] !== targetId || !task.musicDuration) return;

                    ensureItemRecords(task);

                    // A. è·å–è¯¥ä»»åŠ¡åœ¨å½“å‰ç»´åº¦çš„æ—§å€ç‡
                    const currentDimRatio = task.ratios[viewType];

                    // B. æ™ºèƒ½åˆ¤æ–­ï¼š
                    // å¦‚æœè¯¥ä»»åŠ¡çš„å€ç‡ç­‰äºæ—§çš„é»˜è®¤å€¼ (è¯´æ˜ä¹‹å‰å°±åœ¨è·Ÿéš)ï¼Œæˆ–è€…æ˜¯ 0/ç©º/null
                    // æˆ–è€…ç­‰äº 20 (æ—§æ•°æ®çš„é»˜è®¤å€¼)
                    if (!currentDimRatio || currentDimRatio == oldDefaultRatio || parseFloat(currentDimRatio) === 20) {

                        // ğŸŸ¢ æ ¸å¿ƒä¿®å¤: è®¾ä¸º nullï¼Œè¡¨ç¤º"è‡ªåŠ¨è·Ÿéš"
                        task.ratios[viewType] = null;

                        // ğŸŸ¢ 2. æ›´æ–°ä¸»æ˜¾ç¤ºå±æ€§ (ä¸ºäº†æ—¥ç¨‹è¡¨æ˜¾ç¤ºæ­£ç¡®)
                        // æ—¥ç¨‹è¡¨(Schedule View)ä¸èµ° calculateGroupStats çš„å®æ—¶è®¡ç®—ï¼Œå®ƒæ˜¯é™æ€æ˜¾ç¤ºçš„
                        // æ‰€ä»¥è¿™é‡Œå¿…é¡»æŠŠæœ€æ–°çš„ newRatio èµ‹å€¼ç»™ task.ratio å’Œ task.estDuration
                        if (task.ratio !== newRatio) {
                            task.ratio = newRatio;
                            task.estDuration = calculateEstTime(task.musicDuration, newRatio);
                        }
                    }
                };

                // æ‰§è¡Œæ›´æ–°
                itemPool.value.forEach(updateTaskLogic);
                scheduledTasks.value.forEach(updateTaskLogic);

                // if (shouldPushHistory) {
                //     pushHistory();
                // }
            };

            // ğŸŸ¢ æ–°å¢: å¤„ç†å¤´åƒæ–‡ä»¶ä¸Šä¼ 
            const handleAvatarUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // 1. é™åˆ¶æ–‡ä»¶å¤§å° (ä¾‹å¦‚ 2MB)
                if (file.size > 2 * 1024 * 1024) {
                    return openAlertModal("å›¾ç‰‡å¤ªå¤§äº†ï¼Œè¯·é€‰æ‹© 2MB ä»¥ä¸‹çš„å›¾ç‰‡");
                }

                // æ›´æ”¹æŒ‰é’®æ–‡å­—æ˜¾ç¤ºçŠ¶æ€ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
                const btnText = document.getElementById('upload-text');
                if (btnText) btnText.innerText = "ä¸Šä¼ ä¸­...";

                try {
                    // 2. ç”Ÿæˆæ–‡ä»¶å: user_id + æ—¶é—´æˆ³ + åç¼€
                    const fileExt = file.name.split('.').pop();
                    const fileName = `${user.value.id}-${Date.now()}.${fileExt}`;
                    const filePath = `${fileName}`;

                    // 3. ä¸Šä¼ åˆ° 'avatars' æ¡¶
                    const {error: uploadError} = await supabaseClient.storage
                        .from('avatars')
                        .upload(filePath, file);

                    if (uploadError) throw uploadError;

                    // 4. è·å–å…¬å¼€è®¿é—® URL
                    const {data} = supabaseClient.storage
                        .from('avatars')
                        .getPublicUrl(filePath);

                    const publicUrl = data.publicUrl;

                    // 5. æ›´æ–°ç”¨æˆ·å…ƒæ•°æ® (Metadata)
                    const {data: userData, error: updateError} = await supabaseClient.auth.updateUser({
                        data: {avatar_url: publicUrl}
                    });

                    if (updateError) throw updateError;

                    // æˆåŠŸï¼
                    user.value = userData.user;
                    openAlertModal("å¤´åƒä¸Šä¼ æˆåŠŸï¼");

                } catch (error) {
                    openAlertModal("ä¸Šä¼ å¤±è´¥: " + error.message);
                    console.error(error);
                } finally {
                    if (btnText) btnText.innerText = "é€‰æ‹©å›¾ç‰‡...";
                    event.target.value = ''; // é‡ç½® inputï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
                }
            };

            // ğŸŸ¢ æ–°å¢: ç™»å‡ºé€»è¾‘
            // ğŸŸ¢ ä¿®æ”¹: æš´åŠ›æ¸…é™¤æ‰€æœ‰ç¼“å­˜ï¼Œç¡®ä¿é€€å‡ºåä¸ä¼šè‡ªåŠ¨ç™»å½•
            // ğŸŸ¢ ä¿®æ”¹: é€€å‡ºç™»å½•æ—¶ï¼Œåªæ¸…é™¤èº«ä»½ä¿¡æ¯ï¼Œä¿ç•™æœ¬åœ°æ•°æ® (v9_data)
            const handleLogout = async () => {
                // 1. ç•Œé¢ä¸Šç½®ç©ºç”¨æˆ·
                user.value = null;

                // 2. æ‰§è¡Œ Supabase ç™»å‡º
                // (Supabase ä¼šè‡ªåŠ¨æ¸…é™¤æµè§ˆå™¨ä¸­ä¸è´¦å·ç›¸å…³çš„ sb-xxx-tokenï¼Œä½†ä¸ä¼šåŠ¨ä½ çš„ v9_data)
                try {
                    await supabaseClient.auth.signOut();
                } catch (e) {
                    console.error("Cloud signout failed:", e);
                }

                // ğŸ”´ å…³é”®ä¿®æ”¹: åˆ é™¤ä¹‹å‰å†™çš„ localStorage.clear() æˆ– removeItem
                // æˆ‘ä»¬ä¸å†æ¸…é™¤æœ¬åœ°å­˜å‚¨ï¼Œè¿™æ ·â€œæ¸¸å®¢æ¨¡å¼â€çš„æ•°æ®æˆ–è€…åˆšæ‰åŒæ­¥ä¸‹æ¥çš„æ•°æ®éƒ½ä¼šç•™åœ¨æœ¬åœ°

                // 3. æç¤ºå¹¶åˆ·æ–°
                openAlertModal("å·²é€€å‡ºè´¦å·è¿æ¥ã€‚");

                localDataVersion.value = 0;

                // åˆ·æ–°é¡µé¢ï¼Œæ­¤æ—¶ onMounted ä¼šå‘ç°æ²¡ç™»å½•ï¼Œä»è€ŒåŠ è½½æœ¬åœ°çš„ v9_data
                window.location.reload();
            };

            // ğŸŸ¢ ä¿®æ”¹: ä¼˜åŒ–åçš„åŠ è½½é€»è¾‘ (æ”¯æŒç‰ˆæœ¬æ§åˆ¶)
            const loadCloudData = async () => {
                if (!user.value) return;

                // 1. ä»äº‘ç«¯æ‹‰å–æ•°æ®ï¼ŒåŒæ—¶æŸ¥è¯¢ content å’Œ version
                const {data, error} = await supabaseClient
                    .from('user_data')
                    .select('content, version') // <--- å…³é”®ä¿®æ”¹ï¼šå¤šæŸ¥ä¸€ä¸ª version
                    .eq('user_id', user.value.id)
                    .single();

                if (data && data.content) {
                    console.log("âœ… å·²åŠ è½½äº‘ç«¯æ•°æ®, ç‰ˆæœ¬:", data.version);
                    const d = data.content;

                    // ğŸŸ¢ å…³é”®: æ›´æ–°æœ¬åœ°ç‰ˆæœ¬å·
                    localDataVersion.value = data.version || 0;

                    // æ¢å¤é€»è¾‘ (ä¿æŒä¸å˜)
                    if (d.pool) itemPool.value = d.pool;
                    if (d.tasks) scheduledTasks.value = d.tasks;

                    if (d.settings) {
                        settings.startHour = d.settings.startHour;
                        settings.endHour = d.settings.endHour;
                        if(d.settings.sessions) settings.sessions = d.settings.sessions;
                        if(d.settings.instruments) settings.instruments = d.settings.instruments;
                        if(d.settings.musicians) settings.musicians = d.settings.musicians;
                        if(d.settings.projects) settings.projects = d.settings.projects;
                        if(d.settings.studios) settings.studios = d.settings.studios;
                        if(d.settings.engineers) settings.engineers = d.settings.engineers;
                        if(d.settings.operators) settings.operators = d.settings.operators;
                        if(d.settings.assistants) settings.assistants = d.settings.assistants;

                        if (d.settings.lastSessionId) {
                            const exists = settings.sessions.find(s => s.id === d.settings.lastSessionId);
                            currentSessionId.value = exists ? exists.id : settings.sessions[0].id;
                        }
                    }
                } else {
                    // äº‘ç«¯æ— æ•°æ®é€»è¾‘ (ä¿æŒä¸å˜)
                    console.log("âš ï¸ äº‘ç«¯æ— æ•°æ®");
                    localDataVersion.value = 0; // é‡ç½®ç‰ˆæœ¬

                    const localStr = localStorage.getItem('v9_data');
                    if (localStr) {
                        const localData = JSON.parse(localStr);
                        const hasRealData = (localData.pool && localData.pool.length > 0) || (localData.tasks && localData.tasks.length > 0);

                        if (hasRealData) {
                            openConfirmModal(
                                'æ•°æ®å†²çª',
                                'æ£€æµ‹åˆ°æ‚¨æœ¬åœ°æœ‰æ—§æ•°æ®ï¼Œè€Œäº‘ç«¯æ˜¯ç©ºçš„ã€‚\n\næ‚¨å¸Œæœ›å¦‚ä½•å¤„ç†ï¼Ÿ',
                                async () => {
                                    // ä¸Šä¼ æœ¬åœ°æ•°æ®é€»è¾‘
                                    const dataToUpload = {
                                        pool: localData.pool || [],
                                        tasks: localData.tasks || [],
                                        settings: localData.settings || settings
                                    };
                                    // åˆå§‹ä¸Šä¼ ï¼Œç‰ˆæœ¬è®¾ä¸º 1
                                    const {error: uploadError} = await supabaseClient
                                        .from('user_data')
                                        .upsert({
                                            user_id: user.value.id,
                                            content: dataToUpload,
                                            version: 1
                                        }, {onConflict: 'user_id'});

                                    if (!uploadError) {
                                        localDataVersion.value = 1;
                                        openAlertModal('æˆåŠŸ', 'âœ… æœ¬åœ°æ•°æ®å·²æˆåŠŸä¸Šä¼ ï¼');
                                    } else {
                                        openAlertModal('ä¸Šä¼ å¤±è´¥', uploadError.message);
                                    }
                                },
                                false,
                                'ä¸Šä¼ æœ¬åœ°æ•°æ®',
                                'æ”¾å¼ƒæœ¬åœ°æ•°æ®'
                            );
                        }
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: å¢åŠ ç‰ˆæœ¬æ£€æŸ¥çš„ä¿å­˜é€»è¾‘ (è§£å†³ Race Condition)
            const saveToCloud = async (force = false) => {
                if (!user.value) return;

                saveStatus.value = 'saving';

                try {
                    // --- æ­¥éª¤ 1: æ£€æŸ¥äº‘ç«¯æœ€æ–°ç‰ˆæœ¬ ---
                    // æˆ‘ä»¬åªæŸ¥è¯¢ version å­—æ®µï¼Œå¼€é”€å¾ˆå°
                    const { data: serverRecord, error: checkError } = await supabaseClient
                        .from('user_data')
                        .select('version')
                        .eq('user_id', user.value.id)
                        .single();

                    // å¦‚æœæŸ¥è¯¢å‡ºé”™ä¸”ä¸æ˜¯"æŸ¥æ— æ­¤äºº"(PGRST116)ï¼Œåˆ™æŠ¥é”™
                    if (checkError && checkError.code !== 'PGRST116') throw checkError;

                    const serverVersion = serverRecord ? serverRecord.version : 0;

                    // ğŸš¨ æ ¸å¿ƒåˆ¤æ–­: å¦‚æœäº‘ç«¯ç‰ˆæœ¬ > æœ¬åœ°ç‰ˆæœ¬ï¼Œè¯´æ˜æœ‰äººæ·è¶³å…ˆç™»äº†
                    if (serverVersion > localDataVersion.value && !force) {
                        console.warn(`ç‰ˆæœ¬å†²çª: æœ¬åœ° v${localDataVersion.value} vs äº‘ç«¯ v${serverVersion}`);
                        saveStatus.value = 'error';
                        window.triggerTouchHaptic('Error');

                        // å¼¹å‡ºå†²çªæç¤º
                        openConfirmModal(
                            'âš  æ•°æ®åŒæ­¥å†²çª',
                            'æ£€æµ‹åˆ°äº‘ç«¯æœ‰æ›´æ–°çš„æ•°æ®ï¼ˆå¯èƒ½æ‚¨åœ¨å…¶ä»–è®¾å¤‡è¿›è¡Œäº†æ“ä½œï¼‰ã€‚\n\nä¸ºäº†é˜²æ­¢æ•°æ®è¦†ç›–ï¼Œè¯·å…ˆåŒæ­¥æœ€æ–°æ•°æ®ã€‚',
                            async () => {
                                await handleManualSync(); // å¼•å¯¼ç”¨æˆ·æ‹‰å–
                            },
                            false,
                            'ç«‹å³åŒæ­¥ (æ¨è)',
                            'æš‚ä¸å¤„ç†'
                        );
                        return; // â›”ï¸ ç»ˆæ­¢ä¿å­˜
                    }

                    // --- æ­¥éª¤ 2: å‡†å¤‡ä¿å­˜ ---
                    const newVersion = serverVersion + 1; // ç‰ˆæœ¬å· +1

                    const dataToSave = {
                        pool: itemPool.value,
                        tasks: scheduledTasks.value,
                        settings: {...settings, lastSessionId: currentSessionId.value}
                    };

                    // --- æ­¥éª¤ 3: æ‰§è¡Œå†™å…¥ ---
                    const { error: saveError } = await supabaseClient.from('user_data').upsert({
                        user_id: user.value.id,
                        content: dataToSave,
                        version: newVersion // å†™å…¥æ–°ç‰ˆæœ¬å·
                    }, {onConflict: 'user_id'});

                    if (saveError) throw saveError;

                    // âœ… ä¿å­˜æˆåŠŸ: æ›´æ–°æœ¬åœ°ç‰ˆæœ¬å·
                    localDataVersion.value = newVersion;
                    console.log(`äº‘ç«¯åŒæ­¥å®Œæˆ (v${newVersion})`);

                    setTimeout(() => {
                        saveStatus.value = 'saved';
                    }, 500);

                } catch (e) {
                    console.error("ä¿å­˜å¤±è´¥", e);
                    saveStatus.value = 'error';
                }
            };

            // --- V11.8 è‡ªå®šä¹‰ä¸‹æ‹‰èœå•çŠ¶æ€ ---
            const activeDropdown = ref(null); // å½“å‰æ‰“å¼€çš„èœå•: 'project' | 'instrument' | 'musician' | null
            const dropdownSearch = ref('');   // ä¸‹æ‹‰èœå•å†…çš„æœç´¢è¯

            // 1. è®¾ç½®å¼¹çª—çš„åˆ†ç»„çŠ¶æ€
            const settingsExpandedGroups = reactive(new Set()); // é»˜è®¤ç©ºSetï¼Œå³å…¨éƒ¨æŠ˜å 

            // 2. ä¸‹æ‹‰èœå•çš„åˆ†ç»„çŠ¶æ€
            const dropdownExpandedGroups = reactive(new Set()); // é»˜è®¤ç©ºSetï¼Œå³å…¨éƒ¨æŠ˜å 

            const toggleDropdownGroup = (groupName) => {
                if (dropdownExpandedGroups.has(groupName)) {
                    dropdownExpandedGroups.delete(groupName);
                } else {
                    dropdownExpandedGroups.add(groupName);
                }
            };

            // 3. ç›‘å¬æœç´¢æ¡†ï¼šå¦‚æœç”¨æˆ·å¼€å§‹æœç´¢ï¼Œè‡ªåŠ¨å±•å¼€æ‰€æœ‰ä¸‹æ‹‰åˆ†ç»„ï¼Œæ–¹ä¾¿æŸ¥æ‰¾
            watch(dropdownSearch, (val) => {
                if (val && val.trim()) {
                    // æœç´¢æ—¶ä¸æ¸…ç©º Setï¼Œè€Œæ˜¯é€»è¾‘ä¸Šè§†ä¸ºå…¨å±•å¼€ (åœ¨ HTML v-show ä¸­å¤„ç†)
                } else {
                    // æœç´¢æ¸…ç©ºæ—¶ï¼Œæ¢å¤ä¹‹å‰çš„æŠ˜å çŠ¶æ€ï¼ˆæˆ–è€…ä½ å¯ä»¥é€‰æ‹©åœ¨è¿™é‡Œ dropdownExpandedGroups.clear() æ¥å…¨éƒ¨æŠ˜å ï¼‰
                    dropdownExpandedGroups.clear();
                }
            });

            // ğŸŸ¢ ä¿®æ”¹ toggleDropdown: æ¯æ¬¡æ‰“å¼€èœå•æ—¶ï¼Œé‡ç½®ä¸ºå…¨æŠ˜å çŠ¶æ€
            const toggleDropdown = (type) => {
                if (activeDropdown.value === type) {
                    activeDropdown.value = null;
                } else {
                    showMobileMenu.value = false;
                    showProfileMenu.value = false;
                    activeDropdown.value = type;
                    dropdownSearch.value = '';
                    activeGroupFilter.value = 'å…¨éƒ¨';

                    // é‡ç½®æŠ˜å çŠ¶æ€
                    dropdownExpandedGroups.clear();

                    setTimeout(() => {
                        const input = document.querySelector('.custom-dropdown-menu input[placeholder*="æœç´¢"]');
                        if (input) input.focus();
                    }, 50);
                }
            };

            // ğŸŸ¢ æ–°å¢: åˆ†ç»„ç­›é€‰çŠ¶æ€
            const activeGroupFilter = ref('å…¨éƒ¨');

            // ğŸŸ¢ ä¿®æ”¹: æ”¯æŒ edit_ å‰ç¼€
            const availableGroups = computed(() => {
                const type = activeDropdown.value;
                if (!type) return [];

                // åŒæ—¶å»é™¤ mobile_ å’Œ edit_ å‰ç¼€
                const realType = type.replace('mobile_', '').replace('edit_', '');

                let list = [];
                if (realType === 'project') list = settings.projects;
                else if (realType === 'instrument') list = settings.instruments;
                else if (realType === 'musician') list = settings.musicians;

                // ... (åç»­å»é‡æ’åºé€»è¾‘ä¿æŒä¸å˜)
                const groups = new Set(list.map(i => (i.group && i.group.trim()) ? i.group : 'æœªåˆ†ç»„'));
                const sorted = Array.from(groups).sort((a, b) => {
                    if (a === 'æœªåˆ†ç»„') return 1;
                    if (b === 'æœªåˆ†ç»„') return -1;
                    return a.localeCompare(b, 'zh-CN');
                });

                return ['å…¨éƒ¨', ...sorted];
            });

            // ğŸ”´ æ–°å¢: åˆ‡æ¢æ‰‹æœºèœå• (äº’æ–¥å…¶ä»–)
            const toggleMobileMenu = () => {
                const wasOpen = showMobileMenu.value;
                // å…ˆå…³é—­å…¶ä»–æ‰€æœ‰èœå•
                activeDropdown.value = null;
                showProfileMenu.value = false;
                // å†åˆ‡æ¢è‡ªå·±
                showMobileMenu.value = !wasOpen;
            };


            // ğŸŸ¢ ä¿®å¤: ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ä¸‹æ‹‰èœå•çš„â€œç‚¹å‡»å¤–éƒ¨å…³é—­â€é€»è¾‘
            const closeDropdowns = (e) => {
                // 1. ä¸»ç•Œé¢ä¸‹æ‹‰èœå• & ç”¨æˆ·èœå•
                const insideSelect = e.target.closest('.custom-select-container');
                const insideUser = e.target.closest('.user-menu-container');

                if (!insideSelect && !insideUser) {
                    activeDropdown.value = null;
                    showProfileMenu.value = false;
                    showMobileMenu.value = false;
                }

                // 2. Settings å¼¹çª—é‡Œçš„åˆ†ç»„ä¸‹æ‹‰
                // å¦‚æœç‚¹å‡»çš„ç›®æ ‡ä¸åœ¨ settings-group-wrapper å†…éƒ¨ï¼Œä¸”å½“å‰æ˜¯æ‰“å¼€çŠ¶æ€ï¼Œåˆ™å…³é—­
                const insideSettingsGroup = e.target.closest('.settings-group-wrapper');
                if (!insideSettingsGroup && settingsGroupFocus.value) {
                    settingsGroupFocus.value = null;
                }

                // âœ¨âœ¨âœ¨ æ–°å¢ï¼šSettings å¼¹çª—é‡Œçš„ã€åç§°ã€‘ä¸‹æ‹‰ âœ¨âœ¨âœ¨
                const insideSettingsName = e.target.closest('.settings-name-wrapper');
                if (!insideSettingsName && settingsNameFocus.value) {
                    settingsNameFocus.value = null;
                }

                // 3. Quick Add å¼¹çª—é‡Œçš„åˆ†ç»„ä¸‹æ‹‰
                // å¦‚æœç‚¹å‡»çš„ç›®æ ‡ä¸åœ¨ quick-add-group-wrapper å†…éƒ¨ï¼Œä¸”å½“å‰æ˜¯æ‰“å¼€çŠ¶æ€ï¼Œåˆ™å…³é—­
                const insideQuickAddGroup = e.target.closest('.quick-add-group-wrapper');
                if (!insideQuickAddGroup && showGroupSuggestions.value) {
                    showGroupSuggestions.value = false;
                }
                // ğŸŸ¢ [æ–°å¢] å…³é—­å½•éŸ³ä¿¡æ¯ä¸‹æ‹‰
                const insideRec = e.target.closest('.rec-dropdown-wrapper');
                if (!insideRec && activeRecDropdown.value) {
                    activeRecDropdown.value = null;
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: æ”¯æŒ edit_ å‰ç¼€
            const filteredOptions = computed(() => {
                const search = dropdownSearch.value.toLowerCase();
                const type = activeDropdown.value;
                if (!type) return [];

                // åŒæ—¶å»é™¤ mobile_ å’Œ edit_ å‰ç¼€
                const realType = type.replace('mobile_', '').replace('edit_', '');

                let list = [];
                if (realType === 'project') list = settings.projects;
                else if (realType === 'instrument') list = settings.instruments;
                else if (realType === 'musician') list = settings.musicians;

                // ... (åç»­æœç´¢ã€ç­›é€‰ã€æ’åºé€»è¾‘ä¿æŒä¸å˜)
                let result = list.filter(i => i.name.toLowerCase().includes(search));

                if (activeGroupFilter.value !== 'å…¨éƒ¨') {
                    result = result.filter(i => {
                        const g = (i.group && i.group.trim()) ? i.group : 'æœªåˆ†ç»„';
                        return g === activeGroupFilter.value;
                    });
                }

                // ğŸŸ¢ ä¿®å¤: å¯ç”¨è‡ªç„¶æ’åº
                result.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN', { numeric: true }));
                return result;
            });

            // ğŸŸ¢ æ–°å¢ helper: å°†å¹³é“ºçš„æ•°ç»„è½¬æ¢ä¸ºåˆ†ç»„å¯¹è±¡ {'åˆ†ç»„A': [item1], 'åˆ†ç»„B': [item2]}
            const getGroupedOptions = (list) => {
                const groups = {};
                const defaultKey = 'æœªåˆ†ç»„'; // é»˜è®¤åˆ†ç»„åç§°

                list.forEach(item => {
                    // å¦‚æœæ²¡æœ‰è®¾ç½® group å­—æ®µï¼Œå½’å…¥é»˜è®¤åˆ†ç»„
                    const g = item.group && item.group.trim() ? item.group : defaultKey;
                    if (!groups[g]) groups[g] = [];
                    groups[g].push(item);
                });

                // ç¨å¾®æ’ä¸ªåºï¼ŒæŠŠâ€œæœªåˆ†ç»„â€æ”¾åˆ°æœ€åï¼Œå…¶ä»–åˆ†ç»„æŒ‰åç§°æ’
                const sortedKeys = Object.keys(groups).sort((a, b) => {
                    if (a === defaultKey) return 1;
                    if (b === defaultKey) return -1;
                    return a.localeCompare(b, 'zh-CN');
                });

                // æ„é€ æœ‰åºçš„éå†æ•°ç»„
                return sortedKeys.map(key => ({
                    name: key,
                    items: groups[key]
                }));
            };

            // ğŸŸ¢ ä¿®æ”¹: æ”¯æŒç¼–è¾‘æ¨¡å¼èµ‹å€¼
            const selectOption = (type, item) => {
                // 1. åˆ¤æ–­å½“å‰ä¸Šä¸‹æ–‡ï¼šå¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ (activeDropdown ä»¥ edit_ å¼€å¤´)
                if (activeDropdown.value && activeDropdown.value.startsWith('edit_')) {
                    const realType = activeDropdown.value.replace('edit_', '');

                    if (realType === 'project') editingItem.value.projectId = item.id;
                    else if (realType === 'instrument') editingItem.value.instrumentId = item.id;
                    else if (realType === 'musician') editingItem.value.musicianId = item.id;

                    // é€‰ä¸­åå…³é—­
                    activeDropdown.value = null;
                    return;
                }

                // 2. åŸæœ‰çš„æ–°å»ºæ¨¡å¼é€»è¾‘ (ä¿æŒä¸å˜)
                if (type === 'project') newItem.projectId = item.id;
                if (type === 'instrument') newItem.instrumentId = item.id;
                if (type === 'musician') {
                    newItem.musicianId = item.id;
                    onMusicianSelect();
                }
                activeDropdown.value = null;
            };

            // åœ¨ onMounted é‡Œç»‘å®šç‚¹å‡»å¤–éƒ¨å…³é—­
            // onMounted(() => { ... window.addEventListener('click', closeDropdowns); ... })
            // åˆ«å¿˜äº†åœ¨ onUnmounted ç§»é™¤

            const SLOT_HEIGHT = 40;
            const PX_PER_MIN = 40 / 30;


            // V9.7.4: sortKey/activeColorKey å¯ä»¥æ˜¯ projectId
            // ä¿®æ”¹ï¼šé»˜è®¤åˆ†ç»„æ”¹ä¸º 'projectId' (é¡¹ç›®)
            const sortKey = ref('projectId');
            const activeColorKey = ref('projectId');
            // æ”¹ç”¨ expandedGroupsï¼šå­˜è°å±•å¼€äº†ï¼Œæ²¡å­˜çš„å°±æ˜¯æŠ˜å çš„ (é»˜è®¤å…¨ç©º=å…¨æŠ˜å )
            const expandedGroups = reactive(new Set());

            // --- V10.3 æ’åºçŠ¶æ€ç®¡ç† ---
            const sortField = ref('status'); // 'name' | 'duration'
            const sortAsc = ref(true);     // true=æ­£åº(A-Z, å°-å¤§), false=å€’åº(Z-A, å¤§-å°)

            // 1. æ–°å»ºé¡¹ç›®çš„ä¸´æ—¶çŠ¶æ€
            const newSettingsItem = reactive({
                instrument: {name: '', group: ''},
                musician: {name: '', group: ''},
                project: {name: '', group: ''}
            });

            // --- ğŸŸ¢ æ–°å¢: å½•éŸ³å…ƒæ•°æ®ç®¡ç†é€»è¾‘ (Settingsé¡µé¢ç”¨) ---
            const newRecInputs = reactive({
                studio: '',
                engineer: '',
                operator: '',
                assistant: ''
            });

            const addRecItem = (type) => {
                // ğŸŸ¢ 1. ä¼˜å…ˆè¯»å–è¾“å…¥æ¡†ä¸­å½“å‰å¡«å†™çš„æ–‡å­—
                let val = recInfoForm[type];

                // å¦‚æœè¾“å…¥æ¡†æ˜¯ç©ºçš„ï¼Œæ‰å¼¹çª—è¯¢é—® (ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ)
                if (!val || !val.trim()) {
                    val = prompt(`Enter new ${type} name:`);
                }

                if (val && val.trim()) {
                    const cleanVal = val.trim();
                    const listKey = type + 's'; // studios, engineers...

                    // ğŸŸ¢ 2. æ£€æŸ¥æ˜¯å¦é‡å¤
                    const exists = settings[listKey].some(item => item.name === cleanVal);

                    if (!exists) {
                        // ä¿å­˜åˆ°å…ƒæ•°æ®åˆ—è¡¨
                        settings[listKey].push({
                            id: Date.now(),
                            name: cleanVal
                        });
                        window.triggerTouchHaptic('Success');

                        // å¯é€‰ï¼šæ·»åŠ æˆåŠŸåç»™ä¸€ç‚¹è§†è§‰åé¦ˆï¼Œæˆ–è€…ä¿æŒä¸‹æ‹‰æ¡†å¼€å¯ä»¥ä¾¿ç¡®è®¤
                        // alert(`Saved "${cleanVal}" to library.`);
                    } else {
                        // å·²ç»åœ¨åº“é‡Œäº†ï¼Œä¸åšä»»ä½•äº‹ï¼Œæˆ–è€…æç¤ºå·²å­˜åœ¨
                    }
                }
            };

            const removeRecItem = (type, id) => {
                let list = null;
                if (type === 'studio') list = settings.studios;
                else if (type === 'engineer') list = settings.engineers;
                else if (type === 'operator') list = settings.operators;
                else if (type === 'assistant') list = settings.assistants;

                if (list) {
                    const idx = list.findIndex(i => i.id === id);
                    if (idx !== -1) {
                        list.splice(idx, 1);
                        pushHistory();
                        window.triggerTouchHaptic('Medium');
                    }
                }
            };

            // --- ğŸŸ¢ åˆ†ç»„é€‰æ‹©å™¨çŠ¶æ€ç®¡ç† ---
            const showGroupSuggestions = ref(false); // ç”¨äº Quick Add å¼¹çª—
            const settingsGroupFocus = ref(null);    // ç”¨äº Settings å¼¹çª—ï¼Œå­˜å‚¨å½“å‰èšç„¦çš„ç±»å‹ ('instrument'/'musician'/'project')

            // 2. è·å–åˆ†ç»„åçš„åˆ—è¡¨ (æ ¸å¿ƒé€»è¾‘) - ğŸŸ¢ ä¿®å¤: å¯ç”¨ numeric: true è‡ªç„¶æ’åº
            const getSettingsGroupedList = (type) => {
                let list = [];
                if (type === 'instrument') list = settings.instruments;
                else if (type === 'musician') list = settings.musicians;
                else if (type === 'project') list = settings.projects;

                const groups = {};
                const defaultKey = 'æœªåˆ†ç»„';

                list.forEach(item => {
                    const g = (item.group && item.group.trim()) ? item.group : defaultKey;
                    if (!groups[g]) groups[g] = [];
                    groups[g].push(item);
                });

                // æ’åºï¼šå…ˆæŒ‰åˆ†ç»„åæ’åºï¼ˆ"æœªåˆ†ç»„"æ”¾æœ€åï¼‰ï¼Œç»„å†…æŒ‰åç§°æ’åº
                // ğŸŸ¢ è¿™é‡ŒåŠ äº† { numeric: true }ï¼Œè§£å†³ C10 æ’åœ¨ C2 å‰é¢çš„é—®é¢˜
                return Object.keys(groups).sort((a, b) => {
                    if (a === defaultKey) return 1;
                    if (b === defaultKey) return -1;
                    // ä¿®å¤åˆ†ç»„åæ’åº (ä¾‹å¦‚ Group 2 vs Group 10)
                    return a.localeCompare(b, 'zh-CN', { numeric: true });
                }).map(key => ({
                    name: key === defaultKey ? '' : key,
                    // ğŸŸ¢ ä¿®å¤é¡¹ç›®åæ’åº (ä¾‹å¦‚ C2 vs C10)
                    items: groups[key].sort((a, b) => a.name.localeCompare(b.name, 'zh-CN', { numeric: true }))
                }));
            };

            // ğŸŸ¢ æ–°å¢ï¼šä½¿ç”¨ computed ç¼“å­˜åˆ†ç»„ç»“æœï¼Œé˜²æ­¢é¡µé¢é‡ç»˜å¯¼è‡´è¾“å…¥æ¡†è·³åŠ¨
            const allSettingsGrouped = computed(() => {
                return {
                    project: getSettingsGroupedList('project'),
                    instrument: getSettingsGroupedList('instrument'),
                    musician: getSettingsGroupedList('musician')
                };
            });

            // ğŸŸ¢ ä¿®å¤: å¥å£®çš„åˆ†ç»„è·å–å‡½æ•°
            const getExistingGroups = (type) => {
                // 1. å®‰å…¨è§£åŒ…: æ— è®ºä¼ å…¥çš„æ˜¯ Ref å¯¹è±¡è¿˜æ˜¯æ™®é€šå­—ç¬¦ä¸²ï¼Œéƒ½ç»Ÿä¸€è½¬ä¸ºå­—ç¬¦ä¸²
                let val = type;
                if (typeof type === 'object' && type !== null && 'value' in type) {
                    val = type.value;
                }

                // å¦‚æœå€¼ä¸ºç©ºï¼Œç›´æ¥è¿”å›
                if (!val) return [];

                // 2. ç§»é™¤å¯èƒ½å­˜åœ¨çš„å‰ç¼€
                // å¼ºåˆ¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²å† replaceï¼Œé˜²æ­¢ val æ˜¯éå­—ç¬¦ä¸²ç±»å‹å¯¼è‡´çš„æŠ¥é”™
                const realType = String(val).replace('mobile_', '');

                // 3. åŒ¹é…æ•°æ®æº
                let list = [];
                if (realType === 'instrument') list = settings.instruments;
                else if (realType === 'musician') list = settings.musicians;
                else if (realType === 'project') list = settings.projects;

                // å¦‚æœæ‰¾ä¸åˆ°å¯¹åº”åˆ—è¡¨ï¼Œè¿”å›ç©º
                if (!list || !Array.isArray(list)) return [];

                // 4. æå–åˆ†ç»„å¹¶å»é‡
                const groups = new Set();
                list.forEach(item => {
                    // ç¡®ä¿ group å­—æ®µå­˜åœ¨ï¼Œä¸”ä¸æ˜¯çº¯ç©ºæ ¼
                    if (item.group && typeof item.group === 'string' && item.group.trim() !== '') {
                        groups.add(item.group.trim());
                    }
                });

                // 5. æ’åºè¿”å› (æŒ‰æ‹¼éŸ³æ’åº)
                return Array.from(groups).sort((a, b) => a.localeCompare(b, 'zh-CN'));
            };


            // 4. é‡å‘½ååˆ†ç»„
            const renameGroup = (type, oldName, newName) => {
                const finalNewName = newName.trim();
                if (oldName === finalNewName) return; // æ²¡å˜

                let list = [];
                if (type === 'instrument') list = settings.instruments;
                else if (type === 'musician') list = settings.musicians;
                else if (type === 'project') list = settings.projects;

                // æ‰¹é‡æ›´æ–°æ‰€æœ‰å±äºè¯¥ç»„çš„é¡¹ç›®
                // å¦‚æœ oldName ä¸ºç©ºï¼Œè¡¨ç¤ºå°†"æœªåˆ†ç»„"çš„é¡¹ç›®å½’å…¥æ–°ç»„
                // å¦‚æœ newName ä¸ºç©ºï¼Œè¡¨ç¤ºå°†è¯¥ç»„é¡¹ç›®å˜ä¸º"æœªåˆ†ç»„"
                list.forEach(item => {
                    const g = (item.group || '').trim();
                    if (g === (oldName || '').trim()) {
                        item.group = finalNewName;
                    }
                });
                pushHistory();
            };

            // ğŸŸ¢ ä¿®æ”¹ï¼šaddSettingsItem (æ”¯æŒâ€œç§»åŠ¨åˆ†ç»„â€é€»è¾‘)
            const addSettingsItem = (type) => {
                const form = newSettingsItem[type];
                const nameStr = form.name.trim();
                const groupStr = form.group.trim();

                if (!nameStr && !groupStr) {
                    return openAlertModal('æ— æ³•æ·»åŠ ', 'è¯·è‡³å°‘è¾“å…¥ åç§° æˆ– åˆ†ç»„ã€‚');
                }

                let list = [];
                if (type === 'instrument') list = settings.instruments;
                else if (type === 'musician') list = settings.musicians;
                else if (type === 'project') list = settings.projects;

                // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒåé¡¹ç›®
                if (nameStr) {
                    const existingItem = list.find(i => i.name.toLowerCase() === nameStr.toLowerCase());

                    if (existingItem) {
                        // âœ¨ åœºæ™¯ A: é¡¹ç›®å·²å­˜åœ¨ -> æ‰§è¡Œâ€œç§»åŠ¨åˆ†ç»„â€æ“ä½œ
                        if (existingItem.group !== groupStr) {
                            existingItem.group = groupStr;

                            // å¦‚æœæœ‰æ–°åˆ†ç»„ï¼Œè‡ªåŠ¨å±•å¼€å®ƒ
                            if (groupStr) settingsExpandedGroups.add(type + '|' + groupStr);

                            pushHistory();
                            window.triggerTouchHaptic('Success');

                            // é‡ç½®è¾“å…¥æ¡†ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡æ“ä½œ
                            form.name = '';
                            return; // ç»“æŸå‡½æ•°ï¼Œä¸åˆ›å»ºæ–° ID
                        } else {
                            // å¦‚æœåˆ†ç»„ä¹Ÿä¸€æ ·ï¼Œé‚£å°±æ˜¯çº¯é‡å¤ï¼ŒæŠ¥é”™
                            window.triggerTouchHaptic('Error');
                            return openAlertModal('é‡å¤æ·»åŠ ', 'è¯¥é¡¹ç›®å·²å­˜åœ¨äºå½“å‰åˆ†ç»„ä¸­ã€‚');
                        }
                    }
                }

                // âœ¨ åœºæ™¯ B: é¡¹ç›®ä¸å­˜åœ¨ -> æ‰§è¡Œâ€œæ–°å»ºâ€æ“ä½œ (åŸæœ‰é€»è¾‘)
                const idPrefix = type === 'project' ? 'P' : (type === 'instrument' ? 'I' : 'M');
                const newItem = {
                    id: generateUniqueId(idPrefix),
                    name: nameStr,
                    group: groupStr,
                    color: generateRandomHexColor()
                };
                if (type === 'musician') newItem.defaultRatio = 20;

                list.push(newItem);

                if (groupStr) {
                    settingsExpandedGroups.add(type + '|' + groupStr);
                }

                form.name = '';
                pushHistory();
                window.triggerTouchHaptic('Success');
            };

            watch(viewDate, () => {
                // é‡ç½®ä¸ºé»˜è®¤èŒƒå›´ï¼Œä»¥æ–°æ—¥æœŸä¸ºä¸­å¿ƒ
                renderedRange.past = 6;
                renderedRange.future = 18;

                // å¦‚æœåœ¨æœˆè§†å›¾ï¼Œéœ€è¦ç¨å¾®å»¶è¿Ÿå®šä½ä¸€ä¸‹ (å¤ç”¨ä¹‹å‰çš„ scrollToMonthDate)
                if (currentView.value === 'month' && monthViewMode.value === 'scrolled') {
                    scrollToMonthDate(viewDate.value);
                }
            });

            // 6. åˆ é™¤é¡¹ç›®
            const removeSettingsItem = (type, id) => {
                // ä½¿ç”¨ä¹‹å‰å®šä¹‰çš„ç‰¹å®šåˆ é™¤å‡½æ•°ä»¥ä¿ç•™ç¡®è®¤å¼¹çª—é€»è¾‘
                if (type === 'instrument') removeInstrument(id);
                else if (type === 'musician') removeMusician(id);
                else if (type === 'project') deleteProject(id);
            };

            const clearSettingsList = (type) => {
                if (type === 'instrument') clearAllInstruments();
                else if (type === 'musician') clearAllMusicians();
                else if (type === 'project') clearAllProjects();
            }

            // --- æ‹–æ‹½é‡åˆ†ç»„é€»è¾‘ ---
            let settingsDragItem = null;

            // ğŸŸ¢ ä¿®æ”¹: æ‹–æ‹½å¼€å§‹ (ä»…æ”¹å˜è§†è§‰é€æ˜åº¦ï¼Œä¸å½±å“æ•°æ®)
            const onSettingsItemDragStart = (item, type, e) => {
                // âœ¨ æ ¸å¿ƒä¿®å¤: å¦‚æœç”¨æˆ·ç‚¹å‡»çš„æ˜¯ è¾“å…¥æ¡† OR æŒ‰é’®ï¼Œé˜»æ­¢æ‹–æ‹½ï¼Œç¡®ä¿ Click äº‹ä»¶èƒ½æ­£å¸¸è§¦å‘
                // ä½¿ç”¨ .closest() ç¡®ä¿å³ä½¿ç‚¹åˆ°æŒ‰é’®é‡Œçš„å›¾æ ‡ä¹Ÿèƒ½è¢«è¯†åˆ«
                if (e.target.closest('input, button, select, i')) {
                    e.preventDefault();
                    return;
                }

                settingsDragItem = {item, type};
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', JSON.stringify(item));

                // è®©æ•´è¡Œå˜åŠé€æ˜
                // å› ä¸ºç°åœ¨ draggable åŠ åœ¨è¡Œä¸Šï¼Œe.target å°±æ˜¯è¡Œæœ¬èº«ï¼Œæˆ–è€…ç”¨ currentTarget æ›´ç¨³
                if (e.currentTarget) {
                    e.currentTarget.style.opacity = '0.4';
                }
            };

            // ğŸŸ¢ æ–°å¢: æ‹–æ‹½ç»“æŸ (æ— è®ºæˆåŠŸä¸å¦ï¼Œéƒ½å¼ºåˆ¶æ¢å¤æ ·å¼)
            const onSettingsItemDragEnd = (e) => {
                // 1. æ¢å¤æ•´è¡Œé€æ˜åº¦
                const rowEl = e.target.closest('.group\\/item');
                if (rowEl) {
                    rowEl.style.opacity = '1';
                }

                // 2. æ¸…ç†å…¨å±€é«˜äº®æ ·å¼
                document.querySelectorAll('.settings-group-container').forEach(el => {
                    el.classList.remove('drag-over');
                });

                // 3. æ¸…ç©ºä¸´æ—¶å˜é‡
                settingsDragItem = null;
            };

            const onSettingsDragOver = (e) => {
                if (settingsDragItem) {
                    e.preventDefault(); // å…è®¸æ”¾ç½®
                    e.currentTarget.classList.add('drag-over');
                }
            };

            const onSettingsDragLeave = (e) => {
                e.currentTarget.classList.remove('drag-over');
            };

            const onSettingsDrop = (targetType, targetGroupName, e) => {
                e.currentTarget.classList.remove('drag-over');
                // æ¢å¤æ ·å¼
                const draggables = document.querySelectorAll('[draggable=true]');
                draggables.forEach(el => el.style.opacity = '1');

                if (!settingsDragItem) return;

                // åªèƒ½åœ¨åŒç±»å‹ä¹‹é—´æ‹–æ‹½
                if (settingsDragItem.type !== targetType) return;

                // å¦‚æœæ‹–åˆ°äº†è‡ªå·±æ‰€åœ¨çš„åˆ†ç»„ï¼Œä¸åšå¤„ç†
                const currentGroup = settingsDragItem.item.group || '';
                const targetGroup = targetGroupName || ''; // ç©ºå­—ç¬¦ä¸²ä»£è¡¨æœªåˆ†ç»„

                if (currentGroup === targetGroup) {
                    settingsDragItem = null;
                    return;
                }

                // æ‰§è¡Œç§»åŠ¨ï¼šæ›´æ–° group å±æ€§
                settingsDragItem.item.group = targetGroup;

                pushHistory();
                settingsDragItem = null;
                window.triggerTouchHaptic('Light');
            };


            // é€šç”¨åˆ‡æ¢æ’åºå‡½æ•°
            const toggleSort = (field) => {
                if (sortField.value === field) {
                    // å¦‚æœç‚¹çš„è¿˜æ˜¯å½“å‰å­—æ®µï¼Œå°±åè½¬é¡ºåº
                    sortAsc.value = !sortAsc.value;
                } else {
                    // å¦‚æœç‚¹äº†æ–°å­—æ®µï¼Œåˆ‡æ¢å­—æ®µ
                    sortField.value = field;
                    // è®¾ç½®é»˜è®¤é¡ºåºï¼šåç§°é»˜è®¤æ­£åº(A-Z)ï¼Œæ—¶é•¿é»˜è®¤å€’åº(ä»é•¿åˆ°çŸ­ï¼Œæ–¹ä¾¿çœ‹å·¥ä½œé‡)
                    sortAsc.value = (field === 'name');
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: getSortIcon (å¢åŠ  Status å›¾æ ‡æ”¯æŒ)
            const getSortIcon = (field) => {
                if (sortField.value !== field) return '';
                if (field === 'name') return sortAsc.value ? 'fa-arrow-down-a-z' : 'fa-arrow-up-a-z';
                if (field === 'duration') return sortAsc.value ? 'fa-arrow-up-short-wide' : 'fa-arrow-down-wide-short';
                // status: æ­£åº(å®Œæˆ->æœªæ’)ç”¨ list-check å›¾æ ‡ï¼Œå€’åºç”¨åå‘
                if (field === 'status') return sortAsc.value ? 'fa-arrow-down-short-wide' : 'fa-arrow-up-wide-short';
                return '';
            };

            const parseTime = s => {
                if (!s) return 0;
                // å»æ‰ç©ºæ ¼ï¼ŒæŒ‰å†’å·åˆ†å‰²
                const p = s.toString().trim().split(':').map(Number);
                if (p.some(isNaN)) return 0; // é˜²æ­¢éæ•°å­—æŠ¥é”™

                if (p.length === 2) return p[0] * 60 + p[1]; // MM:SS
                if (p.length === 3) return p[0] * 3600 + p[1] * 60 + p[2]; // HH:MM:SS
                return p[0] || 0;
            };
            const formatSecs = s => {
                const rounded = Math.round(s); // 1. å…ˆå¯¹æ€»ç§’æ•°å››èˆäº”å…¥

                const h = Math.floor(rounded / 3600);
                const m = Math.floor((rounded % 3600) / 60);
                const sec = rounded % 60; // 2. ä½™æ•°å³ä¸ºç§’æ•°

                return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
            };
            const calculateEstTime = (d, r) => formatSecs(parseTime(d) * (r || 1));
            const timeToMinutes = timeStr => {
                const [h, m] = timeStr.split(':').map(Number);
                return h * 60 + m;
            };

            // --- History & Persistence ---
            // --- History & Persistence ---
            const history = ref([]);
            const historyIndex = ref(-1);

            const user = ref(null);
            const showAuthModal = ref(false);
            const authLoading = ref(false);
            const authForm = reactive({email: '', password: ''});
            const authPasswordRef = ref(null);
            let syncTimeout = null; // ç”¨äºé˜²æŠ–ä¿å­˜

            // ğŸŸ¢ æ–°å¢: åŠ¨æ€è®¡ç®—æŒ‰æ¯”ä¾‹åˆ†é…çš„æ—¶é—´é…é¢
            // é€»è¾‘: (å•æ›²è°±é¢æ—¶é•¿ / åˆ—è¡¨æ‰€æœ‰æ›²ç›®è°±é¢æ€»é•¿) * æ—¥ç¨‹å—æ€»æ—¶é•¿
            const calculateProportionalDuration = (item) => {
                // å®‰å…¨æ£€æŸ¥: å¦‚æœæ²¡æœ‰æ—¥ç¨‹å—å¼•ç”¨æˆ–åˆ—è¡¨ä¸ºç©ºï¼Œå›é€€åˆ°é»˜è®¤æ˜¾ç¤º
                if (!trackListData.value.taskRef || !trackListData.value.items || trackListData.value.items.length === 0) {
                    return item.estDuration;
                }

                // 1. è·å–æ—¥ç¨‹å—çš„æ€»æ—¶é•¿ (ä¾‹å¦‚ "10:43 - 11:05" ä¹‹é—´çš„æ—¶é•¿ï¼Œæˆ–è€…æ˜¯ taskRef.estDuration)
                // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨æ—¥ç¨‹å—çš„ estDuration (å³å·²å®‰æ’æ—¶é•¿)
                const blockSeconds = parseTime(trackListData.value.taskRef.estDuration);

                // 2. è®¡ç®—å½“å‰åˆ—è¡¨ä¸­æ‰€æœ‰æ›²ç›®çš„è°±é¢æ€»é•¿
                let totalMusicSeconds = 0;
                trackListData.value.items.forEach(i => {
                    totalMusicSeconds += parseTime(i.musicDuration || '00:00');
                });

                // é˜²æ­¢é™¤ä»¥é›¶
                if (totalMusicSeconds === 0) return item.estDuration;

                // 3. è®¡ç®—å½“å‰æ›²ç›®çš„æƒé‡å¹¶åˆ†é…æ—¶é—´
                const itemMusicSeconds = parseTime(item.musicDuration || '00:00');
                const allocatedSeconds = (itemMusicSeconds / totalMusicSeconds) * blockSeconds;

                return formatSecs(Math.round(allocatedSeconds));
            };

            // ğŸŸ¢ [ä¿®å¤ç‰ˆ] è·å–é»˜è®¤å€ç‡
            // ä¿®å¤äº†è¯»å– undefined æŠ¥é”™çš„é—®é¢˜
            // ç§»é™¤äº†å¯¹ stats çš„å¾ªç¯å¼•ç”¨ï¼Œé˜²æ­¢æ­»é”
            const getDefaultRatio = (id, type = 'musician') => {
                let list = [];

                // 1. å®‰å…¨åœ°è·å–åˆ—è¡¨
                if (type === 'project') list = settings.projects;
                else if (type === 'instrument') list = settings.instruments;
                else list = settings.musicians;

                // ğŸ›¡ï¸ é˜²å¾¡ä»£ç ï¼šå¦‚æœåˆ—è¡¨å°šæœªåˆå§‹åŒ–æˆ–ä¸ºç©ºï¼Œç›´æ¥è¿”å›é»˜è®¤å€¼
                if (!list || !Array.isArray(list)) return 20;

                // 2. æŸ¥æ‰¾è®¾ç½®
                const item = list.find(i => i.id === id);

                // 3. ä»…è¯»å–è®¾ç½®é‡Œçš„é»˜è®¤å€¼ (æ–­å¼€å¾ªç¯ä¾èµ–)
                if (item && item.defaultRatio && item.defaultRatio > 0) {
                    return item.defaultRatio;
                }

                return 20;
            };

            const pushHistory = () => {
                if (historyIndex.value < history.value.length - 1) history.value = history.value.slice(0, historyIndex.value + 1);

                // ğŸŸ¢ ä¿®å¤: å°† settings ä¹ŸåŠ å…¥åˆ°å†å²è®°å½•å¿«ç…§ä¸­
                history.value.push(JSON.stringify({
                    pool: itemPool.value,
                    tasks: scheduledTasks.value,
                    settings: settings // å…³é”®ä¿®æ”¹ï¼šä¿å­˜è®¾ç½®çŠ¶æ€
                }));

                historyIndex.value++;
                if (history.value.length > 50) {
                    history.value.shift();
                    historyIndex.value--;
                }
            };

            // ğŸŸ¢ ä¿®å¤: Undo æ’¤é”€å‡½æ•° (åŠ å…¥ sectionIndex æ’åºæ”¯æŒ)
            const undo = () => {
                if (historyIndex.value > 0) {
                    historyIndex.value--;
                    const s = JSON.parse(history.value[historyIndex.value]);
                    itemPool.value = s.pool;
                    scheduledTasks.value = s.tasks;

                    if (s.settings) {
                        Object.assign(settings, s.settings);
                    }

                    // --- ğŸŸ¢ TrackList è§†å›¾å®æ—¶åˆ·æ–° ---
                    if (showTrackList.value && trackListData.value.taskRef) {
                        // è·å–å½“å‰è§†å›¾ç±»å‹ (ç¡®ä¿èƒ½è¯»åˆ°æ­£ç¡®çš„æ—¶é—´è®°å½•)
                        const viewType = trackListData.value.viewType || 'musician';

                        // 1. æ ¹æ®å½“å‰ä¸Šä¸‹æ–‡ç­›é€‰ä»»åŠ¡
                        let list = [];
                        // å¦‚æœæ˜¯æŒ‰é¡¹ç›®æŸ¥çœ‹ï¼Œå°±ç­›é€‰åŒé¡¹ç›®çš„ä»»åŠ¡
                        if (viewType === 'project') {
                            list = itemPool.value.filter(i => i.projectId === trackListData.value.taskRef.projectId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        }
                        // å¦‚æœæ˜¯æŒ‰ä¹å™¨æŸ¥çœ‹
                        else if (viewType === 'instrument') {
                            list = itemPool.value.filter(i => i.instrumentId === trackListData.value.taskRef.instrumentId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        }
                        // é»˜è®¤æŒ‰æ¼”å¥å‘˜æŸ¥çœ‹
                        else {
                            list = itemPool.value.filter(i => i.musicianId === trackListData.value.taskRef.musicianId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        }

                        // 2. ğŸŸ¢ å…³é”®ä¿®å¤: ä½¿ç”¨å®Œæ•´çš„æ’åºé€»è¾‘ (å…ˆåˆ†æ®µï¼Œåæ—¶é—´)
                        list.sort((a, b) => {
                            // ç¬¬ä¸€ä¼˜å…ˆçº§: åˆ†æ®µç´¢å¼• (Section)
                            const secA = a.sectionIndex || 0;
                            const secB = b.sectionIndex || 0;
                            if (secA !== secB) return secA - secB;

                            // ç¬¬äºŒä¼˜å…ˆçº§: æ—¶é—´ (Time)
                            const recA = a.records?.[viewType];
                            const recB = b.records?.[viewType];
                            const tA = recA?.recStart || '99:99';
                            const tB = recB?.recStart || '99:99';
                            return tA.localeCompare(tB);
                        });

                        // 3. èµ‹å€¼æ›´æ–° UI
                        trackListData.value.items = list;
                    }
                }
            };

// ğŸŸ¢ ä¿®å¤: Redo é‡åšå‡½æ•° (åŠ å…¥ sectionIndex æ’åºæ”¯æŒ)
            const redo = () => {
                if (historyIndex.value < history.value.length - 1) {
                    historyIndex.value++;
                    const s = JSON.parse(history.value[historyIndex.value]);
                    itemPool.value = s.pool;
                    scheduledTasks.value = s.tasks;

                    if (s.settings) {
                        Object.assign(settings, s.settings);
                    }

                    // --- ğŸŸ¢ TrackList è§†å›¾å®æ—¶åˆ·æ–° ---
                    if (showTrackList.value && trackListData.value.taskRef) {
                        const viewType = trackListData.value.viewType || 'musician';

                        let list = [];
                        if (viewType === 'project') {
                            list = itemPool.value.filter(i => i.projectId === trackListData.value.taskRef.projectId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        } else if (viewType === 'instrument') {
                            list = itemPool.value.filter(i => i.instrumentId === trackListData.value.taskRef.instrumentId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        } else {
                            list = itemPool.value.filter(i => i.musicianId === trackListData.value.taskRef.musicianId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        }

                        // ğŸŸ¢ å…³é”®ä¿®å¤: åŒæ ·çš„æ’åºé€»è¾‘
                        list.sort((a, b) => {
                            const secA = a.sectionIndex || 0;
                            const secB = b.sectionIndex || 0;
                            if (secA !== secB) return secA - secB;

                            const recA = a.records?.[viewType];
                            const recB = b.records?.[viewType];
                            const tA = recA?.recStart || '99:99';
                            const tB = recB?.recStart || '99:99';
                            return tA.localeCompare(tB);
                        });

                        trackListData.value.items = list;
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹åçš„ exportToICS
            const exportToICS = () => {
                if (scheduledTasks.value.length === 0) {
                    openAlertModal("æ—¥ç¨‹è¡¨æ˜¯ç©ºçš„");
                    return;
                }

                openInputModal('å¯¼å‡ºæ—¥å† (ICS)', 'recording_schedule.ics', 'è¯·è¾“å…¥æ–‡ä»¶å', (inputName) => {
                    if (!inputName) return;

                    let fileName = inputName;
                    if (!fileName.toLowerCase().endsWith('.ics')) fileName += '.ics';

                    let ics = "BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//AudioScheduler//CN\n";
                    scheduledTasks.value.forEach(t => {
                        // ... (ä¸­é—´çš„ç”Ÿæˆé€»è¾‘ä¿æŒä¸å˜ï¼Œå®Œå…¨ä¸éœ€è¦æ”¹åŠ¨) ...
                        const dStr = t.date.replace(/-/g, '');
                        const [sh, sm] = t.startTime.split(':').map(Number);
                        const startStr = `${String(sh).padStart(2, '0')}${String(sm).padStart(2, '0')}00`;
                        const durSec = parseTime(t.estDuration);
                        const endD = new Date(new Date(t.date + 'T' + t.startTime).getTime() + durSec * 1000);
                        const endStr = `${endD.getFullYear()}${String(endD.getMonth() + 1).padStart(2, '0')}${String(endD.getDate()).padStart(2, '0')}T${String(endD.getHours()).padStart(2, '0')}${String(endD.getMinutes()).padStart(2, '0')}00`;

                        const musicianName = getNameById(t.musicianId, 'musician');
                        const instrumentName = getNameById(t.instrumentId, 'instrument');
                        const projectName = getNameById(t.projectId, 'project');

                        ics += `BEGIN:VEVENT\nUID:${t.scheduleId}\nDTSTAMP:${dStr}T${startStr}\nDTSTART:${dStr}T${startStr}\nDTEND:${endStr}\nSUMMARY:${musicianName} - ${instrumentName} (${projectName})\nDESCRIPTION:å½•åˆ¶æ—¶é•¿:${t.estDuration}\nEND:VEVENT\n`;
                    });
                    ics += "END:VCALENDAR";

                    const blob = new Blob([ics], {type: 'text/calendar'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName; // ä½¿ç”¨è¾“å…¥çš„æ–‡ä»¶å
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                });
            };

            // ğŸŸ¢ ä¿®æ”¹åçš„ exportJSON
            const exportJSON = () => {
                // è‡ªåŠ¨ç”Ÿæˆé»˜è®¤æ–‡ä»¶å
                const now = new Date();
                const dateStr = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
                const defaultName = `backup_${dateStr}.json`;

                openInputModal('å¤‡ä»½æ•°æ® (JSON)', defaultName, 'è¯·è¾“å…¥æ–‡ä»¶å', (inputName) => {
                    if (!inputName) return;

                    // è‡ªåŠ¨è¡¥å…¨åç¼€
                    let fileName = inputName;
                    if (!fileName.toLowerCase().endsWith('.json')) fileName += '.json';

                    const data = {
                        pool: itemPool.value,
                        tasks: scheduledTasks.value,
                        settings: settings
                    };
                    const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 'æ–‡ä»¶å°†ä¿å­˜åˆ°æ‚¨çš„ä¸‹è½½æ–‡ä»¶å¤¹');
            };

            // --- ğŸŸ¢ å¯¼å…¥å¼¹çª—çŠ¶æ€ ---
            const showImportModal = ref(false);

            // 1. ç‚¹å‡»èœå•ä¸­çš„â€œæ¢å¤æ•°æ®â€æ—¶ï¼Œåªæ‰“å¼€æ¼‚äº®çš„å¼¹çª—
            const importJSON = () => {
                showImportModal.value = true;
            };

            // 2. ç‚¹å‡»å¼¹çª—ä¸­é—´çš„å¤§åŒºåŸŸæ—¶ï¼Œè§¦å‘éšè—çš„ input
            const triggerFileSelect = () => {
                const input = document.getElementById("json-upload");
                if (input) {
                    input.value = ''; // æ¸…ç©ºä¸Šæ¬¡è®°å½•ï¼Œç¡®ä¿é‡å¤é€‰æ–‡ä»¶æœ‰æ•ˆ
                    input.click();
                }
            };

            // ğŸŸ¢ ä¿®æ”¹åçš„ handleJSONFile
            const handleJSONFile = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);

                        // ç®€å•æ ¡éªŒ
                        if (!data.pool && !data.tasks && !data.settings) {
                            throw new Error("æ— æ•ˆçš„å¤‡ä»½æ–‡ä»¶");
                        }

                        pushHistory();
                        itemPool.value = data.pool || [];
                        scheduledTasks.value = data.tasks || [];
                        if (data.settings) Object.assign(settings, data.settings);
                        pushHistory();

                        // âœ… æˆåŠŸåå…³é—­å¯¼å…¥å¼¹çª—
                        showImportModal.value = false;

                        // ä½¿ç”¨æˆ‘ä»¬åˆšæ‰åšçš„æ¼‚äº® Alert æç¤ºæˆåŠŸ
                        openAlertModal('å¯¼å…¥æˆåŠŸ', 'æ•°æ®å·²æˆåŠŸæ¢å¤ï¼');

                    } catch (err) {
                        console.error(err);
                        openAlertModal('å¯¼å…¥å¤±è´¥', 'æ–‡ä»¶æ ¼å¼é”™è¯¯æˆ–å·²æŸåã€‚');
                    }
                };
                reader.readAsText(file, "UTF-8");
                e.target.value = "";
            };


            onMounted(async () => {
                // 1. åŸºç¡€åˆå§‹åŒ– (å¸ƒå±€ã€ä¸»é¢˜ã€ç›‘å¬)
                refreshLayout();
                applyTheme();

                // ğŸŸ¢ [æ–°å¢] å¦‚æœé»˜è®¤æ˜¯æ»šåŠ¨æœˆè§†å›¾ï¼Œåˆå§‹åŒ–æ—¶è‡ªåŠ¨æ»šåŠ¨åˆ°ä»Šå¤©
                if (currentView.value === 'month' && monthViewMode.value === 'scrolled') {
                    nextTick(() => {
                        scrollToMonthDate(viewDate.value);
                    });
                }

                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                    if (themeMode.value === 'auto') applyTheme();
                });
                window.addEventListener('resize', refreshLayout);
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        refreshLayout();
                        setTimeout(refreshLayout, 200);
                    }
                });
                window.addEventListener('pageshow', (e) => {
                    if (e.persisted) refreshLayout();
                });
                // ç»‘å®šå…¨å±€äº‹ä»¶
                const appElement = document.getElementById('app');
                if (appElement) {
                    appElement.addEventListener('click', (event) => {
                        const target = event.target.closest('button, a, [role="button"], .cursor-pointer, .segment-btn');
                        if (target && !['INPUT', 'TEXTAREA'].includes(target.tagName) && !target.hasAttribute('disabled')) {
                            window.triggerTouchHaptic('Medium');
                        }
                    });
                }
                window.addEventListener('keydown', handleGlobalKey);
                window.addEventListener('mousemove', handleResizeMove);
                window.addEventListener('mouseup', handleResizeEnd);
                window.addEventListener('click', closeDropdowns);

                // 2. ç§»é™¤åŠ è½½åŠ¨ç”»
                const loader = document.getElementById('global-loader');
                if (loader) {
                    setTimeout(() => loader.classList.add('hidden'), 300);
                }

                // ---------------------------------------------------------
                // ğŸŸ¢ æ ¸å¿ƒæ•°æ®åŠ è½½é€»è¾‘å¼€å§‹
                // ---------------------------------------------------------

                // æ£€æŸ¥äº‘ç«¯ Session
                const { data } = await supabaseClient.auth.getSession();
                // ğŸŸ¢ å®šä¹‰åˆå§‹åŒ–å‡½æ•° (ç”¨äºå‡ºå‚è®¾ç½®æˆ–ç¬¬ä¸€æ¬¡æ‰“å¼€)
                const initDefaultData = () => {
                    console.log("æ‰§è¡Œåˆå§‹åŒ–ï¼šç”Ÿæˆæ¼”ç¤ºæ•°æ® (Musician A / Project A)...");

                    // 1. å»ºç«‹åŸºç¡€è®¾ç½® (IDå›ºå®šï¼Œæ–¹ä¾¿å…³è”)
                    const demoMusicianId = 'M_DEMO_A';
                    const demoProjectId = 'P_DEMO_A';
                    const demoInstrumentId = 'I_DEMO_A';

                    // è¦†ç›–/åˆå§‹åŒ– settings
                    settings.musicians = [{ id: demoMusicianId, name: 'Musician A', defaultRatio: 20, color: '#a855f7', group: '' }];
                    settings.projects = [{ id: demoProjectId, name: 'Project A', color: '#eab308', group: '' }];
                    settings.instruments = [{ id: demoInstrumentId, name: 'Instrument A', color: '#3b82f6', group: '' }];

                    // ç¡®ä¿ Session å­˜åœ¨
                    if(settings.sessions.length === 0) {
                        settings.sessions = [{id: 'S_DEFAULT', name: 'é»˜è®¤å½•éŸ³æ—¥ç¨‹'}];
                    }
                    currentSessionId.value = settings.sessions[0].id;

                    // 2. å»ºç«‹ä»»åŠ¡æ±  Task-Card
                    const demoTaskId = 'T_DEMO_001';
                    itemPool.value = [{
                        id: demoTaskId,
                        name: 'æ¼”ç¤ºæ›²ç›®', // è¿™é‡Œçš„ name ä¸é‡è¦ï¼Œæ˜¾ç¤ºçš„æ˜¯å…³è”å¯¹è±¡çš„ name
                        sessionId: 'S_DEFAULT',
                        musicianId: demoMusicianId,
                        projectId: demoProjectId,
                        instrumentId: demoInstrumentId,
                        musicDuration: '03:00', // è°±é¢ 3 åˆ†é’Ÿ
                        estDuration: '01:00:00', // é¢„è®¡ 1 å°æ—¶
                        ratio: 20,
                        trackCount: 1,
                        // ğŸŸ¢ å…³é”®: åˆå§‹åŒ–è®°å½•ç»“æ„ï¼Œé˜²æ­¢æŠ¥é”™
                        records: { musician: {}, project: {}, instrument: {} }
                    }];

                    // 3. åœ¨â€œä»Šå¤©â€å»ºç«‹æ—¥ç¨‹
                    const todayStr = formatDate(new Date());
                    scheduledTasks.value = [{
                        scheduleId: Date.now(),
                        templateId: demoTaskId,
                        sessionId: 'S_DEFAULT',
                        musicianId: demoMusicianId,
                        projectId: demoProjectId,
                        instrumentId: demoInstrumentId,
                        date: todayStr,
                        startTime: '10:00',
                        estDuration: '01:00:00',
                        trackCount: 1,
                        ratio: 20,
                        musicDuration: '03:00',
                        reminderMinutes: 15,
                        sound: 'default'
                    }];

                    // 4. å¼ºåˆ¶æ‰“å¼€ä¾§è¾¹æ  (é»˜è®¤çŠ¶æ€)
                    isSidebarOpen.value = true;
                    // å¹¶ä¿å­˜è¿™ä¸ªçŠ¶æ€ï¼Œä»¥å…ä¸‹æ¬¡åˆ·æ–°åˆå…³äº†
                    localStorage.setItem('musche_sidebar_open', 'true');

                    // 5. å±•å¼€ä¾§è¾¹æ é‡Œçš„ç¬¬ä¸€é¡¹ (Musician A)ï¼Œç¡®ä¿ Guide èƒ½å®šä½åˆ°å®ƒ
                    setTimeout(() => {
                        if (musicianStats.value.length > 0) {
                            expandedStatsIds.add(musicianStats.value[0].id);
                        }
                    }, 100); // ç¨ä½œå»¶è¿Ÿç­‰å¾… computed è®¡ç®—
                };

                if (data.session) {
                    // [æƒ…å†µ A] å·²ç™»å½•ï¼šåŠ è½½äº‘ç«¯æ•°æ®
                    user.value = data.session.user;
                    await loadCloudData();

                    // ğŸš©ã€æ ¸å¿ƒä¿®å¤ç‚¹ã€‘ï¼šå¦‚æœå·²ç™»å½•ä½†æ•°æ®æ˜¯ç©ºçš„ï¼Œåˆ™å¼ºåˆ¶åˆå§‹åŒ–é»˜è®¤æ•°æ®
                    if (itemPool.value.length === 0 && scheduledTasks.value.length === 0) {
                        // è°ƒç”¨ä½ å·²å®ç°çš„åˆå§‹åŒ–å‡½æ•°æ¥åˆ›å»ºé»˜è®¤ä»»åŠ¡ã€æ—¥ç¨‹å’Œä¾§è¾¹æ çŠ¶æ€
                        initDefaultData();
                    }

                } else {
                    // [æƒ…å†µ B] æœªç™»å½•ï¼šæ£€æŸ¥æœ¬åœ°æ•°æ®
                    const localStr = localStorage.getItem('v9_data');
                    const d = localStr ? JSON.parse(localStr) : {};


                    // ğŸŸ¢ åˆ¤å®šé€»è¾‘ï¼šå¦‚æœæœ‰æ—§æ•°æ®ï¼ŒåŠ è½½æ—§æ•°æ®ï¼›å¦åˆ™åˆå§‹åŒ–
                    // åˆ¤æ–­ä¾æ®ï¼špool æ•°ç»„æ˜¯å¦æœ‰å†…å®¹
                    if (d.pool && d.pool.length > 0) {
                        // --- åŠ è½½æ—§æ•°æ® ---
                        if (d.settings) {
                            // æ¢å¤å„é¡¹è®¾ç½® (ä½¿ç”¨ Object.assign æˆ–æ‰‹åŠ¨èµ‹å€¼ä»¥ä¿æŒå“åº”æ€§)
                            settings.startHour = d.settings.startHour;
                            settings.endHour = d.settings.endHour;
                            if(d.settings.sessions) settings.sessions = d.settings.sessions;

                            // æ¢å¤åˆ—è¡¨ (å¸¦ group å­—æ®µ)
                            if(d.settings.instruments) settings.instruments = d.settings.instruments;
                            if(d.settings.musicians) settings.musicians = d.settings.musicians;
                            if(d.settings.projects) settings.projects = d.settings.projects;

                            // ğŸŸ¢ [ä¿®å¤] æ¢å¤å½•éŸ³ä¿¡æ¯å…ƒæ•°æ® (é˜²æ­¢åˆ·æ–°ä¸¢å¤±)
                            if(d.settings.studios) settings.studios = d.settings.studios;
                            if(d.settings.engineers) settings.engineers = d.settings.engineers;
                            if(d.settings.operators) settings.operators = d.settings.operators;
                            if(d.settings.assistants) settings.assistants = d.settings.assistants;

                            // æ¢å¤ Session ID
                            if (d.settings.lastSessionId) {
                                const exists = settings.sessions.find(s => s.id === d.settings.lastSessionId);
                                currentSessionId.value = exists ? exists.id : settings.sessions[0].id;
                            }
                        }

                        // æ¢å¤ä»»åŠ¡ (ç¡®ä¿æ•°æ®ç»“æ„å‡çº§)
                        itemPool.value = d.pool.map(item => ensureItemRecords(item));
                        scheduledTasks.value = d.tasks || [];

                        // ä¾§è¾¹æ çŠ¶æ€ï¼šè¯»å–ç”¨æˆ·ä¹‹å‰çš„åå¥½ (åœ¨ setup é¡¶éƒ¨å·²è¯»è¿‡ï¼Œè¿™é‡Œä¸éœ€è¦å¼ºåˆ¶è®¾ä¸º true)
                    } else {
                        // --- æ— æ•°æ® (é¦–æ¬¡æ‰“å¼€ æˆ– æ¢å¤å‡ºå‚è®¾ç½®å) ---
                        initDefaultData();
                    }
                }

                // 3. æ£€æŸ¥æ˜¯å¦éœ€è¦æ’­æ”¾æ–°æ‰‹å¼•å¯¼
                const hasSeenTour = localStorage.getItem('musche_tour_seen');
                if (!hasSeenTour) {
                    // ç¨å¾®å»¶è¿Ÿï¼Œç­‰é¡µé¢å®Œå…¨æ¸²æŸ“ã€ä¾§è¾¹æ å±•å¼€åå†æ’­æ”¾
                    setTimeout(() => {
                        startTour();
                        // æ³¨æ„ï¼šstartTour å‡½æ•°å†…éƒ¨åº”å½“åŒ…å« isSidebarOpen.value = true çš„é€»è¾‘
                    }, 1200);
                }

                // åˆå§‹åŒ–ä¸€æ¬¡å†å²è®°å½•
                pushHistory();
            });

            onUnmounted(() => {
                window.removeEventListener('keydown', handleGlobalKey);
                window.removeEventListener('mousemove', handleResizeMove);
                window.removeEventListener('mouseup', handleResizeEnd);
                window.removeEventListener('click', closeDropdowns);
            });

            watch([itemPool, scheduledTasks, settings, currentSessionId], () => {
                if (user.value) {
                    // åªè¦æ•°æ®ä¸€å˜ï¼Œç«‹åˆ»å˜æ©™è‰²
                    if (saveStatus.value !== 'saving') {
                        saveStatus.value = 'unsaved'; // ğŸŸ  å˜æ©™ï¼šæœ‰æ”¹åŠ¨
                    }

                    clearTimeout(syncTimeout);

                    // âš¡ï¸ 1ç§’åæ‰§è¡Œä¿å­˜ (æ¯”ä¹‹å‰çš„2ç§’æ›´çµæ•)
                    syncTimeout = setTimeout(() => {
                        saveToCloud();
                    }, 1000);
                } else {
                    // ã€æœªç™»å½•/æ¸¸å®¢çŠ¶æ€ã€‘
                    // 1. ä»…ä¿å­˜åˆ°æœ¬åœ°ï¼Œä½œä¸ºç¦»çº¿æ•°æ®
                    const dataToSave = {
                        pool: itemPool.value,
                        tasks: scheduledTasks.value,
                        settings: {...settings, lastSessionId: currentSessionId.value}
                    };
                    localStorage.setItem('v9_data', JSON.stringify(dataToSave));
                }

            }, {deep: true});

            // ğŸŸ¢ ä¿®æ”¹: addProject (ä¸å†ç”Ÿæˆé¢œè‰²)
            const addProject = () => {
                settings.projects.push({
                    id: generateUniqueId('P'),
                    name: `æ–°é¡¹ç›®${settings.projects.length + 1}`,
                    group: ''
                    // color: ... å·²ç§»é™¤
                });
                pushHistory();
            };

            const jumpToGhostContext = (task) => {
                // ğŸŸ¢ [æ–°å¢] ä¸Šé”ï¼šé˜²æ­¢åŸç”Ÿ dblclick äº‹ä»¶ç©¿é€å¯¼è‡´è¯¯å¼€å¼¹çª—
                isContextSwitching.value = true;
                setTimeout(() => {
                    isContextSwitching.value = false;
                }, 600);

                let changed = false;
                let message = [];

                // 1. æ£€æŸ¥ Session æ˜¯å¦ä¸åŒ
                const taskSession = task.sessionId || 'S_DEFAULT';
                if (currentSessionId.value !== taskSession) {
                    currentSessionId.value = taskSession;
                    changed = true;
                    const sessionName = settings.sessions.find(s => s.id === taskSession)?.name || 'ç›®æ ‡æ—¥ç¨‹';
                    message.push(`å·²åˆ‡æ¢åˆ°: ${sessionName}`);
                }

                // 2. æ£€æŸ¥è§†å›¾ç±»å‹ (Sidebar Tab) æ˜¯å¦ä¸åŒ
                // é€»è¾‘ï¼šå¦‚æœä»»åŠ¡æœ‰ projectIdï¼Œå°±åº”è¯¥åœ¨ Project è§†å›¾ä¸‹çœ‹ï¼›æœ‰ instrumentId å» Instrument è§†å›¾...
                let targetTab = 'musician';
                if (task.musicianId) targetTab = 'musician';
                else if (task.projectId) targetTab = 'project';
                else if (task.instrumentId) targetTab = 'instrument';

                if (sidebarTab.value !== targetTab) {
                    sidebarTab.value = targetTab;
                    changed = true;
                    // const tabName = targetTab === 'project' ? 'é¡¹ç›®è§†å›¾' : (targetTab === 'instrument' ? 'ä¹å™¨è§†å›¾' : 'äººå‘˜è§†å›¾');
                    // message.push(`å·²åˆ‡æ¢åˆ° ${tabName}`);
                }

                if (changed) {
                    window.triggerTouchHaptic('Medium');

                    // é«˜äº®ä¸€ä¸‹è¯¥ä»»åŠ¡ï¼Œè®©ç”¨æˆ·çŸ¥é“è·³åˆ°äº†å“ªé‡Œ
                    flashingTaskId.value = task.scheduleId;
                    setTimeout(() => {
                        if (flashingTaskId.value === task.scheduleId) flashingTaskId.value = null;
                    }, 1500);

                    // å¯é€‰ï¼šå¼¹ä¸ªæç¤º
                    // openAlertModal("è§†å›¾è·³è½¬", message.join('\n'));
                } else {
                    // å¦‚æœä¸Šä¸‹æ–‡éƒ½ä¸€æ ·ï¼Œè¯´æ˜å¯èƒ½æ˜¯é€»è¾‘åˆ¤æ–­æ¼äº†ï¼Œæˆ–è€…å®ƒæœ¬æ¥å°±ä¸æ˜¯å¹½çµ
                    window.triggerTouchHaptic('Error');
                }
            };


            // --- V9.7: è½¯æ’æœŸé€»è¾‘ ---
            const scheduledTemplateIds = computed(() => {
                return new Set(scheduledTasks.value.map(t => t.templateId).filter(id => id !== undefined));
            });
            const isScheduled = templateId => scheduledTemplateIds.value.has(templateId);

            const handlePoolItemClick = (poolItemId) => {
                selectTask(poolItemId, 'pool');
                // åŸæ¥çš„é€»è¾‘æ˜¯æ‰‹åŠ¨æ‰¾ task ç„¶å scrollTo
                // ç°åœ¨ selectTask å†…éƒ¨å·²ç»è°ƒç”¨äº† smartScrollToTaskï¼Œæ‰€ä»¥è¿™é‡Œå…¶å®åªéœ€è¦ä¿ç•™ selectTask å³å¯
                // ä½†ä¸ºäº†ä¿é™©ï¼Œå¦‚æœä½ è¿™é‡Œæœ‰ç‰¹æ®Šçš„é€»è¾‘ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è°ƒç”¨ï¼š
                /* const firstScheduled = scheduledTasks.value.find(t => t.templateId === poolItemId);
                    if (firstScheduled) {
                        smartScrollToTask(firstScheduled);
                    }
                    */
            };

            // --- V9.7.4: CSV å¯¼å…¥é€»è¾‘ (åŸºäº ID) ---
            const getOrCreateProjectId = (projectName) => {
                let project = settings.projects.find(p => p.name === projectName);
                if (!project) {
                    project = {id: generateUniqueId('P'), name: projectName, color: generateRandomHexColor()};
                    settings.projects.push(project);
                }
                return project.id;
            };

            // --- ğŸŸ¢ æ–°å¢è¾…åŠ©å‡½æ•°: æŸ¥æ‰¾æˆ–åˆ›å»ºè®¾ç½®é¡¹ ---
            const getOrCreateSettingItem = (type, name, group = '') => {
                if (!name || !name.trim()) return '';

                let list = [];
                let idPrefix = '';

                if (type === 'project') { list = settings.projects; idPrefix = 'P'; }
                else if (type === 'instrument') { list = settings.instruments; idPrefix = 'I'; }
                else if (type === 'musician') { list = settings.musicians; idPrefix = 'M'; }

                // æŸ¥æ‰¾å·²å­˜åœ¨çš„ (ä¸åŒºåˆ†å¤§å°å†™)
                const existing = list.find(i => i.name.toLowerCase() === name.trim().toLowerCase());
                if (existing) return existing.id;

                // åˆ›å»ºæ–°çš„
                const newId = generateUniqueId(idPrefix);
                const newItem = {
                    id: newId,
                    name: name.trim(),
                    group: group.trim(), // ä½¿ç”¨ä¼ å…¥çš„åˆ†ç»„ (å¦‚ Inst Family)
                    color: generateRandomHexColor()
                };

                if (type === 'musician') newItem.defaultRatio = 20; // é»˜è®¤å€ç‡

                list.push(newItem);
                return newId;
            };



            // --- ğŸŸ¢ è¾…åŠ©å‡½æ•°ï¼šå°† HH:MM è½¬æ¢ä¸ºåˆ†é’Ÿæ•° (ç”¨äºè®¡ç®—æ—¶é—´è·ç¦») ---
            const getMins = (timeStr) => {
                if (!timeStr) return 0;
                const [h, m] = timeStr.split(':').map(Number);
                return h * 60 + m;
            };

            // ğŸŸ¢ [æ–°å¢] åŒæ­¥å®¶æ—ç¼–åˆ¶ä¿¡æ¯
            const syncFamilyOrchestration = (item, newOrch) => {
                // 1. æ‰¾åˆ°æ ¹ ID (å¦‚æœè‡ªå·±æ˜¯å­ä»»åŠ¡ï¼Œå– splitFromIdï¼›å¦åˆ™å–è‡ªå·±çš„ ID)
                const rootId = item.splitFromId || item.id;

                // 2. æ‰¾åˆ°æ‰€æœ‰å®¶æ—æˆå‘˜ (æ ¹èŠ‚ç‚¹ + æ‰€æœ‰å­èŠ‚ç‚¹)
                // æ³¨æ„ï¼šåªåŒ¹é… IDï¼Œä¸åŒ¹é… Sessionï¼Œå› ä¸ºç¼–åˆ¶ä¿¡æ¯åº”è¯¥æ˜¯è·¨ Session ç»Ÿä¸€çš„
                const familyMembers = itemPool.value.filter(i => i.id === rootId || i.splitFromId === rootId);

                // 3. æ‰¹é‡æ›´æ–°
                familyMembers.forEach(member => {
                    if (member.orchestration !== newOrch) {
                        member.orchestration = newOrch;
                    }
                });
            };

            // 3. è§¦å‘æ–‡ä»¶é€‰æ‹© (é€‚é…ä½ ç°æœ‰çš„ input id)
            const triggerCSV = () => {
                const input = document.getElementById('csv-import-input');
                if(input) {
                    input.value = '';
                    input.click();
                }
            };

            // 2. è¾…åŠ©å‡½æ•°ï¼šè§£æ CSV å•è¡Œ (å¤„ç†å¼•å·åŒ…è£¹çš„æƒ…å†µ)
            const parseCSVLine = (text) => {
                const result = [];
                let cell = '';
                let inQuotes = false;
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(cell.trim().replace(/^"|"$/g, '')); // å»é™¤åŒ…è£¹çš„å¼•å·
                        cell = '';
                    } else {
                        cell += char;
                    }
                }
                result.push(cell.trim().replace(/^"|"$/g, ''));
                return result;
            };

            // CSV æ ¸å¿ƒè§£æå¼•æ“ (è§£æåŒå¼•å·ã€æ¢è¡Œç¬¦ç­‰å¤æ‚æƒ…å†µ)
            const parseCSVRobust = (text) => {
                const rows = []; let currentRow = []; let currentCell = ''; let insideQuote = false;
                for (let i = 0; i < text.length; i++) {
                    const char = text[i]; const nextChar = text[i + 1];
                    if (char === '"') {
                        if (insideQuote && nextChar === '"') { currentCell += '"'; i++; }
                        else { insideQuote = !insideQuote; }
                    }
                    else if (char === ',' && !insideQuote) { currentRow.push(currentCell.trim()); currentCell = ''; }
                    else if ((char === '\r' || char === '\n') && !insideQuote) {
                        if (char === '\r' && nextChar === '\n') i++;
                        currentRow.push(currentCell.trim()); rows.push(currentRow); currentRow = []; currentCell = '';
                    } else { currentCell += char; }
                }
                if (currentCell || currentRow.length > 0) { currentRow.push(currentCell.trim()); rows.push(currentRow); }
                return rows;
            };

            const handleCSVImport = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.readAsText(file, 'UTF-8');
                reader.onload = (e) => {
                    const csvText = e.target.result;

                    // 1. ä½¿ç”¨ä½ åŸæœ‰çš„è§£æå¼•æ“ (parseCSVRobust)
                    const allRows = parseCSVRobust(csvText);
                    const headerIndex = allRows.findIndex(row =>
                        row.some(cell => (cell.includes('PID') || cell.includes('é¡¹ç›®') || cell.includes('Project')))
                    );

                    if (headerIndex === -1) { alert("æœªæ‰¾åˆ°è¡¨å¤´"); return; }

                    // 2. æ˜ å°„è¡¨å¤´ç´¢å¼•
                    const headers = allRows[headerIndex].map(h => h.replace(/^"|"$/g, '').trim());
                    csvHeadersMap.value = {
                        project: headers.findIndex(h => h.includes('PID') || h.includes('é¡¹ç›®') || h.includes('Project')),
                        instFamily: headers.findIndex(h => h.includes('Inst Family') || h.includes('ä¹å™¨åˆ†ç±»')),
                        instName: headers.findIndex(h => h.includes('Inst Name') || h === 'ä¹å™¨' || h.includes('ä¹å™¨åç§°')),
                        playerName: headers.findIndex(h => h.includes('Player Name') || h === 'Player' || h.includes('äººå‘˜')),
                        duration: headers.findIndex(h => h.includes('Duration') || h.includes('æ—¶é•¿')),

                        // [REC] å½•éŸ³ç›¸å…³
                        recDate: headers.findIndex(h => h.includes('[REC] Date') || h.includes('å½•éŸ³æ—¥æœŸ')),
                        recStart: headers.findIndex(h => h.includes('[REC] Starting Time') || h.includes('å½•éŸ³å¼€å§‹æ—¶é—´')),
                        recEnd: headers.findIndex(h => h.includes('[REC] Ending Time') || h.includes('å½•éŸ³ç»“æŸæ—¶é—´')),
                        recStudio: headers.findIndex(h => (h.includes('[REC] Studio') && !h.includes('Time')) || h.includes('å½•éŸ³æ£š')),
                        recEngineer: headers.findIndex(h => h.includes('[REC] Engineer') || h.includes('å½•éŸ³å¸ˆ')),
                        recOperator: headers.findIndex(h => h.includes('[REC] Operator') || h.includes('å½•éŸ³åŠ©ç†')),
                        recAssistant: headers.findIndex(h => h.includes('[REC] Assistant')),
                        recComments: headers.findIndex(h => h.includes('[REC] Comments') || h.includes('å¤‡æ³¨')),

                        orchestration: headers.findIndex(h => h.includes('Orchestration') || h.includes('ç¼–åˆ¶')),

                        // ğŸŸ¢ [æ–°å¢] [EDT] ç¼–è¾‘æ—¥ç¨‹ç›¸å…³
                        edtDate: headers.findIndex(h => h.includes('[EDT] Date')),
                        edtStart: headers.findIndex(h => h.includes('[EDT] Starting Time')),
                        edtEnd: headers.findIndex(h => h.includes('[EDT] Ending Time')),
                        edtRest: headers.findIndex(h => h.includes('[EDT] Rest Time')),
                        edtEngineer: headers.findIndex(h => h.includes('[EDT] Engineer')),
                        edtStudio: headers.findIndex(h => h.includes('[EDT] Studio')&& !h.includes('Time')),

                        mixEngineer: headers.findIndex(h => h.includes('[MIX] Engineer')),
                        mixStudio: headers.findIndex(h => h.includes('[MIX] Studio') && !h.includes('Time')),
                        masEngineer: headers.findIndex(h => h.includes('[MAS] Engineer')),
                        masStudio: headers.findIndex(h => h.includes('[MAS] Studio') && !h.includes('Time')),
                    };

                    // 3. ä¿å­˜åŸå§‹æ•°æ®å¹¶æ˜¾ç¤ºæ¨¡æ€æ¡†
                    rawCsvRows.value = allRows.slice(headerIndex + 1).filter(r => {
                        // åªæœ‰å½“ é¡¹ç›®å æˆ– ä¹å™¨å/å½•éŸ³å¸ˆ ç­‰å…³é”®åˆ—æœ‰å€¼æ—¶ï¼Œæ‰è§†ä¸ºæœ‰æ•ˆè¡Œ
                        // é¿å…å¯¼å…¥å…¨æ˜¯é€—å·çš„ç©ºè¡Œ
                        const hasProject = csvHeadersMap.value.project > -1 && r[csvHeadersMap.value.project]?.trim();
                        const hasInst = csvHeadersMap.value.instName > -1 && r[csvHeadersMap.value.instName]?.trim();
                        const hasDate = csvHeadersMap.value.edtDate > -1 && r[csvHeadersMap.value.edtDate]?.trim(); // é’ˆå¯¹ç¼–è¾‘æ—¥ç¨‹
                        const hasRecDate = csvHeadersMap.value.recDate > -1 && r[csvHeadersMap.value.recDate]?.trim(); // é’ˆå¯¹å½•éŸ³æ—¥ç¨‹

                        // åªè¦æœ‰ä»»æ„å…³é”®ä¿¡æ¯ï¼Œå°±ä¿ç•™
                        return hasProject || hasInst || hasDate || hasRecDate;
                    });

                    // 4. è°ƒç”¨åˆ·æ–°é¢„è§ˆå‡½æ•°ï¼ˆè§ç¬¬ä¸‰æ­¥ï¼‰
                    refreshCsvPreview();
                    showCsvImportModal.value = true;
                };
            };

            const refreshCsvPreview = () => {
                const rows = rawCsvRows.value;
                const col = csvHeadersMap.value;
                const strategy = csvImportConfig.nameStrategy;

                const preparedData = [];
                const orchGroupsMap = {};
                const processedIndices = new Set();
                const instNameCounter = {}; // è®¡æ•°å™¨ { "ProjectA|Flute": 1 }

                const instTotalCounts = {};

                rows.forEach(row => {
                    const proj = row[col.project] || 'æœªå‘½åé¡¹ç›®';
                    const rawName = row[col.instName] || 'æœªå‘½åä¹å™¨';
                    const cleanName = rawName.replace(/\s+\d+$/, '').trim();
                    const key = `${proj}|${cleanName}`;
                    instTotalCounts[key] = (instTotalCounts[key] || 0) + 1;
                });

                // 1. æ‰«æåˆå¹¶ç»„ (Strings/Brass ç­‰) - ä¿æŒä¸å˜
                rows.forEach((row, index) => {
                    const pid = row[col.project] || 'æœªå‘½åé¡¹ç›®';
                    const pPlayer = (row[col.playerName] || '').toLowerCase();
                    let groupType = '';
                    if (pPlayer.includes('string')) groupType = 'Strings';
                    else if (pPlayer.includes('brass')) groupType = 'Brass';
                    else if (pPlayer.includes('wood') || pPlayer.includes('wind')) groupType = 'Woodwinds';
                    if (col.playerName > -1 && (!row[col.playerName] || !row[col.playerName].trim())) {
                        return;
                    }

                    if (groupType) {
                        const key = `${pid}|${groupType}`;
                        if (!orchGroupsMap[key]) {
                            orchGroupsMap[key] = { firstRow: row, instNames: [], maxDuration: '00:00' };
                        }
                        orchGroupsMap[key].instNames.push(row[col.instName] || '');
                        if ((row[col.duration] || '00:00') > orchGroupsMap[key].maxDuration) {
                            orchGroupsMap[key].maxDuration = row[col.duration];
                        }
                        processedIndices.add(index);
                    }
                });

                // 2. å¤„ç†å•ç‹¬ä¹å™¨ (å…³é”®ä¿®æ”¹)
                rows.forEach((row, index) => {
                    if (strategy === 'merge' && processedIndices.has(index)) return;
                    if (col.playerName > -1 && (!row[col.playerName] || !row[col.playerName].trim())) {
                        return;
                    }

                    const proj = row[col.project] || 'æœªå‘½åé¡¹ç›®';
                    const rawName = row[col.instName] || 'æœªå‘½åä¹å™¨';

                    // A. æå–â€œçº¯å‡€â€åç§° (å»æ‰ CSV é‡Œå¯èƒ½è‡ªå¸¦çš„æ•°å­—ï¼Œæ¯”å¦‚æŠŠ "Flute 2" å˜æˆ "Flute")
                    const cleanName = rawName.replace(/\s+\d+$/, '').trim();

                    // B. è®¡ç®—åºå· (ä»…ç”¨äºé¢„è§ˆæ˜¾ç¤º)
                    const countKey = `${proj}|${cleanName}`;
                    instNameCounter[countKey] = (instNameCounter[countKey] || 0) + 1;
                    const seqNum = instNameCounter[countKey];

                    // C. ç”Ÿæˆâ€œæ˜¾ç¤ºåç§°â€ (å¸¦åºå·)
                    // ğŸŸ¢ ä¿®æ”¹ï¼šåªæœ‰å½“è¯¥é¡¹ç›®ä¸‹è¯¥ä¹å™¨æ•°é‡ > 1 æ—¶ï¼Œæ‰åŠ åºå·
                    let displayName = cleanName;
                    if ((instTotalCounts[countKey] || 0) > 1) {
                        displayName = `${cleanName} ${seqNum}`;
                    }

                    addDataToPrepared(preparedData, row, col, {
                        displayCsvName: displayName, // ğŸŸ¢ UIæ˜¾ç¤ºç”¨ï¼šFlute 1
                        realCsvName: cleanName       // ğŸŸ¢ å®é™…å¯¼å…¥ç”¨ï¼šFlute
                    });
                });

                // 3. å¤„ç†åˆå¹¶ç»„ - ä¿æŒä¸å˜
                if (strategy === 'merge') {
                    Object.keys(orchGroupsMap).forEach(key => {
                        const [pid, groupName] = key.split('|');
                        const groupData = orchGroupsMap[key];
                        addDataToPrepared(preparedData, groupData.firstRow, col, {
                            forceName: groupName,
                            realCsvName: groupName,    // ğŸŸ¢ ä¿®å¤: å¼ºåˆ¶ä¹å™¨åä¹Ÿä¸ºç»„å (åˆ›å»º/å…³è” "Strings" ä¹å™¨)
                            displayCsvName: groupName, // ğŸŸ¢ ä¿®å¤: æ˜¾ç¤ºåä¹ŸåŒæ­¥
                            injectedOrch: getOrchString(groupData.instNames),
                            overrideDuration: groupData.maxDuration
                        });
                    });
                }

                csvImportData.value = preparedData;
            };

// å¦‚æœä½ æƒ³è®©å‹¾é€‰æ¡†å¼€å…³ä¹Ÿå³æ—¶ç”Ÿæ•ˆï¼ˆè™½ç„¶é€šå¸¸æ˜¯å¯¼å…¥æ—¶åˆ¤æ–­ï¼‰ï¼Œä¹Ÿå¯ä»¥ç›‘å¬å®ƒä»¬
            // ç›‘å¬å…¨å±€å¯¼å…¥ç±»å‹å¼€å…³
            watch(() => csvImportConfig.importTypes, () => {
                refreshCsvStatus(); // å¼€å…³ä¸€å˜ï¼Œç«‹åˆ»é‡ç®—æ‰€æœ‰è¡Œçš„çŠ¶æ€æ–‡æœ¬
            }, { deep: true });

            // ğŸŸ¢ ç›‘å¬ç­–ç•¥å˜åŒ–ï¼Œä¸€æ—¦åˆ‡æ¢å•é€‰æ¡†ï¼Œç«‹å³é‡ç®—åˆ—è¡¨
            watch(() => csvImportConfig.nameStrategy, () => {
                if (rawCsvRows.value.length > 0) {
                    refreshCsvPreview();
                }
            });

            const getOrchString = (names) => {
                const counts = {};         // ç”¨äºç»Ÿè®¡æ•°é‡
                const displayNames = {};   // ç”¨äºè®°å½•è¯¥ä¹å™¨å¯¹åº”çš„â€œæœ€ä½³æ˜¾ç¤ºåç§°â€
                const abbrMap = {
                    'violin': 'Vln',
                    'viola': 'Vla',
                    'cello': 'Vc',
                    'double bass': 'Db',
                    'flute': 'Fl'
                };

                names.forEach(n => {
                    // 1. ä¿ç•™åŸå§‹çš„å¤§å°å†™ï¼Œä»…å»é™¤æœ«å°¾æ•°å­—å’Œç©ºæ ¼
                    let rawClean = n.replace(/[\d\s]+$/g, '').trim();
                    // 2. è½¬ä¸ºå°å†™ä»…ç”¨äºåœ¨ counts å’Œ abbrMap ä¸­åš key (åŒ¹é…)
                    let lower = rawClean.toLowerCase();

                    // ç»Ÿè®¡æ•°é‡
                    counts[lower] = (counts[lower] || 0) + 1;

                    // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡é‡åˆ°è¿™ä¸ªä¹å™¨ï¼Œè®°å½•å®ƒçš„æ˜¾ç¤ºåç§°
                    if (!displayNames[lower]) {
                        if (abbrMap[lower]) {
                            displayNames[lower] = abbrMap[lower];
                        } else {
                            // ç¡®ä¿é¦–å­—æ¯å¤§å†™ï¼Œä½†ä¿ç•™åç»­å†…å®¹çš„åŸå§‹å¤§å°å†™ (å¦‚ Bb ä¸­çš„ B)
                            displayNames[lower] = rawClean.charAt(0).toUpperCase() + rawClean.slice(1);
                        }
                    }
                });

                // æœ€åç»„è£…æ—¶ä½¿ç”¨ displayNames é‡Œå­˜å¥½çš„åç§°
                return Object.entries(counts)
                    .map(([lower, v]) => `${v} ${displayNames[lower]}`)
                    .join(', ');
            };
            // ğŸ” è¾…åŠ©ï¼šæ ¹æ®åå­—æŸ¥æ‰¾ ID (ä»…æŸ¥æ‰¾ï¼Œä¸åˆ›å»º)
            const findSettingId = (type, name) => {
                if (!name || !settings[type + 's']) return null;
                const found = settings[type + 's'].find(i => i.name.trim().toLowerCase() === name.trim().toLowerCase());
                return found ? found.id : null;
            };

            const extractTime = (str) => {
                const match = str.match(/(\d{1,2})[:ï¼š](\d{2})/);
                if (match) {
                    return `${String(match[1]).padStart(2, '0')}:${match[2]}`;
                }
                return '';
            };

            const confirmCsvImport = () => {
                if (typeof pushHistory === 'function') pushHistory('Import CSV Data');

                // 1. è¿‡æ»¤å‡ºå½“å‰æ ‡ç­¾é¡µä¸‹çš„æœ‰æ•ˆå‹¾é€‰è¡Œ
                const selectedRows = csvImportData.value.filter(r => r.selected && (activeImportTab.value === 'rec' ? r.hasRecData : r.hasEditData));

                if (selectedRows.length === 0) {
                    if (csvImportData.value.some(r => r.selected)) {
                        openAlertModal("æç¤º", `å½“å‰è§†å›¾ (${activeImportTab.value === 'rec' ? 'Recording' : 'Editing'}) æ²¡æœ‰é€‰ä¸­çš„æœ‰æ•ˆä»»åŠ¡ã€‚`);
                    } else {
                        showCsvImportModal.value = false;
                    }
                    return;
                }

                pushHistory();

                const affectedTaskIds = new Set();
                const { tasks: isTaskMode, time: isTimeMode, orch: isOrchMode } = csvImportConfig.importTypes;

                const validRecordings = [];
                const validEditings = [];

                // ğŸŸ¢ ä¿®å¤: è¿½è¸ªæ‰€æœ‰å—å½±å“çš„ç»´åº¦ï¼Œä¸ä»…ä»…æ˜¯ Musician
                const affectedMusicianIds = new Set();
                const affectedProjectIds = new Set();
                const affectedInstrumentIds = new Set();

                const col = csvHeadersMap.value;

                // ğŸŸ¢ 1. å¿«ç…§ç³»ç»Ÿï¼šç”¨äºå¯¼å…¥åé‡æ–°å¯¹é½ä»»åŠ¡ (Task -> Schedule)
                const taskToScheduleMap = new Map();
                const snapshotLoaded = new Set(); // é˜²æ­¢é‡å¤åŠ è½½

                // ğŸŸ¢ é€šç”¨å¿«ç…§å‡½æ•°
                const ensureSnapshot = (id, type) => {
                    const key = `${type}_${id}`;
                    if (!id || snapshotLoaded.has(key)) return;

                    // æ‰¾åˆ°è¯¥ç»´åº¦ä¸‹ç°æœ‰çš„æ—¥ç¨‹
                    const sList = scheduledTasks.value.filter(t => {
                        if ((t.sessionId || 'S_DEFAULT') !== currentSessionId.value) return false;
                        if (type === 'musician') return t.musicianId === id;
                        if (type === 'project') return t.projectId === id && !t.musicianId; // ç¼–è¾‘æ—¥ç¨‹é€šå¸¸æ²¡æœ‰æ¼”å¥å‘˜
                        if (type === 'instrument') return t.instrumentId === id;
                        return false;
                    }).sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));

                    // æ‰¾åˆ°è¯¥ç»´åº¦ä¸‹ç°æœ‰çš„ä»»åŠ¡
                    const iList = itemPool.value.filter(i => {
                        if ((i.sessionId || 'S_DEFAULT') !== currentSessionId.value) return false;
                        if (type === 'musician') return i.musicianId === id;
                        if (type === 'project') return i.projectId === id;
                        if (type === 'instrument') return i.instrumentId === id;
                        return false;
                    });

                    // å»ºç«‹æ˜ å°„
                    iList.forEach(item => {
                        const idx = item.sectionIndex || 0;
                        if (sList[idx]) taskToScheduleMap.set(item.id, sList[idx].scheduleId);
                    });
                    snapshotLoaded.add(key);
                };

                const formatCell = (val) => val ? val.replace(/[\r\n]+/g, ' / ').trim() : '';
                const getMins = (t) => {
                    if (!t) return 0;
                    const [h, m] = t.split(':').map(Number);
                    return (h || 0) * 60 + (m || 0);
                };
                const formatSecsLocal = (seconds) => {
                    if (seconds <= 0) return "01:00:00";
                    const h = Math.floor(seconds / 3600);
                    const m = Math.floor((seconds % 3600) / 60);
                    const s = Math.floor(seconds % 60);
                    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
                };

                // ğŸŸ¢ 2. éå†å¤„ç†æ¯ä¸€è¡Œæ•°æ®
                selectedRows.forEach(data => {
                    const pId = getOrCreateSettingItem('project', data.projectName);
                    const iId = getOrCreateSettingItem('instrument', data.name_real, data.group);
                    const mId = getOrCreateSettingItem('musician', data.playerName, data.group);

                    // æ³¨å†Œå—å½±å“çš„ ID å¹¶å»ºç«‹å¿«ç…§
                    if (mId) { affectedMusicianIds.add(mId); ensureSnapshot(mId, 'musician'); }
                    if (pId) { affectedProjectIds.add(pId); ensureSnapshot(pId, 'project'); }
                    if (iId) { affectedInstrumentIds.add(iId); ensureSnapshot(iId, 'instrument'); }

                    // // Project Info (æ··éŸ³å¸ˆç­‰) æ›´æ–°
                    // if (pId && data._raw) {
                    //     const row = data._raw;
                    //     const proj = settings.projects.find(p => p.id === pId);
                    //     if (proj) {
                    //         if (col.mixEngineer > -1 && row[col.mixEngineer]) proj.mixingEngineer = formatCell(row[col.mixEngineer]);
                    //         if (col.mixStudio > -1 && row[col.mixStudio]) proj.mixingStudio = formatCell(row[col.mixStudio]);
                    //         if (col.masEngineer > -1 && row[col.masEngineer]) proj.masteringEngineer = formatCell(row[col.masEngineer]);
                    //         if (col.masStudio > -1 && row[col.masStudio]) proj.masteringStudio = formatCell(row[col.masStudio]);
                    //     }
                    // }

                    // === Recording Import (å½•éŸ³å¯¼å…¥) ===
                    if (activeImportTab.value === 'rec') {
                        if (!data.hasRecData) return;

                        // ğŸŸ¢ã€æ–°å¢ã€‘å°† Project Info æ›´æ–°ç§»åˆ°è¿™é‡Œ
                        // åªæœ‰åœ¨ Editing æ¨¡å¼ä¸‹ï¼Œæ‰æ›´æ–°æ··éŸ³/æ¯å¸¦ç­‰é¡¹ç›®å±‚çº§ä¿¡æ¯
                        if (pId && data._raw) {
                            const row = data._raw;
                            const proj = settings.projects.find(p => p.id === pId);
                            if (proj) {
                                if (col.mixEngineer > -1 && row[col.mixEngineer]) proj.mixingEngineer = formatCell(row[col.mixEngineer]);
                                if (col.mixStudio > -1 && row[col.mixStudio]) proj.mixingStudio = formatCell(row[col.mixStudio]);
                                if (col.masEngineer > -1 && row[col.masEngineer]) proj.masteringEngineer = formatCell(row[col.masEngineer]);
                                if (col.masStudio > -1 && row[col.masStudio]) proj.masteringStudio = formatCell(row[col.masStudio]);
                            }
                        }

                        let taskItem = itemPool.value.find(item => item.projectId === pId && item.name === data.name_merge && item.musicianId === mId && (item.splitTag === (data.isSplit ? `Part ${data.partIndex + 1}` : null)));

                        if (isTaskMode && !taskItem) {
                            // ğŸŸ¢ ä¿®å¤: å¦‚æœåˆå¹¶åä¸ä¹å™¨åä¸€è‡´ (å¿½ç•¥å¤§å°å†™)ï¼Œåˆ™ä¸ç¡¬ç¼–ç ä»»åŠ¡å
                            const _inst = settings.instruments.find(i => i.id === iId);
                            const _isSameName = _inst && _inst.name.toLowerCase() === data.name_merge.toLowerCase();
                            taskItem = {
                                id: generateUniqueId('T'),
                                sessionId: currentSessionId.value,
                                projectId: pId, instrumentId: iId, musicianId: mId,
                                name: _isSameName ? '' : data.name_merge, // ğŸŸ¢ åŠ¨æ€åç§°é€»è¾‘
                                musicDuration: data.duration,
                                orchestration: '',
                                records: { musician: {}, project: {}, instrument: {} },
                                splitTag: data.isSplit ? `Part ${data.partIndex + 1}` : null,
                                ratio: 20,
                                estDuration: calculateEstTime(data.duration, 20),
                                _isNewImport: true
                            };
                            itemPool.value.push(taskItem);
                        }

                        if (!taskItem) return;

                        // æ›´æ–°ä»»åŠ¡å±æ€§
                        if (isOrchMode && data.orchestration) taskItem.orchestration = data.orchestration;
                        if (isTimeMode && data.duration && data.duration !== '00:00') {
                            if (taskItem.musicDuration !== data.duration) {
                                taskItem.musicDuration = data.duration;
                                taskItem.estDuration = calculateEstTime(data.duration, taskItem.ratio || 20);
                                affectedTaskIds.add(taskItem.id);
                            }
                        }

                        // å‡†å¤‡å½•éŸ³æ—¶é—´æ•°æ®
                        const rDate = data.recDate;
                        const rStart = data.recStart;
                        const rEnd = data.recEnd;

                        if (rDate && rStart) {
                            // ğŸŸ¢ å†™å…¥ä»»åŠ¡è®°å½•
                            if (taskItem.records) {
                                if(!taskItem.records.musician) taskItem.records.musician = {};
                                taskItem.records.musician.recStart = rStart;
                                if (rEnd) {
                                    taskItem.records.musician.recEnd = rEnd;
                                    const [h1, m1] = rStart.split(':').map(Number);
                                    const [h2, m2] = rEnd.split(':').map(Number);
                                    let startMins = h1 * 60 + m1;
                                    let endMins = h2 * 60 + m2;
                                    if (endMins < startMins) endMins += 24 * 60;
                                    taskItem.records.musician.actualDuration = formatSecs((endMins - startMins) * 60);
                                }
                            }

                            let sMins = getMins(rStart);
                            let eMins = rEnd ? getMins(rEnd) : sMins + 60;
                            if (eMins <= sMins) eMins += 1440;

                            const row = data._raw;
                            validRecordings.push({
                                task: taskItem,
                                pId, iId, mId,
                                date: typeof normalizeDate === 'function' ? normalizeDate(rDate) : rDate,
                                startMins: sMins, endMins: eMins,
                                info: {
                                    studio: data.recStudio || '',
                                    engineer: data.recEngineer || '',
                                    operator: (col.recOperator > -1) ? formatCell(row[col.recOperator]) : '',
                                    assistant: (col.recAssistant > -1) ? formatCell(row[col.recAssistant]) : '',
                                    notes: (col.recComments > -1) ? formatCell(row[col.recComments]) : ''
                                }
                            });
                        }
                    }
                    // === Editing Import (ç¼–è¾‘å¯¼å…¥) ===
                    else if (activeImportTab.value === 'edt') {
                        if (!data.hasEditData) return;

                        // æ³¨æ„ï¼šç¼–è¾‘ä»»åŠ¡å¯èƒ½æ²¡æœ‰æ¼”å¥å‘˜(mId)ï¼Œä¸»è¦é  Project å’Œ Name åŒ¹é…
                        let taskItem = itemPool.value.find(item => item.projectId === pId && item.name === data.name_merge && item.musicianId === mId && (item.splitTag === (data.isSplit ? `Part ${data.partIndex + 1}` : null)));

                        if (isTaskMode && !taskItem) {
                            const _inst = settings.instruments.find(i => i.id === iId);
                            const _isSameName = _inst && _inst.name.toLowerCase() === data.name_merge.toLowerCase();
                            taskItem = {
                                id: generateUniqueId('T'),
                                sessionId: currentSessionId.value,
                                projectId: pId, instrumentId: iId, musicianId: mId,
                                name: _isSameName ? '' : data.name_merge, // ğŸŸ¢ åŠ¨æ€åç§°é€»è¾‘
                                musicDuration: data.duration,
                                orchestration: '',
                                records: { musician: {}, project: {}, instrument: {} },
                                splitTag: data.isSplit ? `Part ${data.partIndex + 1}` : null,
                                ratio: 20,
                                estDuration: calculateEstTime(data.duration, 20),
                                _isNewImport: true
                            };
                            itemPool.value.push(taskItem);
                        }

                        if (!taskItem) return;

                        const eDate = data.edtDate;
                        const eStart = data.edtStart;
                        const eEnd = data.edtEnd;

                        if (eDate && eStart) {
                            // ğŸŸ¢ ä¿®å¤ï¼šå°†ç¼–è¾‘æ—¶é—´å†™å…¥ä»»åŠ¡è®°å½• (Project ç»´åº¦)
                            // è¿™æ ·ä»»åŠ¡åœ¨åˆ—è¡¨ä¸­å°±ä¼šæ˜¾ç¤ºâ€œå®é™…æ—¶é—´â€
                            if (taskItem.records) {
                                if (!taskItem.records.project) taskItem.records.project = {}; // ç¡®ä¿å¯¹è±¡å­˜åœ¨

                                taskItem.records.project.recStart = eStart;
                                if (eEnd) {
                                    taskItem.records.project.recEnd = eEnd;
                                    // è®¡ç®—æŒç»­æ—¶é—´
                                    const [h1, m1] = eStart.split(':').map(Number);
                                    const [h2, m2] = eEnd.split(':').map(Number);
                                    let startMins = h1 * 60 + m1;
                                    let endMins = h2 * 60 + m2;
                                    if (endMins < startMins) endMins += 24 * 60;
                                    taskItem.records.project.actualDuration = formatSecs((endMins - startMins) * 60);
                                }
                                // æ‰£é™¤ä¼‘æ¯æ—¶é—´
                                if (data.edtRest) {
                                    taskItem.records.project.breakMinutes = parseInt(data.edtRest) || 0;
                                }
                            }

                            let sMins = getMins(eStart);
                            let eMins = eEnd ? getMins(eEnd) : sMins + 60;
                            if (eMins <= sMins) eMins += 1440;

                            let durMins = eMins - sMins;
                            if (data.edtRest) durMins -= parseInt(data.edtRest) || 0;

                            validEditings.push({
                                task: taskItem,
                                pId, iId, mId,
                                date: typeof normalizeDate === 'function' ? normalizeDate(eDate) : eDate,
                                startMins: sMins, endMins: eMins,
                                durationMins: durMins,
                                info: {
                                    studio: data.edtStudio || '',
                                    engineer: data.edtEngineer || ''
                                }
                            });
                        }
                    }
                });

                // ğŸŸ¢ 3. ç”Ÿæˆå½•éŸ³æ—¥ç¨‹ (Rec Schedules)
                if (validRecordings.length > 0) {
                    validRecordings.sort((a, b) => a.date.localeCompare(b.date) || a.startMins - b.startMins);

                    for (let i = 0; i < validRecordings.length; i++) {
                        const current = validRecordings[i];
                        let sStart = current.startMins, sEnd = current.endMins;
                        const items = [current.task], infos = [current.info];

                        while (i + 1 < validRecordings.length) {
                            const next = validRecordings[i + 1];
                            if (next.date !== current.date || next.mId !== current.mId) break;

                            // å…è®¸0é—´éš”åˆå¹¶
                            if (next.startMins - sEnd <= 60) {
                                sEnd = Math.max(sEnd, next.endMins);
                                items.push(next.task);
                                infos.push(next.info);
                                i++;
                            } else break;
                        }

                        const mergeF = (list, k) => [...new Set(list.map(x => x[k]).filter(v => v))].join(' / ');
                        const startStr = `${String(Math.floor(sStart / 60)).padStart(2, '0')}:${String(sStart % 60).padStart(2, '0')}`;

                        let targetScheduleId;
                        // æŸ¥æ‰¾ç°æœ‰åŒ¹é…çš„æ—¥ç¨‹å—
                        const existingTask = scheduledTasks.value.find(t => t.date === current.date && t.startTime === startStr && t.musicianId === current.mId && (t.sessionId || 'S_DEFAULT') === currentSessionId.value );

                        if (existingTask) {
                            targetScheduleId = existingTask.scheduleId;
                        } else {
                            targetScheduleId = Date.now() + Math.random();
                            scheduledTasks.value.push({
                                scheduleId: targetScheduleId,
                                sessionId: currentSessionId.value,
                                musicianId: current.mId || null,
                                projectId: (!current.mId && current.pId) ? current.pId : null,
                                instrumentId: (!current.mId && !current.pId && current.iId) ? current.iId : null,
                                date: current.date,
                                startTime: startStr,
                                estDuration: formatSecsLocal((sEnd - sStart) * 60),
                                trackCount: 0,
                                ratio: 20,
                                recordingInfo: {
                                    studio: mergeF(infos, 'studio'),
                                    engineer: mergeF(infos, 'engineer'),
                                    operator: mergeF(infos, 'operator'),
                                    assistant: mergeF(infos, 'assistant'),
                                    notes: mergeF(infos, 'notes')
                                }
                            });
                        }

                        // è®°å½•å…³è”
                        items.forEach(t => {
                            taskToScheduleMap.set(t.id, targetScheduleId);
                        });
                    }
                }

                // ğŸŸ¢ 4. ç”Ÿæˆç¼–è¾‘æ—¥ç¨‹ (Edit Schedules)
                if (validEditings.length > 0) {
                    validEditings.sort((a, b) => a.date.localeCompare(b.date) || a.startMins - b.startMins);

                    for (let i = 0; i < validEditings.length; i++) {
                        const current = validEditings[i];
                        let sStart = current.startMins, sEnd = current.endMins;
                        let duration = current.durationMins;
                        const items = [current.task], infos = [current.info];

                        while (i + 1 < validEditings.length) {
                            const next = validEditings[i + 1];
                            // ç¼–è¾‘æ—¥ç¨‹æŒ‰ Project åˆå¹¶
                            if (next.date !== current.date || next.pId !== current.pId) break;

                            // å…è®¸5åˆ†é’Ÿè¯¯å·®
                            if (Math.abs(next.startMins - sEnd) <= 60) {
                                sEnd = next.endMins;
                                duration += next.durationMins;
                                items.push(next.task);
                                infos.push(next.info);
                                i++;
                            } else break;
                        }

                        const mergeF = (list, k) => [...new Set(list.map(x => x[k]).filter(v => v))].join(' / ');
                        const startStr = `${String(Math.floor(sStart / 60)).padStart(2, '0')}:${String(sStart % 60).padStart(2, '0')}`;

                        let targetScheduleId;
                        // ç¼–è¾‘æ—¥ç¨‹ï¼šæŸ¥æ‰¾ projectId ç›¸åŒä¸”æ—  musicianId çš„å—
                        const existingTask = scheduledTasks.value.find(t => t.date === current.date && t.startTime === startStr && t.projectId === current.pId && !t.musicianId && (t.sessionId || 'S_DEFAULT') === currentSessionId.value );

                        if (existingTask) {
                            targetScheduleId = existingTask.scheduleId;
                        } else {
                            targetScheduleId = Date.now() + Math.random();
                            scheduledTasks.value.push({
                                scheduleId: targetScheduleId,
                                sessionId: currentSessionId.value,
                                musicianId: null, // ç¼–è¾‘é€šå¸¸æ²¡æœ‰æ¼”å¥å‘˜
                                projectId: current.pId,
                                instrumentId: null,
                                date: current.date,
                                startTime: startStr,
                                estDuration: formatSecsLocal(duration * 60),
                                trackCount: 0,
                                ratio: 1,
                                statusOverride: 'completed',
                                editInfo: {
                                    studio: mergeF(infos, 'studio'),
                                    engineer: mergeF(infos, 'engineer')
                                }
                            });
                        }

                        // ğŸŸ¢ è®°å½•å…³è” (å…³é”®)
                        items.forEach(t => {
                            taskToScheduleMap.set(t.id, targetScheduleId);
                        });
                    }
                }

                // ğŸŸ¢ 5. æ”¶å°¾ï¼šç»Ÿä¸€æ›´æ–°æ‰€æœ‰ä»»åŠ¡çš„ sectionIndex (Task -> Schedule)
                const updateIndexes = (id, type) => {
                    let sList = scheduledTasks.value.filter(t => (t.sessionId || 'S_DEFAULT') === currentSessionId.value);
                    let iList = itemPool.value.filter(i => (i.sessionId || 'S_DEFAULT') === currentSessionId.value);

                    if (type === 'musician') {
                        sList = sList.filter(t => t.musicianId === id);
                        iList = iList.filter(i => i.musicianId === id);
                    } else if (type === 'project') {
                        sList = sList.filter(t => t.projectId === id && !t.musicianId); // ä»…å¤„ç†ç¼–è¾‘å—
                        iList = iList.filter(i => i.projectId === id);
                    } else if (type === 'instrument') {
                        sList = sList.filter(t => t.instrumentId === id);
                        iList = iList.filter(i => i.instrumentId === id);
                    }

                    if (sList.length === 0) return;

                    sList.sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));

                    const schedIdToIndex = {};
                    sList.forEach((s, idx) => {
                        schedIdToIndex[s.scheduleId] = idx;
                    });

                    iList.forEach(item => {
                        const targetSchedId = taskToScheduleMap.get(item.id);
                        if (targetSchedId && schedIdToIndex[targetSchedId] !== undefined) {
                            item.sectionIndex = schedIdToIndex[targetSchedId];
                        }
                    });
                };

                // ğŸŸ¢ å¯¹æ‰€æœ‰å—å½±å“çš„ç»´åº¦æ‰§è¡Œæ›´æ–° (ä¹‹å‰å¯èƒ½æ¼äº† Project)
                affectedMusicianIds.forEach(id => updateIndexes(id, 'musician'));
                affectedProjectIds.forEach(id => updateIndexes(id, 'project')); // âœ… å¿…é¡»æ›´æ–°é¡¹ç›®ç´¢å¼•
                affectedInstrumentIds.forEach(id => updateIndexes(id, 'instrument'));

                // æ›´æ–°æ•ˆç‡è®¡ç®— (å¯é€‰)
                if (typeof autoUpdateEfficiency === 'function') {
                    affectedMusicianIds.forEach(id => autoUpdateEfficiency(id, 'musician', false));
                }

                // è‡ªåŠ¨è°ƒæ•´å—å¤§å° (å¦‚æœæœ‰æ–°å½•éŸ³)
                if (validRecordings.length > 0 && typeof autoResizeSchedules === 'function') {
                    autoResizeSchedules(Array.from(affectedTaskIds));
                }

                pushHistory();
                showCsvImportModal.value = false;
                openAlertModal("å¯¼å…¥å®Œæˆ", `æˆåŠŸå¯¼å…¥: å½•éŸ³æ—¥ç¨‹ ${validRecordings.length} ä¸ª, ç¼–è¾‘æ—¥ç¨‹ ${validEditings.length} ä¸ª`);
            };

            // ğŸŸ¢ ä¿®å¤åçš„ addDataToPrepared å‡½æ•° (åŠ å…¥å·®å¼‚å¯¹æ¯”)
            const addDataToPrepared = (targetList, rawRow, col, options = {}) => {
                // 1. åŸºç¡€å­—æ®µè§£æ
                const projectName = rawRow[col.project]?.trim() || 'Unknown Project';
                const rawInstName = rawRow[col.instName]?.trim() || 'Unknown Inst';

                // åç§°ç­–ç•¥
                const instName = options.realCsvName || rawInstName;
                const displayInstName = options.displayCsvName || instName;
                const mergeName = options.forceName || displayInstName;

                // æ•°æ®æ¸…æ´—
                const duration = options.overrideDuration || rawRow[col.duration]?.trim() || '00:00';
                const orchestration = rawRow[col.orchestration]?.trim() || '';
                const playerName = rawRow[col.playerName]?.trim() || '';
                const groupName = rawRow[col.instFamily]?.trim() || '';

                // 2. å½•éŸ³æ•°æ®è§£æ [REC]
                const recDate = rawRow[col.recDate]?.trim();
                const recStart = rawRow[col.recStart]?.trim();
                const hasRecData = !!(recDate && recStart);

                // 3. ç¼–è¾‘æ•°æ®è§£æ [EDT]
                const edtDate = rawRow[col.edtDate]?.trim();
                const edtStart = rawRow[col.edtStart]?.trim();
                const hasEditData = !!(edtDate && edtStart);

                // 4. æ„å»ºå¯¹è±¡
                const newItem = {
                    projectName,
                    playerName,
                    group: groupName,
                    name_real: instName,
                    name_display: displayInstName,
                    name_merge: mergeName,
                    duration,
                    orchestration,

                    // å½•éŸ³ä¿¡æ¯
                    recDate, recStart,
                    recEnd: rawRow[col.recEnd]?.trim(),
                    recStudio: rawRow[col.recStudio]?.trim(),
                    recEngineer: rawRow[col.recEngineer]?.trim(),
                    recOperator: (col.recOperator > -1) ? rawRow[col.recOperator]?.trim() : '',
                    recAssistant: (col.recAssistant > -1) ? rawRow[col.recAssistant]?.trim() : '',
                    recComments: (col.recComments > -1) ? rawRow[col.recComments]?.trim() : '',

                    // ç¼–è¾‘ä¿¡æ¯
                    edtDate, edtStart,
                    edtEnd: rawRow[col.edtEnd]?.trim(),
                    edtStudio: rawRow[col.edtStudio]?.trim(),
                    edtEngineer: rawRow[col.edtEngineer]?.trim(),
                    edtRest: rawRow[col.edtRest]?.trim(),

                    // çŠ¶æ€æ ‡è®°
                    hasRecData,
                    hasEditData,
                    selected: true,
                    _raw: rawRow,
                    isSplit: options.isSplit || false,
                    partIndex: options.partIndex || 0
                };

                // 5. æ™ºèƒ½é‡å¤æ£€æµ‹
                // ä»…é€šè¿‡ é¡¹ç›®å + ä¹å™¨å åˆ¤æ–­èº«ä»½ (ä¸å†åŒ…å« durationï¼Œé¿å…ä¿®æ”¹æ—¶é•¿å¯¼è‡´è¯†åˆ«ä¸ºæ–°ä»»åŠ¡)
                const existingTask = itemPool.value.find(item => {
                    const itemProjName = getNameById(item.projectId, 'project');
                    // åŒ¹é…é€»è¾‘ï¼šä¼˜å…ˆåŒ¹é…è‡ªå®šä¹‰åç§°(item.name)ï¼Œå…¶æ¬¡åŒ¹é…ä¹å™¨åº“åç§°
                    const itemInstName = item.name || getNameById(item.instrumentId, 'instrument');

                    return itemProjName === newItem.projectName &&
                        itemInstName === newItem.name_merge;
                });

                newItem.isDuplicate = !!existingTask;

                // 6. å·®å¼‚æ£€æµ‹ Logic (å…³é”®ä¿®å¤ç‚¹)
                const { tasks: isTaskMode, time: isTimeMode, orch: isOrchMode } = csvImportConfig.importTypes;
                let hasChanges = false;

                if (existingTask) {
                    const norm = str => (str || '').toString().trim();

                    // åªæœ‰å¼€å¯äº† Time æ¨¡å¼ï¼Œä¸”æ—¶é•¿çœŸçš„å˜äº†ï¼Œæ‰ç®—å˜æ›´
                    if (isTimeMode) {
                        const oldDur = norm(existingTask.musicDuration || '00:00');
                        const newDur = norm(newItem.duration);
                        if (oldDur !== newDur) hasChanges = true;
                    }

                    // åªæœ‰å¼€å¯äº† Orch æ¨¡å¼ï¼Œä¸”ç¼–åˆ¶çœŸçš„å˜äº†ï¼Œæ‰ç®—å˜æ›´
                    if (isOrchMode) {
                        const oldOrch = norm(existingTask.orchestration);
                        const newOrch = norm(newItem.orchestration);
                        if (oldOrch !== newOrch) hasChanges = true;
                    }
                }

                const calculateStatus = (hasData) => {
                    if (!hasData) return 'SKIP';
                    if (newItem.isDuplicate) {
                        // åªæœ‰æ£€æµ‹åˆ°å®è´¨æ€§å˜æ›´ (hasChanges = true) æ‰æ˜¾ç¤º UPDATE
                        if (hasChanges) return 'UPDATE';
                        // å¦åˆ™å³ä¾¿æ˜¯é‡å¤ä»»åŠ¡ï¼Œä¹Ÿè§†ä¸ºâ€œå·²å­˜åœ¨ä¸”æ— é¡»æ›´æ–°â€ -> SKIP
                        return 'SKIP';
                    }
                    return isTaskMode ? 'NEW' : 'SKIP';
                };

                newItem.recStatusText = calculateStatus(hasRecData);
                newItem.editStatusText = calculateStatus(hasEditData);

                // é»˜è®¤é€‰ä¸­é€»è¾‘ï¼šåªæœ‰ä¸æ˜¯ SKIP çš„æ‰é€‰ä¸­
                const currentStatus = activeImportTab.value === 'rec' ? newItem.recStatusText : newItem.editStatusText;
                newItem.selected = (currentStatus !== 'SKIP');

                targetList.push(newItem);
            };

            // 4. è¾…åŠ©ï¼šå…¨å±€æ—¥ç¨‹å—è‡ªåŠ¨è°ƒæ•´
            const autoResizeSchedules = (taskIds) => {
                console.log("æ‰§è¡Œå…¨å±€è‡ªåŠ¨è°ƒæ•´...");
                // æ­¤å¤„å¡«å…¥ä½ æœ€åˆä»£ç æœ«å°¾çš„é‚£ä¸ª taskMap.forEach å¾ªç¯é€»è¾‘
                // å®ƒä¼šè‡ªåŠ¨è®¡ç®—æ‰€æœ‰å—å½±å“æ—¥ç¨‹å—çš„ minMins å’Œ maxMinsï¼Œå¹¶æ›´æ–° scheduledTasks çš„ startTime å’Œ estDuration
            };

            // ğŸŸ¢ [æ–°å¢] è®¾ç½®é¡¹é‡å‘½åå¤„ç† (æ”¯æŒé‡åè‡ªåŠ¨åˆå¹¶)
            const handleItemRename = (type, item, event) => {
                const newName = event.target.value.trim();
                const oldName = item.name;

                // 1. ç©ºå€¼æˆ–æœªå˜æ£€æŸ¥
                if (!newName) {
                    event.target.value = oldName; // å›æ»š
                    return;
                }
                if (newName === oldName) return;

                // 2. ç¡®å®šæ•°æ®æº
                let list = [];
                let idKey = '';
                if (type === 'instrument') { list = settings.instruments; idKey = 'instrumentId'; }
                else if (type === 'musician') { list = settings.musicians; idKey = 'musicianId'; }
                else if (type === 'project') { list = settings.projects; idKey = 'projectId'; }

                // 3. æ£€æŸ¥é‡å (æ’é™¤è‡ªèº«)
                const targetItem = list.find(i => i.name.toLowerCase() === newName.toLowerCase() && i.id !== item.id);

                if (targetItem) {
                    // === ğŸš¨ å‘ç°é‡å -> è§¦å‘åˆå¹¶æµç¨‹ ===

                    // å…ˆå›æ»šè¾“å…¥æ¡†æ˜¾ç¤ºï¼Œç­‰å¾…ç”¨æˆ·ç¡®è®¤
                    event.target.value = oldName;

                    openConfirmModal(
                        'åˆå¹¶æ¡ç›®',
                        `æ£€æµ‹åˆ° "${targetItem.name}" å·²å­˜åœ¨ã€‚\nç¡®å®šè¦å°† "${oldName}" åˆå¹¶å½’å…¥ "${targetItem.name}" å—ï¼Ÿ\n\nâš  è­¦å‘Šï¼š\n1. "${oldName}" ä¸‹çš„æ‰€æœ‰ä»»åŠ¡å°†è½¬ç§»ç»™ "${targetItem.name}"ã€‚\n2. "${oldName}" å°†è¢«æ°¸ä¹…åˆ é™¤ã€‚\n3. æ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`,
                        () => {
                            // --- æ‰§è¡Œåˆå¹¶ ---

                            // A. è¿ç§»ä»»åŠ¡æ±  (Pool)
                            itemPool.value.forEach(task => {
                                if (task[idKey] === item.id) {
                                    task[idKey] = targetItem.id;
                                }
                            });

                            // B. è¿ç§»æ—¥ç¨‹è¡¨ (Scheduled Tasks)
                            scheduledTasks.value.forEach(task => {
                                if (task[idKey] === item.id) {
                                    task[idKey] = targetItem.id;
                                }
                            });

                            // C. åˆ é™¤æ—§æ¡ç›® (Source Item)
                            const idx = list.findIndex(i => i.id === item.id);
                            if (idx !== -1) {
                                list.splice(idx, 1);
                            }

                            // D. è§¦å‘å…³è”æ›´æ–° (å¦‚æ•ˆç‡å€¼é‡ç®—)
                            // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬è§¦å‘ç›®æ ‡å¯¹è±¡çš„æ•ˆç‡æ›´æ–°ï¼Œä»¥é˜²åˆå¹¶è¿‡æ¥çš„æ•°æ®å½±å“äº†å¹³å‡å€¼
                            if (type === 'musician') {
                                autoUpdateEfficiency(targetItem.id, 'musician', false);
                            }

                            // E. ä¿å­˜ä¸åé¦ˆ
                            pushHistory();
                            window.triggerTouchHaptic('Success');
                            openAlertModal("åˆå¹¶æˆåŠŸ", `å·²å°†ç›¸å…³ä»»åŠ¡å…¨éƒ¨è½¬ç§»è‡³ "${targetItem.name}"ã€‚`);
                        },
                        true, // isDestructive (çº¢è‰²ç¡®è®¤æŒ‰é’®)
                        'ç¡®è®¤åˆå¹¶',
                        'å–æ¶ˆ'
                    );
                } else {
                    // === âœ… æ— é‡å -> æ­£å¸¸æ”¹å ===
                    item.name = newName;
                    pushHistory();
                }
            };

            // ğŸŸ¢ [æ–°å¢] å½•éŸ³å…ƒæ•°æ®é‡å‘½å (æ”¯æŒçº§è”æ›´æ–°ä»»åŠ¡ + è‡ªåŠ¨åˆå¹¶)
            const handleRecRename = (type, item, event) => {
                const newName = event.target.value.trim();
                const oldName = item.name; // è®°å½•ä¿®æ”¹å‰çš„åå­—

                // 1. åŸºç¡€æ£€æŸ¥
                if (!newName) {
                    event.target.value = oldName; // ä¸èƒ½ä¸ºç©ºï¼Œå›æ»š
                    return;
                }
                if (newName === oldName) return; // æ²¡å˜åŒ–

                // 2. è·å–å¯¹åº”çš„åˆ—è¡¨ (studio -> studios)
                const listKey = type + 's';
                const list = settings[listKey];
                if (!list) return;

                // 3. æŸ¥é‡ï¼šæ£€æŸ¥æ˜¯å¦æ”¹æˆäº†å·²å­˜åœ¨çš„åå­—
                const existing = list.find(i => i.name.toLowerCase() === newName.toLowerCase() && i.id !== item.id);

                // å®šä¹‰æ›´æ–°ä»»åŠ¡çš„é€šç”¨é€»è¾‘
                const updateAllTasks = (targetName) => {
                    let count = 0;
                    // æ›´æ–°ä»»åŠ¡æ± 
                    itemPool.value.forEach(t => {
                        if (t.recordingInfo && t.recordingInfo[type] === oldName) {
                            t.recordingInfo[type] = targetName;
                            count++;
                        }
                    });
                    // æ›´æ–°æ—¥ç¨‹è¡¨
                    scheduledTasks.value.forEach(t => {
                        if (t.recordingInfo && t.recordingInfo[type] === oldName) {
                            t.recordingInfo[type] = targetName;
                            count++;
                        }
                    });
                    return count;
                };

                if (existing) {
                    // === ğŸ…°ï¸ å‘ç°é‡å -> è§¦å‘åˆå¹¶æµç¨‹ ===
                    event.target.value = oldName; // å…ˆåœ¨ UI ä¸Šå›æ»šï¼Œç­‰å¾…ç¡®è®¤

                    openConfirmModal(
                        'åˆå¹¶æ¡ç›®',
                        `æ£€æµ‹åˆ° "${existing.name}" å·²å­˜åœ¨ã€‚\nç¡®å®šè¦å°† "${oldName}" åˆå¹¶å½’å…¥ "${existing.name}" å—ï¼Ÿ\n\nâš  æ³¨æ„ï¼šæ‰€æœ‰ä½¿ç”¨ "${oldName}" çš„ä»»åŠ¡éƒ½å°†è‡ªåŠ¨æ›´æ–°ã€‚`,
                        () => {
                            // 1. æ›´æ–°æ‰€æœ‰ä»»åŠ¡
                            updateAllTasks(existing.name);

                            // 2. åˆ é™¤å½“å‰æ¡ç›® (å› ä¸ºåˆå¹¶åˆ°äº† existing)
                            const idx = list.findIndex(i => i.id === item.id);
                            if (idx !== -1) list.splice(idx, 1);

                            // 3. ä¿å­˜
                            pushHistory();
                            window.triggerTouchHaptic('Success');
                            openAlertModal("åˆå¹¶æˆåŠŸ", `ç›¸å…³ä»»åŠ¡ä¿¡æ¯å·²æ›´æ–°ä¸º "${existing.name}"ã€‚`);
                        },
                        true, // çº¢è‰²æŒ‰é’®
                        'ç¡®è®¤åˆå¹¶'
                    );
                } else {
                    // === ğŸ…±ï¸ æ— é‡å -> ç›´æ¥é‡å‘½å ===

                    // 1. æ›´æ–°è®¾ç½®é¡¹æœ¬èº«
                    item.name = newName;

                    // 2. çº§è”æ›´æ–°æ‰€æœ‰å¼•ç”¨äº†æ—§åå­—çš„ä»»åŠ¡
                    updateAllTasks(newName);

                    // 3. ä¿å­˜
                    pushHistory();
                    window.triggerTouchHaptic('Success');
                }
            };

            // --- V9.7.4 åç§°å’Œé¢œè‰²æŸ¥æ‰¾å™¨ (æ–°å¢é¡¹ç›®ç±»å‹) ---
            const getNameById = (id, type) => {
                if (!id) return 'æœªé€‰æ‹©'; // è¿™é‡Œçš„æ–‡å­—å¯¹åº”ä½ çš„æˆªå›¾

                // ç¡®ä¿ list è·å–æ­£ç¡®
                const list = type === 'instrument' ? settings.instruments :
                    type === 'musician' ? settings.musicians :
                        type === 'project' ? settings.projects : [];

                // ğŸŸ¢ å…³é”®: ä½¿ç”¨ == è€Œä¸æ˜¯ ===ï¼Œé˜²æ­¢ id ç±»å‹(string/number)ä¸ä¸€è‡´å¯¼è‡´æ‰¾ä¸åˆ°
                const item = list.find(i => i.id == id);

                return item ? item.name : (type === 'project' ? 'æœªçŸ¥é¡¹ç›®' : (type === 'instrument' ? 'æœªçŸ¥ä¹å™¨' : 'æœªçŸ¥æ¼”å¥å‘˜'));
            };

            // ğŸŸ¢ ä¿®æ”¹: getGroupColor (å¼ºåˆ¶ç»Ÿä¸€é¢œè‰²ï¼šç´«/é‡‘/è“)
            const getGroupColor = (item, key, isBorder) => {
                // è¿™é‡Œçš„ key å†³å®šäº†æˆ‘ä»¬è¦è·å–å“ªç§ç±»å‹çš„é¢œè‰²

                // 1. æ¼”å¥å‘˜ = ç´«è‰²
                if (key === 'musicianId') return '#a855f7';

                // 2. é¡¹ç›® = é‡‘è‰²
                if (key === 'projectId') return '#eab308';

                // 3. ä¹å™¨ = è“è‰²
                if (key === 'instrumentId') return '#3b82f6';

                // é»˜è®¤ç°è‰²
                return isBorder ? '#9ca3af' : '#f3f4f6';
            };

            // V9.5 ä»»åŠ¡ç§»åŠ¨åŠ©æ‰‹ï¼šæ·»åŠ åˆ†é’Ÿ
            const addMinutesToTime = (timeStr, minutes) => {
                const currentMins = timeToMinutes(timeStr);
                let newMins = currentMins + minutes;

                const minTime = settings.startHour * 60;
                const maxTime = settings.endHour * 60 - 30;

                newMins = Math.max(minTime, Math.min(maxTime, newMins));
                newMins = Math.round(newMins / 30) * 30;

                const h = Math.floor(newMins / 60);
                const m = newMins % 60;
                return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
            };

            // V9.5 ä»»åŠ¡ç§»åŠ¨åŠ©æ‰‹ï¼šæ·»åŠ å¤©æ•°
            const addDaysToDate = (dateStr, days) => {
                const d = new Date(dateStr);
                d.setDate(d.getDate() + days);
                return formatDate(d);
            };

            const onMusicianSelect = () => {
                const m = settings.musicians.find(x => x.id === newItem.musicianId);
                if (m) newItem.ratio = m.defaultRatio;
            };

            const addItemToPool = () => {
                if (!newItem.projectId || !newItem.instrumentId || !newItem.musicianId || !newItem.musicDuration) {
                    openAlertModal('ä¿¡æ¯ä¸å®Œæ•´', 'è¯·åŠ¡å¿…å¡«å†™æ‰€æœ‰ä¿¡æ¯');
                    return;
                }

                const rMusician = getDefaultRatio(newItem.musicianId, 'musician');
                const baseInstName = getNameById(newItem.instrumentId, 'instrument');

                // ğŸŸ¢ ä¿®æ”¹: ä¼˜å…ˆä½¿ç”¨è‡ªåŠ¨è¯†åˆ«çš„å…·ä½“åå­— (Flute 1/2)ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨åŸºç¡€å
                let finalName = newItem._autoSuggestedName || baseInstName;

                // æ£€æŸ¥é‡å¤å¹¶è‡ªåŠ¨ç¼–å· (å¦‚æœåå­—å®Œå…¨ä¸€æ ·æ‰ç¼–å·)
                // æ¯”å¦‚å¦‚æœå·²ç»æœ‰äº† "Flute 1", æ–°æ¥çš„ä¹Ÿæ˜¯ "Flute 1", æ‰ä¼šå˜æˆ "Flute 1 2"
                // ä½†å¦‚æœæ–°æ¥çš„æ˜¯ "Flute 2", åˆ™ä¸ä¼šå†²çª
                const siblings = itemPool.value.filter(t =>
                    (t.sessionId || 'S_DEFAULT') === currentSessionId.value &&
                    t.projectId === newItem.projectId &&
                    t.instrumentId === newItem.instrumentId &&
                    t.name === finalName // åªæ£€æŸ¥å®Œå…¨åŒåçš„
                );

                if (siblings.length > 0) {
                    finalName = `${finalName} ${siblings.length + 1}`;
                }

                const rawItem = {
                    id: generateUniqueId('T'),
                    sessionId: currentSessionId.value,
                    projectId: newItem.projectId,
                    instrumentId: newItem.instrumentId,
                    musicianId: newItem.musicianId,
                    musicDuration: newItem.musicDuration,
                    orchestration: '',
                    ratios: { musician: null, project: null, instrument: null },
                    ratio: rMusician,
                    estDuration: calculateEstTime(newItem.musicDuration, rMusician),
                    name: finalName // ä½¿ç”¨æ–°åå­—
                };

                const finalItem = ensureItemRecords(rawItem);
                itemPool.value.push(finalItem);

                // æ¸…ç†ä¸´æ—¶æ ‡è®°
                newItem._autoSuggestedName = null;

                pushHistory();
                if(isMobile.value) window.triggerTouchHaptic('Success');
                showMobileTaskInput.value = false;
            };

            // ğŸŸ¢ [é‡å†™] è·å–ä»»åŠ¡å€ç‡ (æ”¯æŒåŠ¨æ€ç»§æ‰¿)
            // é€»è¾‘: å¦‚æœä»»åŠ¡è‡ªå·±æœ‰è®¾å®šå€ç‡ï¼Œå°±ç”¨ä»»åŠ¡çš„ï¼›å¦åˆ™å»è¯»å…¨å±€è®¾ç½®(settings)é‡Œçš„é»˜è®¤å€ç‡
            const getTaskRatio = (item, contextType = null) => {
                if (!item.ratios) ensureItemRecords(item);

                // 1. ç¡®å®šå½“å‰ä¸Šä¸‹æ–‡ç±»å‹
                let type = contextType;
                if (!type) {
                    if (trackListData.value && showTrackList.value) {
                        type = trackListData.value.viewType;
                    } else {
                        type = sidebarTab.value || 'musician';
                    }
                }

                // 2. ä¼˜å…ˆè¯»å–ä»»åŠ¡è‡ªèº«çš„â€œç§æœ‰å€ç‡â€ (Manual Override)
                const localRatio = item.ratios[type];
                if (localRatio && localRatio > 0) {
                    return localRatio;
                }

                // 3. å¦‚æœä»»åŠ¡æ²¡æœ‰ç§æœ‰å€ç‡ï¼Œåˆ™â€œåŠ¨æ€ç»§æ‰¿â€å…¨å±€è®¾ç½®çš„é»˜è®¤å€ç‡
                let targetId = null;
                if (type === 'project') targetId = item.projectId;
                else if (type === 'instrument') targetId = item.instrumentId;
                else targetId = item.musicianId;

                // è°ƒç”¨ä¹‹å‰ä¿®å¥½çš„ getDefaultRatio (åªè¯» settingsï¼Œä¸äº§ç”Ÿæ­»é”)
                return getDefaultRatio(targetId, type);
            };

            // ğŸŸ¢ [æ–°å¢] æ¸…ç†æ—§å€ç‡æ•°æ® (Data Cleaning)
            const cleanOldRatios = () => {
                openConfirmModal(
                    'æ¸…ç†æ—§å€ç‡æ•°æ®',
                    'æ­¤æ“ä½œå°†æŠŠæ‰€æœ‰å€ç‡ä¸º x20 (é»˜è®¤å€¼) çš„ä»»åŠ¡é‡ç½®ä¸ºâ€œè‡ªåŠ¨è·Ÿéšæ¨¡å¼â€ã€‚\n\næ¸…ç†åï¼Œè¿™äº›ä»»åŠ¡å°†ä¸å†é”å®šå€ç‡ï¼Œè€Œæ˜¯å®æ—¶è·Ÿéšå¤§å¡ç‰‡çš„å¹³å‡æ•ˆç‡è®¡ç®—æ—¶é•¿ã€‚\n(æ‰‹åŠ¨è®¾ç½®çš„å…¶ä»–ç‰¹æ®Šå€ç‡ä¸ä¼šå—å½±å“)',
                    () => {
                        let count = 0;

                        // å®šä¹‰å¤„ç†å•æ¡æ•°æ®çš„é€»è¾‘
                        const processItem = (item) => {
                            let changed = false;

                            // ç¡®ä¿ç»“æ„å­˜åœ¨
                            ensureItemRecords(item);

                            // éå†ä¸‰ä¸ªç»´åº¦
                            ['musician', 'project', 'instrument'].forEach(type => {
                                // æ ¸å¿ƒé€»è¾‘ï¼šå¦‚æœå€ç‡ç­‰äº 20ï¼Œå°±è®¾ä¸º null (è‡ªåŠ¨)
                                if (parseFloat(item.ratios[type]) === 20) {
                                    item.ratios[type] = null;
                                    changed = true;
                                }
                            });

                            // å…¼å®¹æ€§æ¸…ç†ï¼šå¦‚æœä¸» ratio ä¹Ÿæ˜¯ 20ï¼Œä¹Ÿå¯ä»¥é‡ç½®ä¸€ä¸‹
                            // (è™½ç„¶ä¸»è¦æ˜¯é  ratios å¯¹è±¡ï¼Œä½†ä¸ºäº†æ•°æ®æ•´æ´)
                            if (parseFloat(item.ratio) === 20) {
                                // è¿™é‡Œä¸ç½®ç©ºï¼Œä¿ç•™æ•°å€¼ç±»å‹ï¼Œä½†åœ¨ä¸‹æ¬¡è®¡ç®—æ—¶å®ƒä¼šè¢«è¦†ç›–
                            }

                            if (changed) count++;
                        };

                        // 1. æ¸…ç†ä»»åŠ¡æ± 
                        itemPool.value.forEach(processItem);

                        // 2. æ¸…ç†æ—¥ç¨‹è¡¨
                        scheduledTasks.value.forEach(processItem);

                        // 3. å¼ºåˆ¶ä¿å­˜å¹¶åé¦ˆ
                        pushHistory();

                        // è§¦å‘ä¸€æ¬¡å…¨å±€é‡ç®—ï¼Œç¡®ä¿ç•Œé¢æ—¶é•¿ç«‹å³åˆ·æ–°
                        // (è™½ç„¶ calculateGroupStats æ˜¯è‡ªåŠ¨çš„ï¼Œä½†è¿™é‡Œæ‰‹åŠ¨è§¦å‘ä¸€ä¸‹æ›´ç¨³)
                        if (musicianStats.value.length > 0) {
                            // éšæ„è§¦å‘ä¸€ä¸ªæ›´æ–°æ¥å¼ºåˆ¶è§†å›¾é‡ç»˜
                            const firstId = musicianStats.value[0].id;
                            autoUpdateEfficiency(firstId, 'musician', false);
                        }

                        window.triggerTouchHaptic('Success');
                        openAlertModal('æ¸…ç†å®Œæˆ', `å·²æˆåŠŸå°† ${count} ä¸ªä»»åŠ¡é‡ç½®ä¸ºè‡ªåŠ¨è·Ÿéšæ¨¡å¼ã€‚\nç°åœ¨å®ƒä»¬ä¼šä¹–ä¹–è·Ÿéšå¤§å¡ç‰‡çš„æ•ˆç‡äº†ï¼`);
                    },
                    false, // éç ´åæ€§æ“ä½œ (è™½ç„¶æ”¹äº†æ•°æ®ï¼Œä½†æ˜¯æ˜¯è‰¯æ€§çš„)
                    'ç«‹å³æ¸…ç†'
                );
            };

            // ğŸŸ¢ ä¿®å¤: åˆ—è¡¨åˆ†ç»„æŠ˜å  (æ–°å¢éœ‡åŠ¨åé¦ˆ)
            const toggleCollapse = (groupKey) => {
                if (isMobile.value) window.triggerTouchHaptic('Medium'); // ğŸŸ¢ å¢åŠ éœ‡åŠ¨åé¦ˆ

                if (expandedGroups.has(groupKey)) {
                    expandedGroups.delete(groupKey);
                } else {
                    expandedGroups.add(groupKey);
                }
            };

            // --- Drag & Drop ---
            let draggedData = null;
            // ğŸŸ¢ ä¿®æ”¹: æ‹–æ‹½å¼€å§‹æ—¶ï¼Œè®¡ç®—é¼ æ ‡ç›¸å¯¹äºä»»åŠ¡é¡¶éƒ¨çš„åç§»é‡
            const dragStart = (e, item, source) => {
                let offsetMinutes = 0;

                // å¦‚æœæ˜¯æ‹–åŠ¨æ—¥ç¨‹è¡¨ä¸Šçš„ä»»åŠ¡
                if (source === 'schedule' && e.target) {
                    const rect = e.target.getBoundingClientRect();
                    // è®¡ç®—é¼ æ ‡è·ç¦»ä»»åŠ¡é¡¶éƒ¨çš„åƒç´ è·ç¦»
                    const offsetY = e.clientY - rect.top;
                    // å°†åƒç´ è½¬æ¢ä¸ºåˆ†é’Ÿ (pxPerMin.value æ˜¯æ¯åˆ†é’Ÿçš„é«˜åº¦)
                    const rawMinutes = offsetY / pxPerMin.value;
                    // å‘ä¸‹å–æ•´åˆ°æœ€è¿‘çš„ 30 åˆ†é’Ÿåˆ»åº¦ï¼Œä¿è¯å¸é™„
                    offsetMinutes = Math.floor(rawMinutes / 30) * 30;
                }

                // å°† offsetMinutes å­˜å…¥ draggedData
                draggedData = {item, source, isCopy: e.altKey, offsetMinutes};

                e.dataTransfer.effectAllowed = 'move';

                // ... (åç»­çš„å…‹éš†æ ·å¼é€»è¾‘ä¿æŒä¸å˜) ...
                if (source === 'schedule' && e.target) {
                    const clone = e.target.cloneNode(true);
                    // ... (å…‹éš†æ ·å¼ä»£ç çœç•¥ï¼Œä¿æŒåŸæ ·å³å¯) ...
                    clone.classList.remove('is-selected');
                    clone.style.setProperty('opacity', '0.4', 'important');
                    clone.style.position = 'absolute';
                    clone.style.top = '-9999px';
                    clone.style.zIndex = '9999';
                    clone.style.width = `${e.target.offsetWidth}px`;
                    document.body.appendChild(clone);
                    // è¿™é‡Œä¸ºäº†è§†è§‰å¯¹é½ï¼Œæ‹–æ‹½æ—¶çš„â€œæŠŠæ‰‹â€ä½ç½®ä¹Ÿå»ºè®®å‡å» offset
                    // ä½†ä¸ºäº†ç®€å•ï¼ŒåŸæœ‰çš„ setDragImage é€»è¾‘é€šå¸¸å¤Ÿç”¨äº†ï¼Œè¿™é‡Œåªç”¨æ”¹æ•°æ®é€»è¾‘
                    const rect = e.target.getBoundingClientRect();
                    const offsetX = e.clientX - rect.left;
                    const offsetY = e.clientY - rect.top;
                    e.dataTransfer.setDragImage(clone, offsetX, offsetY);

                    setTimeout(() => {
                        document.body.removeChild(clone);
                        e.target.classList.add('pointer-events-none');
                        e.target.style.transition = 'none';
                        e.target.style.opacity = '0';
                    }, 0);
                }
            };

            // --- æ–°å¢å¼€å§‹: æ‹–æ‹½ç»“æŸå¤„ç† ---
            const handleDragEnd = (e) => {
                if (e.target) {
                    e.target.classList.remove('pointer-events-none');
                    // æ¸…é™¤è¡Œå†…æ ·å¼ï¼Œæ¢å¤ CSS ç±»ä¸­å®šä¹‰çš„é»˜è®¤æ ·å¼
                    e.target.style.opacity = '';
                    e.target.style.transition = '';
                }
                draggedData = null;
            };
            // --- æ–°å¢ç»“æŸ ---

            const dragEnterPool = e => e.currentTarget.classList.add('drag-over');
            const dragLeavePool = e => e.currentTarget.classList.remove('drag-over');

            // ğŸŸ¢ ä¿®å¤: æ‹–åŠ¨å·²æ’ç¨‹ä»»åŠ¡å›ä»»åŠ¡æ±  (åŒæ­¥æ‰§è¡Œæ•°æ®æ¸…ç†)
            const dropToPool = e => {
                e.currentTarget.classList.remove('drag-over');
                if (!draggedData) return;

                // ä»…å¤„ç†ä»æ—¥ç¨‹è¡¨æ‹–å›çš„æƒ…å†µ
                if (draggedData.source === 'schedule') {
                    const taskToDelete = draggedData.item;

                    // ğŸŸ¢ æ–°å¢: æ‹¦æˆªå·²å®Œæˆä»»åŠ¡
                    if (isResourceCompleted(taskToDelete)) {
                        window.triggerTouchHaptic('Error');
                        return openAlertModal("æ“ä½œè¢«æ‹’ç»", "è¯¥ä»»åŠ¡æ‰€å±å¯¹è±¡å·²å¤„äºã€å®Œæˆã€‘çŠ¶æ€ï¼Œç¦æ­¢ç§»å›ä»»åŠ¡æ± ã€‚");
                    }

                    // ğŸŸ¢ 1. æ‰§è¡Œæ•°æ®æ¸…ç† (å¤ç”¨é”®ç›˜åˆ é™¤çš„æ ¸å¿ƒé€»è¾‘)
                    if (taskToDelete.templateId) {
                        // æƒ…å†µ A: å•æ›²ä»»åŠ¡ (æœ‰æ˜ç¡® ID) -> æ¸…ç†æŒ‡å®š ID çš„å½•éŸ³æ•°æ®
                        clearPoolRecord(taskToDelete.templateId);
                    } else {
                        // æƒ…å†µ B: èšåˆä»»åŠ¡ (å¤§å¡ç‰‡) -> æ¸…ç†å¯¹åº” Section çš„æ•°æ®å¹¶ä¿®æ­£ç´¢å¼•
                        // æ³¨æ„ï¼šå¿…é¡»ç¡®ä¿ clearAggregateRecords å‡½æ•°å·²å®šä¹‰ä¸”åœ¨ä½œç”¨åŸŸå†…
                        if (typeof clearAggregateRecords === 'function') {
                            clearAggregateRecords(taskToDelete);
                        } else {
                            console.error("æ‰¾ä¸åˆ° clearAggregateRecords å‡½æ•°ï¼Œæ— æ³•æ¸…ç†èšåˆæ•°æ®");
                        }
                    }

                    // ğŸŸ¢ 2. ç‰©ç†åˆ é™¤æ—¥ç¨‹å—
                    scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== taskToDelete.scheduleId);

                    // 3. åé¦ˆä¸ä¿å­˜
                    if (isMobile.value) window.triggerTouchHaptic('Medium');
                    pushHistory();
                }

                draggedData = null;
            };

            const dragEnterSlot = e => {
                if (e.target.closest('.droppable-slot')) e.target.closest('.droppable-slot').classList.add('drag-over');
            };
            const dragLeaveSlot = e => {
                if (e.target.closest('.droppable-slot')) e.target.closest('.droppable-slot').classList.remove('drag-over');
            };
            // ğŸŸ¢ ä¿®æ”¹: dropToSchedule (åŠ å…¥é˜²é‡å æ£€æµ‹)
            // ğŸŸ¢ [é‡å†™] dropToSchedule (åŸºäºåæ ‡è®¡ç®—ï¼Œè§£å†³é®æŒ¡é—®é¢˜)
            const dropToSchedule = (e, dateStr) => {
                // æ¸…é™¤é«˜äº®æ ·å¼
                document.querySelectorAll('.grid-slot.drag-over').forEach(el => el.classList.remove('drag-over'));

                if (!draggedData) return;

                // 1. è·å–åˆ—å®¹å™¨ (Column) å’Œ æ—¶é—´å®¹å™¨ (Grid Container)
                // æ— è®º e.target æ˜¯ slot è¿˜æ˜¯ task-blockï¼Œå¾€ä¸Šæ‰¾éƒ½èƒ½æ‰¾åˆ° data-date-str
                const colEl = e.target.closest('[data-date-str]');
                if (!colEl) return;

                const container = colEl.querySelector('.relative[style*="min-height"]');
                if (!container) return;

                const {item, source, offsetMinutes} = draggedData;

                // 2. åŸºäºé¼ æ ‡ Y åæ ‡è®¡ç®—æ—¶é—´ (è€Œä¸æ˜¯ä¾èµ– slot.dataset.time)
                const rect = container.getBoundingClientRect();
                const relativeY = e.clientY - rect.top; // é¼ æ ‡åœ¨å®¹å™¨å†…çš„ç›¸å¯¹é«˜åº¦

                // å¦‚æœæ˜¯ä»æ—¥ç¨‹å†…éƒ¨æ‹–åŠ¨ï¼Œéœ€è¦å‡å»é¼ æ ‡æŠ“å–ä½ç½®çš„åç§»ï¼Œä¿æŒè§†è§‰ä¸è·³åŠ¨
                let adjustY = relativeY;
                if (source === 'schedule' && offsetMinutes) {
                    adjustY -= (offsetMinutes * pxPerMin.value);
                }

                // è½¬æ¢ä¸ºåˆ†é’Ÿ
                const rawMins = adjustY / pxPerMin.value;
                // åŠ ä¸Šèµ·å§‹å°æ—¶ (å¦‚ 10:00)
                const totalMins = (settings.startHour * 60) + rawMins;

                // å¸é™„åˆ° 30 åˆ†é’Ÿç½‘æ ¼
                let snappedMins = Math.round(totalMins / 30) * 30;

                // è¾¹ç•Œé™åˆ¶
                const minStart = settings.startHour * 60;
                const maxStart = settings.endHour * 60 - 30; // è‡³å°‘ç•™30åˆ†é’Ÿ
                snappedMins = Math.max(minStart, Math.min(maxStart, snappedMins));

                // ç”Ÿæˆ HH:MM å­—ç¬¦ä¸²
                const h = Math.floor(snappedMins / 60);
                const m = snappedMins % 60;
                const newStartTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

                // 3. å‡†å¤‡æ£€æµ‹å‚æ•°
                let checkType = 'musician'; // é»˜è®¤ä¸ºäººå‘˜
                let newDuration = '';
                let excludeId = null;

                if (source === 'aggregate') {
                    // ä»ä¾§è¾¹æ æ‹–å…¥ï¼šç±»å‹ç”±å½“å‰ Tab å†³å®š
                    checkType = sidebarTab.value;
                    // è®¡ç®—ç»Ÿè®¡å¡ç‰‡å‰©ä½™æ—¶é•¿
                    const remainingSecs = item.totalSeconds - item.scheduledSeconds;
                    if (remainingSecs <= 0) {
                        pushHistory(); // ç”šè‡³å¯èƒ½æ— æ³•æ‹–åŠ¨ï¼Œè¿™é‡Œåšä¸ªé˜²å¾¡
                        draggedData = null;
                        return;
                    }
                    let remainingMins = Math.ceil(remainingSecs / 1800) * 30;
                    if (remainingMins === 0) remainingMins = 30;
                    newDuration = formatSecs(remainingMins * 60);

                } else if (source === 'schedule') {
                    // æ—¥ç¨‹å†…éƒ¨ç§»åŠ¨
                    if (item.projectId) checkType = 'project';
                    else if (item.instrumentId) checkType = 'instrument';

                    newDuration = item.estDuration;
                    excludeId = item.scheduleId; // ç§»åŠ¨æ—¶æ’é™¤è‡ªå·±

                } else if (source === 'pool') {
                    // ä»ä»»åŠ¡æ± æ‹–å…¥
                    if (item.projectId) checkType = 'project';
                    else if (item.instrumentId) checkType = 'instrument';

                    newDuration = item.estDuration;
                }

                // 4. æ‰§è¡Œå†²çªæ£€æµ‹
                // æ³¨æ„ï¼šcheckOverlap å†…éƒ¨å·²ç»åŒ…å«äº† "ä¸åŒç±»å‹å…è®¸é‡å " çš„é€»è¾‘ (tType !== checkType return false)
                if (checkOverlap(dateStr, newStartTime, newDuration, excludeId, checkType)) {
                    openAlertModal('æ—¶é—´å†²çª', 'è¯¥æ—¶é—´æ®µå·²æœ‰åŒç±»å‹çš„å…¶ä»–å®‰æ’ã€‚');
                    window.triggerTouchHaptic('Error');
                    draggedData = null;
                    return;
                }

                // 5. æ‰§è¡Œæ”¾ç½®é€»è¾‘ (Create / Update)
                if (source === 'aggregate') {
                    const nt = {
                        scheduleId: Date.now(),
                        sessionId: currentSessionId.value,
                        musicianId: sidebarTab.value === 'musician' ? item.id : '',
                        projectId: sidebarTab.value === 'project' ? item.id : '',
                        instrumentId: sidebarTab.value === 'instrument' ? item.id : '',
                        date: dateStr,
                        startTime: newStartTime,
                        estDuration: newDuration,
                        trackCount: item.trackCount,
                        ratio: item.defaultRatio || 20,
                        reminderMinutes: 15,
                        sound: 'default'
                    };
                    scheduledTasks.value.push(nt);
                    window.triggerTouchHaptic('Success');

                } else if (source === 'schedule') {
                    const idx = scheduledTasks.value.findIndex(t => t.scheduleId === item.scheduleId);
                    if (idx !== -1) {
                        // å¿…é¡»æ·±æ‹·è´å¹¶æ›´æ–°ï¼Œç¡®ä¿ Vue å“åº”å¼è§¦å‘
                        const nt = JSON.parse(JSON.stringify(item));
                        nt.date = dateStr;
                        nt.startTime = newStartTime;
                        scheduledTasks.value[idx] = nt;
                        window.triggerTouchHaptic('Success');
                    }

                } else if (source === 'pool') {
                    const nt = {
                        scheduleId: Date.now(),
                        templateId: item.id,
                        sessionId: currentSessionId.value,
                        projectId: item.projectId,
                        instrumentId: item.instrumentId,
                        musicianId: item.musicianId,
                        musicDuration: item.musicDuration,
                        ratio: item.ratio,
                        estDuration: item.estDuration,
                        date: dateStr,
                        startTime: newStartTime,
                        reminderMinutes: 15,
                        sound: 'default'
                    };
                    scheduledTasks.value.push(nt);
                    window.triggerTouchHaptic('Success');
                }

                pushHistory();
                draggedData = null;
            };

            // ğŸŸ¢ ä¿®æ”¹: dropToMonth (åŠ å…¥é˜²é‡å æ£€æµ‹)
            const dropToMonth = (e, dateStr) => {
                document.querySelectorAll('.droppable-slot.drag-over').forEach(el => el.classList.remove('drag-over'));
                if (!draggedData) return;
                const {item, source} = draggedData;

                // 1. ç¡®å®šç›®æ ‡æ—¶é—´å’Œæ—¶é•¿
                let targetStartTime = settings.startHour + ':00'; // é»˜è®¤æ’åœ¨å¼€å¤´
                let targetDuration = '';
                let excludeId = null;
                let checkType = 'musician';
                if (source === 'aggregate') {
                    checkType = sidebarTab.value;
                } else {
                    if (item.projectId) checkType = 'project';
                    else if (item.instrumentId) checkType = 'instrument';
                }

                if (source === 'schedule') {
                    targetStartTime = item.startTime; // ä¿æŒåŸæœ‰æ—¶é—´ä¸å˜
                    targetDuration = item.estDuration;
                    excludeId = item.scheduleId;
                } else {
                    // æ–°ä»»åŠ¡é»˜è®¤æ—¶é•¿ 30åˆ†é’Ÿ æˆ– å‰©ä½™æ—¶é•¿
                    targetDuration = item.estDuration || '00:30';
                }

                if (checkOverlap(dateStr, targetStartTime, targetDuration, excludeId, checkType)) {
                    openAlertModal('æ—¶é—´å†²çª', 'è¯¥æ—¥æœŸå·²æœ‰åŒç±»å‹çš„å…¶ä»–å®‰æ’ã€‚');
                    window.triggerTouchHaptic('Error');
                    draggedData = null;
                    return;
                }

                // --- 3. é€šè¿‡æ£€æµ‹ï¼Œæ‰§è¡ŒåŸæœ‰é€»è¾‘ ---
                if (source === 'schedule') {
                    const task = scheduledTasks.value.find(t => t.scheduleId === item.scheduleId);
                    if (task) {
                        task.date = dateStr;
                        pushHistory();
                    }
                } else if (source === 'aggregate' || source === 'pool') {
                    // ... (ä¿æŒä½ ä¸Šä¸€è½®æ”¹å¥½çš„æ„å»º ID çš„é€»è¾‘) ...
                    let mId = '', pId = '', iId = '';
                    let ratio = 20;
                    let estDur = '00:30';
                    let tCount = 0;
                    let musDur = '';

                    if (source === 'pool') {
                        mId = item.musicianId;
                        pId = item.projectId;
                        iId = item.instrumentId;
                        ratio = item.ratio;
                        estDur = item.estDuration;
                        musDur = item.musicDuration;
                    } else {
                        if (sidebarTab.value === 'musician') mId = item.id;
                        else if (sidebarTab.value === 'project') pId = item.id;
                        else if (sidebarTab.value === 'instrument') iId = item.id;
                        ratio = item.defaultRatio || 20;
                        estDur = item.estDuration || '00:30';
                        tCount = item.trackCount || 0;
                    }
                    const tId = source === 'pool' ? item.id : undefined;

                    const nt = {
                        scheduleId: Date.now(),
                        templateId: tId, // <--- æ·»åŠ è¿™è¡Œ
                        sessionId: currentSessionId.value,
                        musicianId: mId,
                        projectId: pId,
                        instrumentId: iId,
                        date: dateStr,
                        startTime: targetStartTime,
                        estDuration: estDur,
                        trackCount: tCount,
                        ratio: ratio,
                        musicDuration: musDur,
                        reminderMinutes: 15,
                        sound: 'default'
                    };
                    scheduledTasks.value.push(nt);
                    pushHistory();
                }
                draggedData = null;
            };


            const initResize = (e, t) => {
                e.preventDefault();
                e.stopPropagation();
                const el = e.target.closest('.task-block');
                resizing.value = {
                    task: t,
                    startY: e.clientY,
                    startH: el.offsetHeight,
                    // ğŸŸ¢ è®°å½•åŸå§‹æ—¶é•¿ä»¥ä¾¿å›é€€
                    originalDuration: t.estDuration
                };
                document.body.style.cursor = 'ns-resize';
            };


            // ğŸŸ¢ ä¿®æ”¹: è°ƒæ•´æ—¶é•¿ (å¸é™„åˆ° Grid ç»å¯¹æ—¶é—´åˆ»åº¦)
            const handleResizeMove = e => {
                if (!resizing.value) return;
                const {task, startY, startH} = resizing.value;

                // 1. è®¡ç®—é¼ æ ‡ç§»åŠ¨åçš„ç‰©ç†é«˜åº¦
                const delta = e.clientY - startY;
                const rawHeight = Math.max(5, startH + delta); // æœ€å° 5px

                // 2. å°†é«˜åº¦è½¬æ¢ä¸ºåˆ†é’Ÿæ•° (ä¸å–æ•´)
                const rawDurationMins = rawHeight / pxPerMin.value;

                // 3. è·å–ä»»åŠ¡å¼€å§‹çš„ç»å¯¹åˆ†é’Ÿæ•° (ä¾‹å¦‚ 10:15 = 615)
                const startMins = timeToMinutes(task.startTime);

                // 4. è®¡ç®—æ‹–åŠ¨åçš„â€œç†è®ºç»“æŸæ—¶é—´â€
                const rawEndMins = startMins + rawDurationMins;

                // 5. ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: å°†ç»“æŸæ—¶é—´å¸é™„åˆ°æœ€è¿‘çš„ 30 åˆ†é’Ÿåˆ»åº¦ (:00 æˆ– :30)
                // è¿™æ ·æ— è®ºå¼€å§‹æ—¶é—´æ˜¯å¤šå°‘(å¦‚10:15)ï¼Œç»“æŸæ—¶é—´æ€»æ˜¯å¯¹é½ç½‘æ ¼çš„(å¦‚10:30, 11:00)
                const snappedEndMins = Math.round(rawEndMins / 30) * 30;

                // 6. åç®—æ–°æ—¶é•¿
                let newDurationMins = snappedEndMins - startMins;

                // 7. æœ€å°ä¿æŠ¤ (é˜²æ­¢è´Ÿæ•°æˆ–0ï¼Œè‡³å°‘ä¿ç•™5åˆ†é’Ÿ)
                if (newDurationMins < 5) newDurationMins = 5;

                // 8. æ›´æ–°è§†å›¾
                const newDurationStr = formatSecs(newDurationMins * 60);
                if (task.estDuration !== newDurationStr) {
                    task.estDuration = newDurationStr;
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: handleResizeEnd
            const handleResizeEnd = () => {
                if (!resizing.value) return;
                const t = resizing.value.task;

                // ç¡®å®šç±»å‹
                let type = 'musician';
                if (t.projectId) type = 'project';
                else if (t.instrumentId) type = 'instrument';

                // ä¼ å…¥ type
                if (checkOverlap(t.date, t.startTime, t.estDuration, t.scheduleId, type)) {
                    t.estDuration = resizing.value.originalDuration;
                    openAlertModal('å†²çª', 'è°ƒæ•´åçš„æ—¶é—´æœ‰é‡å ');
                    window.triggerTouchHaptic('Error');
                } else {
                    // âœ… æ— å†²çªï¼Œæ­£å¸¸ä¿å­˜
                    const m = parseTime(t.musicDuration);
                    const r = parseTime(t.estDuration);
                    if (m > 0) t.ratio = (r / m).toFixed(1);
                    pushHistory();
                }

                resizing.value = null;
                document.body.style.cursor = '';
            };

            // ğŸŸ¢ æ–°å¢: æ»šåŠ¨ä¾§è¾¹æ åˆ°æŒ‡å®š ID
            const scrollToSidebarItem = (targetId) => {
                if (!targetId) return;

                // ç¨å¾®å»¶è¿Ÿï¼Œç¡®ä¿ DOM çŠ¶æ€ç¨³å®š
                setTimeout(() => {
                    // ä½¿ç”¨åˆšæ‰åœ¨ HTML ä¸­æ·»åŠ çš„ data-stat-id æŸ¥æ‰¾å…ƒç´ 
                    const el = document.querySelector(`[data-stat-id="${targetId}"]`);

                    if (el) {
                        el.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center' // æ»šåŠ¨åˆ°è§†å£ä¸­é—´ï¼Œä½“éªŒæ›´å¥½
                        });

                        // å¯é€‰: ç»™ä¸€ä¸ªä¸´æ—¶çš„é—ªçƒé«˜äº®ï¼Œæç¤ºç”¨æˆ·ä½ç½®
                        el.classList.add('ring-2', 'ring-[#ffffff]');
                        setTimeout(() => {
                            el.classList.remove('ring-2', 'ring-[#ffffff]');
                        }, 800);
                    }
                }, 50);
            };

            // ğŸŸ¢ [ä¿®æ”¹] é€‰ä¸­ä»»åŠ¡é€»è¾‘ (å¢å¼ºè·³è½¬èƒ½åŠ›ï¼šæ”¯æŒ Section ç´¢å¼•ç²¾å‡†å®šä½)
            const selectTask = (id, src, event) => {
                // 1. å¦‚æœç‚¹å‡»çš„æ˜¯æ—¥ç¨‹è¡¨ä¸­çš„ä»»åŠ¡
                if (src === 'schedule') {
                    selectedSource.value = src;
                    selectedTaskId.value = id;
                    selectedPoolIds.value.clear();

                    // --- ğŸŸ¢ æ–°å¢éƒ¨åˆ†å¼€å§‹: ä¾§è¾¹æ è”åŠ¨æ»šåŠ¨ ---
                    const task = scheduledTasks.value.find(t => t.scheduleId === id);
                    if (task) {
                        // æ ¹æ®å½“å‰ä¾§è¾¹æ çš„ Tab ç±»å‹ï¼Œå†³å®šæˆ‘ä»¬è¦æ‰¾å“ªä¸ª ID
                        let targetId = null;
                        if (sidebarTab.value === 'project') targetId = task.projectId;
                        else if (sidebarTab.value === 'instrument') targetId = task.instrumentId;
                        else targetId = task.musicianId; // é»˜è®¤ä¸º musician

                        // å¦‚æœæ‰¾åˆ°äº†å…³è” IDï¼Œå¹¶ä¸”ä¾§è¾¹æ æ˜¯æ‰“å¼€çš„ï¼Œæ‰§è¡Œæ»šåŠ¨
                        if (targetId && (isSidebarOpen.value || isMobile.value)) {
                            scrollToSidebarItem(targetId);
                        }
                    }
                    // --- ğŸŸ¢ æ–°å¢éƒ¨åˆ†ç»“æŸ ---

                    return;
                }

                // 2. å¦‚æœç‚¹å‡»çš„æ˜¯ä¾§è¾¹æ (Pool)ä¸­çš„ä»»åŠ¡
                if (src === 'pool') {
                    selectedSource.value = src;
                    selectedTaskId.value = id;
                    lastPoolFocusId.value = id;

                    const isShift = event && event.shiftKey;
                    const isCtrl = event && (event.metaKey || event.ctrlKey);

                    // å•é€‰æ—¶ï¼Œå°è¯•è·³è½¬
                    if (!isShift && !isCtrl) {
                        const poolItem = itemPool.value.find(i => i.id === id);
                        if (poolItem) {
                            // --- ç­–ç•¥ A: ç²¾ç¡®åŒ¹é… (å•æ›²æ¨¡å¼) ---
                            // æ£€æŸ¥æ˜¯å¦æœ‰æ—¥ç¨‹å—ç›´æ¥å¼•ç”¨äº†è¿™ä¸ª templateId
                            let specificTask = scheduledTasks.value.find(t =>
                                (t.sessionId || 'S_DEFAULT') === currentSessionId.value &&
                                t.templateId === id
                            );

                            if (specificTask) {
                                // å¦‚æœæ‰¾åˆ°äº†å…·ä½“çš„æ—¥ç¨‹å—ï¼Œç›´æ¥è·³è¿‡å»
                                smartScrollToTask(specificTask);
                                if (isMobile.value) window.triggerTouchHaptic('Light');
                            } else {
                                // --- ç­–ç•¥ B: èšåˆåŒ¹é… (Section æ¨¡å¼) ---
                                // å¦‚æœæ²¡æœ‰å…·ä½“å¼•ç”¨ï¼Œè¯´æ˜æ˜¯èšåˆåœ¨æŸä¸ªå¤§æ—¥ç¨‹å—é‡Œï¼Œé€šè¿‡ sectionIndex å®šä½

                                // 1. æ ¹æ®å½“å‰ä¾§è¾¹æ è§†å›¾ï¼Œå†³å®šåŒ¹é…å“ªä¸ªç»´åº¦çš„ ID
                                let filterKey = 'musicianId'; // é»˜è®¤æŒ‰äººå‘˜
                                if (sidebarTab.value === 'project') filterKey = 'projectId';
                                else if (sidebarTab.value === 'instrument') filterKey = 'instrumentId';

                                const filterId = poolItem[filterKey];

                                if (filterId) {
                                    // 2. æ‰¾åˆ°è¯¥èµ„æºåœ¨å½“å‰ Session ä¸‹çš„æ‰€æœ‰æ—¥ç¨‹å—
                                    const relatedSchedules = scheduledTasks.value.filter(t =>
                                        (t.sessionId || 'S_DEFAULT') === currentSessionId.value &&
                                        t[filterKey] === filterId
                                    );

                                    // 3. æ’åº (æŒ‰æ—¶é—´é¡ºåºï¼Œç¡®ä¿ç´¢å¼•å¯¹åº”æ­£ç¡®)
                                    relatedSchedules.sort((a, b) => {
                                        if (a.date !== b.date) return a.date.localeCompare(b.date);
                                        return a.startTime.localeCompare(b.startTime);
                                    });

                                    if (relatedSchedules.length > 0) {
                                        // 4. ğŸŸ¢ æ ¸å¿ƒä¿®å¤: ä½¿ç”¨ sectionIndex å®šä½ç›®æ ‡å—
                                        let targetIndex = 0;
                                        if (poolItem.sectionIndex !== undefined && poolItem.sectionIndex >= 0) {
                                            // ç¡®ä¿ç´¢å¼•ä¸è¶Šç•Œ (é˜²æ­¢æ—¥ç¨‹å—è¢«åˆ åç´¢å¼•æœªæ›´æ–°çš„æƒ…å†µ)
                                            targetIndex = Math.min(poolItem.sectionIndex, relatedSchedules.length - 1);
                                        }

                                        const targetTask = relatedSchedules[targetIndex];
                                        smartScrollToTask(targetTask);

                                        // ç»™ä¸ªåé¦ˆ
                                        if (isMobile.value) window.triggerTouchHaptic('Light');
                                    }
                                }
                            }
                        }
                    }

                    // å¤šé€‰é€»è¾‘ (ä¿æŒä¸å˜)
                    if (isShift && lastPoolClickId.value) {
                        const visibleItems = [];
                        if (sidebarTab.value === 'browse') {
                            groupedItemPool.value.forEach(group => {
                                if (expandedGroups.has(group.key)) visibleItems.push(...group.items);
                            });
                        } else {
                            currentSidebarList.value.forEach(stat => {
                                if (expandedStatsIds.has(stat.id)) visibleItems.push(...stat.items);
                            });
                        }
                        const startIdx = visibleItems.findIndex(i => i.id === lastPoolClickId.value);
                        const endIdx = visibleItems.findIndex(i => i.id === id);
                        if (startIdx !== -1 && endIdx !== -1) {
                            const min = Math.min(startIdx, endIdx);
                            const max = Math.max(startIdx, endIdx);
                            for (let i = min; i <= max; i++) {
                                selectedPoolIds.value.add(visibleItems[i].id);
                            }
                        }
                    } else if (isCtrl) {
                        if (selectedPoolIds.value.has(id)) selectedPoolIds.value.delete(id);
                        else selectedPoolIds.value.add(id);
                        lastPoolClickId.value = id;
                    } else {
                        // æ™®é€šå•å‡»ï¼Œé‡ç½®å¤šé€‰
                        selectedPoolIds.value.clear();
                        selectedPoolIds.value.add(id);
                        lastPoolClickId.value = id;
                    }
                }
            };

            // æ›¿æ¢åŸæœ‰çš„ clearSelection å‡½æ•°
            const clearSelection = () => {
                selectedTaskId.value = null;
                selectedSource.value = null;
                selectedPoolIds.value.clear(); // æ–°å¢ï¼šæ¸…ç©ºå¤šé€‰
            };

            // V9.5 ä»»åŠ¡é‡å è®¡ç®—
            const getOverlapCount = (targetTask) => {
                const dayTasks = scheduledTasks.value.filter(t => t.date === targetTask.date);
                const targetStart = timeToMinutes(targetTask.startTime);
                const targetEnd = targetStart + parseTime(targetTask.estDuration) / 60;

                let overlapCount = 0;
                for (const task of dayTasks) {
                    if (task.scheduleId === targetTask.scheduleId) continue;

                    const taskStart = timeToMinutes(task.startTime);
                    const taskEnd = taskStart + parseTime(task.estDuration) / 60;

                    if (targetStart < taskEnd && targetEnd > taskStart) {
                        overlapCount++;
                    }
                }
                return overlapCount;
            };

            // V9.5 ä»»åŠ¡é”®ç›˜ç§»åŠ¨é€»è¾‘
            // V9.5 ä»»åŠ¡é”®ç›˜ç§»åŠ¨é€»è¾‘ (V11.2 ä¿®æ”¹ï¼šå·¦å³ç§»åŠ¨è‡ªåŠ¨åˆ‡æ¢å‘¨è§†å›¾)
            // V11.3 å‡çº§ï¼šæ”¯æŒå‘¨è§†å›¾(æ”¹æ—¶é—´)å’Œæœˆè§†å›¾(æ”¹æ—¥æœŸ)çš„é”®ç›˜ç§»åŠ¨
            // ğŸŸ¢ ä¿®å¤: moveTask (ä¿®å¤å˜é‡æœªå®šä¹‰æŠ¥é”™ï¼Œç¡®ä¿å†²çªæ£€æµ‹é€»è¾‘æ­£ç¡®)
            const moveTask = (task, direction) => {
                let updated = false;
                const isMonth = currentView.value === 'month';

                const checkMonthViewSwitch = (dStr) => {
                    if (!isMonth) return;
                    const newD = new Date(dStr);
                    const currentD = new Date(viewDate.value);
                    if (newD.getMonth() !== currentD.getMonth() || newD.getFullYear() !== currentD.getFullYear()) {
                        viewDate.value = newD;
                    }
                };

                // ç¡®å®šç±»å‹
                let type = 'musician';
                if (task.projectId) type = 'project';
                else if (task.instrumentId) type = 'instrument';

                // ğŸŸ¢ ä¿®å¤: å°†è®¡ç®—é€»è¾‘å’Œå†²çªæ£€æµ‹ç§»åˆ°å…·ä½“çš„æ–¹å‘åˆ¤æ–­å†…éƒ¨
                // è¿™æ ·èƒ½ç¡®ä¿ newTime/newDate åœ¨æ£€æµ‹å‰å·²ç»è®¡ç®—å‡ºæ¥

                if (direction === 'up') {
                    if (isMonth) {
                        const newDate = addDaysToDate(task.date, -7);
                        // æ£€æµ‹æ—¥æœŸå†²çª
                        if (checkOverlap(newDate, task.startTime, task.estDuration, task.scheduleId, type)) {
                            window.triggerTouchHaptic('Error');
                            return;
                        }
                        if (newDate !== task.date) {
                            pushHistory();
                            task.date = newDate;
                            updated = true;
                            checkMonthViewSwitch(newDate);
                        }
                    } else {
                        const newTime = addMinutesToTime(task.startTime, -30);
                        // æ£€æµ‹æ—¶é—´å†²çª
                        if (checkOverlap(task.date, newTime, task.estDuration, task.scheduleId, type)) {
                            window.triggerTouchHaptic('Error');
                            return;
                        }
                        if (newTime !== task.startTime) {
                            pushHistory();
                            task.startTime = newTime;
                            updated = true;
                        }
                    }
                } else if (direction === 'down') {
                    if (isMonth) {
                        const newDate = addDaysToDate(task.date, 7);
                        if (checkOverlap(newDate, task.startTime, task.estDuration, task.scheduleId, type)) {
                            window.triggerTouchHaptic('Error');
                            return;
                        }
                        if (newDate !== task.date) {
                            pushHistory();
                            task.date = newDate;
                            updated = true;
                            checkMonthViewSwitch(newDate);
                        }
                    } else {
                        const newTime = addMinutesToTime(task.startTime, 30);
                        if (checkOverlap(task.date, newTime, task.estDuration, task.scheduleId, type)) {
                            window.triggerTouchHaptic('Error');
                            return;
                        }
                        if (newTime !== task.startTime) {
                            pushHistory();
                            task.startTime = newTime;
                            updated = true;
                        }
                    }
                } else if (direction === 'left') {
                    const newDate = addDaysToDate(task.date, -1);
                    if (checkOverlap(newDate, task.startTime, task.estDuration, task.scheduleId, type)) {
                        window.triggerTouchHaptic('Error');
                        return;
                    }
                    if (newDate !== task.date) {
                        pushHistory();
                        task.date = newDate;
                        updated = true;
                        if (isMonth) checkMonthViewSwitch(newDate);
                        else if (currentView.value === 'week' && newDate < currentWeekDays.value[0].dateStr) viewDate.value = new Date(newDate);
                    }
                } else if (direction === 'right') {
                    const newDate = addDaysToDate(task.date, 1);
                    if (checkOverlap(newDate, task.startTime, task.estDuration, task.scheduleId, type)) {
                        window.triggerTouchHaptic('Error');
                        return;
                    }
                    if (newDate !== task.date) {
                        pushHistory();
                        task.date = newDate;
                        updated = true;
                        if (isMonth) checkMonthViewSwitch(newDate);
                        else if (currentView.value === 'week' && newDate > currentWeekDays.value[6].dateStr) viewDate.value = new Date(newDate);
                    }
                }
            };

            // ğŸŸ¢ [æ–°å¢] ä¸“é—¨ç”¨äºæ¸…ç†èšåˆä»»åŠ¡å½•éŸ³æ•°æ®çš„å‡½æ•°
            const clearAggregateRecords = (task) => {
                // 1. ç¡®å®šä»»åŠ¡ç±»å‹å’Œ ID
                let filterKey = 'musicianId';
                let filterId = task.musicianId;
                let viewType = 'musician';

                if (task.projectId) {
                    filterKey = 'projectId';
                    filterId = task.projectId;
                    viewType = 'project';
                } else if (task.instrumentId) {
                    filterKey = 'instrumentId';
                    filterId = task.instrumentId;
                    viewType = 'instrument';
                }

                // 2. æ‰¾åˆ°è¯¥ä»»åŠ¡åœ¨å½“å‰ Session ä¸­çš„é¡ºåº (Section Index)
                // å› ä¸ºèšåˆä»»åŠ¡æ˜¯é€šè¿‡ç´¢å¼•ä¸ä»»åŠ¡æ± æ¡ç›®å…³è”çš„
                const relatedSchedules = scheduledTasks.value.filter(t =>
                    (t.sessionId || 'S_DEFAULT') === currentSessionId.value &&
                    t[filterKey] === filterId
                ).sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));

                const sectionIndex = relatedSchedules.findIndex(t => t.scheduleId === task.scheduleId);
                if (sectionIndex === -1) return;

                // 3. éå†ä»»åŠ¡æ± ï¼Œæ¸…ç†å¯¹åº” Section çš„æ•°æ®
                let hasCleared = false;
                itemPool.value.forEach(item => {
                    // å¿…é¡»åŒ¹é… ID ä¸” åŒ¹é… SectionIndex
                    if (item[filterKey] === filterId) {
                        if (item.sectionIndex === sectionIndex) {
                            // --- æ‰§è¡Œæ¸…ç† ---
                            if (item.records && item.records[viewType]) {
                                const rec = item.records[viewType];
                                if (rec.actualDuration || rec.recStart) {
                                    rec.actualDuration = '';
                                    rec.recStart = '';
                                    rec.recEnd = '';
                                    rec.breakMinutes = 0;
                                    hasCleared = true;
                                }
                            }
                        }

                        // ğŸŸ¢ å…³é”®: åˆ é™¤ä¸­é—´çš„ä¸€ä¸ªå—åï¼Œåé¢çš„å—ç´¢å¼•éœ€è¦å‰ç§»
                        // å¦åˆ™åé¢çš„ä»»åŠ¡ä¼šæ‰¾ä¸åˆ°å¯¹åº”çš„æ—¥ç¨‹å—
                        if (item.sectionIndex > sectionIndex) {
                            item.sectionIndex--;
                        }
                    }
                });

                // 4. å¦‚æœæœ‰æ•°æ®è¢«æ¸…ç†ï¼Œå¼ºåˆ¶æ›´æ–°æ•ˆç‡è®¡ç®—
                if (hasCleared) {
                    autoUpdateEfficiency(filterId, viewType, false);
                }
            };

            // ğŸŸ¢ ä¿®å¤: å…¨å±€å¿«æ·é”®æ§åˆ¶ (ä¼˜åŒ– ESC å…³é—­é¡ºåº)
            const handleGlobalKey = e => {
                const isAnyModalOpen =
                    showSettings.value || showEditor.value || showTrackList.value ||
                    showAuthModal.value || showCropModal.value || showMobileMenu.value ||
                    showColorPickerModal.value || showMobileTaskInput.value ||
                    showQuickAddModal.value || showRecInfoModal.value ||
                    showConfirmModal.value || showInputModal.value ||
                    showSplitModal.value || showCreditModal.value ||
                    showMidiManager.value || showMidiImportModal.value || showCsvImportModal.value ||
                    showProjectInfoModal.value;


                // 2. ESC é”®ç‰¹æƒå¤„ç† (æŒ‰è§†è§‰å±‚çº§ï¼Œç”±ä¸Šè‡³ä¸‹é€å±‚å¤„ç†)
                if (e.key === 'Escape') {

                    // === å±‚çº§ 1: å…¨å±€é¡¶å±‚æµ®çª— (ä¼˜å…ˆçº§æœ€é«˜ï¼Œæ— è®ºä¸‹é¢æ˜¯ä»€ä¹ˆ) ===
                    if (showDurationPicker.value) { closePicker(); e.preventDefault(); return; }
                    if (showColorPickerModal.value) { showColorPickerModal.value = false; e.preventDefault(); return; }
                    // ç¡®è®¤æ¡†/è¾“å…¥æ¡†é€šå¸¸åœ¨æœ€é¡¶å±‚
                    if (showConfirmModal.value) { closeConfirmModal(); e.preventDefault(); return; }
                    if (showInputModal.value) { closeInputModal(); e.preventDefault(); return; }

                    // === å±‚çº§ 2: ä¸šåŠ¡å¼¹çª— (æŒ‰å †å é¡ºåºåˆ¤æ–­) ===
                    // å…³é”®é€»è¾‘ï¼šå…ˆåˆ¤æ–­é¡¶å±‚å¼¹çª—ï¼Œå†åˆ¤æ–­è¯¥å¼¹çª—å†…éƒ¨çš„ä¸‹æ‹‰/çŠ¶æ€â€˜

                    if (showProjectInfoModal.value) {
                        showProjectInfoModal.value = false;
                        return;
                    }

                    // [Top] å¿«é€Ÿæ·»åŠ å¼¹çª— (å¯èƒ½å åŠ åœ¨ MobileTaskInput ä¹‹ä¸Š)
                    if (showQuickAddModal.value) {
                        // ä¼˜å…ˆå…³é—­å†…éƒ¨çš„åˆ†ç»„å»ºè®®
                        if (showGroupSuggestions.value) { showGroupSuggestions.value = false; }
                        // å¦åˆ™å…³é—­å¼¹çª—æœ¬èº«
                        else { showQuickAddModal.value = false; }
                        e.preventDefault(); return;
                    }

                    // [Top] å½•éŸ³ä¿¡æ¯å¼¹çª— (å¯èƒ½å åŠ åœ¨ TrackList ä¹‹ä¸Š)
                    if (showRecInfoModal.value) {
                        if (activeRecDropdown.value) { activeRecDropdown.value = null; }
                        else { showRecInfoModal.value = false; }
                        e.preventDefault(); return;
                    }

                    // [Top] æ‹†åˆ†/Credit/è£åˆ‡/å¯¼å…¥ (ç‹¬ç«‹å¼¹çª—)
                    if (showSplitModal.value) { showSplitModal.value = false; e.preventDefault(); return; }
                    if (showCreditModal.value) { showCreditModal.value = false; e.preventDefault(); return; }
                    if (showCropModal.value) { showCropModal.value = false; e.preventDefault(); return; }
                    if (showImportModal.value) { showImportModal.value = false; e.preventDefault(); return; }
                    // ğŸŸ¢ æ–°å¢ï¼šå¤„ç† CSV å¯¼å…¥å¼¹çª—çš„å…³é—­
                    if (showCsvImportModal.value) {
                        showCsvImportModal.value = false;
                        e.preventDefault();
                        return;
                    }

                    // [Top] MIDI å¯¼å…¥ç•Œé¢ (ğŸŸ¢ ä¿®å¤: åŠ å…¥ ESC æ”¯æŒ)
                    if (showMidiImportModal.value) {
                        // å¦‚æœæ‰“å¼€äº†å³é”®èœå•ï¼Œå…ˆå…³èœå•
                        if (activeImportMenu.rowId) { closeImportMenu(); }
                        else { showMidiImportModal.value = false; }
                        e.preventDefault(); return;
                    }

                    // [Top] MIDI ç®¡ç†ç•Œé¢ (ğŸŸ¢ ä¿®å¤: åŠ å…¥ ESC æ”¯æŒ)
                    if (showMidiManager.value) {
                        // å¦‚æœæ‰“å¼€äº†åˆ†ç»„èœå•ï¼Œå…ˆå…³èœå•
                        if (activeMidiGroupRow.value) { activeMidiGroupRow.value = null; }
                        else { showMidiManager.value = false; }
                        e.preventDefault(); return;
                    }

                    // [Middle] TrackList è¯¦æƒ…é¡µ
                    if (showTrackList.value) { showTrackList.value = false; e.preventDefault(); return; }

                    // [Middle] ç¼–è¾‘/æ–°å»ºé¡µ (MobileTaskInput / Editor)
                    if (showMobileTaskInput.value) {
                        // å¦‚æœå†…éƒ¨çš„ä¸»ä¸‹æ‹‰èœå•æ‰“å¼€äº†ï¼Œå…ˆå…³ä¸‹æ‹‰
                        if (activeDropdown.value) { activeDropdown.value = null; }
                        else { showMobileTaskInput.value = false; }
                        e.preventDefault(); return;
                    }

                    if (showEditor.value) {
                        // Editor å†…éƒ¨ä¹Ÿæœ‰ä¸‹æ‹‰
                        if (activeDropdown.value && activeDropdown.value.startsWith('edit_')) { activeDropdown.value = null; }
                        else { showEditor.value = false; }
                        e.preventDefault(); return;
                    }

                    // [Bottom] è®¾ç½®é¡µ
                    if (showSettings.value) {
                        if (settingsNameFocus.value || settingsGroupFocus.value) {
                            settingsNameFocus.value = null; settingsGroupFocus.value = null;
                        } else {
                            showSettings.value = false;
                        }
                        e.preventDefault(); return;
                    }

                    // [Bottom] ä¾§è¾¹æ èœå•/ç”¨æˆ·èœå•
                    if (showMobileMenu.value) { showMobileMenu.value = false; e.preventDefault(); return; }
                    if (showProfileMenu.value) { showProfileMenu.value = false; e.preventDefault(); return; }
                    if (showAuthModal.value) { showAuthModal.value = false; e.preventDefault(); return; }

                    // === å±‚çº§ 3: åŸºç¡€ç•Œé¢äº¤äº’ (æœ€ä½ä¼˜å…ˆçº§) ===

                    // å¦‚æœæ²¡æœ‰ä»»ä½•å¼¹çª—ï¼Œä½†åœ¨ä¸»ç•Œé¢æ‰“å¼€äº†ä¸‹æ‹‰ (å¦‚ Session åˆ‡æ¢)
                    if (activeDropdown.value) { activeDropdown.value = null; e.preventDefault(); return; }

                    // æ¸…é™¤ä»»åŠ¡é€‰æ‹©
                    if (selectedTaskId.value || selectedPoolIds.value.size > 0) {
                        clearSelection();
                        e.preventDefault();
                        return;
                    }
                }

                if (e.shiftKey && e.key.toLowerCase() === 'f') {
                    // è¾“å…¥æ¡†ä¿æŠ¤ï¼šå¦‚æœåœ¨æ‰“å­—ï¼Œä¸è§¦å‘æŠ˜å 
                    const isTyping = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName);
                    if (isTyping) return;

                    e.preventDefault();

                    // --- åœºæ™¯ 1: CSV å¯¼å…¥å¼¹çª— ---
                    if (showCsvImportModal.value) {
                        const allGroups = groupedCsvData.value.map(g => g.projectName);
                        const isAllCollapsed = allGroups.every(name => collapsedProjects.has(name));
                        if (isAllCollapsed) {
                            collapsedProjects.clear();
                        } else {
                            allGroups.forEach(name => collapsedProjects.add(name));
                        }
                        if (isMobile.value) window.triggerTouchHaptic('Light');
                        return;
                    }

                    // --- åœºæ™¯ 2: MIDI ç®¡ç†å™¨å¼¹çª— (ä¿®å¤ç‚¹) ---
                    if (showMidiManager.value) {
                        // ä¿®æ­£ï¼šä»æ•°ç»„ä¸­æå–ç»„åï¼Œå¹¶ç§»é™¤ Set çš„ .value
                        const allGroups = projectMidiGroups.value.map(g => g.name);
                        const isAllExpanded = allGroups.every(name => midiManagerExpandedGroups.has(name));

                        if (isAllExpanded) {
                            midiManagerExpandedGroups.clear();
                        } else {
                            midiManagerExpandedGroups.clear();
                            allGroups.forEach(name => midiManagerExpandedGroups.add(name));
                        }
                        if (isMobile.value) window.triggerTouchHaptic('Light');
                        return;
                    }

                    // --- åœºæ™¯ 3: ä¾§è¾¹æ ä»»åŠ¡æ±  (åŸé€»è¾‘) ---
                    const allItems = filteredSidebarList.value;
                    if (allItems.length > 0) {
                        const isAllExpanded = allItems.every(item => expandedStatsIds.has(item.id));
                        if (isAllExpanded) {
                            expandedStatsIds.clear();
                        } else {
                            allItems.forEach(item => expandedStatsIds.add(item.id));
                        }
                    }
                    return;
                }

                // 4. æ’¤é”€/é‡åš (Cmd+Z / Ctrl+Z) - è¿™äº›é€šå¸¸å…è®¸åœ¨æ— å¼¹çª—æ—¶å…¨å±€è§¦å‘
                if ((e.metaKey || e.ctrlKey)) {
                    if (e.key.toLowerCase() === 'z') {
                        e.preventDefault();
                        if (e.shiftKey) redo(); else undo();
                        return;
                    }
                    if (e.key.toLowerCase() === 'y') {
                        e.preventDefault();
                        redo();
                        return;
                    }
                }

                // 3. ğŸŸ¢ æ ¸å¿ƒä¿®å¤: å¦‚æœæœ‰ä»»ä½•å¼¹çª—æ‰“å¼€ï¼Œç›´æ¥åœæ­¢åç»­é€»è¾‘
                // è¿™é˜²æ­¢äº†åœ¨å¼¹çª—æ‰“å¼€æ—¶ï¼ŒæŒ‰ä¸‹ Delete é”®è¯¯åˆ èƒŒæ™¯é‡Œçš„ä»»åŠ¡ï¼Œæˆ–è€…æŒ‰æ–¹å‘é”®ç§»åŠ¨ä»»åŠ¡
                if (isAnyModalOpen) return;

                // 5. è¾“å…¥æ¡†ä¿æŠ¤: é˜²æ­¢åœ¨ä¾§è¾¹æ æœç´¢æ¡†æ‰“å­—æ—¶è§¦å‘å¿«æ·é”®
                const isTyping = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName);
                if (isTyping) return;

                // ğŸŸ¢ ä¿®æ”¹: handleGlobalKey ä¸­çš„ Tab é”®é€»è¾‘
                if (e.key === 'Tab') {
                    e.preventDefault();
                    if (e.altKey) {
                        // Alt+Tab: åˆ‡æ¢ Session (ä¿æŒä¸å˜)
                        const sessions = settings.sessions;
                        const currentIndex = sessions.findIndex(s => s.id === currentSessionId.value);
                        let nextIndex = e.shiftKey ? (currentIndex - 1 + sessions.length) % sessions.length : (currentIndex + 1) % sessions.length;
                        if (sessions.length > 0) currentSessionId.value = sessions[nextIndex].id;
                    } else if (e.shiftKey) {
                        // Shift+Tab: åˆ‡æ¢ å‘¨/æœˆ è§†å›¾ (ä¿æŒä¸å˜)
                        currentView.value = currentView.value === 'week' ? 'month' : 'week';
                        switchView(target);
                    } else {
                        // ğŸŸ¢ Tab: åœ¨ äººå‘˜ -> é¡¹ç›® -> ä¹å™¨ ä¹‹é—´å¾ªç¯åˆ‡æ¢
                        if (sidebarTab.value === 'musician') {
                            sidebarTab.value = 'project';
                        } else if (sidebarTab.value === 'project') {
                            sidebarTab.value = 'instrument';
                        } else {
                            sidebarTab.value = 'musician';
                        }

                        // å¯é€‰: åˆ‡æ¢æ—¶ç»™ä¸ªè½»å¾®éœ‡åŠ¨åé¦ˆ
                        if (isMobile.value) window.triggerTouchHaptic('Light');
                    }
                    return;
                }

                // 8. ä¾§è¾¹æ å¯¼èˆª (ä»…å½“æœªé€‰ä¸­æ—¥ç¨‹è¡¨ä»»åŠ¡æ—¶ç”Ÿæ•ˆ)
                if (selectedSource.value !== 'schedule' && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                    // Browse æ¨¡å¼ä¸‹çš„å·¦å³é”® (åˆ‡æ¢åˆ†ç»„)
                    if (sidebarTab.value === 'browse' && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                        e.preventDefault();
                        const keys = ['projectId', 'musicianId', 'instrumentId'];
                        const currentIndex = keys.indexOf(sortKey.value);
                        let newIndex = e.key === 'ArrowRight' ? (currentIndex + 1) % keys.length : (currentIndex - 1 + keys.length) % keys.length;
                        sortKey.value = keys[newIndex];
                        activeColorKey.value = keys[newIndex];
                        return;
                    }

                    // ä¸Šä¸‹é”®é€‰æ‹©åˆ—è¡¨é¡¹
                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        e.preventDefault();
                        const visibleItems = [];
                        if (sidebarTab.value === 'browse') {
                            groupedItemPool.value.forEach(group => {
                                if (expandedGroups.has(group.key)) visibleItems.push(...group.items);
                            });
                        } else {
                            musicianStats.value.forEach(stat => {
                                if (expandedStatsIds.has(stat.id)) visibleItems.push(...stat.items);
                            });
                        }
                        if (visibleItems.length === 0) return;

                        let currentIdx = -1;
                        const focusId = lastPoolFocusId.value || lastPoolClickId.value;
                        if (focusId) currentIdx = visibleItems.findIndex(i => i.id === focusId);

                        let newIdx = currentIdx === -1
                            ? (e.key === 'ArrowDown' ? 0 : visibleItems.length - 1)
                            : (e.key === 'ArrowDown' ? Math.min(currentIdx + 1, visibleItems.length - 1) : Math.max(currentIdx - 1, 0));

                        const targetItem = visibleItems[newIdx];
                        if (targetItem) {
                            selectTask(targetItem.id, 'pool', e);
                            // ç®€å•çš„æ»šåŠ¨è·Ÿéšé€»è¾‘
                            setTimeout(() => {
                                const activeEl = document.querySelector('#sidebar .border-blue-600') || document.querySelector('#sidebar .ring-2');
                                if (activeEl) activeEl.scrollIntoView({behavior: 'smooth', block: 'nearest'});
                            }, 0);
                        }
                        return;
                    }
                }

                // 9. æ—¥ç¨‹è¡¨æ“ä½œ (ç§»åŠ¨ä»»åŠ¡)
                if (selectedTaskId.value && selectedSource.value === 'schedule') {
                    const task = scheduledTasks.value.find(t => t.scheduleId === selectedTaskId.value);
                    if (!task) return;

                    const keyMap = {'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right'};
                    const direction = keyMap[e.key];

                    if (direction) {
                        e.preventDefault();
                        moveTask(task, direction);
                    }
                }

                // 10. åˆ é™¤æ“ä½œ
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    // æƒ…å†µ A: åˆ é™¤ä¾§è¾¹æ é€‰ä¸­çš„ä»»åŠ¡æ± é¡¹ç›® ... (ä¿æŒä¸å˜)
                    if (selectedSource.value === 'pool' && selectedPoolIds.value.size > 0) {

                        // ğŸ›¡ï¸ [æ–°å¢] æ‰¹é‡åˆ é™¤å‰çš„å®‰å…¨æ£€æŸ¥
                        let canDeleteAll = true;
                        for (const id of selectedPoolIds.value) {
                            const task = itemPool.value.find(i => i.id === id);
                            if (task) {
                                // å¤ç”¨æ£€æŸ¥å‡½æ•°ï¼Œå¦‚æœè¿”å› falseï¼Œæ ‡è®°ä¸ºä¸å¯åˆ é™¤
                                if (!checkCanDeleteSplit(task)) {
                                    canDeleteAll = false;
                                    break; // åªè¦æœ‰ä¸€ä¸ªä¸è¡Œï¼Œå°±å…¨éƒ¨æ‰“æ–­
                                }
                            }
                        }
                        if (!canDeleteAll) return; // â›”ï¸ é˜»æ­¢åˆ é™¤

                        // ... (åŸæœ‰çš„åˆ é™¤é€»è¾‘) ...
                        selectedPoolIds.value.forEach(id => {
                            const task = itemPool.value.find(i => i.id === id);
                            if (task) restoreSplitTime(task);
                        });
                        scheduledTasks.value = scheduledTasks.value.filter(t => !selectedPoolIds.value.has(t.templateId));
                        itemPool.value = itemPool.value.filter(i => !selectedPoolIds.value.has(i.id));
                        cleanupEmptySchedules();
                        clearSelection();
                        pushHistory();
                    }
                    // æƒ…å†µ B: åˆ é™¤æ—¥ç¨‹è¡¨é€‰ä¸­çš„ä»»åŠ¡ (å•é€‰)
                    else if (selectedTaskId.value && selectedSource.value === 'schedule') {
                        const taskToDelete = scheduledTasks.value.find(t => t.scheduleId === selectedTaskId.value);

                        // ğŸŸ¢ æ–°å¢: æ‹¦æˆªå·²å®Œæˆä»»åŠ¡
                        if (taskToDelete && isResourceCompleted(taskToDelete)) {
                            window.triggerTouchHaptic('Error');
                            // è¿™é‡Œä½¿ç”¨è½»æç¤ºæˆ–è€…ä¸åšåŠ¨ä½œï¼Œé¿å…é¢‘ç¹å¼¹çª—æ‰“æ–­ï¼Œæˆ–è€…å¯ä»¥é€‰æ‹©å¼¹çª—
                            return openAlertModal("æ— æ³•åˆ é™¤", "è¯¥ä»»åŠ¡å¤„äºã€å®Œæˆã€‘ä¿æŠ¤çŠ¶æ€ã€‚");
                        }

                        if (taskToDelete) {
                            // ğŸŸ¢ ä¿®å¤å¼€å§‹: åŒºåˆ† å•æ›²ä»»åŠ¡ å’Œ èšåˆä»»åŠ¡ è¿›è¡Œæ¸…ç†
                            if (taskToDelete.templateId) {
                                // 1. å•æ›²ä»»åŠ¡ (æœ‰ templateId) -> æ¸…ç†æŒ‡å®š ID
                                clearPoolRecord(taskToDelete.templateId);
                            } else {
                                // 2. èšåˆä»»åŠ¡ (æ—  templateId) -> ä½¿ç”¨æ–°å‡½æ•°æ¸…ç†å…³è”æ•°æ®
                                clearAggregateRecords(taskToDelete);
                            }
                            // ğŸŸ¢ ä¿®å¤ç»“æŸ

                            // ç‰©ç†åˆ é™¤
                            scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== selectedTaskId.value);

                            // è§¦å‘éœ‡åŠ¨åé¦ˆ
                            if (isMobile.value) window.triggerTouchHaptic('Medium');

                            clearSelection();
                            pushHistory();
                        }
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: handleTaskDblClick é€‚é…ä¸‰ç§è§†å›¾é€»è¾‘
            const handleTaskDblClick = (e, task) => {
                if (isContextSwitching.value) return;
                if (isTaskGhost(task)) {
                    jumpToGhostContext(task);
                    return;
                }
                window.triggerTouchHaptic('Heavy');

                if (e.metaKey || e.ctrlKey) {
                    // ... (ä¿ç•™åŸæœ‰çš„æ‹†åˆ†é€»è¾‘ä¸å˜) ...
                    const rect = e.currentTarget.getBoundingClientRect();
                    const clickY = e.clientY - rect.top;
                    const splitM = Math.round((clickY / pxPerMin.value) / 30) * 30;
                    const tot = parseTime(task.estDuration);
                    if (splitM * 60 >= tot || splitM <= 0) return;
                    const t1 = JSON.parse(JSON.stringify(task));
                    t1.scheduleId = Date.now();
                    t1.estDuration = formatSecs(splitM * 60);
                    const t2 = JSON.parse(JSON.stringify(task));
                    t2.scheduleId = Date.now() + 1;
                    const [h, m] = task.startTime.split(':').map(Number);
                    const sm = h * 60 + m + splitM;
                    t2.startTime = `${Math.floor(sm / 60)}:${String(sm % 60).padStart(2, '0')}`;
                    t2.estDuration = formatSecs(tot - splitM * 60);
                    scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== task.scheduleId);
                    scheduledTasks.value.push(t1, t2);
                    pushHistory();
                } else {
                    const currentSchedule = scheduledTasks.value.find(t => t.scheduleId === task.scheduleId);
                    if (!currentSchedule) return;

                    // 1. ç¡®å®šæ—¥ç¨‹å—ç±»å‹ (ç”¨äºåç»­ç­›é€‰å’Œæ˜¾ç¤º)
                    let blockType = 'musician';
                    let filterId = task.musicianId;

                    if (task.musicianId) {
                        blockType = 'musician';
                        filterId = task.musicianId;
                    } else if (task.projectId) {
                        blockType = 'project';
                        filterId = task.projectId;
                    } else if (task.instrumentId) {
                        blockType = 'instrument';
                        filterId = task.instrumentId;
                    }

                    // 2. ç­›é€‰ç›¸å…³çš„æ—¥ç¨‹ (ç”¨äºè®¡ç®—åˆ†æ®µ)
                    // æ³¨æ„ï¼šè¿™é‡Œè¦æ ¹æ®ç±»å‹ç­›é€‰ï¼Œæ¯”å¦‚æ˜¯é¡¹ç›®å—ï¼Œå°±è¦æ‰¾åŒé¡¹ç›®åŒSessionçš„æ‰€æœ‰å—
                    const relatedSchedules = scheduledTasks.value
                        .filter(t => {
                            if ((t.sessionId || 'S_DEFAULT') !== currentSessionId.value) return false;
                            if (blockType === 'musician') return t.musicianId === filterId;
                            if (blockType === 'project') return t.projectId === filterId && !t.musicianId; // ä¸¥æ ¼åŒ¹é…ç±»å‹
                            if (blockType === 'instrument') return t.instrumentId === filterId && !t.musicianId && !t.projectId;
                            return false;
                        })
                        .sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));

                    const currentSectionIndex = relatedSchedules.findIndex(t => t.scheduleId === task.scheduleId);
                    const totalSections = relatedSchedules.length;

                    // 3. ç­›é€‰ä»»åŠ¡æ±  (Pool Items)
                    // æ ¹æ® blockType å†³å®šç­›é€‰æ¡ä»¶
                    const poolItems = itemPool.value.filter(i => {
                        if ((i.sessionId || 'S_DEFAULT') !== currentSessionId.value) return false;
                        if (blockType === 'musician') return i.musicianId === filterId;
                        if (blockType === 'project') return i.projectId === filterId;
                        if (blockType === 'instrument') return i.instrumentId === filterId;
                        return false;
                    });

                    // åˆå§‹åŒ–åˆ†æ®µ
                    poolItems.forEach(i => {
                        ensureItemRecords(i);
                        if (i.sectionIndex === undefined) i.sectionIndex = 0;
                        if (i.sectionIndex >= totalSections) i.sectionIndex = totalSections - 1;
                    });

                    // 4. è®¾ç½®å¼¹çª—æ•°æ®
                    let modalTitle = '';
                    if (blockType === 'musician') modalTitle = getNameById(filterId, 'musician');
                    else if (blockType === 'project') modalTitle = getNameById(filterId, 'project');
                    else if (blockType === 'instrument') modalTitle = getNameById(filterId, 'instrument');

                    trackListData.value = {
                        name: modalTitle,
                        items: poolItems,
                        taskRef: currentSchedule,
                        totalSections: totalSections,
                        currentSectionIndex: currentSectionIndex,
                        schedules: relatedSchedules,
                        viewType: blockType // ğŸŸ¢ å…³é”®ï¼šä¼ å…¥è§†å›¾ç±»å‹ï¼Œä¾› HTML æ¨¡æ¿åˆ¤æ–­æ˜¾ç¤ºå†…å®¹
                    };

                    // ... (å‰é¢çš„ä»£ç ä¿æŒä¸å˜)
                    autoSortTrackList();
                    showTrackList.value = true;

                    // âœ¨âœ¨âœ¨ ä¿®å¤ç‰ˆï¼šè‡ªåŠ¨æ»šåŠ¨é€»è¾‘ âœ¨âœ¨âœ¨
                    // ä½¿ç”¨ setTimeout ä»£æ›¿å•çº¯çš„ nextTickï¼Œç»™æµè§ˆå™¨ 50ms-100ms çš„æ¸²æŸ“ç¼“å†²æ—¶é—´
                    setTimeout(() => {
                        const container = trackListContainerRef.value;
                        if (!container) return;

                        const targetIdx = trackListData.value.currentSectionIndex;

                        // å¦‚æœæ˜¯ç¬¬ 0 æ®µï¼Œç›´æ¥æ»šåˆ°é¡¶éƒ¨ (æœ€ç¨³å¦¥)
                        if (targetIdx === 0) {
                            container.scrollTo({ top: 0, behavior: 'auto' });
                        } else {
                            const dividerId = 'sec-divider-' + targetIdx;
                            const dividerEl = document.getElementById(dividerId);

                            if (dividerEl) {
                                // ğŸŸ¢ å…³é”®ï¼šå…ˆå°è¯•ç¬ç§»
                                dividerEl.scrollIntoView({ behavior: 'auto', block: 'start' });

                                // ğŸŸ¢ åŒé‡ä¿é™©ï¼š
                                // å› ä¸º TransitionGroup çš„åŠ¨ç”»å¯èƒ½ä¼šåœ¨æ»šåŠ¨åæŠŠå…ƒç´ ä½ç½®æŒ¤å
                                // æ‰€ä»¥åœ¨åŠ¨ç”»ç»“æŸ(300ms)åï¼Œå†å¾®è°ƒä¸€æ¬¡ï¼Œç¡®ä¿ä½ç½®ç»å¯¹æ­£ç¡®
                                setTimeout(() => {
                                    const retryEl = document.getElementById(dividerId);
                                    if(retryEl) retryEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }, 350);
                            } else {
                                // è°ƒè¯•ç”¨ï¼šå¦‚æœæ‰¾ä¸åˆ°å…ƒç´ ï¼Œæ‰“å°æ—¥å¿—
                                // console.warn('æœªæ‰¾åˆ°åˆ†å‰²çº¿å…ƒç´ :', dividerId);
                            }
                        }
                    }, 50); // ğŸ‘ˆ è¿™é‡Œè®¾ç½® 50ms å»¶è¿Ÿï¼Œæ—¢ä¸æ˜æ˜¾å¡é¡¿ï¼Œåˆèƒ½é¿å¼€æ¸²æŸ“å†²çª
                    // âœ¨âœ¨âœ¨ ä¿®å¤ç»“æŸ âœ¨âœ¨âœ¨
                }
            };

            const setTrackNow = (item, type) => {
                const viewType = trackListData.value.viewType || 'musician';
                const record = item.records[viewType];

                const now = new Date();
                const timeStr = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

                if (type === 'start') record.recStart = timeStr;
                if (type === 'end') record.recEnd = timeStr;

                calcTrackDiff(item);
                pushHistory();
            };

            // ğŸŸ¢ ä¿®æ”¹: checkOverlap (æ”¯æŒåˆ†å±‚æ£€æµ‹)
            const checkOverlap = (date, startTime, durationStr, excludeId, checkType) => {
                // 1. è®¡ç®—å½“å‰æ„å›¾çš„æ—¶é—´æ®µ
                const newStart = timeToMinutes(startTime);
                const newEnd = newStart + parseTime(durationStr) / 60;

                return scheduledTasks.value.some(t => {
                    // æ’é™¤è‡ªèº«
                    if (t.scheduleId === excludeId) return false;

                    // æ’é™¤å…¶ä»–æ—¥æœŸ
                    if (t.date !== date) return false;

                    // æ’é™¤å…¶ä»– Session
                    if ((t.sessionId || 'S_DEFAULT') !== currentSessionId.value) return false;

                    // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: åˆ¤æ–­ç°æœ‰ä»»åŠ¡ t çš„ç±»å‹
                    let tType = 'musician';
                    if (t.projectId) tType = 'project';
                    else if (t.instrumentId) tType = 'instrument';

                    // ğŸŸ¢ åªæœ‰ç±»å‹ä¸€è‡´æ—¶ï¼Œæ‰æ£€æŸ¥æ—¶é—´å†²çª
                    // (å³: é¡¹ç›®ä»»åŠ¡åªè·Ÿé¡¹ç›®ä»»åŠ¡æ’ï¼Œä¸è·Ÿäººå‘˜ä»»åŠ¡æ’)
                    if (tType !== checkType) return false;

                    // è®¡ç®—ç°æœ‰ä»»åŠ¡çš„æ—¶é—´æ®µ
                    const tStart = timeToMinutes(t.startTime);
                    const tEnd = tStart + parseTime(t.estDuration) / 60;

                    return (newStart < tEnd && newEnd > tStart);
                });
            };


            const saveTrackRecord = (item) => {
                if (trackSaveTimer) clearTimeout(trackSaveTimer);
                trackSaveTimer = setTimeout(() => {
                    const viewType = trackListData.value.viewType || 'musician';
                    let targetId = item.musicianId;
                    if (viewType === 'project') targetId = item.projectId;
                    else if (viewType === 'instrument') targetId = item.instrumentId;

                    // ğŸŸ¢ è°ƒç”¨æ–°å‡½æ•°
                    autoUpdateEfficiency(targetId, viewType);
                }, 1500);
            };

            const clearTrackTime = (item) => {
                const viewType = trackListData.value.viewType || 'musician';
                const record = item.records[viewType];

                record.recStart = '';
                record.recEnd = '';
                record.actualDuration = '';

                autoResizeScheduleByRecords(true, false);

                // ğŸŸ¢ è·å–æ­£ç¡®çš„ ID å¹¶è°ƒç”¨æ–°å‡½æ•°
                let targetId = item.musicianId;
                if (viewType === 'project') targetId = item.projectId;
                else if (viewType === 'instrument') targetId = item.instrumentId;

                autoUpdateEfficiency(targetId, viewType, false);

                pushHistory();
                window.triggerTouchHaptic('Medium');
            };

            // ğŸŸ¢ è¾…åŠ©ï¼šè®¡ç®—ç¼–åˆ¶äººæ•° (å°† "4.3.2.1" è§£æä¸º 10, "4 Hn" è§£æä¸º 4)
            const getOrchSize = (str) => {
                if (!str) return 0;
                // æå–æ‰€æœ‰æ•°å­—å¹¶æ±‚å’Œ
                const nums = str.match(/\d+/g);
                if (!nums) return 0; // å¦‚æœæ²¡æœ‰æ•°å­—ï¼ˆå¦‚ "Solo"ï¼‰ï¼Œç®—ä½œ 0ï¼Œæˆ–è€…ä½ å¯ä»¥è®¾ä¸º 1
                return nums.reduce((sum, n) => sum + parseInt(n, 10), 0);
            };

            // ğŸŸ¢ è¾…åŠ©ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºç®¡å¼¦ä¹ç»„ (Brass/String/Woodwind)
            const isOrchestraGroup = (item) => {
                const name = getNameById(item.instrumentId, 'instrument').toLowerCase();
                // ä¹Ÿå¯ä»¥ç»“åˆ settings ä¸­çš„ group å­—æ®µåˆ¤æ–­ï¼Œè¿™é‡Œç®€å•åŒ¹é…å¸¸ç”¨å…³é”®è¯
                const group = (settings.instruments.find(i => i.id === item.instrumentId)?.group || '').toLowerCase();
                const text = name + ' ' + group;
                return /string|str|brass|wind|wood|hn|tpt|tbn|tuba|vln|vla|vc|db|flute|oboe|clar|bsn/.test(text);
            };

            // ğŸŸ¢ è¾…åŠ©ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºæ‰“å‡»ä¹ (Percussion)
            const isPercussionGroup = (item) => {
                const name = getNameById(item.musicianId, 'musician').toLowerCase();

                // åªæœ‰æ¼”å¥å‘˜åå­—é‡Œå¸¦æœ‰ "perc" (å¦‚ "Percussion", "Perc 1", "SPO Perc") æ—¶ï¼Œæ‰è§†ä¸ºæ‰“å‡»ä¹ç»„
                // è¿™æ · "Timpani" æˆ– "Drum Set" å¦‚æœåå­—é‡Œæ²¡å¸¦ Percï¼Œå°±ä¼šæ­£å¸¸æ˜¾ç¤ºé»„è‰²ç¼–åˆ¶æ ‡ç­¾
                return /perc/.test(name);
            };

            // ğŸŸ¢ ä¿®å¤: åˆ¤æ–­æ˜¯å¦ä¸ºå¼¦ä¹ (V3: ä»…æ£€æµ‹æ¼”å¥å‘˜åå­—ï¼Œåªæœ‰æ¼”å¥å‘˜å« "Strings" æ—¶æ‰éšè—)
            const isStringGroup = (item) => {
                // è·å–ã€æ¼”å¥å‘˜ã€‘çš„åå­—ï¼Œè€Œä¸æ˜¯ä¹å™¨å
                const name = getNameById(item.musicianId, 'musician').toLowerCase();

                // åªæœ‰å½“æ¼”å¥å‘˜åå­—é‡ŒåŒ…å« "string", "strings", "str" æ—¶è¿”å› true
                // ä¾‹å¦‚: "String Ensemble", "Strings A", "Orch Strings"
                return /\b(strings?|str)\b/i.test(name);
            };

            // ğŸŸ¢ [ä¿®å¤ç‰ˆ] æ‰‹åŠ¨æ’åºæŒ‰é’®
            const sortTrackList = () => {
                if (!trackListData.value.items) return;

                const viewType = trackListData.value.viewType || 'musician';

                // 1. æ‰§è¡Œæ’åº
                trackListData.value.items = [...trackListData.value.items].sort((a, b) => {
                    // ä¼˜å…ˆçº§ 1: åˆ†æ®µç´¢å¼• (Section) - å¿…é¡»æ˜¯æœ€é«˜ä¼˜å…ˆçº§ï¼Œç¡®ä¿ä»»åŠ¡ä¸è·¨å—ä¹±è·³
                    const secA = a.sectionIndex || 0;
                    const secB = b.sectionIndex || 0;
                    if (secA !== secB) return secA - secB;

                    // ä¼˜å…ˆçº§ 2: Skip çŠ¶æ€ - åœ¨åŒä¸€ä¸ªæ—¥ç¨‹å—å†…éƒ¨ï¼ŒæŠŠä¸å½•çš„ä»»åŠ¡æ’åˆ°å—å†…åº•éƒ¨
                    if (!!a.isSkipped !== !!b.isSkipped) return a.isSkipped ? 1 : -1;

                    // ä¼˜å…ˆçº§ 3: æ—¶é—´ä¼˜å…ˆ - å—å†…æŒ‰å…·ä½“å½•éŸ³å¼€å§‹æ—¶é—´æ’åº
                    const recA = a.records?.[viewType];
                    const recB = b.records?.[viewType];
                    const tA = (recA && recA.recStart) ? recA.recStart : '99:99';
                    const tB = (recB && recB.recStart) ? recB.recStart : '99:99';
                    if (tA !== tB) return tA.localeCompare(tB);

                    // --- ä»¥ä¸‹æ˜¯æ—¶é—´ç›¸åŒæ—¶çš„å¤‡é€‰é€»è¾‘ ---

                    // ä¼˜å…ˆçº§ 3: ç®¡å¼¦ä¹å›¢æŒ‰äººæ•°æ’åº
                    const isOrchA = isOrchestraGroup(a);
                    const isOrchB = isOrchestraGroup(b);
                    if (isOrchA && isOrchB && !isPercussionGroup(a) && !isPercussionGroup(b)) {
                        const sizeA = getOrchSize(a.orchestration);
                        const sizeB = getOrchSize(b.orchestration);
                        if (sizeA !== sizeB) return sizeB - sizeA;
                    }

                    // ä¼˜å…ˆçº§ 4: æ‰“å‡»ä¹æŒ‰åç§°å½’ç±»
                    const nameA = getNameById(a.instrumentId, 'instrument');
                    const nameB = getNameById(b.instrumentId, 'instrument');
                    const isPercA = isPercussionGroup(a);
                    const isPercB = isPercussionGroup(b);

                    if (isPercA && isPercB) {
                        if (nameA !== nameB) return nameA.localeCompare(nameB, 'zh-CN');
                    }

                    return 0;
                });

                // 2. è‡ªåŠ¨å¸é™„ & ä¿å­˜
                autoResizeScheduleByRecords(true, false);
                pushHistory();
                window.triggerTouchHaptic('Medium');
            };

            // ğŸŸ¢ [ä¿®å¤ç‰ˆ] è‡ªåŠ¨æ’åºé€»è¾‘ (ä¸ä¸Šæ–¹ä¿æŒä¸€è‡´)
            const autoSortTrackList = () => {
                if (!trackListData.value.items) return;

                const viewType = trackListData.value.viewType || 'musician';

                trackListData.value.items.sort((a, b) => {
                    // 0. Skip
                    if (!!a.isSkipped !== !!b.isSkipped) return a.isSkipped ? 1 : -1;

                    const secA = a.sectionIndex || 0;
                    const secB = b.sectionIndex || 0;
                    if (secA !== secB) return secA - secB;

                    // ä¼˜å…ˆçº§ 2: Skip çŠ¶æ€ - åœ¨åŒä¸€ä¸ªæ—¥ç¨‹å—å†…éƒ¨ï¼ŒæŠŠä¸å½•çš„ä»»åŠ¡æ’åˆ°å—å†…åº•éƒ¨
                    if (!!a.isSkipped !== !!b.isSkipped) return a.isSkipped ? 1 : -1;

                    // ä¼˜å…ˆçº§ 3: æ—¶é—´ä¼˜å…ˆ - å—å†…æŒ‰å…·ä½“å½•éŸ³å¼€å§‹æ—¶é—´æ’åº
                    const recA = a.records?.[viewType];
                    const recB = b.records?.[viewType];
                    const tA = (recA && recA.recStart) ? recA.recStart : '99:99';
                    const tB = (recB && recB.recStart) ? recB.recStart : '99:99';
                    if (tA !== tB) return tA.localeCompare(tB);

                    // 3. Orchestra Size
                    const isOrchA = isOrchestraGroup(a);
                    const isOrchB = isOrchestraGroup(b);
                    if (isOrchA && isOrchB && !isPercussionGroup(a) && !isPercussionGroup(b)) {
                        const sizeA = getOrchSize(a.orchestration);
                        const sizeB = getOrchSize(b.orchestration);
                        if (sizeA !== sizeB) return sizeB - sizeA;
                    }

                    // 4. Percussion Grouping
                    const nameA = getNameById(a.instrumentId, 'instrument');
                    const nameB = getNameById(b.instrumentId, 'instrument');
                    const isPercA = isPercussionGroup(a);
                    const isPercB = isPercussionGroup(b);
                    if (isPercA && isPercB) {
                        if (nameA !== nameB) return nameA.localeCompare(nameB, 'zh-CN');
                    }

                    return 0;
                });
            };

            // ğŸŸ¢ ä¿®æ”¹: å¢åŠ  shouldSaveHistory å‚æ•°ï¼Œé˜²æ­¢æ‹–åŠ¨æ—¶å¡é¡¿
            const moveDivider = (dividerIndex, direction, shouldSaveHistory = true) => {
                const upperSection = dividerIndex - 1;
                const lowerSection = dividerIndex;
                const items = trackListData.value.items;

                if (direction === 'up') {
                    // å‘ä¸Šç§»ï¼šæŠŠä¸Šæ–¹åˆ†æ®µçš„æœ€åä¸€ä¸ªä»»åŠ¡ï¼Œæ‹‰åˆ°ä¸‹æ–¹åˆ†æ®µ
                    for (let i = items.length - 1; i >= 0; i--) {
                        if (items[i].sectionIndex === upperSection) {
                            items[i].sectionIndex = lowerSection;
                            break;
                        }
                    }
                } else if (direction === 'down') {
                    // å‘ä¸‹ç§»ï¼šæŠŠä¸‹æ–¹åˆ†æ®µçš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œæ¨åˆ°ä¸Šæ–¹åˆ†æ®µ
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].sectionIndex === lowerSection) {
                            items[i].sectionIndex = upperSection;
                            break;
                        }
                    }
                }

                // é‡æ–°æ’åº
                // autoSortTrackList();

                // ğŸŸ¢ å…³é”®: æ‹–åŠ¨è¿‡ç¨‹ä¸­ä¸å­˜å†å²ï¼Œåªåœ¨æ¾æ‰‹æ—¶å­˜
                if (shouldSaveHistory) {
                    pushHistory();
                }
            };

            // --- Date/View Logic ---
            const timeSlots = computed(() => {
                const s = [];
                for (let i = settings.startHour; i < settings.endHour; i++) {
                    s.push(`${i}:00`);
                    s.push(`${i}:30`);
                }
                return s;
            });

            // ğŸŸ¢ ä¿®æ”¹: getTaskStyle (å¢åŠ  z-index æ§åˆ¶)
            const getTaskStyle = t => {
                const [h, m] = t.startTime.split(':').map(Number);
                const top = ((h - settings.startHour) * 60 + m) * pxPerMin.value;
                const hgt = (parseTime(t.estDuration) / 60) * pxPerMin.value;

                let baseColor = '#a855f7';
                if (t.projectId) baseColor = '#eab308';
                else if (t.instrumentId) baseColor = '#3b82f6';

                // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: è®¡ç®—å±‚çº§
                // å¦‚æœä»»åŠ¡ä¸æ˜¯å¹½çµï¼ˆå³å®ƒæ˜¯å½“å‰è§†å›¾çš„ä»»åŠ¡ï¼‰ï¼Œå±‚çº§è®¾ä¸º 20 (é«˜)
                // å¦‚æœæ˜¯å¹½çµï¼Œå±‚çº§è®¾ä¸º 1 (ä½)
                const isGhost = isTaskGhost(t); // å¤ç”¨ä¹‹å‰çš„åˆ¤æ–­å‡½æ•°
                const zIndex = isGhost ? 1 : 20;

                return {
                    top: `${top}px`,
                    height: `${hgt}px`,
                    '--task-border': baseColor,
                    zIndex: zIndex, // åº”ç”¨å±‚çº§
                };
            };

            // ğŸŸ¢ æ–°å¢: è·å–æ—¥ç¨‹å—æ˜¾ç¤ºçš„æ ‡é¢˜
            const getBlockTitle = (task) => {
                if (task.musicianId) return getNameById(task.musicianId, 'musician');
                if (task.projectId) return getNameById(task.projectId, 'project');
                if (task.instrumentId) return getNameById(task.instrumentId, 'instrument');
                return 'æœªå‘½åæ—¥ç¨‹';
            };

            // ğŸŸ¢ æ–°å¢: åˆ¤æ–­ä»»åŠ¡æ˜¯å¦ä¸º"å¹½çµ"çŠ¶æ€ (Sessionä¸åŒ¹é… æˆ– è§†å›¾ç±»å‹ä¸åŒ¹é…)
            const isTaskGhost = (task) => {
                // 1. æ£€æŸ¥ Session æ˜¯å¦åŒ¹é… (æœ€åŸºç¡€æ¡ä»¶)
                const taskSession = task.sessionId || 'S_DEFAULT';
                if (taskSession !== currentSessionId.value) return true;

                // 2. æ£€æŸ¥è§†å›¾ç±»å‹æ˜¯å¦åŒ¹é…
                // å½“å‰ä¾§è¾¹æ åœ¨ä»€ä¹ˆæ¨¡å¼ï¼Œå°±åªäº®æ˜¾ä»€ä¹ˆç±»å‹çš„å—

                // å¦‚æœæ˜¯ 'musician' (äººå‘˜) è§†å›¾ -> åªæœ‰å« musicianId çš„å—äº®æ˜¾
                if (sidebarTab.value === 'musician') {
                    return !task.musicianId;
                }

                // å¦‚æœæ˜¯ 'project' (é¡¹ç›®) è§†å›¾ -> åªæœ‰å« projectId çš„å—äº®æ˜¾
                if (sidebarTab.value === 'project') {
                    return !task.projectId;
                }

                // å¦‚æœæ˜¯ 'instrument' (ä¹å™¨) è§†å›¾ -> åªæœ‰å« instrumentId çš„å—äº®æ˜¾
                if (sidebarTab.value === 'instrument') {
                    return !task.instrumentId;
                }

                return false; // é»˜è®¤ä¸å˜æˆå¹½çµ
            };

            const hasRecordingInfo = (task) => {
                // å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ£€æŸ¥å¯¹è±¡æ˜¯å¦æœ‰å†…å®¹
                const checkInfo = (info) => {
                    if (!info) return false;
                    return !!(
                        (info.studio && info.studio.trim()) ||
                        (info.engineer && info.engineer.trim()) ||
                        (info.operator && info.operator.trim()) ||
                        (info.assistant && info.assistant.trim()) ||
                        (info.notes && info.notes.trim())
                    );
                };

                // åŒæ—¶æ£€æŸ¥å½•éŸ³ä¿¡æ¯å’Œç¼–è¾‘ä¿¡æ¯
                return checkInfo(task.recordingInfo) || checkInfo(task.editInfo);
            };

            // ğŸŸ¢ [ä¿®æ”¹] ensureItemRecords: ä¿®å¤â€œè‡ªåŠ¨è·Ÿéšâ€å¤±æ•ˆçš„é—®é¢˜
            const ensureItemRecords = (item) => {
                // 1. åˆå§‹åŒ–æ—¶é—´è®°å½• records (ä¿æŒä¸å˜)
                if (!item.records) {
                    item.records = { musician: {}, project: {}, instrument: {} };
                    if (item.actualDuration || item.recStart || item.recEnd) {
                        item.records.musician = {
                            recStart: item.recStart || '',
                            recEnd: item.recEnd || '',
                            actualDuration: item.actualDuration || '',
                            breakMinutes: item.breakMinutes || 0
                        };
                    }
                }
                if (!item.records.musician) item.records.musician = {};
                if (!item.records.project) item.records.project = {};
                if (!item.records.instrument) item.records.instrument = {};

                // 2. åˆå§‹åŒ–å¤šç»´å€ç‡ ratios
                if (!item.ratios) {
                    // æ—§æ•°æ®è¿ç§»ï¼šå¦‚æœæ˜¯æ—§æ•°æ®ï¼Œä¿ç•™åŸ ratioï¼›å¦‚æœæ˜¯æ–°åˆå§‹åŒ–ï¼Œè®¾ä¸º null (è‡ªåŠ¨)
                    const oldRatio = item.ratio || 20;

                    item.ratios = {
                        // æ¼”å¥å‘˜ï¼šä¿ç•™æ—§å€¼ä½œä¸ºåˆå§‹å€¼
                        musician: item.musicianId ? oldRatio : null,
                        // é¡¹ç›®/ä¹å™¨ï¼šé»˜è®¤ä¸º null (å¼€å¯è‡ªåŠ¨è·Ÿéš)
                        project: null,
                        instrument: null
                    };
                }

                // ğŸ›‘ åˆ é™¤æˆ–æ³¨é‡Šæ‰ä¸‹é¢è¿™ä¸‰è¡Œï¼å®ƒä»¬æ˜¯ç½ªé­ç¥¸é¦–ï¼
                // if (!item.ratios.musician) item.ratios.musician = 20;
                // if (!item.ratios.project) item.ratios.project = 20;
                // if (!item.ratios.instrument) item.ratios.instrument = 20;

                // ğŸŸ¢ æ”¹ä¸ºï¼šå¦‚æœé”®ä¸å­˜åœ¨(undefined)ï¼Œæ‰åˆå§‹åŒ–ä¸º nullï¼›å¦‚æœæ˜¯ null åˆ™ä¿ç•™ null
                if (item.ratios.musician === undefined) item.ratios.musician = null;
                if (item.ratios.project === undefined) item.ratios.project = null;
                if (item.ratios.instrument === undefined) item.ratios.instrument = null;

                return item;
            };

            const formatDate = d => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            // ğŸŸ¢ [ä¿®å¤] æ—¥æœŸæ ‡å‡†åŒ–å‡½æ•°
            const normalizeDate = (input) => {
                if (!input) return '';
                // å°è¯•è§£ææ—¥æœŸ
                const d = new Date(input.replace(/\./g, '/').replace(/-/g, '/'));
                if (isNaN(d.getTime())) return input.trim(); // å¦‚æœè§£æå¤±è´¥ï¼Œè¿”å›åŸå€¼

                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const isToday = d => formatDate(new Date()) === d;

            // --- ğŸŸ¢ æ—¥æœŸåˆ‡æ¢åŠ¨ç”»æ§åˆ¶ ---
            const dateTransitionName = ref('slide-next'); // é»˜è®¤æ–¹å‘

            // ğŸŸ¢ ä¿®å¤: changeDate (ä¿®å¤æœˆè§†å›¾åˆ‡æ¢å¡é¡¿/è·³æœˆé—®é¢˜)
            const changeDate = (dir) => {
                // 1. è®¾ç½®åŠ¨ç”»æ–¹å‘
                if (dir > 0) {
                    dateTransitionName.value = 'slide-next';
                } else {
                    dateTransitionName.value = 'slide-prev';
                }

                const d = new Date(viewDate.value);

                if (currentView.value === 'week') {
                    // --- å‘¨è§†å›¾é€»è¾‘ ---
                    // ç®€å•åŠ å‡ 7 å¤©å³å¯
                    d.setDate(d.getDate() + 7 * dir);
                } else {
                    // --- æœˆè§†å›¾é€»è¾‘ (æ ¸å¿ƒä¿®å¤) ---
                    // 1. å…ˆæŠŠæ—¥æœŸè®¾ä¸º 1 å·
                    // (æ˜¯ä¸ºäº†é˜²æ­¢å¦‚ "1æœˆ31æ—¥ + 1ä¸ªæœˆ" å˜æˆ "3æœˆ3æ—¥" ä»è€Œè·³è¿‡2æœˆçš„é—®é¢˜)
                    d.setDate(1);

                    // 2. å®‰å…¨åœ°åŠ å‡æœˆä»½
                    d.setMonth(d.getMonth() + dir);
                }

                viewDate.value = d;
                window.triggerTouchHaptic('Light'); // éœ‡åŠ¨åé¦ˆ
            };

            const currentWeekDays = computed(() => {
                const d = new Date(viewDate.value);
                const day = d.getDay();
                const diff = d.getDate() - day;
                const s = new Date(d.setDate(diff));
                const r = [];
                for (let i = 0; i < 7; i++) {
                    const c = new Date(s);
                    c.setDate(s.getDate() + i);
                    r.push({
                        dateStr: formatDate(c),
                        weekday: ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][c.getDay()],
                        dateShort: `${c.getMonth() + 1}/${c.getDate()}`
                    });
                }
                return r;
            });

            // ğŸŸ¢ [é‡æ„] é€šç”¨æœˆå†ç”Ÿæˆå‡½æ•° (æ”¯æŒç”Ÿæˆä»»æ„æœˆä»½çš„æ•°æ®)
            const generateMonthGrid = (targetDate) => {
                const y = targetDate.getFullYear();
                const m = targetDate.getMonth(); // 0-11
                const f = new Date(y, m, 1); // å½“æœˆç¬¬ä¸€å¤©
                const l = new Date(y, m + 1, 0); // å½“æœˆæœ€åä¸€å¤©
                const r = [];

                // 1. ä¸Šä¸ªæœˆè¡¥ä½
                for (let i = f.getDay(); i > 0; i--) {
                    const d = new Date(y, m, 1 - i);
                    r.push({
                        fullDate: formatDate(d),
                        dayNum: d.getDate(),
                        isCurrentMonth: false,
                        dateObj: d // ç”¨äºåç»­æ¯”è¾ƒ
                    });
                }

                // 2. å½“æœˆæ—¥æœŸ
                for (let i = 1; i <= l.getDate(); i++) {
                    const d = new Date(y, m, i);
                    r.push({
                        fullDate: formatDate(d),
                        dayNum: i,
                        isCurrentMonth: true,
                        dateObj: d
                    });
                }

                // 3. ä¸‹ä¸ªæœˆè¡¥ä½ (é»˜è®¤è¡¥é½åˆ° 35 æˆ– 42 æ ¼)
                const targetLen = r.length <= 35 ? 35 : 42;
                while (r.length < targetLen) {
                    const nextDateNum = r.length - l.getDate() - f.getDay() + 1;
                    const d = new Date(y, m + 1, nextDateNum);
                    r.push({
                        fullDate: formatDate(d),
                        dayNum: nextDateNum,
                        isCurrentMonth: false,
                        dateObj: d
                    });
                }
                return r;
            };

// ğŸŸ¢ [å…¼å®¹] ä¿æŒåŸæœ‰çš„ currentMonthDays è°ƒç”¨æ–¹å¼ (ç”¨äºåˆ†é¡µæ¨¡å¼)
            const currentMonthDays = computed(() => generateMonthGrid(viewDate.value));

// ğŸŸ¢ [ä¿®æ”¹] ç”Ÿæˆè¿ç»­çš„æ‰å¹³åŒ–å¤©æ•°åˆ—è¡¨ (åŠ¨æ€èŒƒå›´)
            const flatScrolledDays = computed(() => {
                const list = [];
                // ä½¿ç”¨å“åº”å¼å˜é‡
                const bufferMonths = renderedRange.past;
                const totalMonths = renderedRange.past + renderedRange.future;

                // èµ·å§‹æ—¥æœŸï¼šä» viewDate å¾€å‰æ¨
                const startMonthDate = new Date(viewDate.value.getFullYear(), viewDate.value.getMonth() - bufferMonths, 1);

                // 1. è¡¥ä½ (Padding)
                const firstDayWeekday = startMonthDate.getDay();
                for (let i = firstDayWeekday; i > 0; i--) {
                    const d = new Date(startMonthDate);
                    d.setDate(d.getDate() - i);
                    list.push({
                        fullDate: formatDate(d),
                        dayNum: d.getDate(),
                        isCurrentMonth: false,
                        isPadding: true,
                        dateObj: d
                    });
                }

                // 2. ç”ŸæˆçœŸå®æ—¥æœŸ
                for (let i = 0; i < totalMonths; i++) {
                    const currentM = new Date(startMonthDate.getFullYear(), startMonthDate.getMonth() + i, 1);
                    const year = currentM.getFullYear();
                    const month = currentM.getMonth();
                    const daysInMonth = new Date(year, month + 1, 0).getDate();

                    for (let d = 1; d <= daysInMonth; d++) {
                        const dateObj = new Date(year, month, d);
                        list.push({
                            fullDate: formatDate(dateObj),
                            dayNum: d,
                            isCurrentMonth: true,
                            isFirstDay: d === 1,
                            dateObj: dateObj
                        });
                    }
                }

                // 3. å°¾éƒ¨è¡¥é½
                const remaining = list.length % 7;
                if (remaining > 0) {
                    const lastDate = list[list.length - 1].dateObj;
                    for (let i = 1; i <= (7 - remaining); i++) {
                        const d = new Date(lastDate);
                        d.setDate(d.getDate() + i);
                        list.push({
                            fullDate: formatDate(d),
                            dayNum: d.getDate(),
                            isCurrentMonth: false,
                            isPadding: true,
                            dateObj: d
                        });
                    }
                }

                return list;
            });

            // ğŸŸ¢ [æ–°å¢] æ— é™æ»šåŠ¨å¤„ç†å‡½æ•°
            const handleInfiniteScroll = (e) => {
                // åªåœ¨æœˆè§†å›¾çš„æ»šåŠ¨æ¨¡å¼ä¸‹ç”Ÿæ•ˆ
                if (currentView.value !== 'month' || monthViewMode.value !== 'scrolled') return;
                if (isLoadingMore.value) return;

                const el = e.target; //é€šå¸¸æ˜¯ #main-content
                const threshold = 800; // è§¦å‘é˜ˆå€¼ (åƒç´ )

                // 1. å‘ä¸Šæ»šåŠ¨åŠ è½½æ›´å¤šå†å²
                if (el.scrollTop < threshold) {
                    isLoadingMore.value = true;

                    // è®°å½•å½“å‰çš„æ»šåŠ¨é«˜åº¦å’Œä½ç½®
                    const oldScrollHeight = el.scrollHeight;
                    const oldScrollTop = el.scrollTop;

                    // å¢åŠ  6 ä¸ªæœˆå†å²
                    renderedRange.past += 6;

                    // ç­‰å¾… DOM æ›´æ–°åï¼Œä¿®æ­£æ»šåŠ¨æ¡ä½ç½®
                    nextTick(() => {
                        const newScrollHeight = el.scrollHeight;
                        // å…³é”®ï¼šæ–°çš„é«˜åº¦ - æ—§çš„é«˜åº¦ = æ–°å¢å†…å®¹çš„é«˜åº¦
                        el.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
                        isLoadingMore.value = false;
                    });
                }
                // 2. å‘ä¸‹æ»šåŠ¨åŠ è½½æ›´å¤šæœªæ¥
                else if (el.scrollTop + el.clientHeight > el.scrollHeight - threshold) {
                    isLoadingMore.value = true;
                    renderedRange.future += 6; // å¢åŠ  6 ä¸ªæœˆæœªæ¥

                    nextTick(() => {
                        isLoadingMore.value = false;
                    });
                }
            };

            // ğŸŸ¢ [ä¿®æ”¹] æ»šåŠ¨åˆ°æŒ‡å®šæ—¥æœŸ (å¹¶å±…ä¸­æ˜¾ç¤º)
            const scrollToMonthDate = (targetDate) => {
                // 1. æ ¼å¼åŒ–ç›®æ ‡æ—¥æœŸå­—ç¬¦ä¸² (YYYY-MM-DD)
                // è¿™æ ·æˆ‘ä»¬å¯ä»¥ç²¾ç¡®å®šä½åˆ°â€œä»Šå¤©â€æˆ–è€…â€œé€‰ä¸­çš„é‚£å¤©â€ï¼Œè€Œä¸ä»…ä»…æ˜¯æœˆåˆ
                const targetDateStr = formatDate(targetDate);

                // 2. ç¨å¾®å»¶è¿Ÿï¼Œç­‰å¾… DOM æ¸²æŸ“
                setTimeout(() => {
                    // 3. åˆ©ç”¨ data-date å±æ€§æŸ¥æ‰¾å…·ä½“çš„æ—¥æœŸæ ¼å­
                    // (HTML æ¨¡æ¿ä¸­å·²ç»‘å®š :data-date="day.fullDate")
                    const el = document.querySelector(`[data-date="${targetDateStr}"]`);

                    if (el) {
                        // 4. block: 'center' å°†å…¶ç½®äºè§†å£å‚ç›´å±…ä¸­ä½ç½®
                        el.scrollIntoView({ behavior: 'auto', block: 'center' });
                    } else {
                        // å…œåº•ï¼šå¦‚æœæ‰¾ä¸åˆ°å…·ä½“æ—¥æœŸï¼ˆæ¯”å¦‚åˆ‡åˆ°äº†å¾ˆè¿œçš„æœˆä»½ï¼‰ï¼Œå°è¯•é€€å›æ‰¾å½“æœˆ1å·
                        const y = targetDate.getFullYear();
                        const m = String(targetDate.getMonth() + 1).padStart(2, '0');
                        const monthStartId = `${y}-${m}-01`;
                        const monthEl = document.querySelector(`[data-month-start="${monthStartId}"]`);

                        if (monthEl) {
                            monthEl.scrollIntoView({ behavior: 'auto', block: 'center' });
                        }
                    }
                }, 50);
            };

            // ç›‘å¬æ•°æ®å˜åŒ– (æ”¹åäº†)
            watch(flatScrolledDays, () => {
                if (monthViewMode.value === 'scrolled') {
                    nextTick(() => initMonthObserver());
                }
            });



            // ğŸŸ¢ [ä¿®æ”¹] é¡¶éƒ¨æ ‡é¢˜é€»è¾‘ï¼šæ ¹æ®æ¨¡å¼æ˜¾ç¤ºä¸åŒæ—¥æœŸ
            const currentDateLabel = computed(() => {
                // 1. å¦‚æœæ˜¯æœˆè§†å›¾-æ»šåŠ¨æ¨¡å¼ï¼Œæ˜¾ç¤º IntersectionObserver ä¾¦æµ‹åˆ°çš„æ—¥æœŸ
                if (currentView.value === 'month' && monthViewMode.value === 'scrolled') {
                    return `${visibleTopDate.value.getFullYear()}å¹´ ${visibleTopDate.value.getMonth() + 1}æœˆ`;
                }

                // 2. å…¶ä»–æƒ…å†µ (å‘¨è§†å›¾ æˆ– æœˆè§†å›¾-åˆ†é¡µ)ï¼Œæ˜¾ç¤ºé€‰ä¸­çš„ viewDate
                return `${viewDate.value.getFullYear()}å¹´ ${viewDate.value.getMonth() + 1}æœˆ`;
            });

            // æ‰¾åˆ°åŸæœ‰çš„ tasksByDateMap å®šä¹‰ï¼Œç”¨è¿™æ®µä»£ç æ›¿æ¢å®ƒ
            const tasksByDateMap = computed(() => {
                const map = {};
                // ğŸ”´ ä¿®æ”¹ç‚¹: è¿™é‡ŒåŸæ¥æ˜¯ scheduledTasks.valueï¼Œç°åœ¨æ”¹æˆ filteredScheduledTasks.value
                for (const task of filteredScheduledTasks.value) {
                    if (!map[task.date]) {
                        map[task.date] = [];
                    }
                    map[task.date].push(task);
                }

                for (const date in map) {
                    map[date].sort((a, b) => {
                        return a.startTime.localeCompare(b.startTime);
                    });
                }

                return map;
            });

            // è¾…åŠ©å‡½æ•°ï¼šä»…ä¿ç•™ç”¨äºæ¨¡æ¿ä¸­ä»ç„¶éœ€è¦å‡½æ•°è°ƒç”¨çš„æå°‘æ•°æƒ…å†µ (å¯é€‰ï¼Œä¸»è¦ä¸ºäº†å…¼å®¹)
            const getTasksForDate = (d) => {
                return tasksByDateMap.value[d] || [];
            };
            const switchToWeek = d => {
                viewDate.value = new Date(d);
                currentView.value = 'week';
            };
            const openEditModal = (i, s) => {
                editingItem.value = JSON.parse(JSON.stringify(i));

                // ğŸŸ¢ å…³é”®ä¿®æ”¹ï¼šå¦‚æœå€ç‡ä¸ºç©ºæˆ–0ï¼Œé»˜è®¤è®¾ä¸º getDefaultRatio
                if (!editingItem.value.ratio || editingItem.value.ratio <= 0) {
                    editingItem.value.ratio = getDefaultRatio(editingItem.value.musicianId); // ğŸŸ¢ ä½¿ç”¨é€šç”¨é»˜è®¤å€ç‡
                }

                editingSource.value = s;
                showEditor.value = true;
            };

            const saveEdit = () => {
                if (editingItem.value.orchestration) {
                    editingItem.value.orchestration = editingItem.value.orchestration.trim();
                }
                // ğŸŸ¢ æ–°å¢ï¼šä¿å­˜å‰çš„æœ€åä¸€é“é˜²çº¿ï¼Œå¦‚æœä¸ºç©ºå¼ºåˆ¶è®¾ä¸º 20
                if (!editingItem.value.ratio || editingItem.value.ratio <= 0) {
                    editingItem.value.ratio = getDefaultRatio(editingItem.value.musicianId);
                }

                // æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿ä¹æ›²æ—¶é•¿å’Œå€æ•°æ›´æ–°åï¼Œä¼°ç®—æ—¶é•¿ä¹Ÿä¼šæ›´æ–°
                editingItem.value.estDuration = calculateEstTime(editingItem.value.musicDuration, editingItem.value.ratio);
                // ğŸŸ¢ã€æ–°å¢ã€‘ä¿å­˜æ—¶ï¼Œè‡ªåŠ¨åŒæ­¥ç¼–åˆ¶ä¿¡æ¯ç»™æ‰€æœ‰å…³è”çš„ Part
                syncFamilyOrchestration(editingItem.value, editingItem.value.orchestration);

                if (editingSource.value === 'pool') {
                    const idx = itemPool.value.findIndex(x => x.id === editingItem.value.id);
                    if (idx !== -1) {
                        // æ›´æ–°ä»»åŠ¡æ¨¡æ¿
                        itemPool.value[idx] = editingItem.value;
                        // å¦‚æœæ˜¯æ¨¡æ¿ï¼ŒåŒæ—¶æ›´æ–°æ‰€æœ‰å·²æ’æœŸçš„å®ä¾‹
                        scheduledTasks.value.filter(st => st.templateId === editingItem.value.id).forEach(st => {
                            st.projectId = editingItem.value.projectId;
                            st.instrumentId = editingItem.value.instrumentId;
                            st.musicianId = editingItem.value.musicianId;
                            st.musicDuration = editingItem.value.musicDuration;
                            st.ratio = editingItem.value.ratio;
                            st.estDuration = editingItem.value.estDuration;
                        });
                    }
                } else {
                    const idx = scheduledTasks.value.findIndex(x => x.scheduleId === editingItem.value.scheduleId);
                    if (idx !== -1) {
                        scheduledTasks.value[idx] = editingItem.value;
                        updateTaskNotification(scheduledTasks.value[idx]);
                    }
                }

                showEditor.value = false;

                // ğŸŸ¢ ä¿®å¤ç‚¹ï¼šä¿å­˜åï¼Œç«‹å³è§¦å‘æ•ˆç‡é‡ç®—
                // å› ä¸ºä¿®æ”¹äº†æ—¶é•¿(Music Duration)ï¼Œä¼šå¯¼è‡´åˆ†æ¯å˜åŒ–ï¼Œä»è€Œå½±å“å¹³å‡å€ç‡
                if (editingItem.value.musicianId) autoUpdateEfficiency(editingItem.value.musicianId, 'musician', false);
                if (editingItem.value.projectId) autoUpdateEfficiency(editingItem.value.projectId, 'project', false);
                // å¦‚æœéœ€è¦æ”¯æŒä¹å™¨è§†å›¾çš„è‡ªåŠ¨æ›´æ–°ï¼Œä¹Ÿå¯ä»¥åŠ ä¸Šï¼š
                // if (editingItem.value.instrumentId) autoUpdateEfficiency(editingItem.value.instrumentId, 'instrument', false);

                pushHistory();
            };

            // ğŸŸ¢ [ä¿®æ”¹] deleteEditingItem
            const deleteEditingItem = () => {
                // 1. å¦‚æœæ˜¯åˆ é™¤æ—¥ç¨‹ï¼Œå…ˆå–æ¶ˆç³»ç»Ÿé€šçŸ¥ (ä¿æŒåŸæœ‰é€»è¾‘)
                if (editingSource.value !== 'pool') {
                    const LocalNotifications = window.Capacitor?.Plugins?.LocalNotifications;
                    if (LocalNotifications) {
                        const notifId = editingItem.value.scheduleId % 2147483647;
                        LocalNotifications.cancel({notifications: [{id: notifId}]});
                    }
                }

                if (editingSource.value === 'pool') {
                    // ğŸ›¡ï¸ [æ–°å¢] æ£€æŸ¥æ˜¯å¦ä¸ºæœ«ç«¯ä»»åŠ¡ (ä»…é’ˆå¯¹ä»»åŠ¡æ± åˆ é™¤)
                    if (!checkCanDeleteSplit(editingItem.value)) return;

                    // ğŸŸ¢ æ ¸å¿ƒä¿®å¤: åœ¨ç‰©ç†åˆ é™¤å‰ï¼Œå°è¯•å°†æ—¶é—´å½’è¿˜ç»™çˆ¶ä»»åŠ¡ (Part 1)
                    restoreSplitTime(editingItem.value);

                    // åˆ é™¤ä»»åŠ¡æ± é€»è¾‘
                    scheduledTasks.value = scheduledTasks.value.filter(t => t.templateId !== editingItem.value.id);
                    itemPool.value = itemPool.value.filter(i => i.id !== editingItem.value.id);
                    cleanupEmptySchedules();
                } else {
                    // === åˆ é™¤æ—¥ç¨‹è¡¨é€»è¾‘ (ä¿æŒä¸å˜) ===
                    if (editingItem.value.templateId) {
                        clearPoolRecord(editingItem.value.templateId);
                    }
                    scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== editingItem.value.scheduleId);
                }

                showEditor.value = false;
                pushHistory();
            };

            const sidebarTab = ref('musician');

            // ğŸŸ¢ [é‡å†™] æ ¸å¿ƒç»Ÿè®¡å‡½æ•° (æ™ºèƒ½æœç´¢ä¼˜åŒ–ç‰ˆï¼šä¿®å¤ "Part 1" è¯¯æœ "Part 2" çš„é—®é¢˜)
            const calculateGroupStats = (sourceList, filterKey) => {
                const currentSessionItems = itemPool.value.filter(t =>
                    (t.sessionId || 'S_DEFAULT') === currentSessionId.value
                );

                const recordTypeMap = {
                    'musicianId': 'musician',
                    'projectId': 'project',
                    'instrumentId': 'instrument'
                };
                const currentRecordType = recordTypeMap[filterKey] || 'musician';

                // --- 1. å‡†å¤‡æœç´¢æ¡ä»¶ ---
                const rawQuery = globalSearchQuery.value.trim().toLowerCase();
                const statusDefinitions = {
                    'å®Œæˆ': ['completed'], 'finished': ['completed'],
                    'è¿›è¡Œä¸­': ['in-progress'], 'ing': ['in-progress'],
                    'ç¼ºæ—¶': ['insufficient'], 'missing': ['insufficient'],
                    'å·²æ’': ['full', 'completed'], 'full': ['full', 'completed']
                };

                const textKeywords = [];
                const statusFilters = new Set();

                if (rawQuery) {
                    // 1. æå–çŠ¶æ€å…³é”®è¯
                    // æˆ‘ä»¬å…ˆç”¨ç©ºæ ¼æ‹†åˆ†æ¥æ£€æŸ¥æ˜¯å¦åŒ…å«çŠ¶æ€è¯ (å¦‚ "Part 1 å®Œæˆ")
                    const tempParts = rawQuery.split(/\s+/).filter(k => k);
                    const nonStatusParts = [];

                    tempParts.forEach(inputWord => {
                        let isStatus = false;
                        for (const [key, statuses] of Object.entries(statusDefinitions)) {
                            if (key.includes(inputWord) || inputWord.includes(key)) {
                                statuses.forEach(s => statusFilters.add(s));
                                isStatus = true;
                                break;
                            }
                        }
                        if (!isStatus) nonStatusParts.push(inputWord);
                    });

                    // 2. ç”Ÿæˆæ–‡æœ¬å…³é”®è¯ (æ™ºèƒ½é˜²æ‹†åˆ†é€»è¾‘)
                    // é‡æ–°ç»„åˆå‰©ä½™çš„éçŠ¶æ€è¯
                    const cleanQuery = nonStatusParts.join(' ');

                    if (cleanQuery) {
                        // ğŸŸ¢ æ ¸å¿ƒä¼˜åŒ–: æ£€æµ‹ "å•è¯+ç©ºæ ¼+æ•°å­—" æ¨¡å¼ (ä¾‹å¦‚ "Part 1", "Take 2", "Violin 1")
                        // å¦‚æœç¬¦åˆè¿™ç§æ¨¡å¼ï¼Œå¼ºåˆ¶ä½œä¸ºæ•´ä½“åŒ¹é…ï¼Œä¸æ‹†åˆ†
                        const isSequencePattern = /^[a-zA-Z\u4e00-\u9fa5]+\s+\d+$/.test(cleanQuery);

                        if (isSequencePattern) {
                            textKeywords.push(cleanQuery); // æ•´ä½“æ¨å…¥ï¼Œå¦‚ ["part 1"]
                        } else {
                            // å¦åˆ™æ­£å¸¸æ‹†åˆ†ï¼Œæ”¯æŒ "Violin Mozart" æœ "Mozart Violin"
                            textKeywords.push(...cleanQuery.split(/\s+/));
                        }
                    }
                }

                // æ˜¯å¦å¤„äºæ–‡æœ¬æœç´¢æ¨¡å¼
                const isSearchMode = textKeywords.length > 0;

                const stats = sourceList.map(group => {
                    // 1. è·å–è¯¥ç»„ä¸‹çš„åŸå§‹ä»»åŠ¡
                    let poolItems = currentSessionItems.filter(t => t[filterKey] === group.id);

                    // --- è¿‡æ»¤é€»è¾‘ ---
                    if (isSearchMode) {
                        poolItems = poolItems.filter(item => {
                            // åŸä»£ç ï¼š
                            // const fullText = getFullSearchText(item, group.name);

                            // ğŸŸ¢ ä¿®æ”¹åï¼šå°†å½“å‰å¤§å¡ç‰‡çš„åˆ†ç»„ (group.group) ä¹Ÿæ‹¼æ¥åˆ°æœç´¢æ–‡ä¸­
                            // è¿™æ ·æ¯”å¦‚æ‚¨åœ¨ä¹å™¨è§†å›¾æœ "Pluck"ï¼Œå±äº Pluck åˆ†ç»„çš„ "Guitar" å¡ç‰‡å°±ä¼šè¢«åŒ¹é…åˆ°
                            const groupContext = `${group.name} ${group.group || ''}`;
                            const fullText = getFullSearchText(item, groupContext);

                            return textKeywords.every(k => smartMatch(fullText, k));
                        });
                    }

                    if (poolItems.length === 0) return null;

                    // 2. è·å–è¯¥ç»„çš„æ—¥ç¨‹å—
                    const scheduleItems = scheduledTasks.value.filter(t =>
                        t[filterKey] === group.id &&
                        (t.sessionId || 'S_DEFAULT') === currentSessionId.value
                    );
                    scheduleItems.sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));
                    const scheduleCount = scheduleItems.length;

                    // --- A. è®¡ç®—å¹³å‡å€ç‡ (åŸºäºç­›é€‰åçš„æ¡ç›®) ---
                    let groupTotalActual = 0;
                    let groupTotalMusic = 0;

                    poolItems.forEach(item => {
                        ensureItemRecords(item);
                        const rec = item.records ? item.records[currentRecordType] : null;
                        if (rec && rec.actualDuration && item.musicDuration) {
                            const act = parseTime(rec.actualDuration);
                            const mus = parseTime(item.musicDuration);
                            if (act > 0 && mus > 0) {
                                groupTotalActual += act;
                                groupTotalMusic += mus;
                            }
                        }
                    });

                    const avgRealRatio = (groupTotalMusic > 0)
                        ? parseFloat((groupTotalActual / groupTotalMusic).toFixed(1))
                        : 0;

                    let smartBaseRatio = 20;
                    if (avgRealRatio > 0) {
                        smartBaseRatio = avgRealRatio;
                    } else if (group.defaultRatio && group.defaultRatio > 0) {
                        smartBaseRatio = parseFloat(group.defaultRatio);
                    }

                    // --- B. è®¡ç®—æ€»éœ€æ—¶é•¿ (åº”ç”¨æ™ºèƒ½å€ç‡) ---
                    let totalSecs = 0;
                    let totalActualSec = 0;
                    let recordedCount = 0;
                    let effectiveCount = 0;

                    const displayItems = poolItems.map(rawItem => {
                        ensureItemRecords(rawItem);

                        const rec = rawItem.records ? rawItem.records[currentRecordType] : null;
                        const actualDur = (rec && rec.actualDuration) ? rec.actualDuration : null;

                        const manualRatio = rawItem.ratios ? rawItem.ratios[currentRecordType] : null;
                        const rawVal = manualRatio ? parseFloat(manualRatio) : 0;
                        let validManualRatio = null;

                        if (rawVal > 0 && rawVal !== 20 && rawVal !== smartBaseRatio) {
                            // è¿™é‡Œå¢åŠ ä¸€ä¸ªå®¹é”™ï¼šå¦‚æœ manualRatio å’Œ defaultRatio ç›¸åŒï¼Œä¹Ÿè§†ä¸ºè‡ªåŠ¨
                            const defaultR = (group.defaultRatio && group.defaultRatio > 0) ? parseFloat(group.defaultRatio) : 20;
                            if (rawVal !== defaultR) {
                                validManualRatio = rawVal;
                            }
                        }

                        const isManual = (validManualRatio !== null);
                        const effectiveRatio = isManual ? validManualRatio : smartBaseRatio;
                        const dynEst = calculateEstTime(rawItem.musicDuration, effectiveRatio);

                        if (!rawItem.isSkipped) {
                            effectiveCount++;
                            if (actualDur) {
                                recordedCount++;
                                totalActualSec += parseTime(actualDur);
                            }
                            totalSecs += parseTime(dynEst || '00:00');
                        }

                        return {
                            ...rawItem,
                            actualDuration: actualDur,
                            ratio: effectiveRatio,
                            isManualRatio: isManual,
                            estDuration: dynEst,
                            _sortTime: (rec && rec.recStart) ? rec.recStart : '99:99'
                        };
                    });

                    // æ’åº
                    displayItems.sort((a, b) => {
                        if (!!a.isSkipped !== !!b.isSkipped) return a.isSkipped ? 1 : -1;
                        if (sortField.value === 'duration' || sortField.value === 'status') {
                            const actualA = parseTime(a.actualDuration || '00:00');
                            const actualB = parseTime(b.actualDuration || '00:00');
                            if (actualA !== actualB) return sortAsc.value ? (actualB - actualA) : (actualA - actualB);
                            const estA = parseTime(a.estDuration || '00:00');
                            const estB = parseTime(b.estDuration || '00:00');
                            if (estA !== estB) return sortAsc.value ? (estB - estA) : (estA - estB);
                        } else if (sortField.value === 'name') {
                            const nameA = filterKey === 'musicianId' ? getNameById(a.projectId, 'project') : getNameById(a.musicianId, 'musician');
                            const nameB = filterKey === 'musicianId' ? getNameById(b.projectId, 'project') : getNameById(b.musicianId, 'musician');

                            // ğŸŸ¢ ä¿®å¤ï¼šå¯ç”¨è‡ªç„¶æ’åº
                            return sortAsc.value
                                ? nameA.localeCompare(nameB, 'zh-CN', { numeric: true })
                                : nameB.localeCompare(nameA, 'zh-CN', { numeric: true });
                        }
                        const secA = a.sectionIndex || 0;
                        const secB = b.sectionIndex || 0;
                        if (secA !== secB) return secA - secB;
                        return a._sortTime.localeCompare(b._sortTime);
                    });

                    // --- C. è®¡ç®—å·²æ’æœŸæ—¶é•¿ (æœç´¢æ¨¡å¼: ä»…ç´¯åŠ çœŸå®å½•éŸ³æ—¶é•¿) ---
                    let scheduledSecs = 0;

                    if (isSearchMode) {
                        displayItems.forEach(item => {
                            if (item.sectionIndex !== undefined && item.sectionIndex >= 0 && item.sectionIndex < scheduleItems.length) {
                                if (item.actualDuration && item.actualDuration !== '00:00') {
                                    scheduledSecs += parseTime(item.actualDuration);
                                }
                            }
                        });
                    } else {
                        // æ™®é€šæ¨¡å¼
                        scheduleItems.forEach((block, blockIndex) => {
                            const blockTotalSecs = parseTime(block.estDuration);
                            const itemsInBlock = poolItems.filter(item => {
                                const sIdx = item.sectionIndex !== undefined ? item.sectionIndex : 0;
                                return sIdx === blockIndex;
                            });
                            const totalBreakSecs = itemsInBlock.reduce((sum, item) => {
                                const rec = item.records && item.records[currentRecordType];
                                const bMins = (rec && rec.breakMinutes) ? parseInt(rec.breakMinutes) : 0;
                                return sum + (bMins * 60);
                            }, 0);
                            let totalGapSecs = 0;
                            const recordedItems = itemsInBlock.filter(item => {
                                const r = item.records?.[currentRecordType];
                                return r && r.recStart && r.recEnd;
                            });
                            recordedItems.sort((a, b) => {
                                const tA = a.records[currentRecordType].recStart;
                                const tB = b.records[currentRecordType].recStart;
                                return tA.localeCompare(tB);
                            });
                            for(let i = 0; i < recordedItems.length - 1; i++) {
                                const curr = recordedItems[i];
                                const next = recordedItems[i+1];
                                const currRec = curr.records[currentRecordType];
                                const nextRec = next.records[currentRecordType];
                                const toMins = (t) => { const [h,m] = t.split(':').map(Number); return h*60+m; };
                                let endMins = toMins(currRec.recEnd);
                                let startMins = toMins(nextRec.recStart);
                                if (startMins >= endMins) {
                                    const gap = startMins - endMins;
                                    if (gap > 0) totalGapSecs += (gap * 60);
                                }
                            }
                            let netBlockDuration = blockTotalSecs - totalBreakSecs - totalGapSecs;
                            if (netBlockDuration < 0) netBlockDuration = 0;
                            scheduledSecs += netBlockDuration;
                        });
                    }

                    // --- D. çŠ¶æ€åˆ¤æ–­ ---
                    const trackCount = poolItems.length;
                    let statusKey = 'unscheduled';

                    if (trackCount > 0 && effectiveCount === 0) {
                        statusKey = 'completed';
                    }
                    else if (effectiveCount > 0 && recordedCount === effectiveCount) {
                        statusKey = 'completed';
                    }
                    else if (scheduledSecs > 0 && scheduledSecs < totalSecs) {
                        statusKey = 'insufficient';
                    }
                    else if (recordedCount > 0) {
                        statusKey = 'in-progress';
                    }
                    else if (scheduledSecs >= totalSecs && totalSecs > 0) {
                        statusKey = 'full';
                    }

                    if (statusFilters.size > 0) {
                        if (!statusFilters.has(statusKey)) return null;
                    }

                    return {
                        ...group,
                        id: group.id,
                        items: displayItems,
                        trackCount,
                        scheduleCount,
                        totalDuration: formatSecs(totalSecs),
                        totalSeconds: totalSecs,
                        scheduledSeconds: scheduledSecs,
                        completedSeconds: totalActualSec,
                        statusKey,
                        avgRealRatio,
                        recordedCount,
                        isFullyScheduled: (statusKey === 'full' || statusKey === 'completed')
                    };
                }).filter(Boolean);

                return stats.sort((a, b) => {
                    if (sortField.value === 'name') {
                        // ğŸŸ¢ ä¿®å¤: å¯ç”¨è‡ªç„¶æ’åº
                        return sortAsc.value
                            ? a.name.localeCompare(b.name, 'zh-CN', { numeric: true })
                            : b.name.localeCompare(a.name, 'zh-CN', { numeric: true });
                    }
                    if (sortField.value === 'status') {
                        const statusWeight = { 'completed': 0, 'in-progress': 1, 'insufficient': 2, 'full': 3, 'unscheduled': 4 };
                        const wA = statusWeight[a.statusKey] ?? 99;
                        const wB = statusWeight[b.statusKey] ?? 99;
                        if (wA !== wB) return sortAsc.value ? (wA - wB) : (wB - wA);
                        return a.name.localeCompare(b.name, 'zh-CN');
                    }
                    const valA = a.totalSeconds;
                    const valB = b.totalSeconds;
                    if (valA < valB) return sortAsc.value ? -1 : 1;
                    if (valA > valB) return sortAsc.value ? 1 : -1;
                    return 0;
                });
            };

            // 3. ä¸‰ä¸ªç»´åº¦çš„è®¡ç®—å±æ€§
            // ä»ç„¶ä¿ç•™ musicianStats è¿™ä¸ªåå­—ï¼Œä»¥å…¼å®¹ä½ ä»£ç ä¸­å¯èƒ½å¼•ç”¨å®ƒçš„åœ°æ–¹
            const musicianStats = computed(() => calculateGroupStats(settings.musicians, 'musicianId'));
            const projectStats = computed(() => calculateGroupStats(settings.projects, 'projectId'));
            const instrumentStats = computed(() => calculateGroupStats(settings.instruments, 'instrumentId'));

            // ğŸŸ¢ æ–°å¢: ç»Ÿè®¡å½“å‰ Session ä¸‹çš„æ´»è·ƒä»»åŠ¡æ€»æ•°
            const activeTaskCount = computed(() => {
                return itemPool.value.filter(t => (t.sessionId || 'S_DEFAULT') === currentSessionId.value).length;
            });

            // 4. å½“å‰ä¾§è¾¹æ æ˜¾ç¤ºçš„æ•°æ®æº
            const currentSidebarList = computed(() => {
                if (sidebarTab.value === 'project') return projectStats.value;
                if (sidebarTab.value === 'instrument') return instrumentStats.value;
                return musicianStats.value;
            });

            // V10.0 æ–°å¢ï¼šè®¡ç®—æ¼”å¥å‘˜ç»Ÿè®¡æ•°æ®
            // --- V10.4 æ–°å¢ï¼šç»Ÿè®¡å¡ç‰‡å±•å¼€çŠ¶æ€ ---
            const expandedStatsIds = reactive(new Set());

            const toggleStatCollapse = (id) => {
                if (expandedStatsIds.has(id)) {
                    expandedStatsIds.delete(id);
                } else {
                    expandedStatsIds.add(id);
                }
            };

            // ğŸŸ¢ æ–°å¢: è®¡ç®—å½“å‰å¼¹çª—å†…æ—¥ç¨‹å—çš„å®æ—¶æ¯”ç‡
            const getSessionRatio = () => {
                const actual = trackListData.value.actualDuration;
                const items = trackListData.value.items;

                if (!actual || !items || items.length === 0) return '-';

                const actualSec = parseTime(actual);
                if (actualSec === 0) return '-';

                // è®¡ç®—è¯¥å—å†…æ‰€æœ‰æ›²ç›®çš„è°±é¢æ€»é•¿
                const totalMusicSec = items.reduce((sum, item) => sum + parseTime(item.musicDuration), 0);

                if (totalMusicSec === 0) return '-';

                return (actualSec / totalMusicSec).toFixed(1);
            };

            // ğŸŸ¢ æ–°å¢: å°†çœŸå®æ¯”å€¼åº”ç”¨ä¸ºé»˜è®¤æ¯”å€¼
            // ğŸŸ¢ ä¿®å¤: æ›´æ–°å€ç‡å¹¶é‡ç®—æ‰€æœ‰ä»»åŠ¡æ—¶é•¿
            // ğŸŸ¢ ä¿®æ”¹: ç§»é™¤ç¡®è®¤å¼¹çª—ï¼Œç›´æ¥æ›´æ–°å…¨å±€å€ç‡
            // ğŸŸ¢ ä¿®å¤: æ›´æ–°æ•ˆç‡ (ä¿®å¤æ—¥ç¨‹å—ç¼©ä¸º0çš„Bug)
            const updateMusicianRatio = (stat) => {
                if (!stat.avgRealRatio || stat.avgRealRatio <= 0) return;

                const newRatio = parseFloat(stat.avgRealRatio);

                // 1. æ›´æ–°æ¼”å¥å‘˜çš„å…¨å±€é»˜è®¤è®¾ç½®
                const mus = settings.musicians.find(m => m.id === stat.id);
                if (mus) {
                    mus.defaultRatio = newRatio;
                }

                // 2. æ›´æ–°ã€ä»»åŠ¡æ± ã€‘é‡Œè¯¥æ¼”å¥å‘˜çš„æ‰€æœ‰ä»»åŠ¡
                // ä»»åŠ¡æ± é‡Œçš„éƒ½æ˜¯æ¨¡æ¿ï¼Œè‚¯å®šæœ‰ musicDurationï¼Œæ‰€ä»¥å¿…é¡»æ›´æ–° estDuration ä»¥ä¾¿ä¸‹æ¬¡æ‹–æ‹½
                itemPool.value.forEach(item => {
                    if (item.musicianId === stat.id) {
                        item.ratio = newRatio;
                        if (item.musicDuration) {
                            item.estDuration = calculateEstTime(item.musicDuration, newRatio);
                        }
                    }
                });

                // 3. æ›´æ–°ã€æ—¥ç¨‹è¡¨ã€‘é‡Œè¯¥æ¼”å¥å‘˜çš„æ‰€æœ‰ä»»åŠ¡
                scheduledTasks.value.forEach(task => {
                    if (task.musicianId === stat.id) {
                        task.ratio = newRatio;

                        // ğŸŸ¢ å…³é”®ä¿®å¤: åªæœ‰å½“ä»»åŠ¡æ‹¥æœ‰â€œè°±é¢æ—¶é•¿â€æ—¶ï¼Œæ‰æ ¹æ®æ–°å€ç‡é‡ç®—æ—¶é•¿
                        // å¦‚æœæ˜¯çº¯æ—¶é—´å ä½å—(æ²¡æœ‰musicDuration)ï¼Œåˆ™ä¿æŒåŸæœ‰æ’æœŸæ—¶é—´ä¸å˜
                        if (task.musicDuration) {
                            task.estDuration = calculateEstTime(task.musicDuration, newRatio);
                        }
                    }
                });

                pushHistory();
            };

            const musicianScheduledStats = computed(() => {
                const map = {};

                for (const mus of settings.musicians) {
                    map[mus.id] = {
                        id: mus.id,
                        name: mus.name,
                        color: mus.color,
                        scheduledSeconds: 0
                    };
                }

                for (const task of scheduledTasks.value) {
                    const sec = parseTime(task.estDuration);
                    if (map[task.musicianId]) {
                        map[task.musicianId].scheduledSeconds += sec;
                    }
                }

                // æ ¼å¼åŒ–
                return Object.values(map).map(m => ({
                    ...m,
                    scheduledFormatted: formatSecs(m.scheduledSeconds)
                }));
            });

            // ğŸŸ¢ ä¿®å¤: è·³è½¬å›ä»Šå¤© (ä¿®å¤åŠ¨ç”»æ–¹å‘)
            const jumpToToday = () => {
                const now = new Date();

                // ğŸŸ¢ å…³é”®ä¿®å¤: åˆ¤æ–­ä»Šå¤©æ˜¯åœ¨å½“å‰è§†å›¾çš„"å·¦è¾¹"è¿˜æ˜¯"å³è¾¹"
                if (now.getTime() > viewDate.value.getTime()) {
                    dateTransitionName.value = 'slide-next'; // ä»Šå¤©åœ¨æœªæ¥ -> å·¦æ»‘
                } else if (now.getTime() < viewDate.value.getTime()) {
                    dateTransitionName.value = 'slide-prev'; // ä»Šå¤©åœ¨è¿‡å» -> å³æ»‘
                }

                // 1. é‡ç½®æ—¥æœŸ
                viewDate.value = now;

                // 2. åªæœ‰åœ¨å‘¨è§†å›¾æ‰éœ€è¦æ»šåŠ¨å®šä½
                if (currentView.value === 'week') {
                    setTimeout(() => {
                        if (weekContainer.value) {
                            // --- A. è®¡ç®—å‚ç›´ä½ç½® (å®šä½åˆ°å½“å‰æ—¶é—´) ---
                            const currentMins = now.getHours() * 60 + now.getMinutes();
                            const startMins = settings.startHour * 60;
                            // å‚ç›´ç›®æ ‡ä½ç½® (åƒç´ )
                            const targetTop = (currentMins - startMins) * pxPerMin.value;
                            // å‚ç›´å±…ä¸­ä¿®æ­£
                            const screenHeight = weekContainer.value.clientHeight;
                            const scrollTop = Math.max(0, targetTop - (screenHeight / 2));

                            // --- B. è®¡ç®—æ°´å¹³ä½ç½® (å®šä½åˆ°ä»Šå¤©è¿™ä¸€åˆ—) ---
                            const dayIndex = now.getDay();
                            const timeColWidth = window.innerWidth < 800 ? 40 : 70;
                            const dayColWidth = 100; // è¿™é‡Œçš„å®½åº¦ä¼°ç®—å¯èƒ½éœ€è¦æ ¹æ®å®é™… dayColWidth.value è°ƒæ•´ï¼Œä½†é€šå¸¸å¤Ÿç”¨
                            const targetCenterX = timeColWidth + (dayIndex * dayColWidth) + (dayColWidth / 2);
                            const containerWidth = weekContainer.value.clientWidth;
                            const scrollLeft = Math.max(0, targetCenterX - (containerWidth / 2));

                            // --- C. æ‰§è¡ŒåŒå‘æ»šåŠ¨ ---
                            weekContainer.value.scrollTo({
                                top: scrollTop,
                                left: scrollLeft,
                                behavior: 'smooth'
                            });
                        }
                    }, 100);
                }
            };

            const handlePageUnload = () => {
                if (saveStatus.value === 'unsaved') {
                    // å°è¯•å‘é€æœ€åçš„æ•°æ® (åˆ©ç”¨ Beacon API æˆ–åŒæ­¥è¯·æ±‚ï¼Œä½†æœ€ç®€å•çš„æ˜¯ç”±æµè§ˆå™¨å°½åŠ›å‘é€)
                    saveToCloud(true);
                }
            };

            // ğŸŸ¢ æ–°å¢: ä¸“é—¨ç”¨äºç‚¹å‡»é¢œè‰²æ¡è·³è½¬æ—¥ç¨‹çš„å‡½æ•°
            const jumpToStatSchedule = (stat) => {
                if (isMobile.value) window.triggerTouchHaptic('Medium');

                // 1. æŸ¥æ‰¾ç›¸å…³ä»»åŠ¡ (æ ¹æ®å½“å‰ Tab ç±»å‹ç­›é€‰)
                let relatedTasks = [];
                if (sidebarTab.value === 'project') {
                    relatedTasks = scheduledTasks.value.filter(t => t.projectId === stat.id);
                } else if (sidebarTab.value === 'instrument') {
                    relatedTasks = scheduledTasks.value.filter(t => t.instrumentId === stat.id);
                } else {
                    relatedTasks = scheduledTasks.value.filter(t => t.musicianId === stat.id);
                }

                // 2. è¿‡æ»¤æ‰éå½“å‰ Session çš„ä»»åŠ¡
                relatedTasks = relatedTasks.filter(t => (t.sessionId || 'S_DEFAULT') === currentSessionId.value);

                // å¦‚æœæ²¡æœ‰å·²æ’æœŸçš„ä»»åŠ¡ï¼Œæ— æ³•è·³è½¬
                if (relatedTasks.length === 0) {
                    openAlertModal("æœªæ’æœŸ", "è¯¥æ¡ç›®ä¸‹æš‚æ—¶æ²¡æœ‰å·²å®‰æ’çš„æ—¥ç¨‹ã€‚");
                    return;
                }

                // 3. æ’åº (æŒ‰æ—¶é—´é¡ºåºï¼Œç¡®ä¿è·³è½¬é€»è¾‘ç¬¦åˆç›´è§‰)
                relatedTasks.sort((a, b) => {
                    const dateA = new Date(a.date + 'T' + a.startTime);
                    const dateB = new Date(b.date + 'T' + b.startTime);
                    return dateA - dateB;
                });

                // 4. å¾ªç¯è·å–ç›®æ ‡ä»»åŠ¡
                let currentIndex = statClickIndexMap[stat.id] || 0;
                if (currentIndex >= relatedTasks.length) currentIndex = 0;

                const targetTask = relatedTasks[currentIndex];

                // æ›´æ–°ä¸‹ä¸€æ¬¡ç‚¹å‡»çš„ç´¢å¼• (+1)
                statClickIndexMap[stat.id] = (currentIndex + 1) % relatedTasks.length;

                // 5. æ‰§è¡Œè·³è½¬
                smartScrollToTask(targetTask);
            };

            // ğŸŸ¢ ä¿®å¤åçš„ handleStatCardClick (ä»…åœ¨å±•å¼€æ—¶è·³è½¬)
            const handleStatCardClick = (stat) => {
                if (isMobile.value) window.triggerTouchHaptic('Medium');

                // 1. åˆ‡æ¢å±•å¼€/æŠ˜å çŠ¶æ€
                toggleStatCollapse(stat.id);

                // ğŸ›‘ æ ¸å¿ƒä¿®æ”¹: æ£€æŸ¥çŠ¶æ€ï¼Œå¦‚æœæ˜¯"æ”¶èµ·"æ“ä½œï¼Œç›´æ¥ç»“æŸï¼Œä¸è·³è½¬
                /*if (!expandedStatsIds.has(stat.id)) {
                    return;
                }

                // --- ä»¥ä¸‹æ˜¯å±•å¼€åçš„è·³è½¬é€»è¾‘ ---

                // 2. æŸ¥æ‰¾ç›¸å…³ä»»åŠ¡
                let relatedTasks = [];
                if (sidebarTab.value === 'project') {
                    relatedTasks = scheduledTasks.value.filter(t => t.projectId === stat.id);
                } else if (sidebarTab.value === 'instrument') {
                    relatedTasks = scheduledTasks.value.filter(t => t.instrumentId === stat.id);
                } else {
                    relatedTasks = scheduledTasks.value.filter(t => t.musicianId === stat.id);
                }

                // è¿‡æ»¤æ‰éå½“å‰ Session çš„ä»»åŠ¡
                relatedTasks = relatedTasks.filter(t => (t.sessionId || 'S_DEFAULT') === currentSessionId.value);

                // å¦‚æœè¯¥å¡ç‰‡ä¸‹æ²¡æœ‰å·²æ’æœŸçš„ä»»åŠ¡ï¼Œåªå±•å¼€åˆ—è¡¨ï¼Œä¸è·³è½¬
                if (relatedTasks.length === 0) return;

                // æ’åº (æŒ‰æ—¥æœŸå’Œæ—¶é—´)
                relatedTasks.sort((a, b) => {
                    const dateA = new Date(a.date + 'T' + a.startTime);
                    const dateB = new Date(b.date + 'T' + b.startTime);
                    return dateA - dateB;
                });

                // 3. è·å–ç›®æ ‡ä»»åŠ¡ (å¾ªç¯ç‚¹å‡»é€»è¾‘)
                let currentIndex = statClickIndexMap[stat.id] || 0;
                if (currentIndex >= relatedTasks.length) currentIndex = 0;

                const targetTask = relatedTasks[currentIndex];

                // æ›´æ–°ä¸‹ä¸€æ¬¡ç‚¹å‡»çš„ç´¢å¼•
                statClickIndexMap[stat.id] = (currentIndex + 1) % relatedTasks.length;

                // 4. æ‰§è¡Œè·³è½¬ (è°ƒç”¨ä¸Šä¸€è½®å°è£…å¥½çš„é€šç”¨å‡½æ•°)
                smartScrollToTask(targetTask);*/
            };


            // ğŸŸ¢ ä¿®æ”¹: æ¸…ç©ºåˆ—è¡¨ (çº§è”åˆ é™¤ä»»åŠ¡ï¼Œå¢åŠ ç¡®è®¤å¼¹çª—)
            const clearAllInstruments = () => {
                if (settings.instruments.length === 0) return;

                openConfirmModal(
                    'æ¸…ç©ºä¹å™¨åº“',
                    'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ä¹å™¨å—ï¼Ÿ\nâš  è­¦å‘Šï¼šæ‰€æœ‰å…³è”çš„ä»»åŠ¡ï¼ˆä»»åŠ¡æ± åŠæ—¥ç¨‹ï¼‰éƒ½å°†è¢«æ°¸ä¹…åˆ é™¤ï¼',
                    () => {
                        // 1. è·å–è¦åˆ é™¤çš„IDé›†åˆ
                        const idsToDelete = new Set(settings.instruments.map(i => i.id));

                        // 2. æ¸…ç©ºè®¾ç½®
                        settings.instruments = [];

                        // 3. çº§è”åˆ é™¤: ä»»åŠ¡æ± 
                        itemPool.value = itemPool.value.filter(item => !idsToDelete.has(item.instrumentId));

                        // 4. çº§è”åˆ é™¤: æ—¥ç¨‹è¡¨
                        scheduledTasks.value = scheduledTasks.value.filter(task => !idsToDelete.has(task.instrumentId));

                        // 5. æ¸…ç†ç©ºæ—¥ç¨‹å—
                        cleanupEmptySchedules();

                        pushHistory();
                        window.triggerTouchHaptic('Medium');
                    },
                    true // çº¢è‰²å±é™©æŒ‰é’®
                );
            };

            const clearAllMusicians = () => {
                if (settings.musicians.length === 0) return;

                openConfirmModal(
                    'æ¸…ç©ºäººå‘˜åº“',
                    'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ¼”å¥å‘˜å—ï¼Ÿ\nâš  è­¦å‘Šï¼šæ‰€æœ‰å…³è”çš„ä»»åŠ¡ï¼ˆä»»åŠ¡æ± åŠæ—¥ç¨‹ï¼‰éƒ½å°†è¢«æ°¸ä¹…åˆ é™¤ï¼',
                    () => {
                        const idsToDelete = new Set(settings.musicians.map(m => m.id));

                        settings.musicians = [];
                        itemPool.value = itemPool.value.filter(item => !idsToDelete.has(item.musicianId));
                        scheduledTasks.value = scheduledTasks.value.filter(task => !idsToDelete.has(task.musicianId));

                        cleanupEmptySchedules();

                        pushHistory();
                        window.triggerTouchHaptic('Medium');
                    },
                    true
                );
            };

            const clearAllProjects = () => {
                if (settings.projects.length === 0) return;

                openConfirmModal(
                    'æ¸…ç©ºé¡¹ç›®åº“',
                    'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰é¡¹ç›®å—ï¼Ÿ\nâš  è­¦å‘Šï¼šæ‰€æœ‰å…³è”çš„ä»»åŠ¡ï¼ˆä»»åŠ¡æ± åŠæ—¥ç¨‹ï¼‰éƒ½å°†è¢«æ°¸ä¹…åˆ é™¤ï¼',
                    () => {
                        const idsToDelete = new Set(settings.projects.map(p => p.id));

                        settings.projects = [];
                        itemPool.value = itemPool.value.filter(item => !idsToDelete.has(item.projectId));
                        scheduledTasks.value = scheduledTasks.value.filter(task => !idsToDelete.has(task.projectId));

                        cleanupEmptySchedules();

                        pushHistory();
                        window.triggerTouchHaptic('Medium');
                    },
                    true
                );
            };


            // --- ğŸŸ¢ æ‰‹æœºç«¯é€‚é…é€»è¾‘ ---
            // --- ğŸŸ¢ æ‰‹æœºç«¯é€‚é… & å¸ƒå±€è‡ªåŠ¨ä¿®å¤ ---
            const isMobile = ref(window.innerWidth < 800);
            const isContextSwitching = ref(false); // ğŸŸ¢ [æ–°å¢] ä¸Šä¸‹æ–‡åˆ‡æ¢é”
            const mobileTab = ref('schedule');

            // ğŸŸ¢ ä¼˜åŒ–: å¢å¼ºç‰ˆå¸ƒå±€åˆ·æ–°å‡½æ•°
            const refreshLayout = () => {
                const w = window.innerWidth;

                // 1. è·å–ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸² (åˆ¤æ–­æ˜¯å¦ä¸º Android/iPhone ç­‰)
                const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                // 2. åˆ¤æ–­æ˜¯å¦æ”¯æŒç²—ç•¥æŒ‡é’ˆ (é€šå¸¸æŒ‡è§¦æ‘¸å±) - è¿™æ˜¯ä¸€ä¸ªæ›´ç°ä»£çš„ CSS/JS åª’ä½“ç‰¹æ€§æ£€æµ‹
                const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;

                // 3. ç»¼åˆåˆ¤æ–­:
                // åªæœ‰å½“ [å®½åº¦å°äº 800] ä¸” ([æ˜¯ç§»åŠ¨ç«¯UA] æˆ– [æ˜¯è§¦æ‘¸è®¾å¤‡]) æ—¶ï¼Œæ‰åˆ¤å®šä¸ºç§»åŠ¨ç«¯ã€‚
                // è¿™æ ·ç”µè„‘æµè§ˆå™¨ç¼©çª„æ—¶ï¼Œå› ä¸ºä¸æ»¡è¶³åä¸¤ä¸ªæ¡ä»¶ï¼Œä¾ç„¶ä¼šä¿æŒç”µè„‘ç«¯è§†å›¾ã€‚
                isMobile.value = w < 800 && (isMobileUA || isCoarsePointer);

                // 2. é‡æ–°è®¡ç®—è§†å£é«˜åº¦ (è§£å†³åœ°å€æ é®æŒ¡)
                let vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);

                // 3. ğŸŸ¢ æ–°å¢: ç”µè„‘ç«¯å“åº”å¼ä¿æŠ¤é€»è¾‘
                // å½“å±å¹•å®½åº¦å°äº 1100px (æ¥è¿‘ iPad æ¨ªå±å°ºå¯¸) æ—¶ï¼Œè‡ªåŠ¨æ”¶èµ·ä¾§è¾¹æ ï¼Œé˜²æ­¢é¡¶éƒ¨æ—¥æœŸæ–‡å­—è¢«æŒ¤å‹æ¢è¡Œ
                if (!isMobile.value && w < 1100) {
                    if (isSidebarOpen.value) {
                        isSidebarOpen.value = false;
                    }
                } else if (!isMobile.value && w >= 1100) {
                    // å¯é€‰: å®½åº¦è¶³å¤Ÿå¤§æ—¶ï¼Œå¦‚æœæ‚¨å¸Œæœ›è‡ªåŠ¨å±•å¼€ï¼Œå¯ä»¥å–æ¶ˆä¸‹é¢è¿™è¡Œçš„æ³¨é‡Š
                    isSidebarOpen.value = true;
                }

                // 4. å¼ºåˆ¶é‡ç»˜ (ä¿æŒåŸæœ‰é€»è¾‘)
                if (isMobile.value) {
                    document.body.style.display = 'none';
                    document.body.offsetHeight;
                    document.body.style.display = '';
                }
            };

            onMounted(() => {
                // åˆå§‹åŒ–æ‰§è¡Œ
                refreshLayout();

                // ğŸŸ¢ 1. åˆå§‹åŒ–åº”ç”¨ä¸»é¢˜
                applyTheme();

                // ğŸŸ¢ 2. ç›‘å¬ç³»ç»Ÿé¢œè‰²å˜åŒ– (å®ç°"è·Ÿéšç³»ç»Ÿ"çš„å®æ—¶åˆ‡æ¢)
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                    // åªæœ‰å½“å½“å‰æ¨¡å¼æ˜¯ 'auto' æ—¶ï¼Œæ‰å“åº”ç³»ç»Ÿçš„å˜åŒ–
                    if (themeMode.value === 'auto') {
                        applyTheme();
                    }
                });

                // ç›‘å¬çª—å£å¤§å°æ”¹å˜ (æ—‹è½¬å±å¹•ç­‰)
                window.addEventListener('resize', refreshLayout);

                // ğŸŸ¢ å…³é”®: ç›‘å¬ç½‘é¡µâ€œæ˜¾ç¤º/éšè—â€ (åˆ‡åå°å›æ¥)
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        refreshLayout();
                        // å»¶è¿Ÿ 200ms å†æ‰§è¡Œä¸€æ¬¡ï¼Œç¡®ä¿æµè§ˆå™¨ UI åŠ¨ç”»å·²ç»“æŸ
                        setTimeout(refreshLayout, 200);
                    }
                });

                // ğŸŸ¢ å…³é”®: ç›‘å¬ Safari çš„é¡µé¢ç¼“å­˜æ¢å¤ (BFCache)
                window.addEventListener('pageshow', (e) => {
                    if (e.persisted) {
                        refreshLayout();
                    }
                });
                // æ£€æŸ¥ LocalStorage
                const hasSeenTour = localStorage.getItem('musche_tour_seen');
                if (!hasSeenTour) {
                    // ç¨å¾®å»¶è¿Ÿï¼Œç­‰é¡µé¢åŠ è½½å®Œã€æ•°æ®æ¸²æŸ“å®Œå†æ˜¾ç¤º
                    setTimeout(() => {
                        startTour();
                        localStorage.setItem('musche_tour_seen', 'true');
                    }, 1500);
                }
                window.addEventListener('beforeunload', handlePageUnload);
            });

            onUnmounted(() => {
                window.removeEventListener('resize', refreshLayout);
                window.removeEventListener('beforeunload', handlePageUnload);
                // è¿™é‡Œçœç•¥äº† remove å…¶ä»–ç›‘å¬ï¼Œå› ä¸ºè¿™æ˜¯æ ¹ç»„ä»¶ï¼Œé”€æ¯å³åˆ·æ–°ï¼Œé€šå¸¸ä¸éœ€è¦æ¸…ç†
            });


            return {
                sidebarTab,
                showMetadataManager,
                activeTaskCount,
                isResourceCompleted,
                musicianStats,
                projectStats,
                instrumentStats,
                itemPool,
                scheduledTasks,
                settings,
                currentView,
                currentDateLabel,
                currentWeekDays,
                currentMonthDays,
                timeSlots,
                selectedTaskId,
                showSettings,
                showEditor,
                editingItem,
                editingSource,
                newItem,
                weekContainer,
                dragStart,
                dragEnterPool,
                dragLeavePool,
                dropToPool,
                dragEnterSlot,
                dragLeaveSlot,
                dropToSchedule,
                dropToMonth,
                handleDragEnd,
                initResize,
                selectTask,
                clearSelection,
                onMusicianSelect,
                addItemToPool,
                changeDate,
                isToday,
                getTasksForDate,
                getTaskStyle,
                switchToWeek,
                calculateEstTime,
                openEditModal,
                saveEdit,
                deleteEditingItem,
                handleTaskDblClick,
                handleGlobalKey,
                undo,
                redo,
                historyIndex,
                history,
                pushHistory,
                exportToICS,
                currentSidebarList,
                handleRecRename,
                sortKey,
                expandedGroups,
                toggleCollapse,
                cleanupEmptySchedules,
                sortField,
                sortAsc,
                toggleSort,
                getSortIcon,
                calculateGroupStats,
                expandedStatsIds,
                toggleStatCollapse,
                resetAutoHide,
                showTrackList,
                trackListData,
                slotHeight,
                getNameById,
                generateUniqueId,
                getOverlapCount,
                jumpToGhostContext,
                activeColorKey,
                getGroupColor,
                getTextColor,

                exportJSON,
                importJSON,
                handleJSONFile,

                selectedPoolIds,
                lastPoolClickId,
                sidebarWidth,

                handlePoolItemClick,
                isScheduled,
                clearAllInstruments,
                clearAllMusicians,
                clearAllProjects,

                flashingTaskId,
                handleStatCardClick,
                isSidebarOpen,

                activeDropdown,
                dropdownSearch,
                toggleDropdown,
                selectOption,
                filteredOptions,
                getOrCreateSettingItem,

                user,
                showAuthModal,
                authForm,
                authLoading,
                handleLogin,
                handleRegister,
                handleResetPwd,
                handleLogout,

                showProfileMenu,
                tempAvatarUrl,
                userAvatar,
                handleUserBtnClick,
                updateAvatar,

                currentSessionId,
                currentSessionName,
                switchSession,
                handleSessionAction,
                tempNickname,
                userDisplayName,
                updateNickname,
                ensureItemRecords,

                handleCSVImport,
                handleAvatarUpload,
                authPasswordRef,
                addProject,
                deleteCurrentSchedule,
                clearTrackTime,
                isTaskGhost,
                deleteProject,
                deleteTrackFromList,
                getGroupedOptions,
                isSyncing,
                handleManualSync,
                viewTransitionName,
                switchView,
                onMainTouchStart,
                onMainTouchEnd,

                isMobile,
                mobileTab,
                showMobileMenu,
                isDark,
                toggleTheme,
                themeMode,
                applyTheme,
                getThemeLabel,
                showMobileTaskInput,
                calculateSingleRatio,
                updateMusicianRatio,
                getSessionRatio,
                autoCalcDuration,
                saveScheduleActualTime,
                saveTrackActual,
                setTrackNow,
                calcTrackDiff,
                autoUpdateEfficiency,
                toggleMobileMenu,
                closeDropdowns,
                calculateProportionalDuration,
                getDefaultRatio,
                onDragStart,
                showInputModal,
                inputModalConfig,
                openInputModal,
                closeInputModal,
                confirmInputModal,
                universalInputRef,
                showConfirmModal,
                confirmModalConfig,
                openAlertModal,
                openConfirmModal,
                closeConfirmModal,
                handleConfirmAction,
                showImportModal,
                triggerFileSelect,
                showOrchestrationField,
                showCropModal,
                cropImgSrc,
                cropImgRef,
                checkOverlap,
                autoResizeScheduleByRecords,
                onFileSelect,
                cancelCrop,
                confirmCrop,
                smartScrollToTask,
                currentQuickAddGroups,
                activeGroupFilter,
                availableGroups,
                factoryReset,
                jumpToToday,
                tasksByDateMap,
                showQuickAddModal,
                quickAddForm,
                openQuickAdd,
                confirmQuickAdd,
                draggingTaskElement,
                scheduleReminder,
                onTrackListReminderChange,
                initialTouchCoords,
                dayColWidth,
                widthIcon,
                cycleDayWidth,
                settingsExpandedGroups,
                toggleSettingsGroup,
                dropdownExpandedGroups,
                toggleDropdownGroup,
                showGroupSuggestions,
                settingsGroupFocus,
                dragElClone,
                dragSourceType,
                showDurationPicker,
                tempDuration,
                pickerMinRef,
                pickerPos,
                closePicker,
                resetDuration,
                formatDate,
                viewDate,
                isDefaultRatio,
                isResizingMobile,
                mobileResizeState,
                initMobileResize,
                handleMobileResizeMove,
                handleMobileResizeEnd,
                pickerSecRef,
                openDurationPicker,
                onScroll,
                confirmDurationPicker,
                formatSecs,
                handleTouchStart,
                handleTouchMove,
                handleTouchEnd,
                handlePoolTouchStart,
                sortedInstruments,
                sortedMusicians,
                sortedProjects,
                removeInstrument,
                removeMusician,
                startAutoScroll,
                stopAutoScroll,
                updateAutoScrollDirection,
                setTrackBreak,
                sortTrackList,
                moveDivider,
                autoSortTrackList,
                trackListContainerRef,
                startDividerDrag,
                draggingSectionIndex,
                onDividerDragMove,
                onDividerDragEnd,
                getBlockTitle,
                dateTransitionName,
                jumpToStatSchedule,
                getSettingsGroupedList,
                allSettingsGrouped,
                renameGroup,
                addSettingsItem,
                removeSettingsItem,
                newSettingsItem,
                getExistingGroups,
                clearSettingsList,
                onSettingsItemDragStart,
                onSettingsDragOver,
                onSettingsDragLeave,
                onSettingsDrop,
                onSidebarTouchStart,
                onSidebarTouchEnd,
                sidebarTransitionName,
                sidebarScrollRef,
                switchSidebarTab,
                isAllGroupsExpanded,
                toggleAllGroups,
                showColorPickerModal,
                presetColors,
                tempColor,
                openColorPicker,
                resetColorPicker,
                saveColorPicker,
                settingsNameFocus,
                getUngroupedItems,
                inputRects,
                updateInputRect,
                getFloatingStyle,
                onSettingsScroll,
                splitTrack,
                restoreSplitTime,
                showSplitModal,
                splitState,
                smartMatch,
                getFullSearchText,
                openSplitSlider,
                onSplitSliderInput,
                confirmSplitSlider,
                startTour,
                toggleSidebar,
                desktopSteps,
                mobileSteps,
                onSettingsItemDragEnd,
                disableRowDrag,
                enableRowDrag,
                saveStatus,
                handlePageUnload,
                isContextSwitching,
                getTaskRatio,
                cleanOldRatios,
                clearPoolRecord,
                clearAggregateRecords,
                onMainMouseDown,
                onMainMouseUp,
                isMouseViewDrag,
                onMainWheel,
                showRecInfoModal,
                recInfoForm,
                openRecInfoModal,
                saveRecInfo,
                activeRecDropdown,
                recDropdownSearch,
                filteredRecOptions,
                selectRecOption,
                createRecOption,
                newRecInputs,
                addRecItem,
                removeRecItem,
                globalSearchQuery,
                handleSearchEnter,
                filteredSidebarList,
                handleItemRename,
                hasRecordingInfo,
                autoDistributeSections,
                startTrackDrag,
                isSearchFocused,
                handleSearchBlur,
                onSearchFocus,
                triggerTouchHaptic: window.triggerTouchHaptic,
                orchTemplates,
                parsedRoster,
                getRosterName,
                updateRosterName,
                percKeywords,
                percState,
                isPercussionMode,
                scanPercussionTags,
                addPercPlayer,
                removePercPlayer,
                togglePercTagSelect,
                assignTagsToPlayer,
                updatePercOrchestration,
                getOrchSize,
                isOrchestraGroup,
                isPercussionGroup,
                isStringGroup,
                activeOrchPresets,
                getNameWithGroup,
                getFamilyTotalDuration,
                syncFamilyOrchestration,
                triggerCSV,
                showCreditModal,
                generatedCreditText,
                openCreditModal,
                copyCreditText,
                monthViewMode, // æ–°å¢
                flatScrolledDays, // æ–°å¢
                generateMonthGrid, // æ–°å¢
                setMonthRef,
                scrollToMonthDate,
                handleInfiniteScroll,
                handleHeaderDoubleTap,      // <--- æ–°å¢å¯¼å‡º
                handleMonthCellDoubleTap,
                triggerMidiImport, // ğŸŸ¢ æ–°å¢
                openMidiManager,
                showMidiManager,
                managingProject,
                projectMidiList,
                updateMidiDuration,
                removeMidiMapping,
                clearProjectMidi,
                triggerMidiImportForProject,
                showMidiImportModal,
                midiImportData,
                midiBpm,
                handleMidiFile,
                confirmMidiImport,
                calculateAccurateDuration,
                convertTicksToSeconds,
                calculateQuantizedDuration,
                isOverlapping,
                calculateEffectiveDuration,
                processMidiFile,
                onImportInstChange,
                availableInstrumentGroups,
                activeImportMenu,
                importMenuPos,
                importSearchQuery,
                openImportMenu,
                closeImportMenu,
                selectImportInst,
                selectImportNewInst,
                selectImportGroup,
                filteredImportOptions,
                midiGroupSearchQuery,
                filteredMidiGroups,
                updateInstrumentGroup,
                selectMidiGroup,
                activeMidiGroupRow,
                midiGroupPos,
                openMidiGroupDropdown,
                midiTimeSig,
                findGroupFromLibrary,
                cleanMidiTrackName,
                sortedLibrary,
                normalizeForMatch,
                findGroupSmart,
                instrumentLibrary,
                midiGroupData,
                midiViewMode,
                currentMidiDisplayList,
                midiGroupExpanded,
                toggleMidiGroupExpand,
                toggleGroupSelection,
                projectMidiGroups,
                midiManagerExpandedGroups,
                toggleMidiManagerGroup,
                autoFillMidiDuration,
                getSmartName,
                trackListSearchQuery,
                handleTrackListSearchAction,
                showCsvImportModal,
                csvImportData,
                csvImportConfig,
                toggleCsvSelection, // ğŸŸ¢ æ–°å¢
                handleCSVImport,     // ğŸŸ¢ æ–°å¢
                confirmCsvImport,
                getOrchString,
                addDataToPrepared,
                refreshCsvPreview,
                findSettingId,
                normalizeDate,
                refreshCsvStatus,
                toggleAllRows,
                calculateRowStatusText,
                showProjectInfoModal,
                projectInfoForm,
                openProjectInfoModal,
                saveProjectInfo,
                groupedCsvData,       // ğŸŸ¢ æ–°å¢
                collapsedProjects,    // ğŸŸ¢ æ–°å¢
                toggleProjectCollapse,
                activeImportTab,
                isAllSelected,
                isGroupSelected,
                csvSearchQuery,
                extractTime

            };
        }
    }).mount('#app');
</script>
</body>
</html>