<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Musche</title>
    <link rel="icon" href=https://gdpsiinrxhpmxvgvgxeh.supabase.co/storage/v1/object/public/avatars/icon.png>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chango&family=Josefin+Sans:ital,wght@0,100..700;1,100..700&family=Noto+Serif+SC:wght@200..900&family=Noto+Serif:ital,wght@0,100..900;1,100..900&family=Outfit:wght@100..900&display=swap"
          rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.4.21/vue.global.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        glass: {
                            light: 'rgba(255, 255, 255, 0.45)',
                            dark: 'rgba(20, 20, 20, 0.65)',
                            border: 'rgba(255, 255, 255, 0.2)',
                            borderDark: 'rgba(255, 255, 255, 0.08)'
                        }
                    },
                    boxShadow: {
                        'liquid': '0 8px 32px 0 rgba(0, 0, 0, 0.15)',
                        'glow': '0 0 15px rgba(59, 130, 246, 0.5)'
                    }
                }
            }
        }
    </script>

    <style>


        /* --- åŠ¨æ€æ¶²æ€èƒŒæ™¯ --- */
        body {
            background: radial-gradient(at 0% 0%, hsla(253, 16%, 7%, 1) 0, transparent 50%),
            radial-gradient(at 50% 0%, hsla(225, 39%, 30%, 1) 0, transparent 50%),
            radial-gradient(at 100% 0%, hsla(339, 49%, 30%, 1) 0, transparent 50%);
            background-size: cover;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
            font-size: 14px;
            /* ğŸŸ¢ ä¼˜åŒ–: ä½¿ç”¨ dvh é€‚åº”ç§»åŠ¨ç«¯åœ°å€æ ï¼Œå›é€€å…¼å®¹ 100vh */
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            /* ğŸŸ¢ ä¼˜åŒ–: ç¦æ­¢ iOS æ©¡çš®ç­‹å›å¼¹æ•ˆæœï¼Œè®©å®ƒæ„Ÿè§‰åƒåŸç”Ÿ App */
            overscroll-behavior: none;
            color: #1d1d1f;
            transition: background 0.5s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        .font-mono {
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
        }

        /* å…è®¸è¾“å…¥æ¡†å¯é€‰æ‹© */
        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        /* ğŸŸ¢ ä¼˜åŒ–: äº®è‰²æ¨¡å¼èƒŒæ™¯ (é™å™ªã€æŠ¤çœ¼ç‰ˆ) */
        html:not(.dark) body {
            /* 1. åº•è‰²æ”¹ä¸ºåå†·çš„ç°è“è‰²ï¼Œä¸å†æ˜¯åˆºçœ¼çš„äº®ç™½ */
            background-color: #dfe1e5;

            /* 2. å¤§å¹…é™ä½å…‰æ–‘çš„é€æ˜åº¦ (0.5 -> 0.15)ï¼Œåªä¿ç•™æå…¶å¾®å¼±çš„æ°›å›´æ„Ÿ */
            background-image: radial-gradient(at 40% 20%, hsla(28, 100%, 74%, 0.15) 0px, transparent 50%),
            radial-gradient(at 80% 0%, hsla(189, 100%, 56%, 0.15) 0px, transparent 50%),
            radial-gradient(at 0% 50%, hsla(355, 100%, 93%, 0.15) 0px, transparent 50%),
            radial-gradient(at 80% 50%, hsla(340, 100%, 76%, 0.15) 0px, transparent 50%),
            radial-gradient(at 0% 100%, hsla(22, 100%, 77%, 0.15) 0px, transparent 50%),
            radial-gradient(at 80% 100%, hsla(242, 100%, 70%, 0.15) 0px, transparent 50%);

            /* æ–‡å­—é¢œè‰²åŠ æ·±ï¼Œå‡ ä¹çº¯é»‘ */
            color: #0f0f10;
        }

        html.dark body {
            color: #f5f5f7;
        }

        /* --- ğŸŸ¢ åˆ—è¡¨å¹³æ»‘åŠ¨ç”» (FLIP) --- */
        /* 1. ç§»åŠ¨ä¸­çš„å…ƒç´  (Vue ä¼šè‡ªåŠ¨å¤„ç†ä½ç½®è®¡ç®—) */
        .list-move,
        .list-enter-active,
        .list-leave-active {
            transition: all 0.3s cubic-bezier(0.55, 0, 0.1, 1);
        }

        /* 2. å…ƒç´ è¿›å…¥å‰/ç¦»å¼€åçš„çŠ¶æ€ */
        .list-enter-from,
        .list-leave-to {
            opacity: 0;
            transform: scaleY(0.01) translate(0, 10px);
        }

        /* 3. ç¡®ä¿ç¦»å¼€çš„å…ƒç´ è„±ç¦»æ–‡æ¡£æµï¼Œè®©åé¢çš„å…ƒç´ èƒ½å¹³æ»‘è¡¥ä½ (å…³é”®!) */
        .list-leave-active {
            position: absolute;
            width: 100%;
            z-index: -1; /* é˜²æ­¢é®æŒ¡ */
        }

        /* å®¹å™¨ä¸ä¾§è¾¹æ  (ä¿æŒä¸å˜) */
        /* 3. å¸ƒå±€å®¹å™¨ (ä¿®æ”¹èƒŒæ™¯ä¸ºæ¸å˜é€æ˜) */
        .liquid-window {
            border-radius: 0;
            border: none; /* ç§»é™¤è¾¹æ¡†ï¼Œè®©æ¸å˜è‡ªç„¶èåˆ */
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;

            /* ä¿®æ”¹è¿™é‡Œ: ä½¿ç”¨å åŠ çš„åŠé€æ˜ç™½ï¼Œè®©èƒŒæ™¯çœ‹èµ·æ¥åƒ"ç£¨ç ‚ç»ç’ƒä¸‹çš„ç°è‰²" */
            background: radial-gradient(
                    ellipse at center,
                    rgba(255, 255, 255, 0.6) 0%, /* ä¸­é—´ç¨å¾®äº®ä¸€ç‚¹ */ rgba(240, 242, 245, 0.8) 100% /* è¾¹ç¼˜å˜ç°ï¼Œå¢åŠ å®ä½“æ„Ÿ */
            );
            backdrop-filter: blur(30px);
        }

        html.dark .liquid-window {
            /* ğŸŸ¢ æš—è‰²æ¨¡å¼ï¼šç”±å†…å‘å¤–é€æ¸é€æ˜ */
            background: radial-gradient(
                    ellipse at center,
                    rgba(30, 32, 35, 0.95) 40%, /* ä¸­é—´ï¼šæ·±ç°è‰²ï¼Œå‡ ä¹ä¸é€ */ rgba(30, 32, 35, 0.2) 100% /* è¾¹ç¼˜ï¼šéå¸¸é€æ˜ï¼Œèå…¥èƒŒæ™¯ */
            );
            border: none;
            box-shadow: none; /* ç§»é™¤é˜´å½±ï¼Œå®Œå…¨é æ¸å˜ */
        }

        .glass-sidebar {
            background: rgba(245, 245, 247, 0.5);
            backdrop-filter: blur(40px);
            border-right: 1px solid rgba(0, 0, 0, 0.05);
        }

        html.dark .glass-sidebar {
            background: rgba(40, 40, 40, 0.4);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        * {
            scrollbar-width: none;
        }

        /* ğŸŸ¢ è°ƒæ•´ 2: å…³é”®å°ºå¯¸ä¸å˜é‡ */
        :root {
            --slot-height: 40px; /* é«˜åº¦å¢åŠ åˆ° 60pxï¼Œç»™å¤§å­—ä½“ç•™ç©ºé—´ */
            --time-col-width: 70px; /* æ—¶é—´åˆ—åŠ å®½ï¼Œé˜²æ­¢æ–‡å­—æ¢è¡Œ */
            --grid-line-light: rgba(0, 0, 0, 0.08);
            --grid-line-dark: rgba(255, 255, 255, 0.08);
        }

        .drag-item {
            cursor: grab;
        }

        .drag-item:active {
            cursor: grabbing;
            transform: scale(1.02);
        }

        /* å¡ç‰‡æ ·å¼ */
        .stat-card {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 12px; /* å¢åŠ å†…è¾¹è· */
            margin-bottom: 8px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative;
            border-left-width: 5px; /* åŠ ç²—è¾¹æ¡† */
        }

        html.dark .stat-card {
            background: rgba(60, 60, 60, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: #eee;
        }

        .stat-card:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }

        html.dark .stat-card:hover {
            background: rgba(80, 80, 80, 0.8);
        }

        .time-label-slot {
            height: var(--slot-height);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 12px;
            /* ğŸŸ¢ å­—ä½“åŠ å¤§ */
            font-size: 13px;
            color: #86868b;
            font-weight: 600;

            /* ğŸŸ¢ æ–°å¢: å‘ä¸Šå¹³ç§» 50%ï¼Œä½¿æ–‡å­—ä¸­å¿ƒå¯¹é½è¯¥æ—¶é—´æ ¼çš„é¡¶éƒ¨ç½‘æ ¼çº¿ */
            transform: translateY(-50%);
        }

        .grid-slot {
            height: var(--slot-height);
            border-bottom: 1px solid var(--grid-line-light);
            width: 100%;
            position: relative;
        }

        html.dark .grid-slot {
            border-bottom: 1px solid var(--grid-line-dark);
        }

        .grid-slot:nth-child(odd) {
            border-bottom-style: solid;
        }

        .grid-slot:nth-child(even) {
            border-bottom: none;
        }

        .grid-slot:nth-child(even)::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            border-bottom: 1px dotted var(--grid-line-light);
            opacity: 0.5;
        }

        html.dark .grid-slot:nth-child(even)::after {
            border-bottom-color: var(--grid-line-dark);
        }

        /* ğŸŸ¢ ä¿®å¤: æ—¥ç¨‹å—æ ·å¼ (å·¦ä¾§æ˜¾ç¤ºæ¼”å¥å‘˜é¢œè‰²æ¡) */
        .task-block {
            position: absolute;
            left: 4px;
            right: 2px;
            background: #fafafa !important;

            /* ğŸŸ¢ æ ¸å¿ƒä¿®å¤: å·¦è¾¹æ¡†å®½åº¦è®¾ä¸º 4pxï¼Œé¢œè‰²ç»‘å®šåˆ°å˜é‡ */
            border-left: 4px solid var(--task-border, #007aff) !important;

            border-radius: 6px;
            color: #000 !important;
            font-size: 12px;
            line-height: 1.3;
            overflow: hidden;
            cursor: grab;
            z-index: 10;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            padding: 4px 6px;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            border-right: 1px solid rgba(0, 0, 0, 0.05);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* ğŸŸ¢ ä¿®å¤: æš—è‰²æ¨¡å¼æ—¥ç¨‹å— (åŠ ä¸Š !important ä»¥è¦†ç›–äº®è‰²æ¨¡å¼çš„å¼ºåˆ¶è®¾ç½®) */
        html.dark .task-block {
            /* 1. èƒŒæ™¯è‰²åŠ  !important */
            background: rgba(45, 45, 48, 0.95) !important;

            /* 2. æ–‡å­—é¢œè‰²åŠ  !important */
            color: #f5f5f7 !important;

            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .task-block .secondary-text {
            color: #6e6e73 !important;
            font-size: 11px; /* æ¬¡è¦ä¿¡æ¯ç¨å¾®å¤§ä¸€ç‚¹ */
        }

        html.dark .task-block .secondary-text {
            color: #a1a1a6 !important; /* ç¡®ä¿è¿™é‡Œä¹Ÿæœ‰ !important */
        }

        .task-block.is-selected {
            box-shadow: 0 0 0 2px #0A84FF, 0 8px 16px rgba(0, 0, 0, 0.2);
            z-index: 100 !important;
            transform: scale(1.02);
        }

        html.dark .task-block.is-selected {
            /* æš—è‰²æ¨¡å¼ä¸‹ï¼šä½¿ç”¨ç™½è‰²/äº®è‰²å¤–è½®å»“ï¼Œå¹¶å¢åŠ é˜´å½±å¯¹æ¯”åº¦ */
            box-shadow: 0 0 0 2px #ffffff, /* 3px å®½çš„ç™½è‰²è¾¹æ¡†ï¼Œå¢åŠ å¯¹æ¯”åº¦ */ 0 8px 16px rgba(0, 0, 0, 0.5); /* æ›´é‡çš„é˜´å½± */

            /* ç¡®ä¿ z-index å’Œ transform ä¿æŒä¸å˜ */
            z-index: 100 !important;
            transform: scale(1.02);
        }

        /* å¼¹çª—ä¸æ§ä»¶ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9999;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-window {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(40px) saturate(200%);
            border-radius: 18px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        html.dark .modal-window {
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
        }

        .cursor-ns-resize {
            will-change: transform;
        }

        .segmented-control {
            background: rgba(118, 118, 128, 0.12);
            border-radius: 8px;
            padding: 3px;
            display: flex;
        }

        html.dark .segmented-control {
            background: rgba(118, 118, 128, 0.24);
        }

        .segment-btn {
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            color: #1d1d1f;
            cursor: default;
            transition: all 0.2s;
        }

        html.dark .segment-btn {
            color: #f5f5f7;
        }

        .segment-btn.active {
            background: white;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12), 0 3px 1px rgba(0, 0, 0, 0.04);
            color: black;
        }

        html.dark .segment-btn.active {
            background: #636366;
            color: white;
        }

        .glass-input {
            /* ğŸŸ¢ ä¿®æ”¹: èƒŒæ™¯æ”¹ä¸ºåŠé€æ˜ç™½è‰²ï¼Œè€Œä¸æ˜¯ç°è‰²ï¼Œæ›´å¹²å‡€ */
            background: rgba(255, 255, 255, 0.8);

            /* åŠ æ·±æ–‡å­—é¢œè‰² */
            color: #111;

            border: 1px solid rgba(0, 0, 0, 0.05); /* åŠ ä¸ªå¾®å¼±è¾¹æ¡† */
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 13px;
            transition: all 0.2s;
        }

        /* èšç„¦æ—¶ */
        .glass-input:focus {
            background: #fff;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        /* æš—è‰²æ¨¡å¼ä¿æŒä¸å˜ */
        html.dark .glass-input {
            background: rgba(255, 255, 255, 0.1);
            color: inherit;
            border-color: transparent;
        }

        html.dark .glass-input:focus {
            background: rgba(255, 255, 255, 0.15);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .resize-handle {
            height: 10px;
            opacity: 0;
            transition: opacity 0.2s;
            background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));
            cursor: ns-resize;
            position: absolute;
            bottom: 0;
            width: 100%;
        }

        .task-block:hover .resize-handle {
            opacity: 1;
        }

        /* --- ğŸŸ¢ ä¿®æ”¹åçš„ CSS: æ·¡é»„è‰²å‘¼å¸é—ªçƒ (2æ¬¡) --- */
        @keyframes flash-highlight {
            0%, 100% {
                /* èµ·å§‹å’Œç»“æŸï¼šå®Œå…¨é€æ˜ */
                box-shadow: 0 0 0 0 rgba(250, 204, 21, 0);
            }
            50% {
                /* ä¸­é—´çŠ¶æ€ï¼šæ·¡é»„è‰²å…‰æ™•ï¼Œ4px å®½åº¦ï¼Œ0.6 é€æ˜åº¦ */
                box-shadow: 0 0 0 4px rgba(250, 204, 21, 0.6);
            }
        }

        .is-flashing {
            /* å°†åŠ¨ç”»æ—¶é•¿ä» 0.8s å¢åŠ åˆ° 1.2sï¼Œä½¿å…¶å‘¼å¸æ›´ç¼“æ…¢æŸ”å’Œ */
            /* è®¾ç½®ä¸º infiniteï¼Œç”± JS çš„å®šæ—¶å™¨æ¥è´Ÿè´£ç§»é™¤ç±»ååœæ­¢åŠ¨ç”» */
            animation: flash-highlight 1.2s ease-in-out infinite;
            z-index: 110 !important; /* ç¡®ä¿é—ªçƒæ—¶å±‚çº§æœ€é«˜ï¼Œä¸è¢«é®æŒ¡ */
        }

        /* --- V11.7 æ–°å¢: å¤šæ—¥ç¨‹(Session) å¹½çµæ¨¡å¼æ ·å¼ --- */
        .task-block.is-ghost {
            /* ç°è‰²æ–œçº¿èƒŒæ™¯ï¼Œè¡¨ç¤ºä¸å¯ç”¨ */
            background: repeating-linear-gradient(
                    45deg,
                    rgba(200, 200, 200, 0.3),
                    rgba(200, 200, 200, 0.3) 10px,
                    rgba(180, 180, 180, 0.3) 10px,
                    rgba(180, 180, 180, 0.3) 20px
            ) !important;
            border-left-color: #9ca3af !important; /* ç°è‰²è¾¹æ¡† */
            color: #6b7280 !important; /* ç°è‰²æ–‡å­— */
            opacity: 0.6;
            pointer-events: auto !important; /* å…³é”®ï¼šç¦æ­¢é¼ æ ‡ç‚¹å‡»ã€æ‹–æ‹½ */
            filter: grayscale(100%); /* å¼ºåˆ¶é»‘ç™½ */
            z-index: 0 !important; /* å±‚çº§æœ€ä½ï¼Œå«åœ¨åº•ä¸‹ */
        }

        /* --- ğŸŸ¢ æ–°å¢: æœˆè§†å›¾å¹½çµæ ·å¼ --- */
        /* ç›®æ ‡: åŒ¹é… .grid-cols-7 å†…éƒ¨çš„ .text-[11px] ä»»åŠ¡æ¡ */
        .grid-cols-7 .text-\[11px\].is-ghost {
            /* ç»§æ‰¿ Week View çš„ç°è‰²æ–œçº¿èƒŒæ™¯ */
            background: repeating-linear-gradient(
                    45deg,
                    rgba(200, 200, 200, 0.3),
                    rgba(200, 200, 200, 0.3) 10px,
                    rgba(180, 180, 180, 0.3) 10px,
                    rgba(180, 180, 180, 0.3) 20px
            ) !important; /* å¼ºåˆ¶è¦†ç›– inline style */
            color: #6b7280 !important; /* ç°è‰²æ–‡å­— */
            opacity: 0.6;
            box-shadow: none !important; /* ç§»é™¤é˜´å½±ï¼Œé™ä½è§†è§‰å¹²æ‰° */
            border: 1px solid rgba(180, 180, 180, 0.3); /* æ·»åŠ ä¸€ä¸ªå¾®å¼±çš„è¾¹æ¡† */
            pointer-events: auto; /* ç¡®ä¿å¯ä»¥åŒå‡»è·³è½¬ */
        }

        /* ğŸŸ¢ æš—è‰²æ¨¡å¼é€‚é… */
        html.dark .grid-cols-7 .text-\[11px\].is-ghost {
            background: repeating-linear-gradient(
                    45deg,
                    rgba(60, 60, 60, 0.3),
                    rgba(60, 60, 60, 0.3) 10px,
                    rgba(80, 80, 80, 0.3) 10px,
                    rgba(80, 80, 80, 0.3) 20px
            ) !important;
            color: #9ca3af !important;
            border-color: rgba(80, 80, 80, 0.3);
        }

        /* ğŸŸ¢ ä¿®å¤: æœˆè§†å›¾å¹½çµå°åœ†ç‚¹é¢œè‰² */
        .grid-cols-7 .text-\[11px\].is-ghost .w-1\.5.h-1\.5 {
            background-color: #9ca3af !important;
        }

        html.dark .task-block.is-ghost {
            background: repeating-linear-gradient(
                    45deg,
                    rgba(60, 60, 60, 0.3),
                    rgba(60, 60, 60, 0.3) 10px,
                    rgba(80, 80, 80, 0.3) 10px,
                    rgba(80, 80, 80, 0.3) 20px
            ) !important;
            border-left-color: #4b5563 !important;
            color: #9ca3af !important;
        }

        @keyframes menu-slide-in {
            from {
                opacity: 0;
                transform: translateY(-8px) scale(0.98);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* ğŸŸ¢ ä¿®å¤: ç”¨æˆ·èœå• (æ”¹ä¸º Fixed å®šä½ï¼Œå½»åº•æ‘†è„±çˆ¶å®¹å™¨é™åˆ¶) */
        .mobile-user-menu {
            /* 1. æ ¸å¿ƒä¿®æ”¹: ä½¿ç”¨ fixed å®šä½ï¼Œç›´æ¥ç›¸å¯¹äºå±å¹•çª—å£ */
            position: fixed !important;

            /* 2. å‚ç›´å®šä½: é¡¶éƒ¨è·ç¦» = Headeré«˜åº¦ (çº¦60-70px) + é—´è· */
            /* ä½¿ç”¨ calc åŠ¨æ€è®¡ç®—ï¼Œé¿å¼€é¡¶éƒ¨å¯¼èˆªæ  */
            top: 76px !important;

            /* 3. æ°´å¹³å®šä½: è·ç¦»å±å¹•å³è¾¹ç¼˜ 16px (ä¸é¡µé¢ Padding ä¿æŒä¸€è‡´) */
            right: 30px !important;

            /* 4. æ¸…é™¤æ—§çš„å®šä½å¹²æ‰° */
            left: auto !important;
            margin: 0 !important;

            /* 5. å†…éƒ¨æ ·å¼ä¼˜åŒ– */
            padding: 24px !important;
            width: 320px !important;
            max-width: calc(100vw - 32px) !important;

            /* 6. åŠ¨ç”»åŸç‚¹ */
            transform-origin: top right !important;

            /* 7. ç¡®ä¿å±‚çº§æœ€é«˜ */
            z-index: 99999 !important;
        }

        /* ğŸŸ¢ æœ€ç»ˆç‰ˆ: æç®€æ‰‹æœºé€‚é… (å…è®¸æ»šåŠ¨ï¼Œæ— é®æŒ¡) */
        @media (max-width: 800px) and (hover: none) {
            /* 1. åŸºç¡€å­—ä½“ */
            html, body {
                font-size: 12px !important;
            }

            body {
                min-width: 0 !important;      /* æ‰‹æœºç«¯ä¸éœ€è¦æœ€å°å®½åº¦ */
                overflow: hidden !important;  /* æ‰‹æœºç«¯æ¢å¤ç¦æ­¢æ»šåŠ¨ï¼Œä½“éªŒæ›´åƒåŸç”ŸApp */
                overflow-x: hidden !important;
            }

            /* 2. éšè—æ— å…³å…ƒç´  */
            .cursor-ew-resize {
                display: none !important;
            }

            /* ğŸŸ¢ ä¿®å¤ 1: å¼ºåˆ¶å…¨å±ï¼Œå»é™¤åœ†è§’å’Œå¤–è¾¹è· */
            #app {
                padding: 0 !important; /* å»æ‰æœ€å¤–å±‚çš„é»‘è¾¹é—´éš™ */
                height: 100vh !important;
                height: 100dvh !important;
            }

            .liquid-window {
                border-radius: 0 !important; /* å»æ‰çª—å£åœ†è§’ï¼Œå˜æˆç›´è§’ */
                border: none !important;
                box-shadow: none !important;
            }

            /* 4. ä¾§è¾¹æ  (ä»»åŠ¡æ± ) - ğŸŸ¢ ä¿®å¤: èƒŒæ™¯å¿…é¡»ææ·¡ï¼Œå¦åˆ™æŒ¡ä½åº•å±‚ç”»é¢ï¼Œå¯¼è‡´ä¸Šå±‚æ— æ³•æ¨¡ç³Š */
            #sidebar {
                position: fixed !important;
                top: 64px;
                left: 0;
                right: 0;
                bottom: 0 !important;
                padding-bottom: calc(80px + env(safe-area-inset-bottom)) !important;
                z-index: 40;
                width: 100% !important;

                /* ğŸŸ¢ å…³é”®ä¿®æ”¹: èƒŒæ™¯é¢œè‰²é€æ˜åº¦é™åˆ° 0.1 */
                background: rgba(255, 255, 255, 0.1) !important;

                /* ä¾§è¾¹æ è‡ªå·±ä¹Ÿè¦æœ‰æ¨¡ç³Šï¼Œå½¢æˆå±‚æ¬¡æ„Ÿ */
                backdrop-filter: blur(30px) saturate(150%) !important;
                -webkit-backdrop-filter: blur(30px) saturate(150%) !important;

                overflow-y: auto !important;
            }

            /* æš—è‰²æ¨¡å¼é€‚é… */
            html.dark #sidebar {
                background: rgba(30, 30, 30, 0.4) !important;
            }

            /* 5. ä¸»å†…å®¹åŒº (æ—¥ç¨‹è¡¨) */
            #main-content {
                position: fixed !important;
                top: 64px;
                left: 0;
                right: 0;
                bottom: 0 !important; /* å æ»¡åˆ°åº•éƒ¨ */
                padding-bottom: calc(60px + env(safe-area-inset-bottom)) !important; /* ğŸŸ¢ å…³é”®: ç”¨ padding æ’‘å¼€åº•éƒ¨ç©ºé—´ */
                z-index: 30;
                overflow-y: auto !important; /* ğŸŸ¢ å…³é”®: å…è®¸æ»šåŠ¨ */
            }

            /* 6. ç´§å‡‘åŒ–æ˜¾ç¤º */
            .task-block {
                padding: 2px 4px !important;
                border-left-width: 3px !important;
            }

            .stat-card {
                padding: 8px !important;
                border-left-width: 3px !important;
            }

            .is-zooming-now .task-block {
                transition: none !important;
            }

            :root {
                --time-col-width: 40px;
            }

            .pb-safe {
                padding-bottom: env(safe-area-inset-bottom);
            }

            .time-label-slot {
                font-size: 10px !important; /* å­—ä½“æ”¹å° */
                padding-right: 4px !important; /* å‡å°‘å³è¾¹è· */
                justify-content: center !important; /* å±…ä¸­å¯¹é½ */
            }

            /* ğŸŸ¢ ä¿®å¤å: ç§»é™¤å¤šä½™çš„ padding */
            .fixed.bottom-0 {
                /* åˆ é™¤è¿™è¡Œï¼Œå› ä¸ºå†…éƒ¨çš„ div å·²ç»æœ‰ .pb-safe ç±»äº†ï¼Œä¸éœ€è¦è¿™é‡Œå†åŠ ä¸€æ¬¡ */
                /* padding-bottom: env(safe-area-inset-bottom); */

                margin-bottom: 0px;
                /* å»ºè®®æŠŠèƒŒæ™¯è‰²ä¹Ÿå»æ‰ï¼Œå› ä¸ºé‡Œé¢çš„ div å·²ç»æœ‰èƒŒæ™¯è‰²äº†ï¼Œè¿™é‡Œä¿ç•™å¯èƒ½å¯¼è‡´é€æ˜åº¦å åŠ  */
                background-color: transparent;
            }

            html.dark .fixed.bottom-0 {
                background-color: rgba(28, 28, 30, 0.95);
            }

            #sidebar, #main-content {
                /* ğŸŸ¢ ä¿®æ”¹: ç§»é™¤æ‰€æœ‰å†…è¾¹è·ï¼Œè®©å†…å®¹å¡«æ»¡å±å¹• */
                padding-bottom: 0 !important;
                padding-left: 0 !important;
                padding-right: 0 !important;
            }

            /* ğŸŸ¢ ä¿®å¤: æ‰‹æœºç«¯ä¸‹æ‹‰èœå•å®šä½ä¼˜åŒ– */
            /* 1. åŸºç¡€æ ·å¼é‡ç½®: ä¿æŒç»å¯¹å®šä½ï¼Œå»æ‰å¤šä½™çš„é˜´å½±é®ç½© */
            /* 2. é’ˆå¯¹ã€ç”¨æˆ·å¤´åƒå¼¹çª—ã€‘(ğŸŸ¢ ä¿®å¤: å¢åŠ è¾¹ç•Œé˜²æ’ä¿æŠ¤) */
            .mobile-user-menu {
                /* 1. ç´§è´´å³ä¾§å¯¹é½ï¼Œä¸å†å‘å³åç§»ï¼Œé˜²æ­¢è¶…å‡ºå±å¹• */
                right: 0 !important;

                /* 2. ä¿æŒå·¦ä¾§è‡ªåŠ¨ï¼Œé å³å±•å¼€ */
                left: auto !important;

                /* 3. åŠ¨ç”»åŸç‚¹è®¾ä¸ºå³ä¸Šè§’ */
                transform-origin: top right !important;

                /* 4. ğŸŸ¢ å…³é”®: é™åˆ¶æœ€å¤§å®½åº¦ï¼Œé˜²æ­¢åœ¨å°å±å¹•æ‰‹æœºä¸Šå‘å·¦æº¢å‡ºå±å¹• */
                max-width: calc(100vw - 32px) !important; /* å±å¹•å®½åº¦å‡å»å·¦å³é—´è· */

                /* 5. ç¨å¾®å¢åŠ ä¸€ç‚¹é¡¶éƒ¨è·ç¦»ï¼Œä»¥å…è´´ç€å¤´åƒ */
                margin-top: 8px !important;
            }

            /* 3. é’ˆå¯¹ã€ä¸­é—´ Session å¼¹çª—ã€‘çš„ç‰¹æ®Šä¿®æ­£ */
            /* æ‰¾åˆ°ä¸­é—´é‚£ä¸ªå®¹å™¨é‡Œçš„èœå• */
            .flex-1.flex.justify-center .custom-dropdown-menu {
                left: 50% !important;
                right: auto !important;
                transform: translateX(-50%) !important; /* æ°´å¹³å±…ä¸­ */
                transform-origin: top center !important; /* åŠ¨ç”»ä»é¡¶éƒ¨ä¸­é—´å±•å¼€ */
            }

            /* ... ä¹‹å‰çš„æ‰‹æœºç«¯æ ·å¼ ... */
            /* ğŸŸ¢ æ–°å¢: æ‰‹æœºç«¯æœˆè§†å›¾æ·±åº¦é€‚é… (ä»¿ iOS) */
            /* 1. æ˜ŸæœŸè¡¨å¤´: æç®€ã€ç¼©å° */
            .grid-cols-7 .p-3.text-right {
                padding: 4px !important;
                text-align: center !important;
                font-size: 10px !important;
                height: 24px !important;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* 2. æ—¥æœŸæ ¼å­: é«˜åº¦å‹ç¼©ï¼Œå»æ‰ä¸å¿…è¦çš„ç•™ç™½ */
            .grid-cols-7 .droppable-slot {
                height: auto !important;
                min-height: 50px !important; /* è®¾å®šæœ€å°é«˜åº¦ï¼Œç”±å†…å®¹æ’‘å¼€ */
                aspect-ratio: 0.5; /* ä¿æŒç±»ä¼¼æ—¥å†çš„æ¯”ä¾‹ */
                padding: 2px !important;
            }

            /* 3. æ—¥æœŸæ•°å­—: å±…ä¸­ã€å˜å° */
            .grid-cols-7 .text-right.mb-1 {
                text-align: center !important;
                margin-bottom: 2px !important;
            }

            .grid-cols-7 .text-sm.font-bold.w-7.h-7 {
                width: 20px !important;
                height: 20px !important;
                font-size: 12px !important;
                line-height: 20px !important;
            }

            /* 4. ä»»åŠ¡æ¡: å˜æˆè¶…è¿·ä½ çš„è‰²å— (Micro-bars) */
            .grid-cols-7 .space-y-1 .text-\[11px\] {
                font-size: 8px !important; /* æå°å­—ä½“ */
                padding: 1px 3px !important; /* æå°å†…è¾¹è· */
                height: 14px !important; /* å›ºå®šé«˜åº¦ */
                border-radius: 2px !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                display: flex !important;
                align-items: center !important;
            }

            /* éšè—ä»»åŠ¡æ¡å‰é¢çš„å°åœ†ç‚¹ (å¤ªå åœ°äº†) */
            .grid-cols-7 .space-y-1 .w-1\.5.h-1\.5 {
                display: none !important;
            }

            /* éšè—å…·ä½“æ—¶é—´ (å¤ªå åœ°äº†)ï¼Œåªæ˜¾ç¤ºåå­— */
            .grid-cols-7 .space-y-1 .font-mono.opacity-80 {
                display: none !important;
            }

            /* ğŸŸ¢ æ–°å¢: å…¨å±€åŠ è½½é¡µæ ·å¼ (åŸç”ŸCSSï¼Œä¸ä¾èµ–Tailwind) */
            /* ğŸŸ¢ ä¿®æ”¹: å…¨å±€åŠ è½½é¡µæ ·å¼ (æ¶²æ€ç£¨ç ‚é£æ ¼) */
            #global-loader {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                /* ä½¿ç”¨ä¸ App ä¸€è‡´çš„æ·±è‰²æ¸å˜èƒŒæ™¯ */
                background: radial-gradient(at 0% 0%, hsla(253, 16%, 7%, 1) 0, transparent 50%),
                radial-gradient(at 50% 0%, hsla(225, 39%, 30%, 1) 0, transparent 50%),
                radial-gradient(at 100% 0%, hsla(339, 49%, 30%, 1) 0, transparent 50%),
                #121212; /* åº•è‰² */
                background-size: cover;
                z-index: 99999;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.6s;
            }

            /* ç»ç’ƒè´¨æ„Ÿå®¹å™¨ */
            .loader-glass-box {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                padding: 40px;
                border-radius: 12px;
                box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            /* ç°ä»£åŒ–çš„åŠ è½½åœˆ */
            .loader-spinner {
                width: 50px;
                height: 50px;
                border: 3px solid rgba(255, 255, 255, 0.1);
                border-top-color: #007aff;
                border-right-color: #a855f7; /* æ¸å˜è‰²æ•ˆæœ */
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
                margin-bottom: 20px;
            }

            .loader-text {
                font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                font-weight: 500;
                letter-spacing: 2px;
                text-transform: uppercase;
                animation: pulse 2s infinite;
            }

            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }
            @keyframes pulse {
                0%, 100% {
                    opacity: 0.6;
                }
                50% {
                    opacity: 1;
                }
            }

            #global-loader.hidden {
                opacity: 0;
                visibility: hidden;
                pointer-events: none;
                transform: scale(1.05); /* æ¶ˆå¤±æ—¶è½»å¾®æ”¾å¤§ */
            }

            /* --- ğŸŸ¢ ä¿®å¤çµåŠ¨å²›/åˆ˜æµ·å±é®æŒ¡é—®é¢˜ --- */
            /* 1. å®šä¹‰é¡¶éƒ¨é«˜åº¦å˜é‡ï¼šåŸºç¡€é«˜åº¦ 64px + å®‰å…¨åŒºåŸŸé«˜åº¦ */
            :root {
                --header-base-height: 50px;
                --safe-top: env(safe-area-inset-top); /* è·å–ç³»ç»Ÿå®‰å…¨åŒºåŸŸé«˜åº¦ */
                --header-total-height: calc(var(--header-base-height) + var(--safe-top));
            }

            /* ğŸŸ¢ ä¿®å¤ 2: é¡¶éƒ¨ Header å¢åŠ å‘¼å¸ç©ºé—´ï¼Œé˜²æ­¢è´´è¾¹ */
            /* ğŸŸ¢ ä¿®å¤: é¡¶éƒ¨ Header é€æ˜åŒ– (ç§»é™¤é»‘è‰²èƒŒæ™¯å’Œè¾¹æ¡†) */
            header {
                padding-left: 16px !important;
                padding-right: 16px !important;

                /* é€‚é…åˆ˜æµ·å±é«˜åº¦ */
                height: var(--header-total-height) !important;
                padding-top: env(safe-area-inset-top) !important;

                /* ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: èƒŒæ™¯å…¨é€æ˜ï¼Œå»æ‰è¾¹æ¡† */
                background-color: transparent !important;
                backdrop-filter: none !important; /* å¦‚æœä¸éœ€è¦ç£¨ç ‚ä¹Ÿå»æ‰ï¼Œæˆ–è€…ä¿ç•™ blur(20px) */
                border-bottom: none !important;

                /* ç¡®ä¿å®ƒæ‚¬æµ®åœ¨å†…å®¹ä¹‹ä¸Š */
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 50;
            }

            /* æš—è‰²æ¨¡å¼ä¸‹ä¹Ÿå¼ºåˆ¶é€æ˜ */
            html.dark header {
                /* ğŸŸ¢ ä¿®å¤: ç»™æ‰‹æœºç«¯æš—è‰²æ¨¡å¼åŠ æ·±èƒŒæ™¯ï¼Œé˜²æ­¢å‘ç™½ (0.6 = 60% é»‘è‰²) */
                background-color: rgba(0, 0, 0, 0.3) !important;

                /* å¯é€‰: å¦‚æœå¸Œæœ›æ¨¡ç³ŠèƒŒæ™¯ï¼Œå¯ä»¥åŠ ä¸Šè¿™è¡Œ */
                backdrop-filter: blur(20px) !important;

                border-bottom: none !important;
            }

            /* 3. è°ƒæ•´æ‰‹æœºç«¯ä¾§è¾¹æ å’Œä¸»å†…å®¹çš„ top ä½ç½® */
            @media (max-width: 800px) {
                #sidebar,
                #main-content {
                    /* è¿™é‡Œçš„ top å¿…é¡»ç­‰äº header çš„æ–°é«˜åº¦ï¼Œå¦åˆ™ä¼šè¢« header æŒ¡ä½ */
                    top: var(--header-total-height) !important;
                }

                /* 4. å¦‚æœå…¨å±åŠ è½½é¡µä¹Ÿè¢«æŒ¡ä½äº†ï¼Œä¹Ÿä¿®ä¸€ä¸‹ */
                #global-loader {
                    padding-top: var(--safe-top);
                }
            }
        }

        /* ğŸŸ¢ ä¿®æ”¹: å¼ºåŠ›éšè—æµè§ˆå™¨åŸç”Ÿçš„æ—¶é—´é€‰æ‹©å›¾æ ‡ */
        input[type="time"]::-webkit-calendar-picker-indicator {
            background: transparent !important;
            display: none !important;
            -webkit-appearance: none !important;
            width: 0 !important;
            height: 0 !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* --- ğŸŸ¢ æ–°å¢: æ°”æ³¡é£æ ¼æ—¶é—´é€‰æ‹©å™¨ (ä»¿ iOS/VisionOS) --- */
        .bubble-picker-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            /* èƒŒæ™¯é€æ˜ï¼Œä¸å†éœ€è¦å˜æš—ï¼Œç‚¹å‡»ç©ºç™½å¤„å…³é—­ */
            background: transparent;
        }

        .bubble-picker-box {
            position: fixed; /* ä½¿ç”¨ fixed å®šä½ï¼Œé€šè¿‡ JS è®¡ç®—åæ ‡ */
            width: 280px;
            height: 320px;
            background: rgba(255, 255, 255, 0.95); /* ç•¥å¾®é€ç™½çš„èƒŒæ™¯ */
            backdrop-filter: blur(20px);
            border-radius: 32px; /* å¤§åœ†è§’ */
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05),
            0 20px 50px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            overflow: visible; /* å…è®¸å°ä¸‰è§’æº¢å‡º */
            animation: bubblePop 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        html.dark .bubble-picker-box {
            background: rgba(40, 40, 40, 0.95);
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1), 0 20px 50px rgba(0, 0, 0, 0.5);
        }


        html.dark .bubble-picker-box::after {
            border-color: rgba(40, 40, 40, 0.95) transparent transparent transparent;
        }

        /* ğŸŸ¢ ä¿®å¤: æ»šè½®åŒºåŸŸå¢åŠ  hidden é˜²æ­¢æº¢å‡º */
        .bubble-columns {
            flex: 1;
            display: flex;
            justify-content: center;
            position: relative;
            overflow: hidden; /* å…³é”®ï¼šå‰ªè£æº¢å‡ºçš„æ•°å­—ï¼Œé˜²æ­¢å®ƒä»¬è·‘åˆ°ç™½è‰²å¡ç‰‡å¤–é¢ */

            /* é®ç½©ä¿æŒä¸å˜ï¼Œç”¨äºä¸Šä¸‹æ¸éšæ•ˆæœ */
            mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);

            /* ç§»é™¤ä¹‹å‰çš„ padding-topï¼Œæ”¹ç”¨ flex å¸ƒå±€å¯¹é½ */
            margin-top: 20px;
            border-radius: 32px 32px 0 0; /* é¡ºä¾¿ä¿®å¤é¡¶éƒ¨åœ†è§’æº¢å‡º */
        }

        /* ğŸŸ¢ ä¿®å¤: è°ƒæ•´ padding ç¡®ä¿æ•°å­—å®Œç¾å±…ä¸­ */
        .bubble-col {
            flex: 1;
            overflow-y: auto;
            scroll-behavior: smooth;
            scroll-snap-type: y mandatory;
            height: 100%;

            /* è®¡ç®—å…¬å¼: (å®¹å™¨é«˜åº¦ - é€‰ä¸­é¡¹é«˜åº¦) / 2
               å®¹å™¨é«˜åº¦çº¦ 220px (320 - 80 footer - 20 margin)
               é€‰ä¸­é¡¹é«˜åº¦ 44px
               (220 - 44) / 2 = 88px
            */
            padding: 88px 0;
            z-index: 1;
        }

        /* éšè—æ»šåŠ¨æ¡ */
        .bubble-col::-webkit-scrollbar {
            display: none;
        }

        .bubble-item {
            height: 44px;
            line-height: 44px; /* åŠ é«˜ä¸€ç‚¹ï¼Œæ›´æ˜“ç‚¹å‡» */
            text-align: center;
            font-size: 26px; /* å­—ä½“åŠ å¤§ */
            font-weight: 400;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif;
            scroll-snap-align: center;
            color: #000;
            opacity: 0.3;
            transition: opacity 0.2s, transform 0.2s;
        }

        html.dark .bubble-item {
            color: #fff;
        }

        /* é€‰ä¸­æ€é«˜äº® (JSæ§åˆ¶ç±»å) */
        .bubble-item.active-item {
            opacity: 1;
            font-weight: 600;
        }

        /* åº•éƒ¨æŒ‰é’®æ  */
        .bubble-footer {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
        }

        /* Reset æŒ‰é’® (ç°è‰²èƒ¶å›Š) */
        .btn-reset {
            padding: 10px 24px;
            background: rgba(0, 0, 0, 0.05);
            color: #000;
            font-size: 16px;
            font-weight: 600;
            border-radius: 999px; /* èƒ¶å›Šåœ†è§’ */
            transition: background 0.2s;
        }

        html.dark .btn-reset {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .btn-reset:active {
            opacity: 0.7;
        }

        /* Confirm æŒ‰é’® (è“è‰²åœ†å½¢å¯¹å‹¾) */
        .btn-confirm {
            width: 56px;
            height: 56px;
            background: #007aff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
            transition: transform 0.1s;
        }

        .btn-confirm:active {
            transform: scale(0.95);
        }

        @keyframes bubblePop {
            0% {
                opacity: 0;
                transform: scale(0.9) translateY(10px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* --- ğŸŸ¢ ç§»åŠ¨ç«¯åŸç”Ÿ App é£æ ¼é‡ç½® (Mobile First UI) --- */

        /* 1. å…¨å±€å­—ä½“ä¸è§¦æ„Ÿä¼˜åŒ– */
        body {
            /* ä½¿ç”¨ iOS ç³»ç»Ÿå­—ä½“æ ˆ */
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", system-ui, sans-serif;
            -webkit-tap-highlight-color: transparent; /* å»é™¤ç‚¹å‡»é«˜äº®è‰²å— */
            min-width: 800px;
            /* 2. å…³é”®ä¿®æ”¹: å…è®¸æ¨ªå‘æ»šåŠ¨ï¼Œé˜²æ­¢å†…å®¹è¢«åˆ‡æ‰ */
            overflow-x: auto;
            overflow-y: hidden; /* ä¿æŒå‚ç›´æ–¹å‘ç”±å†…éƒ¨å®¹å™¨æ»šåŠ¨ */
        }

        /* 2. å¤§åœ†è§’è¾“å…¥æ¡† (Big Inputs) */
        .mobile-input-group {
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.03);
            margin-bottom: 12px;
        }

        html.dark .mobile-input-group {
            background: rgba(40, 40, 40, 0.6);
            border-color: rgba(255, 255, 255, 0.05);
        }

        /* 3. å·¨å¤§çš„åˆ—è¡¨æŒ‰é’® (List Item Buttons) */
        .mobile-list-btn {
            height: 64px !important; /* å¢å¤§é«˜åº¦ */
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            font-size: 18px !important;
            font-weight: 600;
            width: 100%;
            border-radius: 20px !important;
            transition: background 0.2s;
            margin-bottom: 12px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.03);
        }

        .mobile-list-btn:active {
            background-color: rgba(0, 0, 0, 0.05);
            transform: scale(0.98);
        }

        html.dark .mobile-list-btn:active {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* 4. æ‚¬æµ®åº•éƒ¨å¯¼èˆªæ  (Floating Tab Bar) */
        .mobile-tab-bar {
            position: fixed;
            bottom: 24px; /* è·ç¦»åº•éƒ¨æ‚¬æµ® */
            left: 20px;
            right: 20px;
            height: 70px; /* åŠ é«˜ */
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(25px) saturate(180%);
            border-radius: 35px; /* èƒ¶å›Šå½¢çŠ¶ */
            display: flex;
            align-items: center;
            justify-content: space-around;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15),
            0 0 0 1px rgba(255, 255, 255, 0.2);
            z-index: 900;
            padding: 0 10px;
        }

        html.dark .mobile-tab-bar {
            background: rgba(30, 30, 30, 0.85);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .mobile-tab-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            color: #8e8e93;
        }

        .mobile-tab-item.active {
            color: #fff;
            background: #007aff;
            transform: translateY(-10px); /* é€‰ä¸­æ—¶ç¨å¾®ä¸Šæµ® */
            box-shadow: 0 8px 20px rgba(0, 122, 255, 0.4);
        }

        .mobile-tab-item i {
            font-size: 22px;
            margin-bottom: 2px;
        }

        .mobile-tab-item span {
            font-size: 10px;
            font-weight: 600;
        }

        .mobile-tab-item.active span {
            display: none;
        }

        /* é€‰ä¸­æ—¶åªæ˜¾ç¤ºå¤§å›¾æ ‡ */
        .mobile-tab-item.active i {
            font-size: 26px;
            margin-bottom: 0;
        }

        /* 5. ä¼˜åŒ–åçš„ç»Ÿè®¡å¡ç‰‡ (Widget Style) */
        .mobile-stat-card {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 24px; /* å¤§åœ†è§’ */
            padding: 16px 20px;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.4);
            position: relative;
            overflow: hidden;
        }

        html.dark .mobile-stat-card {
            background: rgba(40, 40, 40, 0.6);
            border-color: rgba(255, 255, 255, 0.05);
        }

        /* 6. é¡¶éƒ¨æ—¥æœŸå¯¼èˆªæ ä¼˜åŒ– */
        .mobile-header-nav {
            height: 56px;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 100px;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin: 16px 16px;
        }

        /* ğŸŸ¢ ä¿®å¤: æš—è‰²æ¨¡å¼é¡¶éƒ¨å¯¼èˆªæ  (æ”¹ä¸ºç™½è‰²ä½é€æ˜åº¦ï¼Œå½¢æˆé«˜çº§ç°) */
        html.dark .mobile-header-nav {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.15);
        }

        /* ğŸŸ¢ æ–°å¢: æ‰‹æœºç«¯è°ƒæ•´æ—¶é•¿æ‰‹æŸ„ */
        .mobile-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px; /* å¢å¤§è§¦æ‘¸çƒ­åŒºï¼Œæ–¹ä¾¿æ‰‹æŒ‡æŒ‰ä½ */
            z-index: 20;
            display: flex;
            align-items: flex-end; /* é ä¸‹å¯¹é½ */
            justify-content: center;
            padding-bottom: 4px;
            cursor: ns-resize;
            /* åªæœ‰æ‰‹æœºç«¯æ˜¾ç¤ºï¼Œç”µè„‘ç«¯éšè— (ç”µè„‘ç«¯ç”¨ hover) */
            opacity: 1;
            touch-action: none;
        }

        /* è§†è§‰ä¸Šçš„å°æ¨ªæ¡ */
        .mobile-resize-bar {
            width: 32px;
            height: 4px;

            /* ğŸŸ¢ ä¿®æ”¹: ç§»é™¤åè‰²æ»¤é•œï¼Œç›´æ¥ç”¨åŠé€æ˜é»‘è‰² */
            background-color: rgba(0, 0, 0, 0.1);

            border-radius: 2px;
            /* backdrop-filter: invert(1); ğŸ‘ˆ åˆ é™¤è¿™è¡Œ */
        }

        /* æš—è‰²æ¨¡å¼ä¸‹ç”¨åŠé€æ˜ç™½è‰² */
        html.dark .mobile-resize-bar {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* ğŸŸ¢ æœ€ç»ˆå®Œç¾ç‰ˆï¼šå¹³è¡¡äº†ã€æ¸…æ™°åº¦ã€‘ä¸ã€ç£¨ç ‚æ„Ÿã€‘ */
        .custom-dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 8px;
            padding: 4px 4px 0 4px !important;

            /* --- äº®è‰²æ¨¡å¼è®¾ç½® --- */
            /* 0.75 æ˜¯äº®è‰²æ¨¡å¼çš„æœ€ä½³ç£¨ç ‚å€¼ */
            background-color: rgba(255, 255, 255, 0.99) !important;

            /* iOS é£æ ¼å¼ºåŠ›æ¨¡ç³Š */
            -webkit-backdrop-filter: blur(25px) saturate(180%) !important;
            backdrop-filter: blur(25px) saturate(180%) !important;

            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 16px;

            /* äº®è‰²æ¨¡å¼é˜´å½± */
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.2);

            z-index: 9999 !important;
            animation: menu-slide-in 0.25s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform: translate3d(0, 0, 0);
        }

        /* --- æš—è‰²æ¨¡å¼è®¾ç½® (å…³é”®ä¿®æ”¹) --- */
        html.dark .custom-dropdown-menu {
            /* ğŸŸ¢ å…³é”®: ä» 0.95 é™å› 0.8 */
            /* 0.8 æ—¢èƒ½æŒ¡ä½åº•ä¸‹çš„å­—(ä¸ä¹±)ï¼Œåˆèƒ½é€å‡ºåº•ä¸‹çš„å…‰(æœ‰ç£¨ç ‚æ„Ÿ) */
            background-color: rgba(30, 30, 30, 0.99) !important;

            /* æš—è‰²æ¨¡å¼è¾¹æ¡†è¦ç»†å¾® */
            border: 1px solid rgba(255, 255, 255, 0.1);

            /* åŠ é‡é˜´å½±ï¼Œä»¥æ­¤æ¥ä¿è¯æ–‡å­—å¯è¯»æ€§ï¼Œè€Œä¸æ˜¯é åŠ åšèƒŒæ™¯ */
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
        }

        /* é¡¶éƒ¨å¸é™„æ åŒæ­¥è°ƒæ•´ */
        html.dark .custom-dropdown-menu .sticky {
            /* ç¨å¾®æ¯”åˆ—è¡¨æ·±ä¸€ç‚¹ç‚¹ï¼Œå¢åŠ å±‚æ¬¡ */
            background-color: rgba(30, 30, 30, 0.99) !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #app .mobile-user-menu {
            /* å¼ºåˆ¶æ¢å¤å®½æ•çš„å†…è¾¹è·ï¼Œè¦†ç›–æ‰å…¨å±€çš„ 4px */
            padding: 24px !important;

            /* ä¿æŒä¹‹å‰çš„å®šä½è®¾ç½® */
            position: fixed !important;
            top: 76px !important;
            right: 30px !important;
            left: auto !important;
            margin: 0 !important;
            width: 320px !important;
            max-width: calc(100vw - 32px) !important;
            transform-origin: top right !important;
            z-index: 99999 !important;
        }

        /* --- ğŸŸ¢ ä¿®å¤ç‰ˆ: ç¼©æ”¾è§†å›¾åˆ‡æ¢åŠ¨ç”» --- */

        /* 1. åŸºç¡€åŠ¨ç”»å±æ€§: å¼€å¯ GPU åŠ é€Ÿï¼Œé˜²æ­¢é—ªçƒ */
        .zoom-in-enter-active,
        .zoom-in-leave-active,
        .zoom-out-enter-active,
        .zoom-out-leave-active {
            transition: all 0.35s cubic-bezier(0.34, 1.3, 0.64, 1);
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            /* ğŸš€ æ ¸å¿ƒä¿®å¤: å¼€å¯ç¡¬ä»¶åŠ é€Ÿ & éšè—èƒŒé¢ */
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-style: preserve-3d;
            transform-origin: center center;
        }

        /* ğŸŸ¢ åœºæ™¯ A: æ”¾å¤§ (Zoom In) - æœˆè§†å›¾ -> å‘¨è§†å›¾ */
        /* æ–°é¡µé¢(å‘¨): ä½äºä¸Šæ–¹ï¼Œä»å°å˜å¤§ */
        .zoom-in-enter-from {
            opacity: 0;
            transform: scale(0.85);
        }

        .zoom-in-enter-active {
            z-index: 20;
        }

        /* ç¡®ä¿è¿›å…¥çš„å…ƒç´ åœ¨ä¸Šé¢ */

        /* æ—§é¡µé¢(æœˆ): ä½äºä¸‹æ–¹ï¼Œå˜å¤§å¹¶å˜æ·¡ */
        .zoom-in-leave-to {
            opacity: 0;
            transform: scale(1.15);
        }

        .zoom-in-leave-active {
            z-index: 10;
        }

        /* ğŸŸ¢ åœºæ™¯ B: ç¼©å° (Zoom Out) - å‘¨è§†å›¾ -> æœˆè§†å›¾ */
        /* æ–°é¡µé¢(æœˆ): ä½äºä¸‹æ–¹ï¼Œä»å¤§å˜å›æ­£å¸¸ */
        .zoom-out-enter-from {
            opacity: 0;
            transform: scale(1.15);
        }

        .zoom-out-enter-active {
            z-index: 10;
        }

        /* æ—§é¡µé¢(å‘¨): ä½äºä¸Šæ–¹ï¼Œç¼©å°å¹¶æ¶ˆå¤± */
        .zoom-out-leave-to {
            opacity: 0;
            transform: scale(0.85);
        }

        /* ğŸš€ æ ¸å¿ƒä¿®å¤: è®©ç¦»å¼€çš„å‘¨è§†å›¾ä¿æŒåœ¨æœ€ä¸Šå±‚ï¼Œç›´åˆ°åŠ¨ç”»ç»“æŸ */
        .zoom-out-leave-active {
            z-index: 20;
        }

        /* --- ğŸŸ¢ ä¿®å¤: è§†å›¾åˆ‡æ¢åŠ¨ç”» (æ›´ç¨³å›ºçš„å¸ƒå±€) --- */
        .view-slide-left-enter-active,
        .view-slide-left-leave-active,
        .view-slide-right-enter-active,
        .view-slide-right-leave-active {
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            width: 100%; /* ç¡®ä¿åŠ¨ç”»æ—¶å æ»¡å®½åº¦ */
            flex: 1; /* ä¿æŒ Flex å¸ƒå±€æ¯”ä¾‹ */
        }

        /* 1. å‘å·¦æ»‘åŠ¨ (Week -> Month) */
        .view-slide-left-enter-from {
            opacity: 0;
            transform: translateX(30px); /* æ–°é¡µé¢ä»å³ä¾§è¿›æ¥ */
        }

        .view-slide-left-leave-to {
            opacity: 0;
            transform: translateX(-30px); /* æ—§é¡µé¢å‘å·¦ä¾§ç¦»å¼€ */
        }

        /* 2. å‘å³æ»‘åŠ¨ (Month -> Week) */
        .view-slide-right-enter-from {
            opacity: 0;
            transform: translateX(-30px); /* æ–°é¡µé¢ä»å·¦ä¾§è¿›æ¥ */
        }

        .view-slide-right-leave-to {
            opacity: 0;
            transform: translateX(30px); /* æ—§é¡µé¢å‘å³ä¾§ç¦»å¼€ */
        }

        /* --- ğŸŸ¢ ä¼˜åŒ–ç‰ˆ: å·¦å³æ»‘åŠ¨åŠ¨ç”» (iOS Push Style) --- */

        /* 1. åŸºç¡€è®¾ç½®: å¼€å¯ GPU åŠ é€Ÿï¼Œå®šä¹‰ç‰©ç†æ›²çº¿ */
        .slide-next-enter-active,
        .slide-next-leave-active,
        .slide-prev-enter-active,
        .slide-prev-leave-active {
            /* ä½¿ç”¨ç±» iOS çš„å¼¹ç°§æ›²çº¿ (Quart)ï¼Œå¼€å§‹å¿«ï¼Œç»“æŸæ—¶å¹³æ»‘å‡é€Ÿ */
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s ease;

            /* å…³é”®: ç»å¯¹å®šä½ï¼Œç¡®ä¿æ–°æ—§é¡µé¢åŒæ—¶å­˜åœ¨å¹¶é‡å  */
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100%;
            min-height: 100%;

            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-style: preserve-3d;

            overflow: hidden; /* é˜²æ­¢åŠ¨ç”»è¿‡ç¨‹ä¸­å‡ºç°åŒé‡æ»šåŠ¨æ¡ */
            z-index: 1;
        }

        /* --- Next: ä¸‹ä¸€å‘¨/æœªæ¥ (å‘å·¦æ¨) --- */

        /* è¿›åœº(æ–°): ä»å±å¹•å³ä¾§è¾¹ç¼˜æ»‘å…¥ */
        .slide-next-enter-from {
            transform: translate3d(100%, 0, 0);
        }

        /* è¿›åœºæ—¶å±‚çº§æ›´é«˜ï¼Œå¹¶å¸¦å·¦ä¾§é˜´å½±ï¼Œäº§ç”Ÿ"è¦†ç›–"æ„Ÿ */
        .slide-next-enter-active {
            z-index: 20;
            box-shadow: -20px 0 40px rgba(0, 0, 0, 0.05);
        }

        /* ç¦»åœº(æ—§): è¢«æ¨åˆ°å·¦ä¾§ï¼Œç¨å¾®å˜æš— (è§†å·®æ•ˆæœ) */
        .slide-next-leave-to {
            transform: translate3d(-25%, 0, 0); /* è¿™é‡Œçš„ -25% åˆ¶é€ è§†å·®ï¼Œä¸å®Œå…¨ç§»å‡ºï¼Œæ›´æœ‰è´¨æ„Ÿ */
            opacity: 0; /* é…åˆé€æ˜åº¦æ¶ˆå¤±ï¼Œé˜²æ­¢ç»ç’ƒèƒŒæ™¯é‡å æ˜¾å¾—æ‚ä¹± */
        }

        .slide-next-leave-active {
            z-index: 10;
        }

        /* --- Prev: ä¸Šä¸€å‘¨/è¿‡å» (å‘å³æ¨) --- */

        /* è¿›åœº(æ–°): ä»å±å¹•å·¦ä¾§è¾¹ç¼˜æ»‘å…¥ */
        .slide-prev-enter-from {
            transform: translate3d(-100%, 0, 0);
        }

        .slide-prev-enter-active {
            z-index: 20;
            box-shadow: 20px 0 40px rgba(0, 0, 0, 0.05);
        }

        /* ç¦»åœº(æ—§): è¢«æ¨åˆ°å³ä¾§ */
        .slide-prev-leave-to {
            transform: translate3d(25%, 0, 0);
            opacity: 0;
        }

        .slide-prev-leave-active {
            z-index: 10;
        }

        /* ğŸŸ¢ é¢å¤–ä¿®å¤: ç¡®ä¿ä¸»å®¹å™¨åœ¨åŠ¨ç”»æ—¶ä¸ä¼šè¢«æ’‘å¼€ */
        #main-content {
            position: relative; /* ç¡®ä¿ absolute å­å…ƒç´ ç›¸å¯¹äºå®ƒå®šä½ */
            overflow: hidden; /* è£å‰ªæ‰é£å‡ºå±å¹•çš„åŠ¨ç”»éƒ¨åˆ† */
        }

        /* ğŸŸ¢ æ ¸å¿ƒä¿®å¤: äº®è‰²æ¨¡å¼ä¸‹çš„ç½‘æ ¼çº¿/è¾¹æ¡†é¢œè‰² */
        /* åŸé…ç½®æ˜¯ç™½è‰²ï¼Œå¯¼è‡´åœ¨äº®èƒŒæ™¯ä¸‹ä¸å¯è§ã€‚è¿™é‡Œå¼ºåˆ¶æ”¹ä¸º 15% é»‘è‰² */
        html:not(.dark) .border-glass-border {
            border-color: rgba(0, 0, 0, 0.06) !important;
        }

        /* ğŸŸ¢ é¢å¤–ä¿®å¤: åŠ æ·±å‘¨è§†å›¾çš„æ¨ªå‘æ—¶é—´çº¿ */
        html:not(.dark) {
            --grid-line-light: rgba(0, 0, 0, 0.06) !important; /* åŠ æ·±åˆ° 15% */
        }

        /* ğŸŸ¢ é¢å¤–ä¿®å¤: æœˆè§†å›¾å¤–æ¡†é˜´å½±å¢å¼º (è®©è¡¨æ ¼æ›´ç«‹ä½“) */
        html:not(.dark) .shadow-liquid {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06) !important;
        }

        /* --- Settings åˆ†ç»„æ ·å¼ --- */
        .settings-group-container {
            background: rgba(0, 0, 0, 0.02);
            border-radius: 12px;
            margin-bottom: 12px;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        html.dark .settings-group-container {
            background: rgba(255, 255, 255, 0.03);
        }

        .settings-group-container.drag-over {
            background: rgba(0, 122, 255, 0.1);
            border-color: #007aff;
        }

        .settings-group-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            user-select: none;
        }

        .settings-group-input {
            background: transparent;
            border: 1px solid transparent;
            font-weight: 700;
            font-size: 13px;
            /* color: #007aff;  <-- ğŸ”´ åˆ é™¤è¿™ä¸€è¡Œï¼Œè®©é¢œè‰²å¯ä»¥åŠ¨æ€æ§åˆ¶ */
            padding: 4px 6px;
            border-radius: 6px;
            transition: all 0.2s;
            width: 100%;
        }

        .settings-group-input:focus {
            background: rgba(255, 255, 255, 0.8);
            border-color: #007aff;
            color: #000;
        }

        html.dark .settings-group-input:focus {
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
        }

        /* è‡ªå®šä¹‰æ»‘å—è½¨é“ */
        input[type=range].custom-slider {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            opacity: 1 !important; /* è¦†ç›–ä¹‹å‰çš„ hidden */
            height: 30px; /* å¢å¤§è§¦æ‘¸åŒºåŸŸ */
            position: relative;
            z-index: 10;
        }

        input[type=range].custom-slider:focus {
            outline: none;
        }

        /* è½¨é“ (Track) */
        input[type=range].custom-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 12px;
            cursor: pointer;
            background: #f3f4f6; /* ç°è‰²åº• */
            border-radius: 6px;
            border: 1px solid rgba(0,0,0,0.05);
        }
        .dark input[type=range].custom-slider::-webkit-slider-runnable-track {
            background: rgba(255,255,255,0.1);
            border: none;
        }

        /* æ»‘å—å¤´ (Thumb) */
        input[type=range].custom-slider::-webkit-slider-thumb {
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #ef4444; /* çº¢è‰²è¾¹æ¡† */
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -9px; /* (12pxè½¨é“é«˜åº¦ / 2) - (28pxæ»‘å—é«˜åº¦ / 2) */
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }


    </style>
</head>
<body>
<div id="global-loader">
    <div class="loader-glass-box">
        <div class="loader-spinner"></div>
        <div class="loader-text">Loading</div>
    </div>
</div>
<div id="app" class="flex flex-col h-full w-full select-none">

    <div class="liquid-window flex-1 flex flex-col overflow-hidden relative">

        <header class="h-16 flex items-center gap-2 px-2 sm:px-6 border-b border-glass-border dark:border-glass-borderDark z-50 shrink-0 relative transition-colors duration-300 dark:bg-black/40">

            <div class="flex items-center gap-2 sm:gap-5 z-50 relative shrink-0">

                <div class="relative custom-select-container">
                    <button @click.stop="toggleMobileMenu"
                            class="w-11 h-11 rounded-full bg-white/40 dark:bg-black/20 border border-white/20 shadow-sm hover:bg-white/60 dark:hover:bg-black/30 flex items-center justify-center transition group backdrop-blur-md">
                        <i class="fa-solid fa-bars text-lg opacity-70"></i>
                    </button>

                    <div v-if="showMobileMenu"
                         class="custom-dropdown-menu w-48 absolute top-full left-0 mt-2 p-1.5 flex flex-col gap-1 bg-white/90 dark:bg-[#1c1c1e]/90 backdrop-blur-xl border border-white/20 shadow-2xl rounded-xl origin-top-left text-left">


                        <button @click="toggleTheme"
                                class="flex items-center gap-3 px-3 py-3.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-6 flex justify-center text-lg transition-colors"
                                 :class="{
                                         'text-blue-500': themeMode === 'auto',
                                         'text-yellow-500': themeMode === 'light',
                                         'text-purple-400': themeMode === 'dark'
                                     }">
                                <i class="fa-solid" :class="getThemeLabel.icon"></i>
                            </div>
                            <div class="flex flex-col items-start leading-none gap-0.5">
                                <span>{{ getThemeLabel.text }}</span>
                                <span class="text-[9px] opacity-40 font-normal uppercase tracking-wider">{{ themeMode
                                    }}</span>
                            </div>
                        </button>

                        <button @click="showSettings = true; showMobileMenu = false"
                                class="flex items-center gap-3 px-3 py-3.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-6 flex justify-center text-gray-500 dark:text-gray-400 text-lg"><i
                                    class="fa-solid fa-gear"></i></div>
                            <span>è®¾ç½®é€‰é¡¹</span>
                        </button>


                        <div class="h-px bg-black/5 dark:bg-white/5 my-1 mx-2"></div>

                        <button @click="exportToICS(); showMobileMenu=false"
                                class="flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-5 flex justify-center text-[#007aff]"><i
                                    class="fa-regular fa-calendar-check"></i></div>
                            <span>å¯¼å‡º ICS æ—¥å†</span>
                        </button>

                        <button @click="exportJSON(); showMobileMenu=false"
                                class="flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-5 flex justify-center text-orange-500"><i class="fa-solid fa-download"></i>
                            </div>
                            <span>å¤‡ä»½æ•°æ® (JSON)</span>
                        </button>

                        <button @click="importJSON(); showMobileMenu=false"
                                class="flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 transition text-sm font-bold w-full">
                            <div class="w-5 flex justify-center text-green-500"><i class="fa-solid fa-upload"></i></div>
                            <span>æ¢å¤æ•°æ® (JSON)</span>
                        </button>
                    </div>
                </div>

                <h1 class="text-xl ml-3 mr-2 hidden sm:block select-none tracking-[0.1em]"
                    style="font-family: 'Chango', sans-serif; font-weight: 400;">

                        <span class="bg-clip-text text-transparent bg-gradient-to-r from-gray-800 to-gray-400 dark:from-white dark:to-gray-500">
                            MUSCHE
                        </span>
                </h1>

                <div class="flex items-center ml-1 gap-1 sm:gap-2">
                    <button @click="handleManualSync"
                            :disabled="isSyncing"
                            class="w-11 h-11 sm:w-9 sm:h-9 rounded-md hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition disabled:opacity-50 group relative"
                            title="åŒæ­¥äº‘ç«¯æ•°æ®">

                        <i class="fa-solid fa-cloud-arrow-down text-lg sm:text-base opacity-80"
                           :class="{'fa-bounce': isSyncing}"></i>

                        <div v-if="!user" class="absolute top-2 right-2 w-1.5 h-1.5 bg-red-500 rounded-full"></div>
                    </button>
                    <button @click="undo" :disabled="historyIndex <= 0"
                            class="w-11 h-11 sm:w-9 sm:h-9 rounded-md hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition disabled:opacity-30">
                        <i class="fa-solid fa-rotate-left text-lg"></i>
                    </button>
                    <button @click="redo" :disabled="historyIndex >= history.length - 1"
                            class="w-11 h-11 sm:w-9 sm:h-9 rounded-md hover:bg-black/5 dark:hover:bg-white/10 flex items-center justify-center transition disabled:opacity-30">
                        <i class="fa-solid fa-rotate-right text-lg"></i>
                    </button>
                </div>
            </div>

            <div class="flex-1 flex justify-center px-2 min-w-0 z-40">
                <div class="relative custom-select-container w-full max-w-[260px]">
                    <button @mousedown.stop="toggleDropdown('session')"
                            class="flex items-center justify-between gap-2 bg-white/50 dark:bg-black/20 backdrop-blur-md px-3 py-1.5 rounded-full border border-glass-border dark:border-glass-borderDark hover:bg-white/80 dark:hover:bg-white/10 transition h-11 w-full shadow-sm group cursor-pointer">

                        <div class="flex items-center gap-2 overflow-hidden flex-1 min-w-0 justify-center sm:justify-start">
                            <i class="fa-solid fa-layer-group text-xs opacity-50 group-hover:text-[#007aff] transition-colors shrink-0"></i>
                            <span class="text-sm font-bold truncate">{{ currentSessionName }}</span>
                        </div>

                        <i class="fa-solid fa-chevron-down text-[10px] opacity-50 transition-transform duration-300 shrink-0 ml-1"
                           :class="{'rotate-180': activeDropdown==='session'}"></i>
                    </button>

                    <div v-if="activeDropdown === 'session'"
                         class="custom-dropdown-menu w-full absolute top-full left-0 mt-2 shadow-2xl ring-1 ring-black/5 origin-top">
                        <div class="px-3 py-2 text-[10px] uppercase font-bold opacity-50 tracking-wider border-b border-black/5 dark:border-white/5 text-left">
                            Switch Session
                        </div>
                        <div class="max-h-60 overflow-y-auto py-1 text-left">
                            <div v-for="s in settings.sessions" :key="s.id"
                                 @mousedown.prevent.stop="switchSession(s.id)"
                                 class="px-4 py-2.5 text-sm hover:bg-[#007aff] hover:text-white cursor-pointer flex justify-between items-center group transition-colors">
                                <span class="font-medium truncate">{{ s.name }}</span>
                                <i v-if="currentSessionId === s.id" class="fa-solid fa-check text-xs"></i>
                            </div>
                        </div>
                        <div class="p-2 bg-black/5 dark:bg-white/5 border-t border-black/5 dark:border-white/5 grid grid-cols-1 gap-1">
                            <button @mousedown.prevent.stop="handleSessionAction('new')"
                                    class="text-left px-3 py-2 text-xs font-bold rounded-md hover:bg-white dark:hover:bg-white/10 flex items-center gap-2 transition cursor-pointer">
                                <i class="fa-solid fa-plus text-green-500"></i> New Session
                            </button>
                            <button @mousedown.prevent.stop="handleSessionAction('rename')"
                                    class="text-left px-3 py-2 text-xs font-bold rounded-md hover:bg-white dark:hover:bg-white/10 flex items-center gap-2 transition cursor-pointer">
                                <i class="fa-solid fa-pen text-orange-500"></i> Rename
                            </button>
                            <button @mousedown.prevent.stop="handleSessionAction('delete')"
                                    class="text-left px-3 py-2 text-xs font-bold rounded-md hover:bg-red-50 dark:hover:bg-red-900/20 text-red-500 flex items-center gap-2 transition cursor-pointer">
                                <i class="fa-solid fa-trash"></i> Delete
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="flex items-center gap-2 sm:gap-3 z-50 relative shrink-0">

                <div class="relative z-50 user-menu-container">
                    <button @click="handleUserBtnClick"
                            class="flex items-center justify-center w-11 h-11 rounded-full transition border cursor-pointer select-none overflow-hidden shrink-0"
                            :class="user ? 'bg-transparent border-transparent' : 'bg-gray-500/10 text-gray-600 border-gray-500/20 border'">

                        <div v-if="user && userAvatar" class="w-full h-full bg-cover bg-center"
                             :style="{backgroundImage: `url(${userAvatar})`}"></div>
                        <i v-else class="fa-solid text-lg"
                           :class="user ? 'fa-user-check text-green-600' : 'fa-user'"></i>
                    </button>

                    <div v-if="showProfileMenu && user"
                         class="custom-dropdown-menu mobile-user-menu w-72 absolute top-full right-0 mt-2 p-4 flex flex-col gap-4 cursor-default text-left max-h-none">

                        <div class="flex items-center gap-4 border-b border-black/5 dark:border-white/5 pb-4">
                            <div class="w-16 h-16 rounded-full bg-black/5 dark:bg-white/10 flex items-center justify-center overflow-hidden border-2 border-white/20 shadow-inner relative shrink-0">
                                <div v-if="userAvatar" class="absolute inset-0 bg-cover bg-center"
                                     :style="{backgroundImage: `url(${userAvatar})`}"></div>
                                <span v-else class="text-2xl font-bold opacity-30">{{ user.email[0].toUpperCase()
                                    }}</span>
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="font-bold text-base truncate">{{ userDisplayName }}</div>
                                <div class="text-xs opacity-50 truncate">{{ user.email }}</div>
                            </div>
                        </div>

                        <div class="space-y-2">
                            <label class="text-[10px] uppercase font-bold opacity-50 tracking-wider">è®¾ç½®æ˜µç§°</label>
                            <div class="flex gap-2">
                                <input v-model="tempNickname"
                                       placeholder="è¾“å…¥æ–°æ˜µç§°"
                                       class="glass-input flex-1 min-w-0 h-9 text-sm"
                                       @keydown.enter="updateNickname">

                                <button @click="updateNickname"
                                        :disabled="authLoading"
                                        class="bg-[#007aff] hover:bg-[#0062cc] text-white rounded-lg px-3 h-9 text-xs font-bold transition flex items-center justify-center shadow-lg shadow-blue-500/30 disabled:opacity-50 shrink-0">
                                    <i v-if="authLoading" class="fa-solid fa-circle-notch fa-spin"></i>
                                    <span v-else>ä¿å­˜</span>
                                </button>
                            </div>
                        </div>

                        <div class="space-y-2">
                            <label class="text-[10px] uppercase font-bold opacity-50 tracking-wider">ä¸Šä¼ å¤´åƒ</label>
                            <div class="flex gap-2 items-center">
                                <label class="flex-1 cursor-pointer bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition rounded-lg h-9 flex items-center justify-center text-xs font-bold gap-2 text-gray-600 dark:text-gray-300 border border-transparent">
                                    <i class="fa-solid fa-cloud-arrow-up"></i>
                                    <span id="upload-text">é€‰æ‹©å›¾ç‰‡...</span>
                                    <input type="file" accept="image/*" class="hidden" @change="onFileSelect">
                                </label>
                            </div>
                            <p class="text-[10px] opacity-40 leading-tight">æ”¯æŒ JPG, PNG, GIFã€‚</p>
                        </div>

                        <button @click="handleLogout"
                                class="w-full py-2.5 rounded-xl bg-red-500/10 text-red-600 hover:bg-red-500/20 border border-red-500/10 transition text-sm font-bold flex items-center justify-center gap-2">
                            <i class="fa-solid fa-arrow-right-from-bracket"></i> é€€å‡ºç™»å½•
                        </button>
                    </div>
                </div>

                <div class="w-px h-6 bg-black/10 dark:bg-white/10 mx-1 hidden sm:block"></div>


                <input id="json-upload" type="file" accept=".json" class="hidden" @change="handleJSONFile">
            </div>
        </header>

        <div class="flex-1 flex overflow-hidden relative">

            <aside id="sidebar"
                   v-show="!isMobile || mobileTab==='pool' || (isMobile && dragElClone && dragSourceType === 'pool')"

                   :style="{
                           width: isMobile ? '100%' : (isSidebarOpen ? sidebarWidth + 'px' : '0px'),
                           opacity: (isMobile || isSidebarOpen) ? 1 : 0
                       }"

                   class="glass-sidebar flex flex-col relative z-20"

                   :class="[
                           isMobile ? 'w-full absolute inset-0 bg-white dark:bg-[#1e1e1e] transition-none' : 'min-w-0 transition-all duration-300 ease-in-out',
                           (isMobile && dragElClone && dragSourceType === 'pool') ? 'z-[-1] opacity-0' : 'z-40',
                           !isSidebarOpen && !isMobile ? 'border-none overflow-hidden' : ''
                       ]"
                   @dragover.prevent @dragenter="dragEnterPool" @dragleave="dragLeavePool" @drop="dropToPool"
                   @click="clearSelection"

                   @touchstart="onSidebarTouchStart"
                   @touchend="onSidebarTouchEnd">

                <div class="flex flex-col px-8 py-5 sm:px-3 sm:py-3 border-b border-glass-border dark:border-glass-borderDark gap-4 sm:gap-3 shrink-0">

                    <button @click="showMobileTaskInput = true"
                            class="w-full h-16 sm:h-auto sm:py-2.5 rounded-[24px] sm:rounded-full bg-[#007aff] hover:bg-[#0062cc] text-white font-bold text-xl sm:text-sm shadow-lg shadow-blue-500/30 transition flex items-center justify-center gap-2 group active:scale-95">
                        <i class="fa-solid fa-plus text-xl sm:text-base group-hover:scale-110 transition-transform"></i>
                        <span>New Task</span>
                    </button>

                    <div class="flex gap-2 w-full bg-black/5 dark:bg-white/5 p-1 rounded-xl">
                        <button @click="switchSidebarTab('musician')"
                                class="flex-1 py-1.5 rounded-lg text-[10px] sm:text-xs font-bold transition uppercase tracking-wide flex items-center justify-center gap-1"
                                :class="sidebarTab==='musician' ? 'bg-white dark:bg-white/20 text-black dark:text-white shadow-sm' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'">
                            <i class="fa-solid fa-user"></i> äººå‘˜
                        </button>

                        <button @click="switchSidebarTab('project')"
                                class="flex-1 py-1.5 rounded-lg text-[10px] sm:text-xs font-bold transition uppercase tracking-wide flex items-center justify-center gap-1"
                                :class="sidebarTab==='project' ? 'bg-white dark:bg-white/20 text-black dark:text-white shadow-sm' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'">
                            <i class="fa-solid fa-folder"></i> é¡¹ç›®
                        </button>

                        <button @click="switchSidebarTab('instrument')"
                                class="flex-1 py-1.5 rounded-lg text-[10px] sm:text-xs font-bold transition uppercase tracking-wide flex items-center justify-center gap-1"
                                :class="sidebarTab==='instrument' ? 'bg-white dark:bg-white/20 text-black dark:text-white shadow-sm' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'">
                            <i class="fa-solid fa-guitar"></i> ä¹å™¨
                        </button>
                    </div>
                </div>

                <div class="flex-1 overflow-y-auto relative overflow-x-hidden"
                     ref="sidebarScrollRef">

                    <Transition :name="sidebarTransitionName">

                        <div :key="sidebarTab" class="w-full min-h-full p-3 pb-24">

                            <div class="flex justify-end gap-3 mb-2 px-1">
                                <button @click="toggleSort('name')"
                                        class="text-[10px] uppercase font-bold tracking-wider opacity-50 hover:opacity-100 transition flex items-center gap-1">
                                    Name <i class="fa-solid" :class="getSortIcon('name')" v-show="sortField==='name'"></i>
                                </button>
                                <button @click="toggleSort('status')"
                                        class="text-[10px] uppercase font-bold tracking-wider opacity-50 hover:opacity-100 transition flex items-center gap-1">
                                    Status <i class="fa-solid" :class="getSortIcon('status')" v-show="sortField==='status'"></i>
                                </button>
                                <button @click="toggleSort('duration')"
                                        class="text-[10px] uppercase font-bold tracking-wider opacity-50 hover:opacity-100 transition flex items-center gap-1">
                                    Time <i class="fa-solid" :class="getSortIcon('duration')"
                                            v-show="sortField==='duration'"></i>
                                </button>
                            </div>

                            <div v-for="stat in currentSidebarList" :key="stat.id"
                                 class="mobile-stat-card group py-6 px-5 sm:p-3"

                                 :draggable="!stat.isFullyScheduled && stat.statusKey !== 'in-progress'"
                                 @dragstart="(!stat.isFullyScheduled && stat.statusKey !== 'in-progress') && dragStart($event, stat, 'aggregate')"

                                 @click.stop="handleStatCardClick(stat)"
                                 @touchstart="handlePoolTouchStart($event, stat, 'aggregate')"
                                 @touchmove="handleTouchMove"
                                 @touchend="handleTouchEnd"
                                 @contextmenu.prevent>

                            <button class="absolute left-0 top-0 bottom-0 w-3 sm:w-2 flex items-center justify-center transition-all duration-200 group/btn z-10 cursor-pointer hover:brightness-110 active:scale-95"
                                    :style="{backgroundColor: stat.statusKey === 'completed' ? '#3b82f6'
                                        : stat.statusKey === 'full' ? '#34c759'
                                        : stat.statusKey === 'insufficient' ? '#ff3b30'
                                        : stat.statusKey === 'in-progress' ? '#f59e0b'
                                        : (sidebarTab === 'project' ? '#eab308' : (sidebarTab === 'instrument' ? '#3b82f6' : '#a855f7'))}"
                                    @click.stop="jumpToStatSchedule(stat)"
                                    title="ç‚¹å‡»è·³è½¬åˆ°æ—¥ç¨‹">

                            </button>

                            <div class="pl-10">
                                <div class="flex justify-between items-center mb-1">
                                    <div class="font-bold text-2xl sm:text-lg leading-none truncate pr-2 flex-1 min-w-0">
                                        {{ stat.name }}

                                        <span v-if="stat.scheduleCount > 1"
                                              class="ml-1 inline-flex items-center justify-center bg-black/5 dark:bg-white/10 px-1.5 h-4 rounded-md text-[10px] font-bold opacity-50 align-middle">
                                                {{ stat.scheduleCount }}
                                            </span>
                                    </div>

                                    <div class="flex items-center gap-1 shrink-0">
                                        <span v-if="stat.statusKey === 'completed'"
                                              class="px-2 py-1 rounded-md bg-blue-500 text-white text-sm sm:text-xs font-bold shadow-sm whitespace-nowrap">å®Œæˆ</span>
                                        <span v-else-if="stat.statusKey === 'in-progress'"
                                              class="px-2 py-1 rounded-md bg-orange-500 text-white text-sm sm:text-xs font-bold shadow-sm whitespace-nowrap">è¿›è¡Œä¸­</span>
                                        <span v-else-if="stat.statusKey === 'full'"
                                              class="px-2 py-1 rounded-md bg-green-500/10 text-green-600 dark:text-green-400 text-sm sm:text-xs font-bold whitespace-nowrap">å·²æ’</span>
                                        <span v-else-if="stat.statusKey === 'insufficient'"
                                              class="px-2 py-1 rounded-md bg-red-500/10 text-red-500 dark:text-red-400 text-sm sm:text-xs font-bold whitespace-nowrap">ç¼ºæ—¶</span>

                                        <button v-if="stat.avgRealRatio > 0"
                                                @click.stop="sidebarTab === 'musician' ? updateMusicianRatio(stat) : null"
                                                class="px-2 py-1 rounded-md bg-purple-100 dark:bg-purple-500/20 text-purple-700 dark:text-purple-300 text-sm sm:text-xs font-mono font-bold transition whitespace-nowrap border border-transparent dark:border-purple-500/20"
                                                :class="sidebarTab === 'musician' ? 'hover:bg-purple-200 active:scale-95 cursor-pointer' : 'cursor-default'">
                                            x{{ stat.avgRealRatio }}
                                        </button>
                                    </div>
                                </div>

                                <div class="flex justify-between items-baseline">
                                    <div class="text-[14px] opacity-50 font-medium flex items-center gap-2">
                                        <span>{{ stat.trackCount }} Items</span>
                                        <span v-if="stat.scheduledSeconds > 0"
                                              class="text-[13px] font-mono font-bold opacity-60 bg-black/5 dark:bg-white/10 px-1.5 rounded-md">
                                                {{ formatSecs(stat.scheduledSeconds) }}
                                            </span>
                                    </div>
                                    <div class="flex items-baseline gap-1">
                                            <span class="text-2xl sm:text-lg font-mono font-bold tracking-tight"
                                                  :class="{
                                                      'text-blue-500 dark:text-blue-400': stat.statusKey === 'completed',
                                                      'text-orange-500 dark:text-orange-400': stat.statusKey === 'in-progress',
                                                      'text-green-600 dark:text-green-400': stat.statusKey === 'full',
                                                      'text-red-500 dark:text-red-400': stat.statusKey === 'insufficient',
                                                      'text-gray-800 dark:text-gray-100': stat.statusKey === 'unscheduled'
                                                  }">
                                                {{ stat.totalDuration }}
                                            </span>
                                    </div>
                                </div>

                                <div class="mt-2 h-1 w-full bg-black/5 dark:bg-white/10 rounded-full overflow-hidden relative">
                                    <div class="h-full rounded-full transition-all duration-500 relative"
                                         :style="{
                                                width: (stat.totalSeconds > 0)
                                                    ? (stat.statusKey === 'insufficient'
                                                        ? Math.min(100, (stat.scheduledSeconds / stat.totalSeconds) * 100).toFixed(1) + '%'
                                                        : (stat.statusKey === 'completed' ? '100%' : Math.min(100, (stat.completedSeconds / stat.totalSeconds) * 100).toFixed(1) + '%')
                                                      )
                                                    : '0%',
                                                backgroundColor: stat.statusKey === 'completed' ? '#3b82f6'
                                                    : stat.statusKey === 'full' ? '#34c759'
                                                    : stat.statusKey === 'insufficient' ? '#ff3b30'
                                                    : stat.statusKey === 'in-progress' ? '#f59e0b'
                                                    : (sidebarTab === 'project' ? '#eab308' : (sidebarTab === 'instrument' ? '#3b82f6' : '#a855f7'))
                                             }">
                                    </div>
                                </div>

                                <div v-if="expandedStatsIds.has(stat.id)"
                                     class="mt-2 pt-2 border-t border-black/5 dark:border-white/5 space-y-1" @click.stop>
                                    <div v-for="item in stat.items" :key="item.id"
                                         @click.stop="selectTask(item.id, 'pool', $event)"
                                         @dblclick.stop="openEditModal(item, 'pool')"
                                         @touchstart="handlePoolTouchStart($event, item)"
                                         @touchmove="handleTouchMove"
                                         @touchend="handleTouchEnd"
                                         class="flex items-center justify-between p-1.5 rounded hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer transition border border-transparent"
                                         :class="{'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800': selectedPoolIds.has(item.id)}">

                                        <div class="flex items-center gap-2 min-w-0 overflow-hidden flex-1 mr-2">
                                            <div class="w-1.5 h-1.5 rounded-full shrink-0"
                                                 :style="{backgroundColor: getGroupColor(item, sidebarTab === 'project' ? 'musicianId' : 'projectId', true)}">
                                            </div>

                                            <div class="flex flex-col min-w-0">
                                                    <span class="text-xs font-bold truncate leading-tight flex items-center gap-1.5"> {{
                                                            sidebarTab === 'musician' ? getNameById(item.projectId, 'project') :
                                                                    sidebarTab === 'project' ? getNameById(item.musicianId, 'musician') :
                                                                            getNameById(item.musicianId, 'musician')
                                                        }}

                                                       <span v-if="item.splitTag"
                                                             class="text-[8px] px-1 rounded-sm font-mono font-bold uppercase tracking-wider shrink-0 bg-red-500/10 text-red-500">
                                                            {{ item.splitTag }}
                                                        </span>

                                                    </span>
                                                <span class="text-[9px] opacity-50 truncate leading-tight mt-0.5">
                                                        {{
                                                        sidebarTab === 'musician' ? getNameById(item.instrumentId, 'instrument') :
                                                                sidebarTab === 'project' ? getNameById(item.instrumentId, 'instrument') :
                                                                        getNameById(item.projectId, 'project')
                                                    }}
                                                    </span>
                                            </div>
                                        </div>

                                        <div class="flex items-center justify-end gap-2 shrink-0">
                                            <span v-if="item.actualDuration"
                                                  class="text-xs sm:text-[9px] font-mono font-bold px-1 py-0.5 rounded whitespace-nowrap"
                                                  :class="parseFloat(calculateSingleRatio(item)) > item.ratio ? 'text-red-500 bg-red-500/10' : 'text-green-600 bg-green-500/10'">x{{ calculateSingleRatio(item)
                                                }}</span>
                                            <span v-else-if="!isDefaultRatio(item)"
                                                  class="text-xs sm:text-[9px] font-mono font-bold text-gray-400 dark:text-gray-500 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded whitespace-nowrap">
                                                    x{{ item.ratio }}
                                                </span>

                                            <div class="flex flex-col items-end gap-0.5 leading-none">
                                                    <span class="font-mono text-sm sm:text-xs font-bold tabular-nums tracking-tight block"
                                                          :class="item.actualDuration ? 'text-[#007aff] dark:text-[#0a84ff]' : 'opacity-80'">
                                                        {{ item.actualDuration || item.estDuration }}
                                                    </span>
                                                <span v-if="item.musicDuration && item.musicDuration !== item.estDuration"
                                                      class="text-[9px] sm:text-[8px] font-mono font-bold text-gray-400 dark:text-gray-500 opacity-60 whitespace-nowrap">
                                                        {{ item.musicDuration }}
                                                    </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </Transition>
                </div>
            </aside>


            <main id="main-content"
                  v-show="!isMobile || mobileTab==='schedule'"
                  class="flex-1 flex flex-col relative bg-white/30 dark:bg-[#1e1e1e]/60 backdrop-blur-md"
                  :class="isMobile ? 'w-full absolute inset-0 z-30' : ''"
                  @touchstart="onMainTouchStart"
                  @touchend="onMainTouchEnd">
                <div class="flex items-center justify-between pr-4 shrink-0 z-50 relative">
                    <button @click="isSidebarOpen = !isSidebarOpen"
                            class="hidden sm:flex w-14 h-14 rounded-full bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 items-center justify-center transition text-gray-500 hover:text-[#007aff] ml-4 shrink-0"
                            :title="isSidebarOpen ? 'æ”¶èµ·ä¾§è¾¹æ ' : 'å±•å¼€ä¾§è¾¹æ '">
                        <i class="fa-solid text-lg transition-transform duration-300"
                           :class="isSidebarOpen ? 'fa-outdent' : 'fa-indent'"></i>
                    </button>
                    <div class="mobile-header-nav flex-1 !ml-2">
                        <button @click="changeDate(-1)"
                                class="w-12 h-10 flex items-center justify-center text-xl text-[#007aff] active:opacity-50">
                            <i class="fa-solid fa-chevron-left"></i>
                        </button>

                        <button @click="jumpToToday"
                                class="flex-1 flex flex-col items-center justify-center leading-none">
                            <span class="text-xs opacity-50 font-bold uppercase mb-0.5">{{ isToday(formatDate(viewDate)) ? 'Today' : 'Date'
                                }}</span>
                            <span class="text-base font-bold">{{ currentDateLabel }}</span>
                        </button>

                        <button @click="changeDate(1)"
                                class="w-12 h-10 flex items-center justify-center text-xl text-[#007aff] active:opacity-50">
                            <i class="fa-solid fa-chevron-right"></i>
                        </button>
                    </div>

                    <button @click="switchView(currentView === 'week' ? 'month' : 'week')"
                            class="ml-2 w-14 h-14 rounded-full bg-black/5 dark:bg-white/10 flex items-center justify-center active:bg-[#007aff] active:text-white transition shrink-0">
                        <i class="fa-solid" :class="currentView==='week'?'fa-calendar-week':'fa-calendar-days'"></i>
                    </button>

                    <button @click="cycleDayWidth"
                            class="ml-4 w-14 h-14 rounded-full bg-black/5 dark:bg-white/10 flex items-center justify-center active:bg-[#007aff] active:text-white transition shrink-0">
                        <i class="fa-solid" :class="widthIcon"></i>
                    </button>
                </div>

                <div class="flex-1 relative w-full overflow-hidden flex flex-col">

                    <Transition :name="viewTransitionName">

                        <div v-if="currentView === 'week'"
                             key="view-week"
                             class="w-full h-full flex flex-col overflow-y-auto relative no-scrollbar overscroll-none"

                             :class="{ 'touch-pan-y': dayColWidth < 60, 'is-zooming-now': isZooming }"

                             ref="weekContainer"
                             :style="{ '--slot-height': slotHeight + 'px' }"
                             @click="clearSelection">
                            <div class="flex min-w-full" ref="weekGridWrapper">

                                <Transition :name="dateTransitionName"
                                            @before-leave="onBeforeLeave"
                                            @after-leave="onAfterLeave">

                                    <div :key="currentWeekDays[0].dateStr" class="w-full min-h-full">

                                        <div class="flex min-w-full min-h-full">

                                            <div class="sticky left-0 z-[800] bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-xl border-r border-glass-border dark:border-glass-borderDark shadow-sm"
                                                 style="width: var(--time-col-width)">

                                                <div class="h-14 w-full border-b border-transparent"></div>

                                                <div v-for="t in timeSlots" :key="t" class="time-label-slot">
                                                    {{ t.endsWith('00') ? t : '' }}
                                                </div>
                                                <div class="time-label-slot">
                                                    {{ settings.endHour === 24 ? '00:00' : settings.endHour + ':00' }}
                                                </div>
                                            </div>

                                            <div v-for="day in currentWeekDays" :key="day.dateStr"
                                                 class="flex-1 border-r border-glass-border dark:border-glass-borderDark flex flex-col relative transition-all duration-300 ease-in-out"
                                                 :style="{ minWidth: dayColWidth + 'px' }"
                                                 :data-date-str="day.dateStr">

                                                <div class="h-14 sticky top-0 z-[600] flex flex-col items-center justify-center bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-xl border-b border-glass-border dark:border-glass-borderDark shadow-sm">
                                                    <span class="text-xs uppercase font-bold opacity-60 mb-0.5">{{ day.weekday
                                                        }}</span>
                                                    <div class="w-8 h-8 flex items-center justify-center rounded-full text-base font-bold"
                                                         :class="isToday(day.dateStr) ? 'bg-[#ff3b30] text-white' : 'opacity-90'">
                                                        {{ day.dateShort.split('/')[1] }}
                                                    </div>
                                                </div>

                                                <div class="relative" style="min-height: 1000px;">
                                                    <div v-for="t in timeSlots" :key="t"
                                                         class="grid-slot droppable-slot"
                                                         :data-time="t"
                                                         @dragenter="dragEnterSlot" @dragleave="dragLeaveSlot"
                                                         @dragover.prevent
                                                         @drop="dropToSchedule($event, day.dateStr)"></div>

                                                    <div v-for="task in (tasksByDateMap[day.dateStr] || [])"
                                                         :key="task.scheduleId"
                                                         class="task-block group"
                                                         :draggable="!isMobile"
                                                         @dragstart.stop="dragStart($event, task, 'schedule')"
                                                         @dragend="handleDragEnd"

                                                         @touchstart.stop="handleTouchStart($event, task, day.dateStr)"
                                                         @touchmove="handleTouchMove"
                                                         @touchend.stop="handleTouchEnd"

                                                         @dblclick.stop="handleTaskDblClick($event, task)"
                                                         :class="{
                                                               'is-selected': selectedTaskId === task.scheduleId,
                                                               'is-overlapping': getOverlapCount(task) > 0,
                                                               'is-flashing': flashingTaskId === task.scheduleId,
                                                               'is-ghost': isTaskGhost(task)
                                                             }"
                                                         :style="getTaskStyle(task)"
                                                         @click.stop="selectTask(task.scheduleId, 'schedule')">

                                                        <div class="flex flex-col h-full justify-between pointer-events-none">
                                                            <div class="font-bold leading-tight truncate pr-1">
                                                                {{ getBlockTitle(task) }}
                                                            </div>
                                                            <div class="mt-auto text-[10px] sm:text-[11px] font-mono opacity-80 flex flex-wrap justify-between gap-x-2 leading-none">
                                                                <span class="whitespace-nowrap">{{task.startTime}}</span>
                                                                <span class="font-bold whitespace-nowrap">{{task.estDuration}}</span>
                                                            </div>
                                                        </div>
                                                        <div class="resize-handle"
                                                             @mousedown.stop="initResize($event, task)"></div>
                                                        <div v-if="isMobile" class="mobile-resize-handle"
                                                             @touchstart.stop.prevent="initMobileResize($event, task)">
                                                            <div class="mobile-resize-bar"></div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </Transition>
                            </div>
                        </div>

                        <div v-else-if="currentView === 'month'"
                             key="view-month"
                             class="w-full h-full overflow-y-auto overflow-x-hidden relative"
                             @click="clearSelection">
                            <Transition :name="dateTransitionName">
                                <div :key="viewDate.getMonth()"
                                     class="w-full min-h-full"
                                     :class="isMobile ? 'p-2 pb-40' : 'p-4'">

                                    <div class="grid grid-cols-7 border-t border-l border-glass-border dark:border-glass-borderDark bg-white/50 dark:bg-[#1e1e1e]/50 rounded-xl overflow-hidden shadow-liquid"
                                         :class="isMobile ? 'w-full min-h-[50vh]' : 'min-w-[800px]'">

                                        <div v-for="w in ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']"
                                             class="p-3 text-right text-xs uppercase font-bold opacity-40 border-b border-r border-glass-border dark:border-glass-borderDark bg-black/5 dark:bg-white/5">
                                            {{w}}
                                        </div>

                                        <div v-for="day in currentMonthDays" :key="day.fullDate"
                                             class="min-h-[100px] sm:h-36 p-1.5 border-b border-r border-glass-border dark:border-glass-borderDark relative hover:bg-black/5 dark:hover:bg-white/5 transition droppable-slot group flex flex-col"
                                             :data-date="day.fullDate"
                                             @dblclick="switchToWeek(day.fullDate)"
                                             @dragover.prevent @drop="dropToMonth($event, day.fullDate)">

                                            <div class="text-right mb-1 shrink-0">
                                                        <span class="text-sm font-bold w-7 h-7 inline-flex items-center justify-center rounded-full"
                                                              :class="[isToday(day.fullDate) ? 'bg-[#ff3b30] text-white' : (day.isCurrentMonth ? 'opacity-80' : 'opacity-30')]">
                                                            {{ day.dayNum }}
                                                        </span>
                                            </div>

                                            <div class="space-y-1 overflow-y-auto max-h-[90px] no-scrollbar flex-1">
                                                <div v-for="task in (tasksByDateMap[day.fullDate] || [])"
                                                     :key="task.scheduleId"
                                                     class="text-[11px] px-2 py-1 rounded-md truncate flex items-center gap-1.5 cursor-grab hover:brightness-110 shadow-sm"
                                                     :class="{
                                                                 'ring-1 ring-white': selectedTaskId === task.scheduleId,
                                                                 'is-flashing': flashingTaskId === task.scheduleId,
                                                                 'is-ghost': isTaskGhost(task)
                                                             }"
                                                     :style="{
                                                                 backgroundColor: task.projectId ? '#eab308' : (task.instrumentId ? '#3b82f6' : '#a855f7'),
                                                                 color: 'white'
                                                             }"
                                                     @click.stop="selectTask(task.scheduleId, 'schedule')"
                                                     @dblclick.stop="handleTaskDblClick($event, task)"
                                                     :draggable="!isMobile"
                                                     @dragstart.stop="dragStart($event, task, 'schedule')"
                                                     @dragend="handleDragEnd"
                                                     @touchstart="handleTouchStart($event, task, day.fullDate)"
                                                     @touchmove="handleTouchMove"
                                                     @touchend.stop="handleTouchEnd">

                                                    <div class="w-1.5 h-1.5 rounded-full bg-white/40"></div>
                                                    <span class="font-mono opacity-80">{{task.startTime}}</span>
                                                    <span class="font-bold truncate">{{ getBlockTitle(task) }}</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </Transition>
                        </div>
                    </Transition>
                </div>
            </main>


            <div v-if="isMobile" class="mobile-tab-bar">
                <button @click="mobileTab='pool'; showMobileTaskInput=false"
                        class="mobile-tab-item"
                        :class="{'active': mobileTab==='pool' && !showMobileTaskInput}">
                    <i class="fa-solid fa-layer-group"></i>
                    <span>ä»»åŠ¡æ± </span>
                </button>

                <button @click="showMobileTaskInput = true"
                        class="mobile-tab-item"
                        :class="{'active': showMobileTaskInput}">
                    <i class="fa-solid fa-circle-plus text-2xl mb-0.5"></i>
                    <span>æ·»åŠ </span>
                </button>

                <button @click="mobileTab='schedule'; showMobileTaskInput=false"
                        class="mobile-tab-item"
                        :class="{'active': mobileTab==='schedule' && !showMobileTaskInput}">
                    <i class="fa-regular fa-calendar-days"></i>
                    <span>æ—¥ç¨‹è¡¨</span>
                </button>
            </div>
        </div>
    </div>

    <div v-if="showSettings" class="modal-overlay z-[5000]" @click.self="showSettings=false">
        <div class="modal-window w-[600px] flex flex-col p-8 animate-[fadeIn_0.2s] max-h-[85vh]">
            <div class="flex justify-between items-center mb-6 shrink-0">
                <h3 class="text-2xl font-bold">Preferences</h3>
                <button @click="showSettings=false"
                        class="w-8 h-8 rounded-full bg-black/10 dark:bg-white/10 hover:bg-black/20 flex items-center justify-center transition">
                    âœ•
                </button>
            </div>

            <div class="space-y-8 overflow-y-auto pr-2 flex-1" @scroll="onSettingsScroll">

                <section>
                    <h4 class="text-xs font-bold uppercase opacity-50 mb-3">Time Range</h4>
                    <div class="flex items-center gap-3">
                        <input v-model.number="settings.startHour" type="number"
                               class="glass-input w-24 text-center font-bold text-lg">
                        <span class="opacity-50 text-sm">to</span>
                        <input v-model.number="settings.endHour" type="number"
                               class="glass-input w-24 text-center font-bold text-lg">
                    </div>
                </section>

                <template v-for="type in ['instrument', 'musician', 'project']" :key="type">
                    <section>
                        <div class="flex justify-between items-center mb-3">
                            <div class="flex items-center gap-3">
                                <h4 class="text-xs font-bold uppercase opacity-50">
                                    {{ type === 'instrument' ? 'Instruments' : (type === 'musician' ? 'Musicians' : 'Projects') }}
                                </h4>

                                <button @click="toggleAllGroups(type)"
                                        class="w-6 h-6 rounded-md bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 flex items-center justify-center transition text-gray-500"
                                        :title="isAllGroupsExpanded(type) ? 'å…¨éƒ¨æŠ˜å ' : 'å…¨éƒ¨å±•å¼€'">
                                    <i class="fa-solid text-[10px]"
                                       :class="isAllGroupsExpanded(type) ? 'fa-compress' : 'fa-expand'"></i>
                                </button>
                            </div>

                            <button @click="clearSettingsList(type)"
                                    class="text-[10px] font-bold text-red-500 bg-red-500/5 hover:bg-red-500/20 px-2 py-1 rounded transition uppercase tracking-wider">
                                Clear
                            </button>
                        </div>

                        <div class="space-y-3">
                            <div v-for="group in getSettingsGroupedList(type)" :key="group.name"
                                 class="settings-group-container"
                                 @dragover.prevent="onSettingsDragOver"
                                 @dragleave="onSettingsDragLeave"
                                 @drop="onSettingsDrop(type, group.name, $event)">

                                <div class="settings-group-header group/header"
                                     @click="toggleSettingsGroup(type, group.name)">
                                    <div class="w-6 flex justify-center opacity-30 mr-2 transition-transform duration-200"
                                         :class="{'rotate-90': settingsExpandedGroups.has(type + '|' + group.name)}"> <i class="fa-solid fa-chevron-right text-[10px]"></i>
                                    </div>

                                    <input :value="group.name"
                                           @click.stop
                                           @change="renameGroup(type, group.name, $event.target.value)"
                                           class="settings-group-input flex-1"
                                           :style="{
                                                   color: type === 'project' ? '#eab308' :
                                                          (type === 'instrument' ? '#3b82f6' : '#a855f7')
                                               }"
                                           placeholder="æœªåˆ†ç»„">

                                    <span class="text-[10px] font-bold opacity-30 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded ml-2 text-black dark:text-white">
                                        {{ group.items.length }}
                                    </span>
                                </div>

                                <div v-show="settingsExpandedGroups.has(type + '|' + group.name)" class="pl-2 pr-2 pb-2 space-y-1">
                                    <div v-for="item in group.items" :key="item.id"
                                         class="flex items-center gap-3 p-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/5 transition group/item bg-white/40 dark:bg-black/20"
                                         draggable="true"
                                         @dragstart="onSettingsItemDragStart(item, type, $event)">

                                        <button @click="openColorPicker(item, type)"
                                                class="w-6 h-6 rounded flex items-center justify-center text-white shadow-sm shrink-0 cursor-pointer hover:scale-110 active:scale-95 transition-transform"
                                                :style="{ backgroundColor: item.color }">

                                            <i class="fa-solid text-[10px]"
                                               :class="type==='project'?'fa-folder':(type==='instrument'?'fa-guitar':'fa-user')"></i>
                                        </button>

                                        <input v-model.lazy="item.name"
                                               class="bg-transparent border-none outline-none font-medium flex-1 text-sm"
                                               placeholder="Name">

                                        <button @click="removeSettingsItem(type, item.id)"
                                                class="w-6 h-6 flex items-center justify-center rounded hover:bg-red-500/10 text-gray-400 hover:text-red-500 transition opacity-0 group-hover/item:opacity-100">
                                            <i class="fa-solid fa-trash text-xs"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div class="flex gap-2 items-center mt-4 p-1 relative isolate">

                                <div class="settings-name-wrapper relative flex-1">

                                    <input v-model="newSettingsItem[type].name"
                                           @focus="updateInputRect($event, 'name'); settingsNameFocus = type"
                                           class="glass-input w-full h-10 pr-8"
                                           :placeholder="'New ' + (type==='instrument'?'Instrument':(type==='musician'?'Musician':'Project')) + ' Name'"
                                           @keydown.enter="addSettingsItem(type)">

                                    <i class="fa-solid fa-chevron-up absolute right-2.5 top-3 text-[10px] transition-transform duration-200 cursor-pointer opacity-50 hover:opacity-100"
                                       :class="{'rotate-180': settingsNameFocus === type}"
                                       @mousedown.prevent="updateInputRect($event, 'name'); settingsNameFocus = (settingsNameFocus === type ? null : type)"></i>

                                    <Teleport to="body">
                                        <div v-if="settingsNameFocus === type"
                                             :style="getFloatingStyle('name')"
                                             class="custom-dropdown-menu max-h-40 overflow-y-auto p-1 origin-bottom animate-[fadeIn_0.1s] shadow-xl border border-black/5 dark:border-white/10">

                                            <div class="px-2 py-1 text-[10px] font-bold opacity-40 uppercase tracking-wider sticky top-0 bg-white/95 dark:bg-[#2c2c2e]/95 backdrop-blur z-10">
                                                æ•´ç†æœªåˆ†ç»„é¡¹ / æˆ–è¾“å…¥æ–°å:
                                            </div>

                                            <div v-for="u in getUngroupedItems(type)" :key="u.id"
                                                 @mousedown.prevent="newSettingsItem[type].name = u.name; settingsNameFocus = null"
                                                 class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-xs font-bold transition-colors flex items-center gap-2">
                                                <div class="w-2 h-2 rounded-full" :style="{backgroundColor: u.color}"></div>
                                                {{ u.name }}
                                            </div>

                                            <div v-if="getUngroupedItems(type).length === 0"
                                                 class="px-3 py-4 text-center opacity-40 text-[10px]">
                                                æš‚æ— æœªåˆ†ç»„é¡¹ç›®
                                            </div>
                                        </div>
                                    </Teleport>
                                </div>

                                <div class="settings-group-wrapper relative w-1/3">
                                    <input v-model="newSettingsItem[type].group"
                                           @focus="updateInputRect($event, 'group'); settingsGroupFocus = type"
                                           class="glass-input w-full h-10 text-xs pr-7"
                                           placeholder="åˆ†ç»„ (å¯é€‰)"
                                           @keydown.enter="addSettingsItem(type)">

                                    <i class="fa-solid fa-chevron-up absolute right-2.5 top-3 text-[10px] transition-transform duration-200 cursor-pointer opacity-50 hover:opacity-100"
                                       :class="{'rotate-180': settingsGroupFocus === type}"
                                       @mousedown.prevent="updateInputRect($event, 'group'); settingsGroupFocus = (settingsGroupFocus === type ? null : type)"></i>

                                    <Teleport to="body">
                                        <div v-if="settingsGroupFocus === type"
                                             :style="getFloatingStyle('group')"
                                             class="custom-dropdown-menu max-h-40 overflow-y-auto p-1 origin-bottom animate-[fadeIn_0.1s] shadow-xl border border-black/5 dark:border-white/10">

                                            <div class="px-2 py-1 text-[10px] font-bold opacity-40 uppercase tracking-wider sticky top-0 bg-white/95 dark:bg-[#2c2c2e]/95 backdrop-blur z-10">
                                                é€‰æ‹©ç°æœ‰åˆ†ç»„:
                                            </div>

                                            <div v-for="g in getExistingGroups(type)" :key="g"
                                                 @mousedown.prevent="newSettingsItem[type].group = g; settingsGroupFocus = null"
                                                 class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-xs font-bold transition-colors text-gray-800 dark:text-gray-200">
                                                {{ g }}
                                            </div>

                                            <div v-if="getExistingGroups(type).length === 0"
                                                 class="px-3 py-4 text-center opacity-40 text-[10px]">
                                                æš‚æ— åˆ†ç»„ï¼Œç›´æ¥è¾“å…¥åˆ›å»º
                                            </div>
                                        </div>
                                    </Teleport>
                                </div>

                                <button @click="addSettingsItem(type)"
                                        class="h-10 px-4 rounded-xl font-bold text-white shadow-lg transition text-sm flex items-center gap-2 shrink-0 active:scale-95"
                                        :class="type==='project'?'bg-[#eab308] hover:bg-[#ca8a04]':(type==='instrument'?'bg-[#3b82f6] hover:bg-[#2563eb]':'bg-[#a855f7] hover:bg-[#9333ea]')">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                            </div>
                        </div>
                    </section>
                </template>

                <section class="p-4 rounded-xl bg-orange-500/10 border border-orange-500/20">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="text-xs font-bold uppercase text-orange-600 dark:text-orange-400 mb-1">Import
                                CSV</h4>
                            <p class="text-[11px] opacity-60 max-w-[250px]">Format: project, instrumentName,
                                musicianName, musicDuration, ratio</p>
                        </div>
                        <label class="cursor-pointer bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow-lg shadow-orange-500/20 transition">
                            <i class="fa-solid fa-file-csv mr-1"></i> Upload
                            <input type="file" accept=".csv" class="hidden" @change="handleCSVImport">
                        </label>
                    </div>
                </section>
            </div>

            <div class="mt-8 pt-4 border-t border-glass-border dark:border-glass-borderDark flex justify-between items-center shrink-0">
                <button @click="factoryReset"
                        class="text-xs font-bold text-red-400 hover:text-red-500 hover:bg-red-500/10 px-4 py-2 rounded-lg transition flex items-center gap-2">
                    <i class="fa-solid fa-triangle-exclamation"></i> æ¢å¤å‡ºå‚è®¾ç½®
                </button>

                <button @click="showSettings=false"
                        class="bg-[#007aff] hover:bg-[#0062cc] text-white px-8 py-2.5 rounded-xl font-bold shadow-lg shadow-blue-500/30 transition text-sm">
                    Done
                </button>
            </div>
        </div>
    </div>

    <div v-if="showEditor" class="modal-overlay" @click.self="showEditor=false">
        <div class="modal-window w-96 p-6 animate-[fadeIn_0.1s]">
            <h3 class="font-bold text-xl mb-6">Edit Event</h3>
            <div class="space-y-4 text-sm">

                <div class="grid grid-cols-2 gap-3 relative">

                    <div class="relative transition-all" :class="activeDropdown === 'edit_project' ? 'z-[50]' : 'z-20'">
                        <button @click.stop="toggleDropdown('edit_project')"
                                class="glass-input w-full h-[42px] flex items-center px-3 font-bold text-sm group">

                            <span class="flex-1 truncate text-center">{{ getNameById(editingItem.projectId, 'project')
                                }}</span>

                            <i class="fa-solid fa-chevron-down opacity-30 text-[10px] transition-transform duration-200"
                               :class="{'rotate-180': activeDropdown === 'edit_project'}"></i>
                        </button>

                        <div v-if="activeDropdown === 'edit_project'" class="custom-dropdown-menu">
                            <div class="sticky top-0 bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-md p-2 border-b border-black/5 dark:border-white/5 z-20">
                                <input v-model="dropdownSearch" placeholder="æœç´¢é¡¹ç›®..."
                                       class="w-full bg-transparent text-sm px-2 py-1 outline-none placeholder:opacity-50"
                                       @click.stop>
                            </div>

                            <div class="max-h-[200px] overflow-y-auto">
                                <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">
                                    <div class="sticky top-0 z-10 w-full px-3 py-1.5 text-[10px] font-bold uppercase tracking-wider opacity-50 bg-gray-50/90 dark:bg-[#2c2c2e]/90 backdrop-blur border-y border-black/5 dark:border-white/5 flex justify-between items-center cursor-pointer"
                                         @click.stop="toggleDropdownGroup(group.name)">
                                        {{ group.name }} <i class="fa-solid fa-chevron-right transition-transform"
                                                            :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                    </div>
                                    <div v-for="item in group.items" :key="item.id"
                                         @click="selectOption('project', item)"
                                         class="px-3 py-2.5 text-sm border-b border-black/5 dark:border-white/5 hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer flex items-center gap-2">

                                        <div class="w-2 h-2 rounded-full shrink-0"
                                             :style="{backgroundColor: item.color || '#eab308'}"></div>

                                        {{ item.name }}
                                    </div>
                                </div>
                                <div v-if="filteredOptions.length===0" class="p-4 text-center opacity-40 text-xs">
                                    æ— ç»“æœ
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="relative transition-all"
                         :class="activeDropdown === 'edit_instrument' ? 'z-[50]' : 'z-20'">
                        <button @click.stop="toggleDropdown('edit_instrument')"
                                class="glass-input w-full h-[42px] flex items-center px-3 font-bold text-sm group">

                            <span class="flex-1 truncate text-center">{{ getNameById(editingItem.instrumentId, 'instrument')
                                }}</span>

                            <i class="fa-solid fa-chevron-down opacity-30 text-[10px] transition-transform duration-200"
                               :class="{'rotate-180': activeDropdown === 'edit_instrument'}"></i>
                        </button>

                        <div v-if="activeDropdown === 'edit_instrument'" class="custom-dropdown-menu">
                            <div class="sticky top-0 bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-md p-2 border-b border-black/5 dark:border-white/5 z-20">
                                <input v-model="dropdownSearch" placeholder="æœç´¢ä¹å™¨..."
                                       class="w-full bg-transparent text-sm px-2 py-1 outline-none placeholder:opacity-50"
                                       @click.stop>
                            </div>
                            <div class="max-h-[200px] overflow-y-auto">
                                <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">
                                    <div class="sticky top-0 z-10 w-full px-3 py-1.5 text-[10px] font-bold uppercase tracking-wider opacity-50 bg-gray-50/90 dark:bg-[#2c2c2e]/90 backdrop-blur border-y border-black/5 dark:border-white/5 flex justify-between items-center cursor-pointer"
                                         @click.stop="toggleDropdownGroup(group.name)">
                                        {{ group.name }} <i class="fa-solid fa-chevron-right transition-transform"
                                                            :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                    </div>
                                    <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">
                                        <div v-for="item in group.items" :key="item.id"
                                             @click="selectOption('instrument', item)"
                                             class="px-3 py-2.5 text-sm border-b border-black/5 dark:border-white/5 hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer flex items-center gap-2">

                                            <div class="w-2 h-2 rounded-full shrink-0"
                                                 :style="{backgroundColor: item.color || '#3b82f6'}"></div>

                                            {{ item.name }}
                                        </div>
                                    </div>
                                </div>
                                <div v-if="filteredOptions.length===0" class="p-4 text-center opacity-40 text-xs">
                                    æ— ç»“æœ
                                </div>
                            </div>
                        </div>
                    </div>

                    <input :value="editingItem.musicDuration"
                           @input="editingItem.musicDuration = $event.target.value"
                           :readonly="isMobile"
                           @click="isMobile && openDurationPicker($event, editingItem, 'musicDuration')"
                           class="glass-input w-full font-mono font-bold tracking-widest text-center text-lg h-[42px]"
                           :class="isMobile ? 'cursor-pointer caret-transparent' : 'cursor-text'"
                           placeholder="00:00">

                    <div class="relative transition-all"
                         :class="activeDropdown === 'edit_musician' ? 'z-[50]' : 'z-20'">
                        <button @click.stop="toggleDropdown('edit_musician')"
                                class="glass-input w-full h-[42px] flex items-center px-3 font-bold text-sm group">

                            <span class="flex-1 truncate text-center">{{ getNameById(editingItem.musicianId, 'musician')
                                }}</span>

                            <i class="fa-solid fa-chevron-down opacity-30 text-[10px] transition-transform duration-200"
                               :class="{'rotate-180': activeDropdown === 'edit_musician'}"></i>
                        </button>

                        <div v-if="activeDropdown === 'edit_musician'" class="custom-dropdown-menu">
                            <div class="sticky top-0 bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-md p-2 border-b border-black/5 dark:border-white/5 z-20">
                                <input v-model="dropdownSearch" placeholder="æœç´¢äººå‘˜..."
                                       class="w-full bg-transparent text-sm px-2 py-1 outline-none placeholder:opacity-50"
                                       @click.stop>
                            </div>
                            <div class="max-h-[200px] overflow-y-auto">
                                <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">
                                    <div class="sticky top-0 z-10 w-full px-3 py-1.5 text-[10px] font-bold uppercase tracking-wider opacity-50 bg-gray-50/90 dark:bg-[#2c2c2e]/90 backdrop-blur border-y border-black/5 dark:border-white/5 flex justify-between items-center cursor-pointer"
                                         @click.stop="toggleDropdownGroup(group.name)">
                                        {{ group.name }} <i class="fa-solid fa-chevron-right transition-transform"
                                                            :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                    </div>
                                    <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">
                                        <div v-for="m in group.items" :key="m.id"
                                             @click="selectOption('musician', m)"
                                             class="px-3 py-2.5 text-sm border-b border-black/5 dark:border-white/5 hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer flex justify-between items-center">

                                            <div class="flex items-center gap-2">
                                                <div class="w-2 h-2 rounded-full shrink-0"
                                                     :style="{backgroundColor: m.color || '#a855f7'}"></div>
                                                <span>{{ m.name }}</span>
                                            </div>

                                            <span class="text-[10px] opacity-50 font-mono bg-black/5 dark:bg-white/10 px-1 rounded">x{{m.defaultRatio}}</span>
                                        </div>
                                    </div>
                                </div>
                                <div v-if="filteredOptions.length===0" class="p-4 text-center opacity-40 text-xs">
                                    æ— ç»“æœ
                                </div>
                            </div>
                        </div>
                    </div>

                </div>

                <div v-if="editingSource === 'schedule'" class="pt-4 border-t border-white/10 mt-2">
                    <div class="flex gap-3">
                        <input type="date" v-model="editingItem.date" class="glass-input flex-1 font-bold text-center">
                        <select v-model="editingItem.startTime"
                                class="glass-input w-24 font-mono font-bold text-center">
                            <option v-for="t in timeSlots" :value="t">{{t}}</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="flex justify-between mt-8">
                <button @click="deleteEditingItem"
                        class="text-red-500 hover:bg-red-500/10 px-4 py-2 rounded-lg transition text-sm font-bold">
                    Delete
                </button>
                <button @click="pushHistory(); saveEdit()"
                        class="bg-[#007aff] text-white px-6 py-2 rounded-lg font-bold shadow hover:shadow-lg transition text-sm">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div v-if="showAuthModal" class="modal-overlay" @click.self="showAuthModal=false">
        <div class="modal-window w-[400px] p-8 animate-[fadeIn_0.2s] text-center">
            <h3 class="text-2xl font-bold mb-2">äº‘ç«¯åŒæ­¥</h3>
            <p class="text-sm opacity-60 mb-6">ç™»å½•åï¼Œæ‚¨çš„æ—¥ç¨‹å°†åœ¨ä¸åŒè®¾å¤‡é—´è‡ªåŠ¨åŒæ­¥ã€‚</p>

            <div class="space-y-4">
                <input id="auth-email"
                       v-model="authForm.email"
                       type="email"
                       placeholder="Email"
                       class="glass-input w-full text-base p-3"
                       enterkeyhint="next"
                       @keydown.enter.prevent="authPasswordRef.focus()">

                <input id="auth-password"
                       ref="authPasswordRef"
                       v-model="authForm.password"
                       type="password"
                       placeholder="Password"
                       class="glass-input w-full text-base p-3"
                       enterkeyhint="go"
                       @keydown.enter.prevent="handleLogin">

                <button @click="handleLogin" :disabled="authLoading"
                        class="w-full bg-[#007aff] text-white py-3 rounded-xl font-bold hover:bg-[#0062cc] transition disabled:opacity-50 shadow-lg shadow-blue-500/30">
                    {{ authLoading ? 'å¤„ç†ä¸­...' : 'ç™» å½•' }}
                </button>

                <div class="flex justify-between items-center text-xs mt-4 px-1">
                    <button @click="handleRegister" :disabled="authLoading"
                            class="text-gray-500 dark:text-gray-400 hover:text-[#007aff] transition font-bold">
                        æ²¡æœ‰è´¦å·ï¼Ÿæ³¨å†Œæ–°å·
                    </button>

                    <button @click="handleResetPwd" :disabled="authLoading"
                            class="text-gray-500 dark:text-gray-400 hover:text-orange-500 transition">
                        å¿˜è®°å¯†ç ï¼Ÿ
                    </button>
                </div>
            </div>
        </div>
    </div>


    <div v-if="showTrackList" class="modal-overlay" @click.self="showTrackList=false">
        <div class="modal-window w-[450px] max-w-[90vw] max-h-[80vh] flex flex-col p-0 overflow-hidden animate-[fadeIn_0.1s]">

            <div class="p-5 bg-white/50 dark:bg-black/20 backdrop-blur border-b border-glass-border dark:border-glass-borderDark flex justify-between items-center shrink-0">
                <h3 class="font-bold text-lg">{{ trackListData.name }} <span
                        class="opacity-50 font-normal text-sm ml-2">Tracks</span></h3>

                <div class="flex items-center gap-2">
                    <button @click="sortTrackList"
                            class="w-8 h-8 flex items-center justify-center hover:bg-black/10 dark:hover:bg-white/10 rounded-full transition group"
                            title="æŒ‰æ—¶é—´æ’åº">
                        <i class="fa-solid fa-arrow-down-short-wide text-xs opacity-50 group-hover:opacity-100 group-hover:text-[#007aff] transition-all"></i>
                    </button>

                    <button @click="showTrackList=false"
                            class="w-8 h-8 flex items-center justify-center hover:bg-black/10 dark:hover:bg-white/10 rounded-full transition">
                        âœ•
                    </button>
                </div>
            </div>

            <div ref="trackListContainerRef" class="p-3 overflow-y-auto flex-1 min-h-[100px] relative">
                <TransitionGroup name="list" tag="div" class="space-y-1 relative">

                    <template v-for="(item, index) in trackListData.items" :key="item.id">

                        <div v-if="trackListData.totalSections > 1 && (
                                  (index === 0 && item.sectionIndex > 0) ||
                                  (index > 0 && item.sectionIndex !== trackListData.items[index-1].sectionIndex)
                               )"
                             :key="'div-sec-' + item.sectionIndex"
                             :id="'sec-divider-' + item.sectionIndex"
                             class="py-3 flex items-center gap-3 select-none group/divider transition-opacity duration-0"
                             :class="{ 'opacity-0': draggingSectionIndex === item.sectionIndex }">

                            <div class="h-px bg-black/10 dark:bg-white/10 flex-1 group-hover/divider:bg-[#007aff]/50 transition-colors"></div>

                            <div class="px-3 py-1.5 rounded-full bg-black/5 dark:bg-white/10 border border-black/5 dark:border-white/5 flex items-center gap-2 text-[10px] font-bold opacity-60 group-hover/divider:opacity-100 group-hover/divider:text-[#007aff] group-hover/divider:bg-[#007aff]/10 transition-all shadow-sm cursor-ns-resize touch-none"
                                 @mousedown="startDividerDrag($event, item.sectionIndex)"
                                 @touchstart.prevent.stop="startDividerDrag($event, item.sectionIndex)">
                                <i class="fa-solid fa-grip-lines-vertical mr-1 opacity-50"></i>
                                <i class="fa-regular fa-calendar"></i>
                                <span>
                                          {{ trackListData.schedules[item.sectionIndex] ? trackListData.schedules[item.sectionIndex].date.split('-').slice(1).join('/') : `Session ${item.sectionIndex + 1}`
                                    }}
                                          <span class="opacity-50 ml-1 font-mono">
                                            ({{ trackListData.schedules[item.sectionIndex]?.startTime }})
                                          </span>
                                    </span>
                            </div>

                            <div class="h-px bg-black/10 dark:bg-white/10 flex-1 group-hover/divider:bg-[#007aff]/50 transition-colors"></div>
                        </div>

                        <div class="track-card p-2.5 rounded-lg border border-transparent hover:border-white/10 transition-colors relative flex flex-col gap-2 mb-2 group"
                             :class="[
                                       item.sectionIndex === trackListData.currentSectionIndex
                                           ? 'bg-black/5 dark:bg-white/10'
                                           : 'bg-black/[0.02] dark:bg-white/[0.02] opacity-60 hover:opacity-100'
                                   ]">

                            <button @click.stop="deleteTrackFromList(item)"
                                    class="absolute top-1 right-1 w-6 h-6 flex items-center justify-center rounded-md text-gray-400/50 hover:text-white hover:bg-red-500 transition-all z-20 cursor-pointer sm:opacity-0 sm:group-hover:opacity-100">
                                <i class="fa-solid fa-trash-can text-[10px]"></i>
                            </button>

                            <button v-if="item.musicDuration && item.musicDuration !== '00:00'"
                                    @click.stop="openSplitSlider(item)"
                                    title="æ‹†åˆ†ä»»åŠ¡ï¼šå½•äº†ä¸€åŠï¼Œå‰©ä¸‹çš„ä¸‹æ¬¡å½•"
                                    class="absolute top-1 right-8 w-6 h-6 flex items-center justify-center rounded-md text-gray-400/50 hover:text-orange-500 hover:bg-orange-500/10 transition-all z-20 cursor-pointer sm:opacity-0 sm:group-hover:opacity-100">
                                <i class="fa-solid fa-scissors text-[10px]"></i>
                            </button>

                            <div class="flex items-center gap-3 overflow-hidden flex-1">
                                <div class="w-2.5 h-2.5 rounded-full shadow-sm shrink-0 mt-0.5"
                                     :style="{backgroundColor: trackListData.viewType === 'project' ? getGroupColor(item, 'instrumentId', true) : getGroupColor(item, 'projectId', true)}">
                                </div>

                                <div class="flex flex-col min-w-0">
                                       <span class="text-xs font-bold leading-tight flex items-center gap-1.5 min-w-0">

                                            <span class="truncate">
                                                {{
                                                    sidebarTab === 'musician' ? getNameById(item.projectId, 'project') :
                                                            sidebarTab === 'project' ? getNameById(item.musicianId, 'musician') :
                                                                    getNameById(item.musicianId, 'musician')
                                                }}
                                            </span>

                                            <span v-if="item.splitTag"
                                                  class="text-[9px] px-1 py-0.5 rounded font-mono font-bold uppercase tracking-wider shrink-0 bg-red-500/10 text-red-500">
                                                {{ item.splitTag }}
                                            </span>

                                        </span>

                                    <span class="text-[10px] opacity-50 truncate mt-0.5">
                                            <template v-if="trackListData.viewType === 'project'">
                                                {{ getNameById(item.musicianId, 'musician') }}
                                            </template>
                                            <template v-else-if="trackListData.viewType === 'instrument'">
                                                {{ getNameById(item.musicianId, 'musician') }}
                                            </template>
                                            <template v-else>
                                                {{ getNameById(item.instrumentId, 'instrument') }}
                                            </template>
                                        </span>
                                </div>
                            </div>

                            <div class="flex items-center gap-2 bg-white/50 dark:bg-black/20 rounded-md p-1.5 border border-black/5 dark:border-white/5">

                                <div class="flex items-center gap-1 flex-1">
                                    <input type="time"
                                           v-model="item.records[trackListData.viewType].recStart"
                                           @change="calcTrackDiff(item)"
                                           class="glass-input flex-1 h-7 text-xs text-center font-mono bg-white/60 dark:bg-black/30 focus:bg-white dark:focus:bg-black/50 rounded-md transition-colors p-0 cursor-text">

                                    <button @click="setTrackNow(item, 'start')" title="è®¾ä¸ºå½“å‰æ—¶é—´"
                                            class="h-7 w-7 rounded-md bg-black/5 dark:bg-white/10 border border-black/5 dark:border-white/5 hover:bg-[#007aff] hover:border-[#007aff] hover:text-white flex items-center justify-center transition shrink-0 group/btn">
                                        <i class="fa-solid fa-clock text-[10px] opacity-60 group-hover/btn:opacity-100"></i>
                                    </button>
                                </div>

                                <button @click="setTrackBreak(item)"
                                        class="h-6 min-w-[20px] px-1 flex items-center justify-center rounded cursor-pointer transition hover:bg-black/5 dark:hover:bg-white/10 group/break"
                                        :title="item.records[trackListData.viewType].breakMinutes > 0 ? `å·²æ‰£é™¤ ${item.records[trackListData.viewType].breakMinutes} åˆ†é’Ÿä¼‘æ¯` : 'è®¾ç½®ä¼‘æ¯æ—¶é—´'">

                                    <div v-if="item.records[trackListData.viewType].breakMinutes > 0"
                                         class="flex items-center gap-0.5 text-[9px] font-bold text-orange-500">
                                        <span>-{{ item.records[trackListData.viewType].breakMinutes }}m</span>
                                    </div>

                                    <span v-else
                                          class="text-[10px] opacity-20 font-bold group-hover/break:opacity-100 group-hover/break:text-[#007aff] transition-all">-</span>
                                </button>

                                <div class="flex items-center gap-1 flex-1">
                                    <input type="time"
                                           v-model="item.records[trackListData.viewType].recEnd"
                                           @change="calcTrackDiff(item)"
                                           class="glass-input flex-1 h-7 text-xs text-center font-mono bg-white/60 dark:bg-black/30 focus:bg-white dark:focus:bg-black/50 rounded-md transition-colors p-0 cursor-text">

                                    <button @click="setTrackNow(item, 'end')" title="è®¾ä¸ºå½“å‰æ—¶é—´"
                                            class="h-7 w-7 rounded-md bg-black/5 dark:bg-white/10 border border-black/5 dark:border-white/5 hover:bg-[#007aff] hover:border-[#007aff] hover:text-white flex items-center justify-center transition shrink-0 group/btn">
                                        <i class="fa-solid fa-clock text-[10px] opacity-60 group-hover/btn:opacity-100"></i>
                                    </button>
                                </div>

                                <button @click="clearTrackTime(item)"
                                        :disabled="!item.records[trackListData.viewType].recStart && !item.records[trackListData.viewType].recEnd"
                                        title="æ¸…é™¤æ—¶é—´è®°å½•"
                                        class="w-7 h-7 ml-1 flex items-center justify-center rounded-md transition shrink-0"
                                        :class="(!item.records[trackListData.viewType].recStart && !item.records[trackListData.viewType].recEnd) ? 'opacity-20 cursor-default text-gray-400' : 'text-gray-400 hover:text-red-500 hover:bg-red-500/10 cursor-pointer'">
                                    <i class="fa-solid fa-eraser text-xs"></i>
                                </button>

                                <div class="w-px h-5 bg-black/10 dark:bg-white/10 mx-1"></div>

                                <div class="flex flex-col items-end min-w-[50px] leading-none gap-1">
                                        <span class="font-mono text-xs font-bold"
                                              :class="item.records[trackListData.viewType].actualDuration ? 'text-indigo-500' : 'opacity-30'">
                                            {{ item.records[trackListData.viewType].actualDuration || '--:--' }}
                                        </span>

                                    <div class="flex items-center gap-1" title="æ•ˆç‡æ¯”å€¼">
                                        <span class="text-[8px] opacity-40 uppercase">EFF</span>
                                        <span class="font-mono text-[10px] font-bold"
                                              :class="calculateSingleRatio(item) > item.ratio ? 'text-red-500' : 'text-green-500'">
                                                x{{ calculateSingleRatio(item) }}
                                            </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>

                    <template v-if="trackListData.items.length > 0">
                        <div v-for="secIndex in (trackListData.totalSections - 1)"
                             :key="'end-div-'+secIndex"
                             :id="'sec-divider-' + secIndex"
                             v-show="secIndex > trackListData.items[trackListData.items.length-1].sectionIndex"
                             class="py-3 flex items-center gap-3 select-none group/divider transition-opacity duration-0"
                             :class="{ 'opacity-0': draggingSectionIndex === secIndex }">

                            <div class="h-px bg-black/10 dark:bg-white/10 flex-1 group-hover/divider:bg-[#007aff]/50 transition-colors"></div>

                            <div class="px-3 py-1.5 rounded-full bg-black/5 dark:bg-white/10 border border-black/5 dark:border-white/5 flex items-center gap-2 text-[10px] font-bold opacity-60 group-hover/divider:opacity-100 group-hover/divider:text-[#007aff] group-hover/divider:bg-[#007aff]/10 transition-all shadow-sm cursor-ns-resize touch-none"
                                 @mousedown="startDividerDrag($event, secIndex)"
                                 @touchstart.prevent.stop="startDividerDrag($event, secIndex)">
                                <i class="fa-solid fa-grip-lines-vertical mr-1 opacity-50"></i>
                                <i class="fa-regular fa-calendar"></i>
                                <span>
                                          {{ trackListData.schedules[secIndex] ? trackListData.schedules[secIndex].date.split('-').slice(1).join('/') : `Session ${secIndex + 1}`
                                    }}
                                          <span class="opacity-50 ml-1 font-mono">
                                            ({{ trackListData.schedules[secIndex]?.startTime }})
                                          </span>
                                    </span>
                            </div>

                            <div class="h-px bg-black/10 dark:bg-white/10 flex-1 group-hover/divider:bg-[#007aff]/50 transition-colors"></div>
                        </div>
                    </template>

                </TransitionGroup>
            </div>

            <div class="p-4 border-t border-glass-border dark:border-glass-borderDark bg-gray-50/50 dark:bg-white/5 shrink-0 flex justify-between items-center">

                <div class="flex items-center gap-2" v-if="trackListData.taskRef">
                    <div class="w-6 h-6 rounded-md bg-black/5 dark:bg-white/10 flex items-center justify-center shrink-0">
                        <i class="fa-regular fa-bell text-xs opacity-60"></i>
                    </div>

                    <select
                            v-model.number="trackListData.taskRef.reminderMinutes"
                            @change="onTrackListReminderChange(trackListData.taskRef)"
                            class="glass-input h-8 text-xs font-bold py-0 pr-8 cursor-pointer bg-transparent focus:bg-white/50 w-32"
                    >
                        <option :value="0">æ— æé†’</option>
                        <option :value="5">æå‰ 5 åˆ†é’Ÿ</option>
                        <option :value="10">æå‰ 10 åˆ†é’Ÿ</option>
                        <option :value="15">æå‰ 15 åˆ†é’Ÿ</option>
                        <option :value="30">æå‰ 30 åˆ†é’Ÿ</option>
                        <option :value="60">æå‰ 1 å°æ—¶</option>
                    </select>
                </div>

                <button @click="deleteCurrentSchedule"
                        class="px-4 py-2 rounded-lg bg-red-500/10 hover:bg-red-500 text-red-600 hover:text-white border border-red-500/20 transition text-xs font-bold flex items-center gap-2 shadow-sm">
                    <i class="fa-solid fa-trash-can"></i> DELETE
                </button>
            </div>
        </div>
    </div>

    <div v-if="showCropModal" class="modal-overlay z-[1000]" @click.self="cancelCrop">
        <div class="modal-window w-[500px] max-w-[90vw] p-6 animate-[fadeIn_0.2s] flex flex-col">
            <h3 class="font-bold text-xl mb-4">è°ƒæ•´å¤´åƒ</h3>

            <div class="w-full h-[300px] bg-black/5 dark:bg-black/50 rounded-lg mb-6 relative z-10">
                <img ref="cropImgRef" :src="cropImgSrc" class="max-w-full block" style="max-height: 100%;">
            </div>

            <div class="flex justify-end gap-3">
                <button @click="cancelCrop"
                        class="px-4 py-2 rounded-lg text-sm font-bold text-gray-500 hover:bg-gray-100 dark:hover:bg-white/10 transition">
                    å–æ¶ˆ
                </button>
                <button @click="confirmCrop" :disabled="authLoading"
                        class="px-6 py-2 rounded-lg text-sm font-bold bg-[#007aff] text-white hover:bg-[#0062cc] transition shadow-lg shadow-blue-500/30 flex items-center gap-2">
                    <i v-if="authLoading" class="fa-solid fa-circle-notch fa-spin"></i>
                    {{ authLoading ? 'ä¸Šä¼ ä¸­...' : 'ç¡®è®¤å¹¶ä¸Šä¼ ' }}
                </button>
            </div>
        </div>
    </div>
    <div v-if="showQuickAddModal" class="modal-overlay z-[2000]" @click.self="showQuickAddModal=false">
        <div class="modal-window w-[350px] p-6 animate-[fadeIn_0.2s] flex flex-col gap-4">
            <h3 class="font-bold text-lg capitalize">Add New {{ quickAddType }}</h3>

            <div class="space-y-3">
                <div>
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1">Name</label>
                    <input id="quick-add-name" v-model="quickAddForm.name"
                           class="glass-input w-full text-base"
                           placeholder="Enter name..."
                           @keydown.enter="!$event.isComposing && confirmQuickAdd()">
                </div>

                <div class="quick-add-group-wrapper relative transition-all"
                     :class="showGroupSuggestions ? 'z-50' : 'z-20'">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1">Group (Optional)</label>

                    <div class="relative">
                        <input v-model="quickAddForm.group"
                               @focus="showGroupSuggestions = true"
                               class="glass-input w-full pr-8"
                               placeholder="è¾“å…¥æ–°åˆ†ç»„æˆ–é€‰æ‹©..."
                               @keydown.enter="!$event.isComposing && confirmQuickAdd()">

                        <i class="fa-solid fa-chevron-down absolute right-3 top-3.5 text-xs transition-transform duration-200 cursor-pointer opacity-50 hover:opacity-100"
                           :class="{'rotate-180': showGroupSuggestions}"
                           @mousedown.prevent="showGroupSuggestions = !showGroupSuggestions"></i>

                        <div v-if="showGroupSuggestions"
                             class="custom-dropdown-menu absolute top-full left-0 w-full mt-1 max-h-40 overflow-y-auto p-1 origin-top animate-[fadeIn_0.1s] z-[100]">

                            <div v-for="g in currentQuickAddGroups" :key="g"
                                 @mousedown.prevent="quickAddForm.group = g; showGroupSuggestions = false"
                                 class="px-3 py-2 rounded-lg hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer text-sm font-medium transition-colors text-gray-800 dark:text-gray-200">
                                {{ g }}
                            </div>

                            <div v-if="currentQuickAddGroups.length === 0"
                                 class="px-3 py-2 opacity-40 text-xs text-center text-gray-800 dark:text-gray-200">
                                æš‚æ— åˆ†ç»„ï¼Œç›´æ¥è¾“å…¥åˆ›å»º
                            </div>
                        </div>
                    </div>
                </div>

                <div v-if="quickAddType === 'musician'">
                    <label class="text-[10px] font-bold opacity-50 uppercase block mb-1">Default Ratio</label>
                    <div class="flex items-center gap-2">
                        <input type="number" v-model="quickAddForm.defaultRatio"
                               class="glass-input w-24 text-center font-mono"
                               @keydown.enter="!$event.isComposing && confirmQuickAdd()">
                        <span class="text-xs opacity-50">x (Efficiency)</span>
                    </div>
                </div>
            </div>

            <div class="flex justify-end gap-2 mt-2">
                <button @click="showQuickAddModal=false"
                        class="px-4 py-2 rounded-lg text-sm font-bold opacity-60 hover:opacity-100 hover:bg-black/5 dark:hover:bg-white/10 transition">
                    Cancel
                </button>
                <button @click="confirmQuickAdd"
                        class="px-6 py-2 rounded-lg text-sm font-bold bg-[#007aff] text-white hover:bg-[#0062cc] transition shadow-lg shadow-blue-500/30">
                    Save
                </button>
            </div>
        </div>
    </div>
    <div v-if="showInputModal" class="modal-overlay z-[10000]" @click.self="closeInputModal">
        <div class="modal-window w-[350px] p-6 animate-[fadeIn_0.2s] flex flex-col gap-4">
            <h3 class="font-bold text-lg">{{ inputModalConfig.title }}</h3>

            <div>
                <input ref="universalInputRef"
                       v-model="inputModalConfig.value"
                       :placeholder="inputModalConfig.placeholder"
                       class="glass-input w-full text-base p-3"
                       @keydown.enter="!$event.isComposing && confirmInputModal()">
                <p v-if="inputModalConfig.hint" class="text-[10px] opacity-50 mt-1.5 ml-1">{{ inputModalConfig.hint
                    }}</p>
            </div>

            <div class="flex justify-end gap-2 mt-2">
                <button @click="closeInputModal"
                        class="px-4 py-2 rounded-lg text-sm font-bold opacity-60 hover:opacity-100 hover:bg-black/5 dark:hover:bg-white/10 transition">
                    å–æ¶ˆ
                </button>
                <button @click="confirmInputModal"
                        class="px-6 py-2 rounded-lg text-sm font-bold bg-[#007aff] text-white hover:bg-[#0062cc] transition shadow-lg shadow-blue-500/30">
                    ç¡®å®š
                </button>
            </div>
        </div>
    </div>
    <div v-if="showConfirmModal" class="modal-overlay z-[9999]"
         @click.self="!confirmModalConfig.isAlert && closeConfirmModal()">
        <div class="modal-window w-[350px] p-6 animate-[bubblePop_0.2s] flex flex-col gap-4 text-center">
            <div class="flex justify-center mb-1">
                <div v-if="confirmModalConfig.isDestructive"
                     class="w-12 h-12 rounded-full bg-red-500/10 flex items-center justify-center text-red-500 text-2xl">
                    <i class="fa-solid fa-triangle-exclamation"></i>
                </div>
                <div v-else-if="confirmModalConfig.isAlert"
                     class="w-12 h-12 rounded-full bg-blue-500/10 flex items-center justify-center text-blue-500 text-2xl">
                    <i class="fa-solid fa-circle-info"></i>
                </div>
                <div v-else
                     class="w-12 h-12 rounded-full bg-orange-500/10 flex items-center justify-center text-orange-500 text-2xl">
                    <i class="fa-solid fa-circle-question"></i>
                </div>
            </div>

            <h3 class="font-bold text-lg leading-tight">{{ confirmModalConfig.title }}</h3>

            <p class="text-sm opacity-60 whitespace-pre-wrap leading-relaxed">{{ confirmModalConfig.content }}</p>

            <div class="flex gap-3 mt-4 justify-center">
                <button v-if="!confirmModalConfig.isAlert"
                        @click="closeConfirmModal"
                        class="flex-1 py-2.5 rounded-xl font-bold bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition text-sm">
                    {{ confirmModalConfig.cancelText || 'å–æ¶ˆ' }}
                </button>

                <button @click="handleConfirmAction"
                        class="flex-1 py-2.5 rounded-xl font-bold text-white shadow-lg transition text-sm flex items-center justify-center gap-2"
                        :class="confirmModalConfig.isDestructive ? 'bg-red-500 hover:bg-red-600 shadow-red-500/30' : 'bg-[#007aff] hover:bg-[#0062cc] shadow-blue-500/30'">
                    {{ confirmModalConfig.confirmText || 'ç¡®å®š' }}
                </button>
            </div>
        </div>
    </div>
    <div v-if="showImportModal" class="modal-overlay z-[4000]" @click.self="showImportModal=false">
        <div class="modal-window w-[400px] p-8 animate-[bubblePop_0.2s] flex flex-col items-center text-center">

            <h3 class="text-xl font-bold mb-2">æ¢å¤æ•°æ®</h3>
            <p class="text-xs opacity-50 mb-6 max-w-[260px] leading-relaxed">
                è¯·é€‰æ‹©ä¹‹å‰å¯¼å‡ºçš„ .json å¤‡ä»½æ–‡ä»¶ã€‚<br>æ³¨æ„ï¼šè¿™å°†è¦†ç›–å½“å‰çš„æ—¥ç¨‹å®‰æ’ã€‚
            </p>

            <div @click="triggerFileSelect"
                 class="w-full h-32 rounded-2xl border-2 border-dashed border-black/10 dark:border-white/10 bg-black/5 dark:bg-white/5 hover:bg-black/10 dark:hover:bg-white/10 transition cursor-pointer flex flex-col items-center justify-center gap-2 group relative overflow-hidden">

                <i class="fa-solid fa-file-import text-6xl absolute opacity-[0.03] group-hover:scale-110 transition-transform duration-500"></i>

                <div class="w-12 h-12 rounded-full bg-blue-500/10 text-[#007aff] flex items-center justify-center text-xl mb-1 group-hover:scale-110 transition-transform">
                    <i class="fa-solid fa-cloud-arrow-up"></i>
                </div>
                <span class="text-sm font-bold opacity-70 group-hover:opacity-100 transition">ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</span>
                <span class="text-[10px] font-mono opacity-40 uppercase">Support: .JSON</span>
            </div>

            <div class="flex gap-3 w-full mt-6">
                <button @click="showImportModal=false"
                        class="flex-1 py-3 rounded-xl font-bold bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition text-sm">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    </div>
    <div v-if="showColorPickerModal" class="modal-overlay z-[6000]" @click.self="showColorPickerModal=false">
        <div class="modal-window w-[340px] p-6 animate-[bubblePop_0.2s] flex flex-col gap-5">

            <div class="text-center">
                <h3 class="font-bold text-lg mb-1">é€‰æ‹©é¢œè‰²</h3>
                <p class="text-[10px] opacity-40 uppercase tracking-widest">Color Picker</p>
            </div>

            <div class="flex items-center gap-3 bg-black/5 dark:bg-white/5 p-2 rounded-xl border border-black/5 dark:border-white/5">
                <div class="w-10 h-10 rounded-full shadow-sm shrink-0 border border-black/10 dark:border-white/10 transition-colors duration-300"
                     :style="{backgroundColor: tempColor}"></div>

                <div class="flex-1 relative">
                    <span class="absolute left-3 top-2.5 text-xs font-bold opacity-30">#</span>
                    <input v-model="tempColor"
                           class="glass-input w-full pl-6 font-mono uppercase text-sm"
                           maxlength="7">
                </div>
            </div>

            <div class="grid grid-cols-5 gap-3 justify-items-center">
                <button v-for="color in presetColors" :key="color"
                        @click="tempColor = color"
                        class="w-9 h-9 rounded-full shadow-sm border border-black/5 dark:border-white/10 hover:scale-110 active:scale-95 transition-all flex items-center justify-center relative group"
                        :style="{backgroundColor: color}">

                    <i v-if="tempColor.toLowerCase() === color.toLowerCase()"
                       class="fa-solid fa-check text-white text-xs drop-shadow-md"></i>
                </button>
            </div>

            <div class="flex items-center gap-3 mt-2">
                <button @click="resetColorPicker"
                        class="w-10 h-10 rounded-xl bg-gray-100 dark:bg-white/10 text-gray-500 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-500/20 transition flex items-center justify-center shrink-0"
                        title="é‡ç½®ä¸ºé»˜è®¤é¢œè‰²">
                    <i class="fa-solid fa-rotate-left"></i>
                </button>

                <button @click="saveColorPicker"
                        class="flex-1 h-10 rounded-xl bg-[#007aff] hover:bg-[#0062cc] text-white font-bold text-sm shadow-lg shadow-blue-500/30 transition">
                    Done
                </button>
            </div>

        </div>
    </div>
    <div v-if="showDurationPicker" class="bubble-picker-overlay" @click.self="closePicker">

        <div class="bubble-picker-box" :style="{ top: pickerPos.top + 'px', left: pickerPos.left + 'px' }">

            <div class="bubble-columns">
                <div class="bubble-highlight"></div>

                <div class="bubble-col" ref="pickerMinRef" @scroll="onScroll($event, 'm')"
                     @mousedown.prevent="onDragStart($event, 'm')">
                    <div v-for="m in 60" :key="'m'+(m-1)"
                         class="bubble-item"
                         :class="{'active-item': tempDuration.m === m-1}">
                        {{ (m - 1).toString().padStart(2, '0') }}
                    </div>
                </div>

                <div class="bubble-col" ref="pickerSecRef" @scroll="onScroll($event, 's')"
                     @mousedown.prevent="onDragStart($event, 's')">
                    <div v-for="s in 60" :key="'s'+(s-1)"
                         class="bubble-item"
                         :class="{'active-item': tempDuration.s === s-1}">
                        {{ (s - 1).toString().padStart(2, '0') }}
                    </div>
                </div>
            </div>

            <div class="bubble-footer">
                <button @click="resetDuration" class="btn-reset">Reset</button>
                <button @click="confirmDurationPicker" class="btn-confirm">
                    <i class="fa-solid fa-check"></i>
                </button>
            </div>
        </div>
    </div>

    <div v-if="showSplitModal" class="modal-overlay z-[11000]" @click.self="showSplitModal=false">
        <div class="modal-window w-[90vw] sm:w-[400px] p-6 animate-[bubblePop_0.2s] flex flex-col items-center">

            <h3 class="font-bold text-xl mb-1 mt-2">æ‹†åˆ†ä»»åŠ¡</h3>
            <p class="text-xs opacity-50 mb-8">æ‹–åŠ¨æ»‘å—è®¾å®šåˆ†å‰²ç‚¹</p>

            <div class="flex justify-between items-end w-full mb-6 px-4">
                <div class="flex flex-col items-center">
                    <span class="text-[10px] font-bold uppercase tracking-wider text-red-500 opacity-80 mb-1">æœ¬æ¬¡å®Œæˆ</span>
                    <span class="text-3xl font-mono font-bold text-red-500">{{ splitState.part1Str }}</span>
                    <span class="text-[9px] px-1.5 py-0.5 rounded bg-red-500/10 text-red-500 font-bold mt-1">PART 1</span>
                </div>

                <i class="fa-solid fa-arrow-right text-gray-300 dark:text-gray-600 mb-4"></i>

                <div class="flex flex-col items-center">
                    <span class="text-[10px] font-bold uppercase tracking-wider opacity-40 mb-1">ç•™ç»™ä¸‹æ¬¡</span>
                    <span class="text-3xl font-mono font-bold opacity-60">{{ splitState.part2Str }}</span>
                    <span class="text-[9px] px-1.5 py-0.5 rounded bg-black/5 dark:bg-white/10 opacity-50 font-bold mt-1">PART 2</span>
                </div>
            </div>

            <div class="w-full px-2 mb-8 relative flex items-center justify-center">
                <input type="range"
                       min="0"
                       :max="splitState.totalSec"
                       v-model.number="splitState.splitPoint"
                       @input="onSplitSliderInput"
                       class="custom-slider"
                       :style="{backgroundSize: (splitState.splitPoint / splitState.totalSec * 100) + '% 100%'}"
                >
                <div class="absolute left-2 top-[50%] -translate-y-[50%] h-[12px] bg-red-500 rounded-l-full pointer-events-none z-0"
                     :style="{width: `calc(${(splitState.splitPoint / splitState.totalSec * 100)}% - 10px)`}"></div>
            </div>

            <div class="flex gap-3 w-full">
                <button @click="showSplitModal=false"
                        class="flex-1 py-3 rounded-xl font-bold bg-black/5 dark:bg-white/10 hover:bg-black/10 transition text-sm">
                    å–æ¶ˆ
                </button>
                <button @click="confirmSplitSlider"
                        class="flex-1 py-3 rounded-xl font-bold text-white bg-red-500 hover:bg-red-600 shadow-lg shadow-red-500/30 transition text-sm">
                    ç¡®è®¤æ‹†åˆ†
                </button>
            </div>

        </div>
    </div>

    <div v-if="showMobileTaskInput" class="modal-overlay z-[1000]" @click.self="showMobileTaskInput=false">
        <div class="modal-window w-[90vw] sm:w-[450px] p-5 animate-[bubblePop_0.3s] relative bg-white/95 dark:bg-[#1c1c1e]/95 backdrop-blur-2xl border border-white/20 shadow-2xl rounded-3xl">
            <h3 class="text-lg font-bold mb-5 text-center opacity-60 uppercase tracking-widest">æ·»åŠ æ–°ä»»åŠ¡</h3>

            <div class="space-y-3 relative">

                <div class="mobile-input-group transition-all duration-200"
                     :class="activeDropdown === 'project' ? 'z-[100] relative' : 'z-20 relative'">
                    <button @click.stop="toggleDropdown('project')"
                            class="w-full h-[64px] flex items-center justify-between px-4 bg-transparent active:bg-black/5 rounded-xl transition">
                        <div class="flex flex-col items-start min-w-0"><span
                                class="text-[10px] opacity-40 font-bold uppercase tracking-wider mb-0.5">Project</span>
                            <div class="flex items-center gap-2 w-full">
                                <div class="w-1.5 h-4 rounded-full shrink-0"
                                     :style="{backgroundColor: newItem.projectId ? getGroupColor({projectId: newItem.projectId}, 'projectId', true) : '#3b82f6'}"></div>
                                <span class="font-bold text-lg truncate leading-tight">{{ getNameById(newItem.projectId, 'project') === 'æœªçŸ¥é¡¹ç›®' ? 'é€‰æ‹©é¡¹ç›®' : getNameById(newItem.projectId, 'project')
                                    }}</span></div>
                        </div>
                        <i class="fa-solid fa-chevron-down opacity-30 text-xs transition-transform duration-300"
                           :class="{'rotate-180': activeDropdown === 'project'}"></i>
                    </button>
                    <div v-if="activeDropdown === 'project'" class="custom-dropdown-menu">
                        <div class="sticky top-0 bg-white/10 dark:bg-black/10 backdrop-blur-sm p-2 border-b border-black/5 dark:border-white/5 z-20">
                            <input v-model="dropdownSearch" placeholder="æœç´¢é¡¹ç›®..."
                                   class="w-full bg-transparent text-base px-2 py-1 outline-none placeholder:text-black/30 dark:placeholder:text-white/30"
                                   @click.stop></div>

                        <div class="max-h-[35vh] overflow-y-auto">
                            <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">

                                <div class="sticky top-0 z-10 w-full px-4 py-2 text-[10px] font-bold uppercase tracking-wider text-gray-500 dark:text-gray-400 bg-gray-50/95 dark:bg-[#2c2c2e]/95 backdrop-blur-md border-y border-black/5 dark:border-white/10 shadow-sm flex justify-between items-center cursor-pointer select-none"
                                     @click.stop="toggleDropdownGroup(group.name)">
                                    <span>{{ group.name }}</span>

                                    <i class="fa-solid fa-chevron-right text-[10px] opacity-50 transition-transform duration-200"
                                       :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                </div>

                                <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">

                                    <div v-if="activeDropdown !== 'musician'" v-for="item in group.items" :key="item.id"
                                         @click="selectOption(activeDropdown === 'project' ? 'project' : 'instrument', item)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex items-center gap-3">

                                        <div class="w-3 h-3 rounded-full shrink-0"
                                             :style="{backgroundColor: item.color ? item.color : (activeDropdown === 'project' ? '#eab308' : '#3b82f6')}">
                                        </div>

                                        {{ item.name }}
                                    </div>

                                    <div v-if="activeDropdown === 'musician'" v-for="m in group.items" :key="m.id"
                                         @click="selectOption('musician', m)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex justify-between items-center">

                                        <div class="flex items-center gap-3">
                                            <div class="w-3 h-3 rounded-full shrink-0"
                                                 :style="{backgroundColor: m.color || '#a855f7'}">
                                            </div>
                                            <span>{{ m.name }}</span>
                                        </div>

                                        <span class="text-xs opacity-50 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded font-mono">x{{m.defaultRatio}}</span>
                                    </div>

                                </div>
                            </div>
                            <div v-if="filteredOptions.length===0" class="p-8 text-center opacity-40 text-sm">æ— ç»“æœ
                            </div>
                        </div>
                        <button @click.stop="openQuickAdd('project')"
                                class="w-full py-3 text-sm font-bold text-[#007aff] bg-black/5 dark:bg-white/5 hover:bg-[#007aff] hover:text-white transition flex items-center justify-center gap-2 border-t border-black/5 dark:border-white/5 sticky bottom-0 backdrop-blur-md">
                            <i class="fa-solid fa-plus"></i> æ–°å»ºé¡¹ç›®
                        </button>
                    </div>
                </div>

                <div class="mobile-input-group transition-all duration-200"
                     :class="activeDropdown === 'instrument' ? 'z-[90] relative' : 'z-10 relative'">
                    <button @click.stop="toggleDropdown('instrument')"
                            class="w-full h-[64px] flex items-center justify-between px-4 bg-transparent active:bg-black/5 rounded-xl transition">
                        <div class="flex flex-col items-start min-w-0"><span
                                class="text-[10px] opacity-40 font-bold uppercase tracking-wider mb-0.5">Instrument</span>
                            <div class="flex items-center gap-2 w-full">
                                <div class="w-1.5 h-4 rounded-full shrink-0"
                                     :style="{backgroundColor: newItem.instrumentId ? getGroupColor({instrumentId: newItem.instrumentId}, 'instrumentId', true) : '#3b82f6'}"></div>
                                <span class="font-bold text-lg truncate leading-tight">{{ getNameById(newItem.instrumentId, 'instrument') === 'æœªçŸ¥ä¹å™¨' ? 'é€‰æ‹©ä¹å™¨' : getNameById(newItem.instrumentId, 'instrument')
                                    }}</span></div>
                        </div>
                        <i class="fa-solid fa-chevron-down opacity-30 text-xs transition-transform duration-300"
                           :class="{'rotate-180': activeDropdown === 'instrument'}"></i>
                    </button>
                    <div v-if="activeDropdown === 'instrument'" class="custom-dropdown-menu">
                        <div class="sticky top-0 bg-white/10 dark:bg-black/10 backdrop-blur-sm p-2 border-b border-black/5 dark:border-white/5 z-20">
                            <input v-model="dropdownSearch" placeholder="æœç´¢ä¹å™¨..."
                                   class="w-full bg-transparent text-base px-2 py-1 outline-none placeholder:text-black/30 dark:placeholder:text-white/30"
                                   @click.stop></div>

                        <div class="max-h-[35vh] overflow-y-auto">
                            <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">

                                <div class="sticky top-0 z-10 w-full px-4 py-2 text-[10px] font-bold uppercase tracking-wider text-gray-500 dark:text-gray-400 bg-gray-50/95 dark:bg-[#2c2c2e]/95 backdrop-blur-md border-y border-black/5 dark:border-white/10 shadow-sm flex justify-between items-center cursor-pointer select-none"
                                     @click.stop="toggleDropdownGroup(group.name)">
                                    <span>{{ group.name }}</span>

                                    <i class="fa-solid fa-chevron-right text-[10px] opacity-50 transition-transform duration-200"
                                       :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                </div>

                                <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">

                                    <div v-if="activeDropdown !== 'musician'" v-for="item in group.items" :key="item.id"
                                         @click="selectOption(activeDropdown === 'project' ? 'project' : 'instrument', item)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex items-center gap-3">

                                        <div class="w-3 h-3 rounded-full shrink-0"
                                             :style="{backgroundColor: item.color ? item.color : (activeDropdown === 'project' ? '#eab308' : '#3b82f6')}">
                                        </div>

                                        {{ item.name }}
                                    </div>

                                    <div v-if="activeDropdown === 'musician'" v-for="m in group.items" :key="m.id"
                                         @click="selectOption('musician', m)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex justify-between items-center">

                                        <div class="flex items-center gap-3">
                                            <div class="w-3 h-3 rounded-full shrink-0"
                                                 :style="{backgroundColor: m.color || '#a855f7'}">
                                            </div>
                                            <span>{{ m.name }}</span>
                                        </div>

                                        <span class="text-xs opacity-50 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded font-mono">x{{m.defaultRatio}}</span>
                                    </div>

                                </div>
                            </div>
                            <div v-if="filteredOptions.length===0" class="p-8 text-center opacity-40 text-sm">æ— ç»“æœ
                            </div>
                        </div>
                        <button @click.stop="openQuickAdd('instrument')"
                                class="w-full py-3 text-sm font-bold text-[#007aff] bg-black/5 dark:bg-white/5 hover:bg-[#007aff] hover:text-white transition flex items-center justify-center gap-2 border-t border-black/5 dark:border-white/5 sticky bottom-0 backdrop-blur-md">
                            <i class="fa-solid fa-plus"></i> æ–°å»ºä¹å™¨
                        </button>
                    </div>
                </div>

                <div class="mobile-input-group transition-all duration-200"
                     :class="activeDropdown === 'musician' ? 'z-[80] relative' : 'z-10 relative'">
                    <button @click.stop="toggleDropdown('musician')"
                            class="w-full h-[64px] flex items-center justify-between px-4 bg-transparent active:bg-black/5 rounded-xl transition">
                        <div class="flex flex-col items-start min-w-0"><span
                                class="text-[10px] opacity-40 font-bold uppercase tracking-wider mb-0.5">Musician</span>
                            <div class="flex items-center gap-2 w-full">
                                <div class="w-1.5 h-4 rounded-full shrink-0"
                                     :style="{backgroundColor: newItem.musicianId ? getGroupColor({musicianId: newItem.musicianId}, 'musicianId', true) : '#3b82f6'}"></div>
                                <span class="font-bold text-lg truncate leading-tight">{{ getNameById(newItem.musicianId, 'musician') === 'æœªçŸ¥æ¼”å¥å‘˜' ? 'é€‰æ‹©äººå‘˜' : getNameById(newItem.musicianId, 'musician')
                                    }}</span></div>
                        </div>
                        <i class="fa-solid fa-chevron-down opacity-30 text-xs transition-transform duration-300"
                           :class="{'rotate-180': activeDropdown === 'musician'}"></i>
                    </button>
                    <div v-if="activeDropdown === 'musician'" class="custom-dropdown-menu">
                        <div class="sticky top-0 bg-white/10 dark:bg-black/10 backdrop-blur-sm p-2 border-b border-black/5 dark:border-white/5 z-20">
                            <input v-model="dropdownSearch" placeholder="æœç´¢äººå‘˜..."
                                   class="w-full bg-transparent text-base px-2 py-1 outline-none placeholder:text-black/30 dark:placeholder:text-white/30"
                                   @click.stop></div>

                        <div class="max-h-[35vh] overflow-y-auto">
                            <div v-for="group in getGroupedOptions(filteredOptions)" :key="group.name">

                                <div class="sticky top-0 z-10 w-full px-4 py-2 text-[10px] font-bold uppercase tracking-wider text-gray-500 dark:text-gray-400 bg-gray-50/95 dark:bg-[#2c2c2e]/95 backdrop-blur-md border-y border-black/5 dark:border-white/10 shadow-sm flex justify-between items-center cursor-pointer select-none"
                                     @click.stop="toggleDropdownGroup(group.name)">
                                    <span>{{ group.name }}</span>

                                    <i class="fa-solid fa-chevron-right text-[10px] opacity-50 transition-transform duration-200"
                                       :class="{'rotate-90': dropdownExpandedGroups.has(group.name) || dropdownSearch}"></i>
                                </div>

                                <div v-show="dropdownExpandedGroups.has(group.name) || dropdownSearch">

                                    <div v-if="activeDropdown !== 'musician'" v-for="item in group.items" :key="item.id"
                                         @click="selectOption(activeDropdown === 'project' ? 'project' : 'instrument', item)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex items-center gap-3">

                                        <div class="w-3 h-3 rounded-full shrink-0"
                                             :style="{backgroundColor: item.color ? item.color : (activeDropdown === 'project' ? '#eab308' : '#3b82f6')}">
                                        </div>

                                        {{ item.name }}
                                    </div>

                                    <div v-if="activeDropdown === 'musician'" v-for="m in group.items" :key="m.id"
                                         @click="selectOption('musician', m)"
                                         class="px-4 py-3 text-base border-b border-black/5 dark:border-white/5 active:bg-black/5 flex justify-between items-center">

                                        <div class="flex items-center gap-3">
                                            <div class="w-3 h-3 rounded-full shrink-0"
                                                 :style="{backgroundColor: m.color || '#a855f7'}">
                                            </div>
                                            <span>{{ m.name }}</span>
                                        </div>

                                        <span class="text-xs opacity-50 bg-black/5 dark:bg-white/10 px-1.5 py-0.5 rounded font-mono">x{{m.defaultRatio}}</span>
                                    </div>

                                </div>
                            </div>
                            <div v-if="filteredOptions.length===0" class="p-8 text-center opacity-40 text-sm">æ— ç»“æœ
                            </div>
                        </div>
                        <button @click.stop="openQuickAdd('musician')"
                                class="w-full py-3 text-sm font-bold text-[#007aff] bg-black/5 dark:bg-white/5 hover:bg-[#007aff] hover:text-white transition flex items-center justify-center gap-2 border-t border-black/5 dark:border-white/5 sticky bottom-0 backdrop-blur-md">
                            <i class="fa-solid fa-plus"></i> æ–°å»ºæ¼”å¥å‘˜
                        </button>
                    </div>
                </div>

                <div class="flex gap-3 items-stretch relative z-0">
                    <div class="mobile-input-group flex-1 mb-0 flex items-center justify-center relative bg-white/80 dark:bg-black/40 h-[64px]">
                        <input
                                :value="newItem.musicDuration"
                                @click="isMobile && openDurationPicker($event, newItem, 'musicDuration')"
                                :readonly="isMobile"
                                @input="newItem.musicDuration = $event.target.value"
                                placeholder="00:00"
                                class="w-full h-full bg-transparent text-center font-mono text-3xl font-bold outline-none text-[#8e8e93] tracking-widest placeholder:text-gray-300"
                                :class="isMobile ? 'cursor-pointer' : 'cursor-text'">
                    </div>
                    <button @click="addItemToPool()"
                            class="w-20 h-[64px] bg-[#007aff] hover:bg-[#0062cc] text-white rounded-2xl shadow-lg shadow-blue-500/30 flex items-center justify-center active:scale-95 transition">
                        <i class="fa-solid fa-plus text-3xl"></i>
                    </button>
                </div>
            </div>

            <button @click="showMobileTaskInput=false"
                    class="absolute top-3 right-3 w-8 h-8 flex items-center justify-center rounded-full bg-black/5 dark:bg-white/5 hover:bg-black/10 dark:hover:bg-white/10 transition z-[150]">
                <i class="fa-solid fa-xmark opacity-50"></i></button>
        </div>
    </div>

</div>


<script>
    const {createApp, ref, computed, onMounted, onUnmounted, watch, reactive} = Vue;

    const SUPABASE_URL = 'https://gdpsiinrxhpmxvgvgxeh.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdkcHNpaW5yeGhwbXh2Z3ZneGVoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5MDI2MDcsImV4cCI6MjA3OTQ3ODYwN30.7INv-SkxE97mylnsxICpd7YVG6SNFHyQTy8qVH1e3Mc';
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

    // --- V9.5/V9.7 é¢œè‰²å¤„ç†å‡½æ•° (V9.7: äº®åº¦é˜ˆå€¼ä» 180 é™åˆ° 150) ---
    const hexToRgb = hex => {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return [r, g, b];
    };

    // --- V11.5 äº¤äº’çŠ¶æ€ ---
    const flashingTaskId = ref(null); // æ§åˆ¶å“ªä¸ªä»»åŠ¡æ­£åœ¨é—ªçƒ
    const statClickIndexMap = reactive({}); // è®°å½•æ¯ä¸ªæ¼”å¥å‘˜ç‚¹å‡»å¾ªç¯åˆ°äº†ç¬¬å‡ ä¸ªä»»åŠ¡
    const getTextColor = hex => {
        if (!hex) return '#1f2937';
        const [r, g, b] = hexToRgb(hex);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness > 150 ? '#1f2937' : '#f9fafb';
    };
    const generateRandomHexColor = () => {
        return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
    };
    const adjustColor = (hex, percent) => { // percent: 0.1 for 10% brighter, -0.1 for 10% darker
        if (!hex) return '#f3f4f6';
        const [r, g, b] = hexToRgb(hex);
        const factor = 1 + percent;
        const newR = Math.min(255, Math.max(0, Math.floor(r * factor)));
        const newG = Math.min(255, Math.max(0, Math.floor(g * factor)));
        const newB = Math.min(255, Math.max(0, Math.floor(b * factor)));
        return '#' + [newR, newG, newB].map(x => x.toString(16).padStart(2, '0')).join('');
    };

    const generateUniqueId = () => {
        // ç”Ÿæˆä¸€ä¸ªåŸºäºæ—¶é—´å’Œéšæœºæ•°çš„å”¯ä¸€å­—ç¬¦ä¸² (UUID é£æ ¼)
        return 't' + Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
    };

    // --- ğŸŸ¢ å…¨å±€å®šä¹‰ï¼šè§¦æ‘¸éœ‡åŠ¨å‡½æ•° ---
    // å®ƒå°†è¢« Vue å†…éƒ¨å’Œå…¨å±€äº‹ä»¶ç›‘å¬å™¨è°ƒç”¨
    window.triggerTouchHaptic = async (style = 'Light') => {
        // ä½¿ç”¨å…¨å±€å¯¹è±¡è·å–æ’ä»¶ï¼Œç¡®ä¿åœ¨ä»»ä½•åœ°æ–¹éƒ½èƒ½è°ƒç”¨
        const Haptics = window.Capacitor?.Plugins?.Haptics;
        if (Haptics) {
            try {
                // ä½¿ç”¨ Impact æ¨¡å¼è¿›è¡Œ UI çº§åé¦ˆ
                await Haptics.impact({style: style.toUpperCase()});
            } catch (e) {
                console.warn("Haptics APIè°ƒç”¨å¤±è´¥:", e.message);
            }
        }
    };


    createApp({
        setup() {
            const itemPool = ref([]);
            const scheduledTasks = ref([]);
            const slotHeight = ref(window.innerWidth < 800 ? 30 : 40);
            const pxPerMin = computed(() => slotHeight.value / 30);
            const currentView = ref('week');
            const viewDate = ref(new Date());
            const selectedTaskId = ref(null);
            const selectedSource = ref(null);
            const selectedPoolIds = ref(new Set()); // å­˜å‚¨ä»»åŠ¡æ± å¤šé€‰çš„ ID
            // V10.2 æ–°å¢ï¼šå·¦ä¾§æ å®½åº¦è°ƒèŠ‚çŠ¶æ€ (è¯·æ·»åŠ åˆ°å…¶ä»– ref å˜é‡é™„è¿‘)
            const sidebarWidth = ref(350); // åˆå§‹å®½åº¦ (åƒç´ )
            const lastPoolClickId = ref(null);      // è®°å½•ä¸Šä¸€æ¬¡ç‚¹å‡»çš„ ID (ç”¨äº Shift èŒƒå›´é€‰æ‹©)
            const lastPoolFocusId = ref(null);      // æ–°å¢ï¼šè®°å½•é”®ç›˜/é¼ æ ‡æœ€åäº¤äº’çš„ ID (ä½œä¸ºé”®ç›˜å¯¼èˆªçš„èµ·ç‚¹)
            const showSettings = ref(false);
            const showEditor = ref(false);
            const showTrackList = ref(false);
            const trackListData = ref({name: '', items: []});
            const editingItem = ref({});
            const editingSource = ref('');
            const weekContainer = ref(null);
            const flashingTaskId = ref(null); // æ§åˆ¶å“ªä¸ªä»»åŠ¡æ­£åœ¨é—ªçƒ
            const statClickIndexMap = reactive({}); // è®°å½•æ¯ä¸ªæ¼”å¥å‘˜ç‚¹å‡»å¾ªç¯åˆ°äº†ç¬¬å‡ ä¸ªä»»åŠ¡
            const showProfileMenu = ref(false);
            const tempAvatarUrl = ref(''); // ç”¨äºè¾“å…¥æ¡†ä¸´æ—¶å­˜å‚¨
            const initialTouchY = ref(0);         // è®°å½•èµ·å§‹ Y åæ ‡ï¼Œç”¨äºåˆ¤æ–­é•¿æŒ‰åæ˜¯å¦ç§»åŠ¨
            // --- ğŸŸ¢ æ–°å¢: æ°”æ³¡é€‰æ‹©å™¨é€»è¾‘ ---
            const showDurationPicker = ref(false);
            const tempDuration = reactive({m: 0, s: 0});
            const pickerMinRef = ref(null);
            const pickerSecRef = ref(null);
            const pickerPos = reactive({top: 0, left: 0}); // ğŸŸ¢ æ–°å¢ï¼šå­˜å‚¨å¼¹çª—åæ ‡
            const showMobileTaskInput = ref(false);
            const trackListContainerRef = ref(null);
            const draggingSectionIndex = ref(null);
            // ğŸŸ¢ ä¿®æ”¹: åˆå§‹åŒ–æ—¶ä¼˜å…ˆè¯»å–æœ¬åœ°å­˜å‚¨ï¼Œå¦‚æœæ²¡æœ‰åˆ™é»˜è®¤ä¸º 100 (æ ‡å‡†)
            // å¦‚æœæ‚¨æƒ³å¼ºåˆ¶é»˜è®¤ä¸ºçª„è§†å›¾ï¼Œå¯ä»¥æŠŠæœ€åçš„ 100 æ”¹ä¸º 52
            const savedWidth = localStorage.getItem('musche_day_width');
            const dayColWidth = ref(savedWidth ? Number(savedWidth) : 52);
            const isResizingMobile = ref(false);
            const mobileResizeState = reactive({task: null, startY: 0, startHeight: 0});
            let dividerDragState = null;
            let trackListScrollTimer = null;
            let pickerCallback = null;
            let dragElClone = null;       // æ‹–æ‹½æ—¶çš„å…‹éš†ä½“
            let dragSourceTask = null;    // æºä»»åŠ¡æ•°æ®
            let dragStartDate = null;     // æºæ—¥æœŸ
            let longPressTimeout = null;  // é•¿æŒ‰å®šæ—¶å™¨
            const lastTapState = reactive({id: null, time: 0}); // ğŸŸ¢ æ–°å¢: è®°å½•åŒå‡»çŠ¶æ€
            let isDraggingMouse = false;
            let startMouseY = 0;
            let startScrollTop = 0;
            let activeColRef = null; // å½“å‰æ‹–åŠ¨çš„æ»šè½® DOM å¼•ç”¨
            let startX = 0, startY = 0;   // è§¦æ‘¸èµ·å§‹ä½ç½®
            let cloneOffsetX = 0, cloneOffsetY = 0; // æ‰‹æŒ‡åœ¨å…ƒç´ å†…çš„åç§»
            let activeDropSlot = null;    // å½“å‰æ‰‹æŒ‡ä¸‹çš„æ”¾ç½®ç›®æ ‡
            let dragSourceEl = null; // ç”¨äºè®°å½•è¢«æ‹–æ‹½çš„åŸå§‹ DOM å…ƒç´ 
            let touchOffsetMinutes = 0;
            let dragClickOffsetY = 0;
            let dragSourceType = 'schedule';
            let autoScrollInterval = null;
            let monthSwitchTimer = null;
            // åœ¨ setup() å¼€å¤´é™„è¿‘æ·»åŠ 
            let trackSaveTimer = null; // ç”¨äºå½•éŸ³æ—¶é—´ä¿å­˜çš„é˜²æŠ–è®¡æ—¶å™¨
            let isScrollingProgrammatically = false;
            let resizeRaf = null; // ç”¨äº requestAnimationFrame é˜²æŠ–

            // --- ğŸŸ¢ æ–°å¢: åˆ†å‰²æ»‘å—çŠ¶æ€ ---
            const showSplitModal = ref(false);
            const splitState = reactive({
                task: null,        // ç›®æ ‡ä»»åŠ¡
                totalSec: 0,       // æ€»æ—¶é•¿(ç§’)
                splitPoint: 0,     // åˆ†å‰²ç‚¹(ç§’)ï¼Œå³ Part 1 çš„æ—¶é•¿
                part1Str: '00:00', // æ˜¾ç¤ºç”¨
                part2Str: '00:00'  // æ˜¾ç¤ºç”¨
            });

            // 1. æ‰“å¼€æ»‘å—å¼¹çª— (æ›¿ä»£åŸæ¥çš„ splitTrack)
            const openSplitSlider = (item) => {
                const totalMusicStr = item.musicDuration;
                if (!totalMusicStr || totalMusicStr === '00:00') {
                    return openAlertModal('æ— æ³•æ‹†åˆ†', 'è¯¥æ›²ç›®æ²¡æœ‰è®¾ç½®è°±é¢æ—¶é•¿ã€‚');
                }

                splitState.task = item;
                splitState.totalSec = parseTime(totalMusicStr);

                // é»˜è®¤ä»ä¸€åŠå¼€å§‹ï¼Œæˆ–è€…ä» 0 å¼€å§‹
                splitState.splitPoint = Math.floor(splitState.totalSec / 2);

                updateSplitStrings();
                showSplitModal.value = true;
            };

            // 2. æ»‘å—æ‹–åŠ¨æ—¶æ›´æ–°æ–‡å­—
            const onSplitSliderInput = () => {
                updateSplitStrings();
                // æ‹–åŠ¨æ—¶ç»™ä¸€ç‚¹è½»å¾®éœ‡åŠ¨åé¦ˆ (èŠ‚æµ)
                window.triggerTouchHaptic('Light');
            };

            const updateSplitStrings = () => {
                const p1 = splitState.splitPoint;
                const p2 = splitState.totalSec - splitState.splitPoint;
                splitState.part1Str = formatSecs(p1);
                splitState.part2Str = formatSecs(p2);
            };

            // 3. ç¡®è®¤æ‹†åˆ† (æ ¸å¿ƒé€»è¾‘ç§»åˆ°è¿™é‡Œ)
            const confirmSplitSlider = () => {
                const item = splitState.task;
                const doneStr = splitState.part1Str;      // Part 1
                const remainingStr = splitState.part2Str; // Part 2 (å‰©ä½™)

                if (splitState.splitPoint <= 0 || splitState.splitPoint >= splitState.totalSec) {
                    return openAlertModal('æ— æ•ˆæ‹†åˆ†', 'è¯·æ‹–åŠ¨æ»‘å—é€‰æ‹©ä¸€ä¸ªä¸­é—´çš„æ—¶é—´ç‚¹ã€‚');
                }

                // --- A. æ›´æ–°å½“å‰ä»»åŠ¡ (Part 1) ---
                item.musicDuration = doneStr;
                item.splitTag = 'Part 1';

                // --- B. åˆ›å»ºæ–°ä»»åŠ¡ (Part 2) ---
                const newRatio = item.ratio || 20;
                const newEst = calculateEstTime(remainingStr, newRatio);

                const newTask = {
                    id: generateUniqueId('T'),
                    splitFromId: item.id,
                    splitTag: 'Part 2',

                    sessionId: item.sessionId || currentSessionId.value,
                    projectId: item.projectId,
                    instrumentId: item.instrumentId,
                    musicianId: item.musicianId,
                    musicDuration: remainingStr,
                    ratio: newRatio,
                    estDuration: newEst,
                    group: item.group || ''
                };

                ensureItemRecords(newTask);
                itemPool.value.push(newTask);

                // --- C. è‡ªåŠ¨æ’æœŸé€»è¾‘ ---
                if (showTrackList.value && trackListData.value.schedules) {
                    const currentIdx = trackListData.value.currentSectionIndex;
                    const nextSchedule = trackListData.value.schedules[currentIdx + 1];

                    if (nextSchedule) {
                        // è‡ªåŠ¨åŠ å…¥ä¸‹ä¸€åœº
                        const scheduleEntry = {
                            scheduleId: Date.now(),
                            templateId: newTask.id,
                            sessionId: currentSessionId.value,
                            musicianId: newTask.musicianId,
                            projectId: newTask.projectId,
                            instrumentId: newTask.instrumentId,
                            date: nextSchedule.date,
                            startTime: nextSchedule.startTime,
                            estDuration: newTask.estDuration,
                            trackCount: 0,
                            ratio: newTask.ratio,
                            musicDuration: newTask.musicDuration,
                            reminderMinutes: 15,
                            sound: 'default'
                        };
                        scheduledTasks.value.push(scheduleEntry);
                        // ç«‹å³æ›´æ–° sectionIndex
                        newTask.sectionIndex = currentIdx + 1;
                    } else {
                        // å½’å…¥æœªæ’æœŸæˆ–æœ€åä¸€æ®µ
                        newTask.sectionIndex = trackListData.value.totalSections > 0 ? trackListData.value.totalSections - 1 : 0;
                    }

                    // ç«‹å³åˆ·æ–°å½“å‰åˆ—è¡¨
                    trackListData.value.items.push(newTask);
                    autoSortTrackList();
                }

                pushHistory();
                window.triggerTouchHaptic('Success');
                if (item.musicianId) autoUpdateMusicianEfficiency(item.musicianId, 'musician', false);

                showSplitModal.value = false;
            };

            // ğŸŸ¢ ä¿®å¤: æ‹†åˆ†ä»»åŠ¡ (ç»Ÿä¸€çº¢è‰²æ ‡ç­¾ + ç«‹å³åˆ·æ–°åˆ—è¡¨)
            const splitTrack = (item) => {
                const totalMusicStr = item.musicDuration;
                if (!totalMusicStr || totalMusicStr === '00:00') {
                    return openAlertModal('æ— æ³•æ‹†åˆ†', 'è¯¥æ›²ç›®æ²¡æœ‰è®¾ç½®è°±é¢æ—¶é•¿ã€‚');
                }

                openInputModal(
                    'æ‹†åˆ†ä»»åŠ¡ (ç•™å¾…ä¸‹æ¬¡)',
                    '',
                    'è¯·è¾“å…¥ å‰©ä½™ è°±é¢æ—¶é•¿ (ä¾‹å¦‚ 01:30)',
                    (remainingStr) => {
                        if (!/^\d{1,2}:\d{2}$/.test(remainingStr)) {
                            return openAlertModal('æ ¼å¼é”™è¯¯', 'è¯·è¾“å…¥æ­£ç¡®çš„æ—¶é—´æ ¼å¼ (MM:SS)');
                        }

                        const totalSec = parseTime(totalMusicStr);
                        const remainSec = parseTime(remainingStr);

                        if (remainSec <= 0 || remainSec >= totalSec) {
                            return openAlertModal('æ•°å€¼é”™è¯¯', 'å‰©ä½™æ—¶é•¿å¿…é¡»å°äºæ€»æ—¶é•¿ä¸”å¤§äº0ã€‚');
                        }

                        const doneSec = totalSec - remainSec;
                        const doneStr = formatSecs(doneSec);

                        // --- A. æ›´æ–°å½“å‰ä»»åŠ¡ (Part 1) ---
                        item.musicDuration = doneStr;
                        item.splitTag = 'Part 1';

                        // --- B. åˆ›å»ºæ–°ä»»åŠ¡ (Part 2) ---
                        const newRatio = item.ratio || 20;
                        const newEst = calculateEstTime(remainingStr, newRatio);

                        const newTask = {
                            id: generateUniqueId('T'),
                            splitFromId: item.id,
                            splitTag: 'Part 2',

                            sessionId: item.sessionId || currentSessionId.value,
                            projectId: item.projectId,
                            instrumentId: item.instrumentId,
                            musicianId: item.musicianId,
                            musicDuration: remainingStr,
                            ratio: newRatio,
                            estDuration: newEst,
                            group: item.group || ''
                        };
                        ensureItemRecords(newTask);
                        itemPool.value.push(newTask);

                        // --- C. è‡ªåŠ¨æ’æœŸé€»è¾‘ ---
                        let autoScheduled = false;

                        if (showTrackList.value && trackListData.value.schedules) {
                            const currentIdx = trackListData.value.currentSectionIndex;
                            const nextSchedule = trackListData.value.schedules[currentIdx + 1];

                            if (nextSchedule) {
                                // è‡ªåŠ¨åŠ å…¥ä¸‹ä¸€åœº
                                const scheduleEntry = {
                                    scheduleId: Date.now(),
                                    templateId: newTask.id,
                                    sessionId: currentSessionId.value,
                                    musicianId: newTask.musicianId,
                                    projectId: newTask.projectId,
                                    instrumentId: newTask.instrumentId,
                                    date: nextSchedule.date,
                                    startTime: nextSchedule.startTime,
                                    estDuration: newTask.estDuration,
                                    trackCount: 0,
                                    ratio: newTask.ratio,
                                    musicDuration: newTask.musicDuration
                                };
                                scheduledTasks.value.push(scheduleEntry);
                                autoScheduled = true;

                                // ğŸŸ¢ å…³é”®ä¿®å¤ï¼šç«‹å³æ›´æ–° sectionIndexï¼Œè®©å®ƒå±äº"ä¸‹ä¸€ä¸ªæ—¥ç¨‹å—"
                                newTask.sectionIndex = currentIdx + 1;
                            } else {
                                // å¦‚æœæ²¡æœ‰ä¸‹ä¸€åœºï¼Œå½’å…¥å½“å‰ Session çš„æœ€åä¸€æ®µæˆ–æœªæ’æœŸ
                                // è¿™é‡Œæˆ‘ä»¬è®©å®ƒæ˜¾ç¤ºåœ¨åˆ—è¡¨é‡Œï¼Œæ‰€ä»¥ç»™ä¸ªæœ‰æ•ˆçš„ç´¢å¼•
                                newTask.sectionIndex = trackListData.value.totalSections > 0 ? trackListData.value.totalSections - 1 : 0;
                            }

                            // ğŸŸ¢ æ ¸å¿ƒä¿®å¤ï¼šæ‰‹åŠ¨å°†æ–°ä»»åŠ¡åŠ å…¥å½“å‰å¼¹çª—çš„æ˜¾ç¤ºåˆ—è¡¨
                            trackListData.value.items.push(newTask);

                            // ç«‹å³é‡æ–°æ’åºï¼Œè®©æ–°ä»»åŠ¡å‡ºç°åœ¨æ­£ç¡®ä½ç½®
                            autoSortTrackList();
                        }

                        pushHistory();
                        window.triggerTouchHaptic('Success');
                        if (item.musicianId) autoUpdateMusicianEfficiency(item.musicianId, 'musician', false);
                    },
                    `æ€»é•¿ ${totalMusicStr}ã€‚æ‹†åˆ†åï¼Œå‰©ä½™éƒ¨åˆ†å°†${trackListData.value.schedules && trackListData.value.schedules[trackListData.value.currentSectionIndex+1] ? 'è‡ªåŠ¨åŠ å…¥ä¸‹ä¸€åœº' : 'å›åˆ°ä»»åŠ¡æ± '}ã€‚`
                );
            };

            // ğŸŸ¢ ä¿®æ”¹: å½’è¿˜æ—¶é—´ (åŒæ—¶æ¸…é™¤æ ‡ç­¾)
            const restoreSplitTime = (taskToDelete) => {
                if (!taskToDelete.splitFromId) return;

                const parent = itemPool.value.find(i => i.id === taskToDelete.splitFromId);

                if (parent) {
                    const parentSec = parseTime(parent.musicDuration);
                    const childSec = parseTime(taskToDelete.musicDuration);

                    if (parentSec > 0 && childSec > 0) {
                        const newTotal = formatSecs(parentSec + childSec);

                        parent.musicDuration = newTotal;

                        // ğŸ· æ¸…é™¤çˆ¶ä»»åŠ¡çš„æ ‡ç­¾
                        delete parent.splitTag;
                        // æˆ–è€… parent.splitTag = null;

                        openAlertModal(
                            'æ—¶é—´å·²å½’è¿˜',
                            `æ‹†åˆ†ä»»åŠ¡å·²åˆå¹¶å›åŸä»»åŠ¡ã€‚\nåŸä»»åŠ¡æ ‡ç­¾å·²ç§»é™¤ï¼Œç°æœ‰æ—¶é•¿: ${newTotal}`
                        );
                        window.triggerTouchHaptic('Success');
                    }
                }
            };

            // --- ğŸŸ¢ æ–°å¢ï¼šè‡ªå®šä¹‰é¢œè‰²é€‰æ‹©å™¨é€»è¾‘ ---
            const showColorPickerModal = ref(false);
            const colorPickerTarget = ref(null); // å½“å‰æ­£åœ¨ç¼–è¾‘çš„å¯¹è±¡ { item, type }
            const tempColor = ref('');           // ä¸´æ—¶é¢œè‰²ï¼Œç¡®è®¤åæ‰åº”ç”¨

            // ğŸŸ¢ ä¿®å¤: éš”ç¦»åæ ‡çŠ¶æ€ï¼Œé˜²æ­¢åˆ‡æ¢æ—¶ä½ç½®è·³åŠ¨
            const inputRects = reactive({
                name: { top: 0, left: 0, width: 0, height: 0 },
                group: { top: 0, left: 0, width: 0, height: 0 }
            });

            // æ›´æ–°åæ ‡ (å¢åŠ  kind å‚æ•°: 'name' | 'group')
            const updateInputRect = (e, kind) => {
                const wrapperClass = kind === 'name' ? '.settings-name-wrapper' : '.settings-group-wrapper';
                const el = e.target.closest(wrapperClass);
                if (el) {
                    const r = el.getBoundingClientRect();
                    inputRects[kind] = { top: r.top, left: r.left, width: r.width, height: r.height };
                }
            };

            // ğŸŸ¢ åŠ¨æ€è®¡ç®—æ ·å¼ (æ ¹æ® kind è·å–å„è‡ªçš„åæ ‡)
            const getFloatingStyle = (kind) => {
                const rect = inputRects[kind]; // è·å–å„è‡ªç‹¬ç«‹çš„åæ ‡
                const windowHeight = window.innerHeight;

                const inputBottom = rect.top + rect.height;
                const spaceBelow = windowHeight - inputBottom;
                const menuHeight = 220;
                const isDropUp = spaceBelow < menuHeight;

                const style = {
                    position: 'fixed',
                    left: `${rect.left}px`,
                    width: `${rect.width}px`,
                    margin: 0,
                    zIndex: 99999,
                };

                if (isDropUp) {
                    style.top = 'auto';
                    style.bottom = `${windowHeight - rect.top + 5}px`;
                    style.transformOrigin = 'bottom center';
                } else {
                    style.top = `${inputBottom + 5}px`;
                    style.bottom = 'auto';
                    style.transformOrigin = 'top center';
                }

                return style;
            };

            // ğŸŸ¢ å…³é”®ï¼šæ»šåŠ¨æ—¶å…³é—­èœå• (é˜²æ­¢èœå•æ‚¬æµ®åœ¨ç©ºä¸­ä¸åŠ¨)
            const onSettingsScroll = () => {
                if (settingsNameFocus.value || settingsGroupFocus.value) {
                    settingsNameFocus.value = null;
                    settingsGroupFocus.value = null;
                }
            };

            // ğŸŸ¢ æ–°å¢ï¼šåç§°è¾“å…¥æ¡†çš„ç„¦ç‚¹çŠ¶æ€
            const settingsNameFocus = ref(null);

            // ğŸŸ¢ æ–°å¢ï¼šè·å–å½“å‰ç±»å‹ä¸‹â€œæœªåˆ†ç»„â€çš„é¡¹ç›®
            const getUngroupedItems = (type) => {
                let list = [];
                if (type === 'instrument') list = settings.instruments;
                else if (type === 'musician') list = settings.musicians;
                else if (type === 'project') list = settings.projects;

                // ç­›é€‰æ¡ä»¶ï¼šæ²¡æœ‰ group æˆ–è€… group æ˜¯ç©ºå­—ç¬¦ä¸²
                return list.filter(i => !i.group || !i.group.trim())
                    .sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));
            };

            // å®šä¹‰ä¸€å¥—ç¬¦åˆ App é£æ ¼çš„é¢„è®¾é¢œè‰²
            const presetColors = [
                '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16',
                '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9',
                '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef',
                '#ec4899', '#f43f5e', '#64748b', '#71717a', '#000000'
            ];

            // æ‰“å¼€é¢œè‰²é€‰æ‹©å™¨
            const openColorPicker = (item, type) => {
                colorPickerTarget.value = { item, type };
                tempColor.value = item.color || getDefaultColorByType(type);
                showColorPickerModal.value = true;
            };

            // è·å–é»˜è®¤é¢œè‰² (ç”¨äºé‡ç½®)
            const getDefaultColorByType = (type) => {
                if (type === 'project') return '#eab308';    // é»„
                if (type === 'instrument') return '#3b82f6'; // è“
                if (type === 'musician') return '#a855f7';   // ç´«
                return '#9ca3af';
            };

            // é‡ç½®é¢œè‰²
            const resetColorPicker = () => {
                if (colorPickerTarget.value) {
                    tempColor.value = getDefaultColorByType(colorPickerTarget.value.type);
                }
            };

            // ç¡®è®¤ä¿å­˜
            const saveColorPicker = () => {
                if (colorPickerTarget.value && tempColor.value) {
                    // æ›´æ–°å¯¹è±¡é¢œè‰²
                    colorPickerTarget.value.item.color = tempColor.value;
                    pushHistory(); // ä¿å­˜å†å²
                }
                showColorPickerModal.value = false;
            };

            // 1. åˆ‡æ¢å•ä¸ªåˆ†ç»„ (ä¿®æ”¹ï¼šå¢åŠ  type å‚æ•°ï¼Œä½¿ç”¨å¤åˆé”®)
            const toggleSettingsGroup = (type, groupName) => {
                const key = type + '|' + groupName; // ğŸŸ¢ ç”Ÿæˆå”¯ä¸€ Key
                if (settingsExpandedGroups.has(key)) {
                    settingsExpandedGroups.delete(key);
                } else {
                    settingsExpandedGroups.add(key);
                }
            };

            // 2. åˆ¤æ–­å…¨å±•å¼€ (ä¿®æ”¹ï¼šä½¿ç”¨å¤åˆé”®æ£€æŸ¥)
            const isAllGroupsExpanded = (type) => {
                const groups = getSettingsGroupedList(type);
                if (groups.length === 0) return false;

                // æ£€æŸ¥æ˜¯å¦æ¯ä¸ªåˆ†ç»„çš„ Key éƒ½åœ¨ Set é‡Œ
                return groups.every(g => settingsExpandedGroups.has(type + '|' + g.name));
            };

            // 3. æ‰¹é‡åˆ‡æ¢ (ä¿®æ”¹ï¼šä½¿ç”¨å¤åˆé”®æ“ä½œ)
            const toggleAllGroups = (type) => {
                const groups = getSettingsGroupedList(type);
                const isAllOpen = isAllGroupsExpanded(type);

                if (isAllOpen) {
                    // å…¨å…³
                    groups.forEach(g => settingsExpandedGroups.delete(type + '|' + g.name));
                } else {
                    // å…¨å¼€
                    groups.forEach(g => settingsExpandedGroups.add(type + '|' + g.name));
                }
            };

            // --- ğŸŸ¢ æ–°å¢: è§†å›¾åˆ‡æ¢åŠ¨ç”»ä¸æ‰‹åŠ¿é€»è¾‘ ---
            const viewTransitionName = ref('view-slide-left'); // é»˜è®¤åŠ¨ç”»æ–¹å‘
            const touchStartX = ref(0);
            const touchStartY = ref(0);

            // --- ğŸŸ¢ æ–°å¢: ä¾§è¾¹æ (ä»»åŠ¡æ± ) æ»‘åŠ¨åˆ‡æ¢ Tab ---
            const sidebarTouchStartX = ref(0);
            const sidebarTouchStartY = ref(0);
            const sidebarTabsOrder = ['musician', 'project', 'instrument']; // å®šä¹‰åˆ‡æ¢é¡ºåº

            const onSidebarTouchStart = (e) => {
                // å¦‚æœæ­£åœ¨æ‹–æ‹½ä»»åŠ¡ï¼Œä¸è®°å½•èµ·ç‚¹ï¼Œé˜²æ­¢è¯¯è§¦
                if (dragElClone) return;

                sidebarTouchStartX.value = e.touches[0].clientX;
                sidebarTouchStartY.value = e.touches[0].clientY;
            };

            // 1. å®šä¹‰åŠ¨ç”»çŠ¶æ€å’Œ Scroll å¼•ç”¨
            const sidebarTransitionName = ref('slide-next');
            const sidebarScrollRef = ref(null);

            // ... (åŸæœ‰çš„ sidebarTouchStartX ç­‰å˜é‡ä¿æŒä¸å˜) ...

            // ğŸŸ¢ æ–°å¢ï¼šæ™ºèƒ½åˆ‡æ¢ Tab å‡½æ•° (å¤„ç†åŠ¨ç”»æ–¹å‘)
            const switchSidebarTab = (targetTab) => {
                if (sidebarTab.value === targetTab) return;

                const order = ['musician', 'project', 'instrument'];
                const oldIdx = order.indexOf(sidebarTab.value);
                const newIdx = order.indexOf(targetTab);

                // åˆ¤æ–­æ–¹å‘ï¼šæ–°ç´¢å¼• > æ—§ç´¢å¼• ? å‘å·¦æ¨(Next) : å‘å³æ¨(Prev)
                sidebarTransitionName.value = newIdx > oldIdx ? 'slide-next' : 'slide-prev';

                // åˆ‡æ¢æ•°æ®
                sidebarTab.value = targetTab;

                // åˆ‡æ¢åè‡ªåŠ¨æ»šå›é¡¶éƒ¨ï¼Œä½“éªŒæ›´å¥½
                if (sidebarScrollRef.value) {
                    sidebarScrollRef.value.scrollTop = 0;
                }
            };

            // ğŸŸ¢ æ›´æ–°ï¼šè§¦æ‘¸ç»“æŸå¤„ç†å‡½æ•° (é›†æˆåŠ¨ç”»é€»è¾‘)
            const onSidebarTouchEnd = (e) => {
                if (dragElClone || !isMobile.value) return;

                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                const diffX = endX - sidebarTouchStartX.value;
                const diffY = endY - sidebarTouchStartY.value;

                if (Math.abs(diffX) > Math.abs(diffY) * 1.5 && Math.abs(diffX) > 50) {
                    const currentIndex = sidebarTabsOrder.indexOf(sidebarTab.value);
                    if (currentIndex === -1) return;

                    let nextIndex = currentIndex;
                    let direction = '';

                    if (diffX < 0) {
                        // å·¦æ»‘ -> ä¸‹ä¸€ä¸ª
                        if (currentIndex < sidebarTabsOrder.length - 1) {
                            nextIndex++;
                            direction = 'next';
                        }
                    } else {
                        // å³æ»‘ -> ä¸Šä¸€ä¸ª
                        if (currentIndex > 0) {
                            nextIndex--;
                            direction = 'prev';
                        }
                    }

                    if (nextIndex !== currentIndex) {
                        // ğŸŸ¢ æ‰‹åŠ¨è®¾ç½®åŠ¨ç”»æ–¹å‘
                        sidebarTransitionName.value = direction === 'next' ? 'slide-next' : 'slide-prev';

                        sidebarTab.value = sidebarTabsOrder[nextIndex];
                        window.triggerTouchHaptic('Light');

                        // æ»šå›é¡¶éƒ¨
                        if (sidebarScrollRef.value) sidebarScrollRef.value.scrollTop = 0;
                    }
                }
                sidebarTouchStartX.value = 0;
                sidebarTouchStartY.value = 0;
            };


            // æ™ºèƒ½åˆ‡æ¢è§†å›¾ (å¸¦ç¼©æ”¾åŠ¨ç”»)
            const switchView = (targetView) => {
                if (targetView === currentView.value) return;

                if (targetView === 'month') {
                    // å‘¨ -> æœˆ: ç¼©å° (Zoom Out)
                    // æ„Ÿè§‰åƒæ˜¯"åé€€"ä¸€æ­¥çœ‹åˆ°å…¨å±€
                    viewTransitionName.value = 'zoom-out';
                } else {
                    // æœˆ -> å‘¨: æ”¾å¤§ (Zoom In)
                    // æ„Ÿè§‰åƒæ˜¯"å‰è¿›"ä¸€æ­¥çœ‹åˆ°ç»†èŠ‚
                    viewTransitionName.value = 'zoom-in';
                }

                // åˆ‡æ¢è§†å›¾
                currentView.value = targetView;
                window.triggerTouchHaptic('Light');
            };

            const resetAutoHide = () => {
                // å¼ºåˆ¶æ˜¾ç¤º
                showMobileSlider.value = true;

                // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                if (idleTimer) clearTimeout(idleTimer);

                // è™½ç„¶æ˜¯"ä¿æŒæ˜¾ç¤º"ï¼Œä½†æˆ‘ä»¬è¿˜æ˜¯é‡ç½®ä¸€ä¸ªå®šæ—¶å™¨ï¼Œ
                // ç¡®ä¿å¦‚æœç”¨æˆ·æ‰‹æŒ‡åœåœ¨æ»‘å—ä¸Šä¸åŠ¨ï¼Œå®ƒä¾ç„¶ä¿æŒæ˜¾ç¤ºçŠ¶æ€
                idleTimer = setTimeout(() => {
                    showMobileSlider.value = true;
                }, 1000);
            };

            // è§¦æ‘¸å¼€å§‹ (è®°å½•èµ·ç‚¹)
            const onMainTouchStart = (e) => {
                // å¦‚æœæ­£åœ¨æ‹–æ‹½ä»»åŠ¡ï¼Œä¸è§¦å‘æ»‘å±åˆ‡æ¢
                if (dragElClone || isResizingMobile.value) return;

                touchStartX.value = e.touches[0].clientX;
                touchStartY.value = e.touches[0].clientY;
            };

            // ğŸŸ¢ ä¿®å¤: è§¦æ‘¸ç»“æŸ (åˆ¤å®šæ›´å®½æ¾ï¼ŒX > Y * 1.5 å³å¯)
            const onMainTouchEnd = (e) => {
                // å¦‚æœæ­£åœ¨æ‹–æ‹½ä»»åŠ¡æˆ–è°ƒæ•´å¤§å°ï¼Œä¸è§¦å‘è§†å›¾åˆ‡æ¢
                if (dragElClone || isResizingMobile.value) return;

                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;

                const diffX = endX - touchStartX.value;
                const diffY = endY - touchStartY.value;

                // ä¼˜åŒ–: æ°´å¹³è·ç¦» > å‚ç›´è·ç¦»çš„ 1.5 å€ (æ¯”ä¹‹å‰çš„ 2 å€æ›´çµæ•) ä¸”è·ç¦» > 50px
                if (Math.abs(diffX) > Math.abs(diffY) * 1.5 && Math.abs(diffX) > 50) {

                    let dir = 0;
                    if (diffX < 0) dir = 1;  // å·¦åˆ’ -> ä¸‹ä¸€å‘¨
                    if (diffX > 0) dir = -1; // å³åˆ’ -> ä¸Šä¸€å‘¨

                    if (dir !== 0) {
                        // A. å‘¨è§†å›¾ (ä»…çª„å±æ¨¡å¼ä¸‹å…è®¸)
                        if (currentView.value === 'week') {
                            if (dayColWidth.value < 60) {
                                changeDate(dir);
                            }
                        }
                        // B. æœˆè§†å›¾ (å§‹ç»ˆå…è®¸)
                        else if (currentView.value === 'month') {
                            changeDate(dir);
                        }
                    }
                }

                // å½’é›¶
                touchStartX.value = 0;
                touchStartY.value = 0;
            };

            const currentScrollSpeed = {x: 0, y: 0};

            // ğŸŸ¢ ä¿®æ”¹: å›¾æ ‡é€»è¾‘ (åŒæ€åˆ‡æ¢)
            const widthIcon = computed(() => {
                // å¦‚æœæ˜¯æ ‡å‡†å®½(100)ï¼Œæ˜¾ç¤ºæ”¶ç¼©å›¾æ ‡
                if (dayColWidth.value >= 100) return 'fa-compress';
                // å¦åˆ™(çª„è§†å›¾)ï¼Œæ˜¾ç¤ºå±•å¼€å›¾æ ‡
                return 'fa-expand';
            });

            const isSidebarOpen = ref(true);

            // ğŸŸ¢ ä¿®æ”¹: åˆ‡æ¢é€»è¾‘ (åªä¿ç•™ æ ‡å‡† <-> çª„)
            const cycleDayWidth = () => {
                if (dayColWidth.value >= 100) {
                    // å½“å‰æ˜¯æ ‡å‡†(100) -> åˆ‡æ¢åˆ° çª„æ¨¡å¼(52)
                    // (å°å±æ‰‹æœºç”¨ 45pxï¼Œå¤§å±ç”¨ 52px åˆšå¥½å®¹çº³7å¤©)
                    dayColWidth.value = window.innerWidth < 400 ? 45 : 52;
                } else {
                    // å½“å‰æ˜¯çª„æ¨¡å¼ -> åˆ‡æ¢å› æ ‡å‡†(100)
                    dayColWidth.value = 100;
                }

                // è®°ä½ç”¨æˆ·çš„é€‰æ‹©
                localStorage.setItem('musche_day_width', dayColWidth.value);

                window.triggerTouchHaptic('Medium'); // éœ‡åŠ¨åé¦ˆ
            };

            // ğŸŸ¢ ä¿®å¤: ç»ˆæä¿®æ­£ç‰ˆæ¸…ç†å‡½æ•°
            // ä¿®å¤äº† S_DEFAULT å«ä¸‹åˆ’çº¿å¯¼è‡´çš„åˆ†ç»„è§£æé”™è¯¯ï¼Œé˜²æ­¢è¯¯åˆ æ‰€æœ‰æ—¥ç¨‹
            const cleanupEmptySchedules = () => {
                const activePoolIds = new Set(itemPool.value.map(i => i.id));
                const originalLength = scheduledTasks.value.length;

                // 1. æŒ‰ "Session | ç±»å‹ | ID" åˆ†ç»„æ—¥ç¨‹å—
                // ğŸ”´ ä¿®å¤: ä½¿ç”¨ "|" ä½œä¸ºåˆ†éš”ç¬¦ï¼Œå› ä¸º S_DEFAULT å«æœ‰ä¸‹åˆ’çº¿ï¼Œä¼šå¯¼è‡´ split å‡ºé”™
                const groups = {};
                const getGroupKey = (t) => {
                    const sess = t.sessionId || 'S_DEFAULT';
                    if (t.musicianId) return `${sess}|M|${t.musicianId}`;
                    if (t.projectId) return `${sess}|P|${t.projectId}`;
                    if (t.instrumentId) return `${sess}|I|${t.instrumentId}`;
                    return null;
                };

                scheduledTasks.value.forEach(t => {
                    if (!t.templateId) { // ä»…å¤„ç†èšåˆå—
                        const k = getGroupKey(t);
                        if (k) {
                            if (!groups[k]) groups[k] = [];
                            groups[k].push(t);
                        }
                    }
                });

                const schedulesKeepSet = new Set();

                // 2. éå†æ¯ä¸€ç»„
                Object.entries(groups).forEach(([key, scheduleBlocks]) => {
                    // A. æ’åº
                    scheduleBlocks.sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));

                    // ğŸ”´ ä¿®å¤: æ­£ç¡®è§£æ Key (ä½¿ç”¨ | åˆ†å‰²)
                    const [sess, type, id] = key.split('|');

                    // B. ç­›é€‰ä»»åŠ¡æ± 
                    const poolItems = itemPool.value.filter(i => {
                        if ((i.sessionId || 'S_DEFAULT') !== sess) return false;
                        if (type === 'M') return i.musicianId === id;
                        if (type === 'P') return i.projectId === id;
                        if (type === 'I') return i.instrumentId === id;
                        return false;
                    });

                    // C. å»ºç«‹æ˜ å°„: SectionIndex -> ä»»åŠ¡åˆ—è¡¨
                    const taskMap = new Map();
                    poolItems.forEach(t => {
                        let idx = parseInt(t.sectionIndex);
                        if (isNaN(idx)) idx = 0;

                        if (!taskMap.has(idx)) taskMap.set(idx, []);
                        taskMap.get(idx).push(t);
                    });

                    // D. æ ¸å¿ƒ: ç´¢å¼•å¯¹é½ä¸ä¿ç•™é€»è¾‘
                    let newBlockIndex = 0;

                    scheduleBlocks.forEach((block, oldIndex) => {
                        const relatedTasks = taskMap.get(oldIndex);

                        if (relatedTasks && relatedTasks.length > 0) {
                            // âœ… å‘½ä¸­ï¼šä¿ç•™è¯¥å—
                            schedulesKeepSet.add(block.scheduleId);

                            // âš¡ï¸ ä¿®æ­£ç´¢å¼•ï¼šå¦‚æœå‰é¢æœ‰å—è¢«åˆ äº†ï¼Œä¿®æ­£å½“å‰ä»»åŠ¡çš„ index
                            if (oldIndex !== newBlockIndex) {
                                relatedTasks.forEach(t => {
                                    t.sectionIndex = newBlockIndex;
                                });
                            }
                            newBlockIndex++;
                        }
                        // âŒ æœªå‘½ä¸­ï¼šè¯¥å—å¯¹åº”ä»»åŠ¡å·²ç©ºï¼Œä¸åŠ å…¥ KeepSet (å³åˆ é™¤)
                    });
                });

                // 3. æ‰§è¡Œç‰©ç†åˆ é™¤
                scheduledTasks.value = scheduledTasks.value.filter(task => {
                    if ((task.sessionId || 'S_DEFAULT') !== currentSessionId.value) return true;

                    // éèšåˆå— (æœ‰å…·ä½“ templateId)ï¼Œæ£€æŸ¥ ID æ˜¯å¦å­˜åœ¨
                    if (task.templateId) return activePoolIds.has(task.templateId);

                    // èšåˆå—ï¼Œæ£€æŸ¥æ˜¯å¦åœ¨ä¿ç•™åå•é‡Œ
                    return schedulesKeepSet.has(task.scheduleId);
                });

                if (scheduledTasks.value.length < originalLength) {
                    window.triggerTouchHaptic('Medium');
                }
            };

            // ğŸŸ¢ æ–°å¢: å¼ºåŠ›æ‰«æå¹¶æ¸…ç†å½“å‰å¼¹çª—å†…çš„ç©ºæ—¥ç¨‹å—
            const pruneEmptySchedules = () => {
                const listData = trackListData.value;
                if (!listData.schedules || listData.schedules.length === 0) return;

                // å€’åºéå†ï¼Œé˜²æ­¢åˆ é™¤å…ƒç´ æ—¶ç´¢å¼•é”™ä½
                for (let i = listData.schedules.length - 1; i >= 0; i--) {
                    // æ£€æŸ¥å±äºå½“å‰ sectionIndex (i) çš„ä»»åŠ¡è¿˜æœ‰å‡ ä¸ª
                    const itemsInSection = listData.items.filter(item => item.sectionIndex === i);

                    // å¦‚æœä¸€ä¸ªéƒ½æ²¡æœ‰äº†ï¼Œè¯´æ˜è¿™ä¸ªæ—¥ç¨‹å—æ˜¯ä¸ªç©ºå£³
                    if (itemsInSection.length === 0) {
                        const scheduleToRemove = listData.schedules[i];

                        // 1. ä»ä¸»æ•°æ®åº“ scheduledTasks ä¸­å½»åº•åˆ é™¤è¯¥æ—¥ç¨‹
                        scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== scheduleToRemove.scheduleId);

                        // 2. ä»å¼¹çª— UI æ•°æ®ä¸­ç§»é™¤
                        listData.schedules.splice(i, 1);

                        // 3. å…³é”®: ä¿®æ­£æ‰€æœ‰åç»­ä»»åŠ¡çš„ sectionIndex
                        // å› ä¸ºç¬¬ i ä¸ªæ—¥ç¨‹æ²¡äº†ï¼Œé‚£ä¹ˆæ‰€æœ‰ sectionIndex > i çš„ä»»åŠ¡ï¼Œç´¢å¼•éƒ½è¦å‡ 1
                        listData.items.forEach(item => {
                            if (item.sectionIndex > i) {
                                item.sectionIndex--;
                            }
                        });
                    }
                }

                // æ›´æ–°æ€»æ®µæ•°
                listData.totalSections = listData.schedules.length;

                // å¦‚æœå…¨éƒ¨åˆ å…‰äº†ï¼Œå…³é—­å¼¹çª—
                if (listData.totalSections === 0) {
                    showTrackList.value = false;
                } else {
                    // ä¿®æ­£å½“å‰æ˜¾ç¤ºçš„ç´¢å¼•ï¼Œé˜²æ­¢è¶Šç•Œ
                    if (listData.currentSectionIndex >= listData.totalSections) {
                        listData.currentSectionIndex = listData.totalSections - 1;
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: æ ¹æ®å½•éŸ³è®°å½•è‡ªåŠ¨è°ƒæ•´æ—¥ç¨‹å— (æ”¯æŒé™é»˜æ¨¡å¼ + æ–°å¸é™„é€»è¾‘)
            const autoResizeScheduleByRecords = (isSilent = false, shouldPushHistory = true) => {
                // 1. è·å–å½“å‰å¼¹çª—ç®¡ç†çš„æ‰€æœ‰æ—¥ç¨‹å— (Sections)
                const sections = trackListData.value.schedules;
                const items = trackListData.value.items;
                const viewType = trackListData.value.viewType || 'musician';

                let hasUpdate = false;

                // --- æ–°å¢: è‡ªå®šä¹‰å¸é™„é€»è¾‘å‡½æ•° ---
                const snapToGrid = (totalMinutes) => {
                    const h = Math.floor(totalMinutes / 60);
                    const m = totalMinutes % 60;

                    // è§„åˆ™: 45åˆ†-14åˆ†å¸é™„åˆ°00åˆ† (45-59å½’ä¸‹ä¸€å°æ—¶00, 0-14å½’æœ¬å°æ—¶00)
                    // è§„åˆ™: 15åˆ†-44åˆ†å¸é™„åˆ°30åˆ†

                    if (m >= 45) {
                        return (h + 1) * 60; // ä¸‹ä¸€å°æ—¶ 00
                    } else if (m >= 15) {
                        return h * 60 + 30;  // æœ¬å°æ—¶ 30
                    } else {
                        return h * 60;       // æœ¬å°æ—¶ 00
                    }
                };

                // 2. éå†æ¯ä¸ªæ—¥ç¨‹å— (Section)
                sections.forEach((scheduleRef, sectionIndex) => {
                    if (!scheduleRef) return;

                    // æ‰¾åˆ°å±äºè¯¥ Section çš„æ‰€æœ‰ Tracks
                    const sectionItems = items.filter(t => (t.sectionIndex || 0) === sectionIndex);

                    if (sectionItems.length === 0) return;

                    let minMins = Infinity;
                    let maxMins = -Infinity;

                    // 3. æ‰¾å‡ºè¯¥æ®µè½å†… æœ€æ—©å¼€å§‹ å’Œ æœ€æ™šç»“æŸ çš„åˆ†é’Ÿæ•°
                    sectionItems.forEach(item => {
                        const rec = item.records[viewType];
                        if (!rec) return;

                        if (rec.recStart) {
                            const [h, m] = rec.recStart.split(':').map(Number);
                            const startVal = h * 60 + m;
                            if (startVal < minMins) minMins = startVal;
                        }
                        if (rec.recEnd) {
                            const [h, m] = rec.recEnd.split(':').map(Number);
                            let endVal = h * 60 + m;
                            // å¤„ç†è·¨å¤©
                            if (rec.recStart) {
                                const [sh, sm] = rec.recStart.split(':').map(Number);
                                if (endVal < (sh * 60 + sm)) endVal += 24 * 60;
                            }
                            if (endVal > maxMins) maxMins = endVal;
                        }
                    });

                    // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ—¶é—´è®°å½•ï¼Œè·³è¿‡
                    if (minMins === Infinity || maxMins === -Infinity) return;

                    // 4. æ‰§è¡Œæ–°çš„å¸é™„é€»è¾‘
                    const newStartMins = snapToGrid(minMins);
                    const newEndMins = snapToGrid(maxMins);

                    // è®¡ç®—æ–°æ—¶é•¿
                    const durationMins = newEndMins - newStartMins;

                    // å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœå¸é™„åå¯¼è‡´æ—¶é•¿ <= 0 (ä¾‹å¦‚ 10:20-10:25 éƒ½å¸é™„åˆ°äº† 10:30)ï¼Œåˆ™ä¸è°ƒæ•´
                    if (durationMins <= 0) return;

                    // 5. æ›´æ–°ä¸»æ•°æ® scheduledTasks
                    const taskInMainArray = scheduledTasks.value.find(t => t.scheduleId === scheduleRef.scheduleId);

                    if (taskInMainArray) {
                        // è½¬æ¢å› HH:MM æ ¼å¼
                        const sh = Math.floor(newStartMins / 60);
                        const sm = newStartMins % 60;
                        const newStartTimeStr = `${String(sh).padStart(2, '0')}:${String(sm).padStart(2, '0')}`;
                        const newDurationStr = formatSecs(durationMins * 60);

                        // æ£€æŸ¥æ˜¯å¦æœ‰å˜æ›´ï¼Œé¿å…æ— æ•ˆæ›´æ–°
                        if (taskInMainArray.startTime !== newStartTimeStr || taskInMainArray.estDuration !== newDurationStr) {
                            taskInMainArray.startTime = newStartTimeStr;
                            taskInMainArray.estDuration = newDurationStr;
                            hasUpdate = true;
                        }
                    }
                });

                if (hasUpdate) {
                    if (shouldPushHistory) {
                        pushHistory();
                    }
                    // è‡ªåŠ¨æ¨¡å¼ä¸‹ä¸å¼¹çª—ï¼Œä½†å¯ä»¥ç»™ä¸ªè½»å¾®éœ‡åŠ¨åé¦ˆ
                    if (!isSilent) {
                        window.triggerTouchHaptic('Success');
                        openAlertModal('è‡ªåŠ¨è°ƒæ•´å®Œæˆ', 'æ—¥ç¨‹å—å·²æ ¹æ®å®é™…å½•éŸ³æ—¶é—´å¸é™„åˆ°æœ€è¿‘çš„ç½‘æ ¼ã€‚');
                    } else {
                        // é™é»˜æ¨¡å¼ä¸‹ï¼Œç¨å¾®éœ‡åŠ¨ä¸€ä¸‹æç¤ºå‘ç”Ÿäº†å˜åŒ–
                        // window.triggerTouchHaptic('Light'); // å¯é€‰
                    }
                } else {
                    if (!isSilent) {
                        openAlertModal('æ— éœ€è°ƒæ•´', 'æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ—¶é—´è®°å½•ï¼Œæˆ–å½“å‰æ—¥ç¨‹å·²åŒ¹é…ã€‚');
                    }
                }
            };


            // ğŸŸ¢ ä¿®å¤ç‰ˆ: æ™ºèƒ½è·³è½¬ (é€‚é…é•¿åŠ¨ç”»)
            const smartScrollToTask = (targetTask) => {
                if (!targetTask) return;

                // 1. å¼ºåˆ¶åˆ‡æ¢åˆ°æ—¥ç¨‹è¡¨ (æ‰‹æœºç«¯)
                if (isMobile.value) {
                    mobileTab.value = 'schedule';
                }

                // 2. å‡†å¤‡ç›®æ ‡æ—¥æœŸ
                const targetDateObj = new Date(targetTask.date.replace(/-/g, '/'));

                // åˆ¤æ–­åŠ¨ç”»æ–¹å‘
                if (targetDateObj.getTime() > viewDate.value.getTime()) {
                    dateTransitionName.value = 'slide-next';
                } else if (targetDateObj.getTime() < viewDate.value.getTime()) {
                    dateTransitionName.value = 'slide-prev';
                }

                // 3. åˆ‡æ¢è§†å›¾ & è®¾ç½®æ—¥æœŸ
                currentView.value = 'week';
                viewDate.value = targetDateObj;

                // 4. è§¦å‘é«˜äº®
                flashingTaskId.value = targetTask.scheduleId;
                setTimeout(() => {
                    if (flashingTaskId.value === targetTask.scheduleId) flashingTaskId.value = null;
                }, 2500);

                // ğŸŸ¢ 5. æ ¸å¿ƒä¼˜åŒ–: å»¶è¿Ÿæ‰§è¡Œæ»šåŠ¨
                // CSS åŠ¨ç”»æ—¶é•¿æ˜¯ 400msï¼Œè¿™é‡Œè®¾ç½® 450ms ç¡®ä¿ DOM ç¨³å®šåå†æ»šåŠ¨
                setTimeout(() => {
                    const container = weekContainer.value;
                    if (container) {
                        const pxPerMinVal = pxPerMin.value; // è·å–å½“å‰ç¼©æ”¾æ¯”ä¾‹

                        // --- A. å‚ç›´å®šä½ ---
                        const startMins = timeToMinutes(targetTask.startTime);
                        const offsetMins = startMins - settings.startHour * 60;
                        // ç¨å¾®å‘ä¸Šåä¸€ç‚¹ (-50px)ï¼Œè®©ä»»åŠ¡ä¸è¦è´´ç€å±å¹•é¡¶è¾¹ï¼Œè§†è§‰æ›´èˆ’é€‚
                        const targetTopPixel = (offsetMins * pxPerMinVal);
                        const scrollTop = Math.max(0, targetTopPixel - 50);

                        // --- B. æ°´å¹³å®šä½ ---
                        const dayIndex = targetDateObj.getDay();
                        const timeColW = isMobile.value ? 40 : 70;
                        // åŠ¨æ€è®¡ç®—åˆ—å®½
                        const totalW = container.scrollWidth - timeColW;
                        const singleDayW = totalW / 7;

                        const targetCenterX = timeColW + (dayIndex * singleDayW) + (singleDayW / 2);
                        const scrollLeft = Math.max(0, targetCenterX - (container.clientWidth / 2));

                        // æ‰§è¡Œå¹³æ»‘æ»šåŠ¨
                        container.scrollTo({
                            top: scrollTop,
                            left: scrollLeft,
                            behavior: 'smooth'
                        });

                        // ğŸŸ¢ åŒé‡ä¿é™©:
                        // æœ‰æ—¶ smooth æ»šåŠ¨ä¼šè¢«å¹¶æœªå®Œå…¨ç»“æŸçš„æ¸²æŸ“æ‰“æ–­
                        // 100ms åæ£€æŸ¥ä½ç½®ï¼Œå¾®è°ƒä¸€æ¬¡ (è¿™æ¬¡ç”¨ auto ç¬é—´å¯¹é½ï¼Œé˜²æ­¢ç”¨æˆ·æ²¡æ„Ÿè§‰)
                        setTimeout(() => {
                            if (Math.abs(container.scrollTop - scrollTop) > 10) {
                                container.scrollTo({top: scrollTop, left: scrollLeft, behavior: 'auto'});
                            }
                        }, 600);
                    }
                }, 1000); // â³ å»¶è¿Ÿå¢åŠ åˆ° 450ms
            };

            // 1. é¼ æ ‡æŒ‰ä¸‹ (å¼€å§‹æ‹–æ‹½)
            const onDragStart = (e, type) => {
                // ä»…å“åº”é¼ æ ‡å·¦é”® (e.button === 0)
                if (e.button !== 0) return;

                e.preventDefault();
                isDraggingMouse = true;
                startMouseY = e.clientY;

                // ç¡®å®šå½“å‰æ“ä½œçš„æ»šè½®å¼•ç”¨
                activeColRef = type === 'm' ? pickerMinRef.value : pickerSecRef.value;
                startScrollTop = activeColRef.scrollTop;

                // åœ¨å…¨å±€æ·»åŠ ç›‘å¬ï¼Œé˜²æ­¢é¼ æ ‡ç§»å‡ºæ»šè½®åŒºåŸŸåæ‹–æ‹½ä¸­æ–­
                window.addEventListener('mousemove', onDragMove);
                window.addEventListener('mouseup', onDragEnd);
            };

            // 2. é¼ æ ‡ç§»åŠ¨ (æ‰‹åŠ¨æ»šåŠ¨)
            const onDragMove = (e) => {
                if (!isDraggingMouse) return;
                e.preventDefault();

                const deltaY = e.clientY - startMouseY;
                // é¼ æ ‡å‘ä¸‹ç§»åŠ¨ï¼Œæ»šè½®åº”è¯¥å‘ä¸Šæ»šåŠ¨ï¼ˆscrollTop å¢å¤§ï¼‰ï¼Œæ‰€ä»¥æ˜¯å‡æ³•
                activeColRef.scrollTop = startScrollTop - deltaY;

                // NOTE: @scroll äº‹ä»¶ä¼šè´Ÿè´£æ›´æ–° tempDuration
            };

            // 3. é¼ æ ‡æŠ¬èµ· (ç»“æŸæ‹–æ‹½)
            const onDragEnd = () => {
                if (!isDraggingMouse) return;

                isDraggingMouse = false;
                // æ¸…ç†å…¨å±€ç›‘å¬å™¨
                window.removeEventListener('mousemove', onDragMove);
                window.removeEventListener('mouseup', onDragEnd);

                // è§¦å‘ä¸€æ¬¡ @scroll äº‹ä»¶ï¼Œç¡®ä¿æœ€åçš„å€¼è¢«å¸é™„åˆ°ä½
                activeColRef.dispatchEvent(new Event('scroll'));
            };


            // 1. æ‰“å¼€é€‰æ‹©å™¨
            // è°ƒç”¨æ–¹å¼: openDurationPicker(item, 'musicDuration')
            const openDurationPicker = (event, targetObj, key) => {
                // --- A. è®¡ç®—åæ ‡ ---
                const targetEl = event.target; // è·å–è¢«ç‚¹å‡»çš„è¾“å…¥æ¡†
                const rect = targetEl.getBoundingClientRect();

                // æ°”æ³¡å®½é«˜ (ä¸ CSS å¯¹åº”)
                const boxWidth = 280;
                const boxHeight = 320;

                // è®¡ç®— Left: å±…ä¸­å¯¹é½è¾“å…¥æ¡†ï¼Œä½†é˜²æ­¢è¶…å‡ºå±å¹•å·¦å³è¾¹ç•Œ
                let left = rect.left + (rect.width / 2) - (boxWidth / 2);
                // è¾¹ç•Œä¿æŠ¤ (å·¦è¾¹ä¸å°äº 10pxï¼Œå³è¾¹ä¸è¶…å±å¹•)
                left = Math.max(10, Math.min(window.innerWidth - boxWidth - 10, left));

                // è®¡ç®— Top: é»˜è®¤æ˜¾ç¤ºåœ¨è¾“å…¥æ¡†ä¸Šæ–¹ (å‡å»æ°”æ³¡é«˜åº¦å’Œä¸€ç‚¹é—´è·)
                let top = rect.top - boxHeight - 15;

                // å¦‚æœä¸Šæ–¹ç©ºé—´ä¸å¤Ÿ (æ¯”å¦‚è¾“å…¥æ¡†åœ¨å±å¹•æœ€é¡¶ç«¯)ï¼Œåˆ™æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                if (top < 10) {
                    top = rect.bottom + 15;
                    // æ³¨æ„ï¼šå¦‚æœæ˜¾ç¤ºåœ¨ä¸‹æ–¹ï¼Œç†è®ºä¸Š CSS çš„å°ä¸‰è§’åº”è¯¥è½¬æ–¹å‘ï¼Œè¿™é‡Œä¸ºç®€åŒ–æš‚ä¸å¤„ç†
                    // æˆ–è€…ä½ å¯ä»¥ç»™ box åŠ ä¸ª class æ¥ç¿»è½¬ ::after
                }

                pickerPos.top = top;
                pickerPos.left = left;

                // --- B. åˆå§‹åŒ–æ•°æ® ---
                const currentVal = targetObj[key] || '';
                let m = 0, s = 0;
                if (currentVal.includes(':')) {
                    const parts = currentVal.split(':');
                    m = parseInt(parts[0]) || 0;
                    s = parseInt(parts[1]) || 0;
                }
                tempDuration.m = m;
                tempDuration.s = s;
                showDurationPicker.value = true;

                // --- C. è®¾ç½®å›è°ƒ ---
                pickerCallback = (isReset = false) => {
                    const finalStr = isReset ? '' : `${String(tempDuration.m).padStart(2, '0')}:${String(tempDuration.s).padStart(2, '0')}`;
                    targetObj[key] = finalStr;

                    if (targetObj.ratio && targetObj.estDuration !== undefined) {
                        if (typeof calculateEstTime === 'function') {
                            targetObj.estDuration = calculateEstTime(finalStr, targetObj.ratio);
                        }
                    }
                    pushHistory(); // ä¿å­˜å†å²
                };

                // --- D. æ»šåŠ¨åˆ°ä½ ---
                Vue.nextTick(() => {
                    scrollToValue(pickerMinRef.value, m);
                    scrollToValue(pickerSecRef.value, s);
                });
            };

            const closePicker = () => {
                showDurationPicker.value = false;
            };

            const scrollToValue = (el, val) => {
                if (el) el.scrollTop = val * 44; // æ³¨æ„: CSSé‡Œæ”¹æˆäº† 44px é«˜
            };

            let scrollTimeout = null;
            const onScroll = (e, type) => {
                clearTimeout(scrollTimeout);
                const el = e.target;

                // 1. è®¡ç®—å½“å‰æ»šåˆ°äº†ç¬¬å‡ æ ¼ (44px æ˜¯ CSS ä¸­å®šä¹‰çš„æ ¼é«˜)
                // Math.round ç¡®ä¿è¿‡åŠå°±å¸é™„åˆ°ä¸‹ä¸€ä¸ªæ•°å­—
                const newIndex = Math.round(el.scrollTop / 44);

                // 2. è·å–æ—§çš„ç´¢å¼• (ä¸Šä¸€æ¬¡çš„çŠ¶æ€)
                const oldIndex = (type === 'm' ? tempDuration.m : tempDuration.s);

                // ğŸŸ¢ å…³é”®ä¿®æ”¹: åªæœ‰å½“æ•°å­—å‘ç”Ÿå˜åŒ–æ—¶ (è·³æ ¼)ï¼Œæ‰è§¦å‘é€»è¾‘
                if (newIndex !== oldIndex) {

                    // A. æ›´æ–°æ•°æ®
                    if (type === 'm') tempDuration.m = newIndex;
                    if (type === 's') tempDuration.s = newIndex;

                    // B. è§¦å‘éœ‡åŠ¨ ğŸ“³
                    // ä½¿ç”¨ 'Light' æ¡£ä½ï¼Œè¿™ç§è½»å¾®çš„æ•²å‡»æ„Ÿæœ€é€‚åˆæ¨¡æ‹Ÿæ»šè½®çš„é½¿æ„Ÿ
                    window.triggerTouchHaptic('Light');
                }
                // ä»…ç”¨äºæ»šåŠ¨ç»“æŸåçš„å¸é™„ä¿®æ­£ (å¯é€‰)

                scrollTimeout = setTimeout(() => {
                    // æ­¤å¤„å¯ä»¥åŠ é€»è¾‘
                }, 100);

            };

            // è¾…åŠ©ï¼šç²¾ç¡®è®¡ç®—å…ƒç´ å æ®çš„ç‰©ç†ç©ºé—´ (å« margin)
            const getOuterHeight = (el) => {
                if (!el) return 0;
                const style = window.getComputedStyle(el);
                const h = el.offsetHeight;
                const mt = parseFloat(style.marginTop) || 0;
                const mb = parseFloat(style.marginBottom) || 0;
                // å¤„ç† margin collapse (é€šå¸¸å– maxï¼Œä½†åœ¨ space-y å¸ƒå±€ä¸­å¾€å¾€æ˜¯å åŠ æˆ–å›ºå®šé—´è·ï¼Œè¿™é‡Œç®€å•ç›¸åŠ é€šå¸¸è¶³å¤Ÿç²¾ç¡®ï¼Œ
                // å› ä¸ºæˆ‘ä»¬æ˜¯ä¸ºäº†è®¡ç®—"è·¨è¶Šè¿™ä¸ªå…ƒç´ éœ€è¦èµ°å¤šè¿œ")
                // åœ¨ flex/block å¸ƒå±€ä¸­ï¼Œä¸ºäº†é˜²æ­¢ collapse è®¡ç®—å¤æ‚ï¼Œç›´æ¥å–å¤–è¾¹è·æ€»å’Œé€šå¸¸æ›´ç¬¦åˆç›´è§‰æ‰‹æ„Ÿ
                return h + Math.max(mt, mb);
            };

            // 1. å¼€å§‹æ‹–æ‹½
            const startDividerDrag = (e, sectionIndex) => {
                if (dividerDragState) return;
                const isTouch = e.type === 'touchstart';
                if (e.cancelable) e.preventDefault();

                // ğŸŸ¢ å…³é”®ä¿®æ”¹: è™½ç„¶ç‚¹å‡»çš„æ˜¯èƒ¶å›Šï¼Œä½†æˆ‘ä»¬è¦æ“ä½œçš„æ˜¯æ•´è¡Œåˆ†å‰²æ¡
                const triggerEl = e.currentTarget;
                const targetEl = triggerEl.closest('.group\\/divider'); // æŸ¥æ‰¾å¸¦æœ‰ group/divider ç±»çš„çˆ¶å®¹å™¨

                // å¦‚æœæ‰¾ä¸åˆ°çˆ¶å®¹å™¨(ç†è®ºä¸Šä¸ä¼š)ï¼Œå°±å›é€€åˆ°å½“å‰å…ƒç´ 
                const actualTarget = targetEl || triggerEl;

                // éšè—åŸå§‹å…ƒç´ 
                actualTarget.style.opacity = '0';

                const rect = actualTarget.getBoundingClientRect();
                const clientY = isTouch ? e.touches[0].clientY : e.clientY;
                const container = trackListContainerRef.value;
                const initialScrollTop = container ? container.scrollTop : 0;

                // è·å–æ‰€æœ‰å¡ç‰‡ DOM
                const taskEls = Array.from(container.querySelectorAll('.track-card'));
                // ğŸŸ¢ 2. è®¡ç®—é«˜åº¦æ—¶åŒ…å« margin (æ›´ç²¾ç¡®)
                const taskHeights = taskEls.map(el => {
                    const style = window.getComputedStyle(el);
                    return el.offsetHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
                });

                // è®¡ç®—åˆ†å‰²æ¡çš„çœŸå®å æ®é«˜åº¦ (åŒ…å« margin)
                const dividerStyle = window.getComputedStyle(targetEl);
                const ghostHeight = targetEl.offsetHeight + parseFloat(dividerStyle.marginTop) + parseFloat(dividerStyle.marginBottom);

                let startIndex = trackListData.value.items.findIndex(item => item.sectionIndex === sectionIndex);
                if (startIndex === -1) startIndex = trackListData.value.items.length;

                // åˆ›å»ºæ›¿èº«
                const ghost = actualTarget.cloneNode(true);
                Object.assign(ghost.style, {
                    position: 'fixed', top: `${rect.top}px`, left: `${rect.left}px`,
                    width: `${rect.width}px`, height: `${rect.height}px`,
                    zIndex: '9999', opacity: '0.95',
                    boxShadow: '0 4px 15px rgba(0,0,0,0.1)',
                    transform: 'none', transition: 'none', pointerEvents: 'none',
                    // æ›¿èº«å¿…é¡»æ˜¯å¯è§çš„
                    opacity: '1'
                });
                document.body.appendChild(ghost);

                draggingSectionIndex.value = sectionIndex;

                dividerDragState = {
                    targetEl: actualTarget, // ğŸŸ¢ ä¿å­˜å¼•ç”¨ä»¥ä¾¿æ¢å¤
                    ghost: ghost,
                    ghostHeight: ghostHeight,
                    taskEls: taskEls,
                    fingerOffset: clientY - rect.top,
                    lastClientY: clientY,
                    lastScrollTop: initialScrollTop,
                    cumulativeDelta: 0,
                    taskHeights: taskHeights,
                    virtualIndex: startIndex,
                    startIndex: startIndex,
                    sectionIndex: sectionIndex
                };

                window.triggerTouchHaptic('Medium');

                if (isTouch) {
                    window.addEventListener('touchmove', onDividerDragMove, {passive: false});
                    window.addEventListener('touchend', onDividerDragEnd);
                    window.addEventListener('touchcancel', onDividerDragEnd);
                } else {
                    window.addEventListener('mousemove', onDividerDragMove);
                    window.addEventListener('mouseup', onDividerDragEnd);
                }
            };

            // 2. æ‹–æ‹½è¿‡ç¨‹ (ä¿æŒä¸å˜ï¼Œç¡®è®¤é€»è¾‘æ— è¯¯)
            const onDividerDragMove = (e) => {
                if (!dividerDragState) return;
                if (e.cancelable) e.preventDefault();

                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                // A. ç§»åŠ¨æ›¿èº«
                const newTop = clientY - dividerDragState.fingerOffset;
                dividerDragState.ghost.style.top = `${newTop}px`;

                const container = trackListContainerRef.value;
                const currentScrollTop = container ? container.scrollTop : 0;
                const dy = clientY - dividerDragState.lastClientY;
                const dScroll = currentScrollTop - dividerDragState.lastScrollTop;

                dividerDragState.lastClientY = clientY;
                dividerDragState.lastScrollTop = currentScrollTop;
                dividerDragState.cumulativeDelta += (dy + dScroll);

                const {taskHeights, startIndex, ghostHeight, taskEls} = dividerDragState;
                let indexChanged = false;

                // è®¡ç®— Virtual Index
                while (dividerDragState.cumulativeDelta < 0) {
                    if (dividerDragState.virtualIndex <= 0) break;
                    const targetIndex = dividerDragState.virtualIndex - 1;
                    const threshold = taskHeights[targetIndex];
                    if (!threshold || threshold < 10) break;

                    if (dividerDragState.cumulativeDelta < -threshold) {
                        dividerDragState.cumulativeDelta += threshold;
                        dividerDragState.virtualIndex--;
                        indexChanged = true;
                    } else break;
                }

                while (dividerDragState.cumulativeDelta > 0) {
                    if (dividerDragState.virtualIndex >= taskHeights.length) break;
                    const targetIndex = dividerDragState.virtualIndex;
                    const threshold = taskHeights[targetIndex];
                    if (!threshold || threshold < 10) break;

                    if (dividerDragState.cumulativeDelta > threshold) {
                        dividerDragState.cumulativeDelta -= threshold;
                        dividerDragState.virtualIndex++;
                        indexChanged = true;
                    } else break;
                }

                if (indexChanged || isMobile.value) {
                    const vIdx = dividerDragState.virtualIndex;
                    if (indexChanged) window.triggerTouchHaptic('Light');

                    taskEls.forEach((el, i) => {
                        let translateY = 0;
                        // å‘ä¸‹æ‹–ï¼šä¸­é—´çš„å¡ç‰‡å‘ä¸Šç§»
                        if (vIdx > startIndex) {
                            if (i >= startIndex && i < vIdx) translateY = -ghostHeight;
                        }
                        // å‘ä¸Šæ‹–ï¼šä¸­é—´çš„å¡ç‰‡å‘ä¸‹ç§»
                        else if (vIdx < startIndex) {
                            if (i >= vIdx && i < startIndex) translateY = ghostHeight;
                        }

                        if (translateY !== 0) {
                            el.style.transform = `translateY(${translateY}px)`;
                            el.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1)';
                        } else {
                            el.style.transform = '';
                            el.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1)';
                        }
                    });
                }

                handleTrackListAutoScroll(clientY);
            };

            // 3. ç»“æŸæ‹–æ‹½ (ä¿®å¤ç‰ˆï¼šå½»åº•æ¸…é™¤æ ·å¼æ®‹ç•™)
            const onDividerDragEnd = () => {
                if (dividerDragState) {
                    const {sectionIndex, startIndex, virtualIndex, taskEls, targetEl} = dividerDragState;

                    // ğŸŸ¢ 1. ç«‹å³æ¸…é™¤æ‰€æœ‰è§†è§‰åç§» (é˜²æ­¢ Vue å¤ç”¨å¸¦åç§»æ ·å¼çš„ DOM)
                    taskEls.forEach(el => {
                        el.style.transform = '';
                        el.style.transition = 'none'; // ç¦ç”¨åŠ¨ç”»ï¼Œç«‹å³å¤ä½
                    });

                    // ğŸŸ¢ 2. æ¢å¤åŸå§‹åˆ†å‰²æ¡æ˜¾ç¤º
                    if (targetEl) targetEl.style.opacity = '';

                    // 3. ç§»é™¤æ›¿èº«
                    if (dividerDragState.ghost && document.body.contains(dividerDragState.ghost)) {
                        document.body.removeChild(dividerDragState.ghost);
                    }

                    // ğŸŸ¢ 4. å»¶è¿Ÿä¸€å¸§æ‰§è¡Œæ•°æ®æ›´æ–°
                    // è¿™æ ·å¯ä»¥ç¡®ä¿ä¸Šé¢çš„ style.transform = '' å·²ç»ç”Ÿæ•ˆ
                    // å¦åˆ™ Vue å¯èƒ½ä¼šå¤ç”¨ä¸€ä¸ªè¿˜å¸¦æœ‰ translateY çš„å…ƒç´ ï¼Œå¯¼è‡´ä½ç½®å åŠ é”™è¯¯
                    requestAnimationFrame(() => {
                        if (virtualIndex !== startIndex) {
                            const diff = virtualIndex - startIndex;
                            const direction = diff > 0 ? 'down' : 'up';
                            const moves = Math.abs(diff);

                            // æ‰¹é‡ä¿®æ”¹æ•°æ®
                            for (let i = 0; i < moves; i++) {
                                moveDivider(sectionIndex, direction, false);
                            }
                            pushHistory();
                        }
                    });
                }

                dividerDragState = null;
                draggingSectionIndex.value = null;
                stopTrackListAutoScroll();

                window.removeEventListener('touchmove', onDividerDragMove);
                window.removeEventListener('touchend', onDividerDragEnd);
                window.removeEventListener('touchcancel', onDividerDragEnd);
                window.removeEventListener('mousemove', onDividerDragMove);
                window.removeEventListener('mouseup', onDividerDragEnd);
                window.removeEventListener('mousemove', onDividerDragMove);
                window.removeEventListener('mouseup', onDividerDragEnd);
            };

            // ğŸŸ¢ æ–°å¢: åŒæ­¥çŠ¶æ€
            const isSyncing = ref(false);

// ğŸŸ¢ æ–°å¢: æ‰‹åŠ¨åŒæ­¥å‡½æ•°
            const handleManualSync = async () => {
                if (!user.value) {
                    return openAlertModal("è¯·å…ˆç™»å½•", "åªæœ‰ç™»å½•åæ‰èƒ½åŒæ­¥äº‘ç«¯æ•°æ®ã€‚");
                }

                if (isSyncing.value) return; // é˜²æ­¢é‡å¤ç‚¹å‡»

                isSyncing.value = true;
                window.triggerTouchHaptic('Medium'); // éœ‡åŠ¨åé¦ˆ

                try {
                    // å¤ç”¨å·²æœ‰çš„ loadCloudData å‡½æ•°
                    await loadCloudData();

                    // ç¨å¾®å»¶è¿Ÿä¸€ç‚¹ï¼Œè®©åŠ¨ç”»è½¬å®Œï¼Œç»™ç”¨æˆ·ä¸€ç§"å·²å®Œæˆ"çš„å®æ„Ÿ
                    setTimeout(() => {
                        isSyncing.value = false;
                        window.triggerTouchHaptic('Success');
                        // å¯é€‰ï¼šå¦‚æœä¸å¸Œæœ›æ¯æ¬¡éƒ½å¼¹çª—ï¼Œå¯ä»¥åªç”¨éœ‡åŠ¨åé¦ˆï¼Œæˆ–è€…ç”¨ä¸€ä¸ªå°Toast
                        // openAlertModal("åŒæ­¥å®Œæˆ", "å·²æ‹‰å–æœ€æ–°çš„äº‘ç«¯æ•°æ®ã€‚");
                    }, 500);

                } catch (e) {
                    isSyncing.value = false;
                    window.triggerTouchHaptic('Error');
                    openAlertModal("åŒæ­¥å¤±è´¥", "ç½‘ç»œè¿æ¥å¼‚å¸¸æˆ–æœåŠ¡ä¸å¯ç”¨ã€‚");
                }
            };

            // 4. è‡ªåŠ¨æ»šåŠ¨é€»è¾‘ (ç¨å¾®è°ƒæ•´äº†ä¸€ä¸‹å‚æ•°ä»¥é…åˆ fixed å®šä½çš„ ghost)
            const handleTrackListAutoScroll = (clientY) => {
                const container = trackListContainerRef.value;
                if (!container) return;

                const rect = container.getBoundingClientRect();
                const edgeSize = 60;
                const maxSpeed = 15;

                stopTrackListAutoScroll();

                let scrollSpeed = 0;
                // åªæœ‰å½“æ›¿èº«åœ¨å®¹å™¨èŒƒå›´å†…æ—¶æ‰è§¦å‘æ»šåŠ¨ï¼Œé˜²æ­¢æ— é™æ»š
                if (clientY < rect.top + edgeSize && clientY > rect.top - 50) {
                    const intensity = Math.max(0, (rect.top + edgeSize - clientY) / edgeSize);
                    scrollSpeed = -maxSpeed * intensity;
                } else if (clientY > rect.bottom - edgeSize && clientY < rect.bottom + 50) {
                    const intensity = Math.max(0, (clientY - (rect.bottom - edgeSize)) / edgeSize);
                    scrollSpeed = maxSpeed * intensity;
                }

                if (scrollSpeed !== 0) {
                    trackListScrollTimer = requestAnimationFrame(function scrollLoop() {
                        if (scrollSpeed !== 0 && container) {
                            container.scrollTop += scrollSpeed;
                            // æ³¨æ„ï¼šå› ä¸º Ghost æ˜¯ fixed å®šä½ï¼Œå®ƒä¸å—å®¹å™¨ scroll å½±å“ï¼Œ
                            // æ‰€ä»¥è¿™é‡Œä¸éœ€è¦åƒä¹‹å‰é‚£æ ·è¡¥å¿ startYï¼Œè§†è§‰ä¸Šæ˜¯è§£è€¦çš„ã€‚
                            trackListScrollTimer = requestAnimationFrame(scrollLoop);
                        }
                    });
                }
            };

            const stopTrackListAutoScroll = () => {
                if (trackListScrollTimer) {
                    cancelAnimationFrame(trackListScrollTimer);
                    trackListScrollTimer = null;
                }
            };

            const confirmDurationPicker = () => {
                if (pickerCallback) pickerCallback(false);
                showDurationPicker.value = false;
            };

            // ğŸŸ¢ æ–°å¢: é‡ç½®åŠŸèƒ½
            const resetDuration = () => {
                if (pickerCallback) pickerCallback(true); // ä¼  true æ¸…ç©º
                showDurationPicker.value = false;
            };

            // 1. è§¦æ‘¸å¼€å§‹ (ä¿®æ”¹ä¸ºè®°å½•åƒç´ åç§»)
            const handleTouchStart = (e, task, dateStr) => {
                if (!isMobile.value) return;

                dragSourceType = 'schedule';

                const touch = e.touches[0];
                const targetEl = e.currentTarget;

                startX = touch.clientX;
                startY = touch.clientY;
                dragSourceTask = task;
                dragStartDate = dateStr;

                const rect = targetEl.getBoundingClientRect();
                cloneOffsetX = touch.clientX - rect.left;
                cloneOffsetY = touch.clientY - rect.top;
                dragClickOffsetY = touch.clientY - rect.top;

                longPressTimeout = setTimeout(() => {
                    // ğŸŸ¢ ä¿®æ”¹: åªæœ‰éå¹½çµä»»åŠ¡æ‰å…è®¸æ‹–æ‹½
                    // å¹½çµä»»åŠ¡è™½ç„¶ä¸èƒ½æ‹–æ‹½ï¼Œä½†å‰é¢çš„ä»£ç å·²ç»è®°å½•äº† dragSourceTask
                    // æ‰€ä»¥ touchend é‡Œçš„åŒå‡»æ£€æµ‹ä¾ç„¶æœ‰æ•ˆ
                    if (!isTaskGhost(task)) {
                        startMobileDrag(targetEl, touch);
                    }
                }, 300);
            };

            // ğŸŸ¢ ä¿®å¤: è§¦æ‘¸å¼€å§‹ (é˜²è¯¯è§¦ + æ™ºèƒ½çŠ¶æ€åˆ¤æ–­)
            const handlePoolTouchStart = (e, item, type = 'pool') => {
                if (!isMobile.value) return;

                // ğŸ›‘ 1. å½»åº•ç¦æ­¢å°å¡ç‰‡æ‹–åŠ¨ (é˜²æ­¢åˆ—è¡¨æ»‘åŠ¨è¯¯è§¦)
                if (type === 'pool') return;

                // ğŸ›‘ 2. å¤§å¡ç‰‡ (aggregate) çŠ¶æ€æ£€æŸ¥
                if (type === 'aggregate') {
                    // å¦‚æœå·²å®Œæˆæˆ–å·²æ’æ»¡ -> ç¦æ­¢æ‹–åŠ¨ï¼Œåªç»™æ‹’ç»åé¦ˆ
                    if (item.statusKey === 'completed' || item.statusKey === 'full' || item.statusKey === 'in-progress') {
                        // ğŸ“³ éœ‡åŠ¨ä¸¤ä¸‹ï¼Œæç¤ºç”¨æˆ·â€œæ­¤äººå·²æå®šï¼Œæ— éœ€å®‰æ’â€
                        //window.triggerTouchHaptic('Medium');
                        //setTimeout(() => window.triggerTouchHaptic('Medium'), 150);
                        return;
                    }
                }

                // --- ä»¥ä¸‹æ˜¯å…è®¸æ‹–åŠ¨çš„æƒ…å†µ (å¤§å¡ç‰‡ && æ—¶é—´ä¸è¶³/æœªæ’æœŸ) ---
                dragSourceType = type;

                const touch = e.touches[0];
                const targetEl = e.currentTarget;

                startX = touch.clientX;
                startY = touch.clientY;
                dragSourceTask = item;

                const rect = targetEl.getBoundingClientRect();
                cloneOffsetX = touch.clientX - rect.left;
                cloneOffsetY = touch.clientY - rect.top;
                dragClickOffsetY = touch.clientY - rect.top;

                // å¯åŠ¨é•¿æŒ‰è®¡æ—¶å™¨
                longPressTimeout = setTimeout(() => {
                    startMobileDrag(targetEl, touch);

                    mobileTab.value = 'schedule'; // è·³è½¬åˆ°æ—¥ç¨‹è¡¨
                    window.triggerTouchHaptic('Heavy'); // æˆåŠŸè§¦å‘éœ‡åŠ¨
                }, 300);
            };

            // ğŸŸ¢ ä¿®æ”¹: handleTouchMove (å¢åŠ å‘¨è§†å›¾è¾¹ç¼˜ç¿»é¡µåŠŸèƒ½)
            const handleTouchMove = (e) => {
                const touch = e.touches[0];

                // A. å¦‚æœè¿˜åœ¨é•¿æŒ‰æ£€æµ‹é˜¶æ®µ
                if (longPressTimeout && !dragElClone) {
                    const deltaX = Math.abs(touch.clientX - startX);
                    const deltaY = Math.abs(touch.clientY - startY);

                    // å¦‚æœæ‰‹æŒ‡ç§»åŠ¨è¶…è¿‡ 10pxï¼Œè§†ä¸ºç”¨æˆ·æƒ³æ»šåŠ¨å±å¹•ï¼Œå–æ¶ˆé•¿æŒ‰
                    if (deltaX > 10 || deltaY > 10) {
                        clearTimeout(longPressTimeout);
                        longPressTimeout = null;
                    }
                    return;
                }

                // B. å¦‚æœå·²ç»å¼€å§‹æ‹–æ‹½
                if (dragElClone) {
                    // ç¦ç”¨å±å¹•æ»šåŠ¨
                    if (e.cancelable) e.preventDefault();

                    // 1. ç§»åŠ¨å…‹éš†ä½“
                    const x = touch.clientX - cloneOffsetX;
                    const y = touch.clientY - cloneOffsetY;
                    dragElClone.style.transform = `translate3d(${x}px, ${y}px, 0)`;

                    // 2. è§†å›¾è‡ªåŠ¨æ»šåŠ¨ä¸ç¿»é¡µæ£€æµ‹
                    const scrollContainer = weekContainer.value;

                    // --- å‘¨è§†å›¾é€»è¾‘ ---
                    if (currentView.value === 'week' && scrollContainer) {
                        // [Part A] ç°æœ‰çš„å…¨å‘è‡ªåŠ¨æ»šåŠ¨ (ä¿æŒä¸å˜)
                        let vx = 0, vy = 0;
                        if (isMobile.value) {
                            const topZone = 500;
                            const bottomZone = window.innerHeight - 150;
                            const leftZone = 60;
                            const rightZone = window.innerWidth - 60;
                            const ramp = 80;

                            if (touch.clientY < topZone) vy = -Math.min(1, (topZone - touch.clientY) / ramp);
                            else if (touch.clientY > bottomZone) vy = Math.min(1, (touch.clientY - bottomZone) / ramp);

                            if (touch.clientX < leftZone) vx = -Math.min(1, (leftZone - touch.clientX) / ramp);
                            else if (touch.clientX > rightZone) vx = Math.min(1, (touch.clientX - rightZone) / ramp);
                        }

                        if (Math.abs(vx) > 0.05 || Math.abs(vy) > 0.05) {
                            if (!autoScrollInterval) startAutoScroll(vx, vy, scrollContainer, scrollContainer);
                            else updateAutoScrollDirection(vx, vy);
                        } else {
                            stopAutoScroll();
                        }

                        // [Part B] æ–°å¢: å‘¨è§†å›¾è¾¹ç¼˜ç¿»é¡µ (ä»¿æœˆè§†å›¾é€»è¾‘)
                        const edgeThreshold = 50; // è¾¹ç¼˜è§¦å‘åŒºåŸŸå¤§å°
                        let switchDir = 0;

                        // æ£€æµ‹å·¦å³è¾¹ç¼˜
                        if (touch.clientX < edgeThreshold) {
                            switchDir = -1; // ä¸Šä¸€å‘¨
                        } else if (touch.clientX > window.innerWidth - edgeThreshold) {
                            switchDir = 1;  // ä¸‹ä¸€å‘¨
                        }

                        if (switchDir !== 0) {
                            // å¦‚æœæ‰‹æŒ‡åœ¨è¾¹ç¼˜ï¼Œä¸”æ²¡æœ‰æ­£åœ¨ç­‰å¾…çš„ç¿»é¡µå®šæ—¶å™¨
                            if (!monthSwitchTimer) {
                                monthSwitchTimer = setTimeout(() => {
                                    changeDate(switchDir); // æ‰§è¡Œç¿»é¡µ (changeDate ä¼šè‡ªåŠ¨å¤„ç† +7/-7 å¤©)
                                    window.triggerTouchHaptic('Medium'); // éœ‡åŠ¨åé¦ˆ

                                    // ç¿»é¡µåé‡ç½®å®šæ—¶å™¨ï¼Œå…è®¸è¿ç»­ç¿»é¡µ
                                    monthSwitchTimer = null;
                                }, 800); // åœç•™ 800ms åè§¦å‘
                            }
                        } else {
                            // ç¦»å¼€è¾¹ç¼˜ï¼Œå–æ¶ˆå®šæ—¶å™¨
                            if (monthSwitchTimer) {
                                clearTimeout(monthSwitchTimer);
                                monthSwitchTimer = null;
                            }
                        }
                    }

                    // --- æœˆè§†å›¾é€»è¾‘ (ä¿æŒä¸å˜) ---
                    else if (currentView.value === 'month' && isMobile.value) {
                        const edgeThreshold = 50;
                        let switchDir = 0;
                        if (touch.clientX < edgeThreshold) switchDir = -1;
                        else if (touch.clientX > window.innerWidth - edgeThreshold) switchDir = 1;

                        if (switchDir !== 0) {
                            if (!monthSwitchTimer) {
                                monthSwitchTimer = setTimeout(() => {
                                    changeDate(switchDir);
                                    window.triggerTouchHaptic('Medium');
                                    monthSwitchTimer = null;
                                }, 800);
                            }
                        } else {
                            if (monthSwitchTimer) {
                                clearTimeout(monthSwitchTimer);
                                monthSwitchTimer = null;
                            }
                        }
                    }

                    // 3. é«˜äº®æ˜¾ç¤ºä¸‹æ–¹çš„æ ¼å­
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (activeDropSlot) activeDropSlot.classList.remove('drag-over');
                    activeDropSlot = null;

                    if (target) {
                        const slot = target.closest('.grid-slot, .droppable-slot');
                        if (slot) {
                            activeDropSlot = slot;
                            activeDropSlot.classList.add('drag-over');
                        }
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: handleTouchEnd
            const handleTouchEnd = (e) => {
                if (longPressTimeout) {
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;

                    // --- åŒå‡»æ£€æµ‹é€»è¾‘ START ---
                    if (!dragElClone && dragSourceType === 'schedule' && dragSourceTask) {
                        const now = Date.now();

                        // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªä»»åŠ¡ï¼Œä¸”é—´éš”å°äº 300ms (åˆ¤å®šä¸ºåŒå‡»)
                        if (lastTapState.id === dragSourceTask.scheduleId && (now - lastTapState.time) < 300) {
                            // ... (åŸæœ‰çš„åŒå‡»å¤„ç†é€»è¾‘ä¿æŒä¸å˜) ...
                            handleTaskDblClick(e, dragSourceTask);

                            lastTapState.id = null;
                            lastTapState.time = 0;
                        } else {
                            // ç¬¬ä¸€æ¬¡ç‚¹å‡» (åˆ¤å®šä¸ºå•å‡»)
                            lastTapState.id = dragSourceTask.scheduleId;
                            lastTapState.time = now;

                            // ğŸŸ¢ æ ¸å¿ƒä¿®å¤: åœ¨è¿™é‡Œæ‰‹åŠ¨è§¦å‘é€‰ä¸­ï¼
                            // è¿™æ ·æ‰‹æŒ‡ä¸€ç¦»å¼€å±å¹•å°±ä¼šé€‰ä¸­ï¼Œä¸å†éœ€è¦ä¾èµ–æµè§ˆå™¨çš„ click äº‹ä»¶
                            selectTask(dragSourceTask.scheduleId, 'schedule');
                        }
                    }
                    // --- ğŸŸ¢ æ–°å¢: åŒå‡»æ£€æµ‹é€»è¾‘ END ---
                }

                stopAutoScroll();

                if (monthSwitchTimer) {
                    clearTimeout(monthSwitchTimer);
                    monthSwitchTimer = null;
                }

                if (dragElClone) {
                    document.body.removeChild(dragElClone);
                    dragElClone = null;
                    if (activeDropSlot) activeDropSlot.classList.remove('drag-over');

                    const touch = e.changedTouches[0];
                    const targetEl = document.elementFromPoint(touch.clientX, touch.clientY);

                    const dropColumn = targetEl ? targetEl.closest('[data-date-str]') : null;
                    const dropMonthCell = targetEl ? targetEl.closest('[data-date]') : null;

                    // --- æƒ…å†µ A: æ”¾ç½®åœ¨å‘¨è§†å›¾ ---
                    if (dropColumn) {
                        const dateStr = dropColumn.dataset.dateStr;
                        const timeGridContainer = dropColumn.querySelector('.relative[style*="min-height"]');

                        if (timeGridContainer && dragSourceTask) {
                            // 1. è®¡ç®—ç›®æ ‡æ—¶é—´
                            const gridRect = timeGridContainer.getBoundingClientRect();
                            const touchYInContainer = touch.clientY - gridRect.top;
                            const taskTopPixel = touchYInContainer - dragClickOffsetY;
                            const minsFromStart = taskTopPixel / pxPerMin.value;
                            let totalMins = (settings.startHour * 60) + minsFromStart;
                            const snappedMins = Math.round(totalMins / 30) * 30;
                            const minMins = settings.startHour * 60;
                            const maxMins = settings.endHour * 60 - 30;
                            const finalMins = Math.max(minMins, Math.min(maxMins, snappedMins));
                            const h = Math.floor(finalMins / 60);
                            const m = finalMins % 60;
                            const newTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

                            // 2. å‡†å¤‡æ£€æµ‹å‚æ•°
                            let checkType = 'musician';
                            let checkDuration = '';
                            let excludeId = null;

                            // åˆ¤æ–­ç±»å‹å’Œæ—¶é•¿
                            if (dragSourceType === 'aggregate') {
                                checkType = sidebarTab.value;
                                const item = dragSourceTask;
                                const remainingSecs = item.totalSeconds - item.scheduledSeconds;
                                if (remainingSecs <= 0) return; // æ²¡æ—¶é—´äº†ï¼Œç›´æ¥é€€å‡º
                                let remainingMins = Math.ceil(remainingSecs / 1800) * 30;
                                if (remainingMins === 0) remainingMins = 30;
                                checkDuration = formatSecs(remainingMins * 60);
                            } else if (dragSourceType === 'pool') {
                                const item = dragSourceTask;
                                if (item.projectId) checkType = 'project';
                                else if (item.instrumentId) checkType = 'instrument';
                                else checkType = 'musician';
                                checkDuration = item.estDuration;
                            } else {
                                // schedule
                                const item = dragSourceTask;
                                if (item.projectId) checkType = 'project';
                                else if (item.instrumentId) checkType = 'instrument';
                                else checkType = 'musician';
                                checkDuration = item.estDuration;
                                excludeId = item.scheduleId; // æ’é™¤è‡ªå·±ï¼Œç§»åŠ¨æ—¶ä¸ç®—å†²çª
                            }

                            // 3. æ‰§è¡Œå†²çªæ£€æµ‹
                            if (checkOverlap(dateStr, newTime, checkDuration, excludeId, checkType)) {
                                openAlertModal('æ—¶é—´å†²çª', 'è¯¥æ—¶é—´æ®µå·²æœ‰é‡å çš„å®‰æ’ã€‚');
                                window.triggerTouchHaptic('Error');
                                if (dragSourceEl) dragSourceEl.style.opacity = '';
                                dragSourceEl = null;
                                activeDropSlot = null;
                                return; // â›”ï¸ å‘ç”Ÿå†²çªï¼Œç»ˆæ­¢æ“ä½œ
                            }

                            // 4. é€šè¿‡æ£€æµ‹ï¼Œæ‰§è¡Œæ”¾ç½®
                            if (dragSourceType === 'aggregate') {
                                const item = dragSourceTask;
                                // æ—¶é•¿é€»è¾‘ä¸Šé¢å·²ç»ç®—è¿‡ä¸€æ¬¡ï¼Œè¿™é‡Œå¤ç”¨
                                const remainingSecs = item.totalSeconds - item.scheduledSeconds;
                                let remainingMins = Math.ceil(remainingSecs / 1800) * 30;
                                if (remainingMins === 0) remainingMins = 30;

                                const nt = {
                                    scheduleId: Date.now(),
                                    sessionId: currentSessionId.value,
                                    musicianId: sidebarTab.value === 'musician' ? item.id : '',
                                    projectId: sidebarTab.value === 'project' ? item.id : '',
                                    instrumentId: sidebarTab.value === 'instrument' ? item.id : '',
                                    date: dateStr,
                                    startTime: newTime,
                                    estDuration: formatSecs(remainingMins * 60),
                                    trackCount: item.trackCount,
                                    ratio: item.defaultRatio || 20
                                };
                                scheduledTasks.value.push(nt);
                                window.triggerTouchHaptic('Success');
                                pushHistory();
                            } else if (dragSourceType === 'pool') {
                                const newTask = {
                                    scheduleId: Date.now(),
                                    sessionId: currentSessionId.value,
                                    projectId: dragSourceTask.projectId,
                                    instrumentId: dragSourceTask.instrumentId,
                                    musicianId: dragSourceTask.musicianId,
                                    musicDuration: dragSourceTask.musicDuration,
                                    ratio: dragSourceTask.ratio,
                                    estDuration: dragSourceTask.estDuration,
                                    date: dateStr,
                                    startTime: newTime
                                };
                                scheduledTasks.value.push(newTask);
                                window.triggerTouchHaptic('Success');
                                pushHistory();
                            } else {
                                // æ—¥ç¨‹å†…éƒ¨ç§»åŠ¨
                                if (dragSourceTask.startTime !== newTime || dragSourceTask.date !== dateStr) {
                                    dragSourceTask.startTime = newTime;
                                    dragSourceTask.date = dateStr;
                                    window.triggerTouchHaptic('Success');
                                    pushHistory();
                                }
                            }
                        }
                    }
                    // --- æƒ…å†µ B: æ”¾ç½®åœ¨æœˆè§†å›¾ ---
                    else if (dropMonthCell && dragSourceTask) {
                        const dateStr = dropMonthCell.dataset.date;

                        // æœˆè§†å›¾ç®€å•å¤„ç†ï¼šå¦‚æœæ˜¯æ—¥ç¨‹å†…éƒ¨ç§»åŠ¨ï¼Œåªæ”¹æ—¥æœŸï¼Œé€šå¸¸ä¸æ£€æµ‹å…·ä½“æ—¶é—´å†²çª(å› ä¸ºæœˆè§†å›¾ä¸æ˜¾ç¤ºå…·ä½“æ—¶é—´è½´)
                        // ä½†å¦‚æœæ‚¨å¸Œæœ›ä¸¥æ ¼æ§åˆ¶ï¼Œå¯ä»¥å‡è®¾æ—¶é—´ä¸å˜è¿›è¡Œæ£€æµ‹ã€‚
                        // è¿™é‡Œä¸ºäº†ä½“éªŒæµç•…ï¼Œæš‚æ—¶åªæ£€æµ‹æ—¥æœŸå˜æ›´ï¼Œä¿ç•™åŸæ—¶é—´ã€‚

                        if (dragSourceType === 'schedule') {
                            if (dragSourceTask.date !== dateStr) {
                                // ä¹Ÿå¯ä»¥åœ¨è¿™é‡ŒåŠ  checkOverlapï¼Œå‡è®¾æ—¶é—´ä¸å˜
                                // if (checkOverlap(dateStr, dragSourceTask.startTime, dragSourceTask.estDuration, dragSourceTask.scheduleId, ...)) ...

                                dragSourceTask.date = dateStr;
                                window.triggerTouchHaptic('Success');
                                pushHistory();
                            }
                        } else if (dragSourceType === 'aggregate' || dragSourceType === 'pool') {
                            const item = dragSourceTask;
                            let mId = '', pId = '', iId = '';
                            let ratio = 20;
                            let estDur = '00:30';
                            let tCount = 0;
                            let musDur = '';
                            let checkType = 'musician';

                            if (dragSourceType === 'pool') {
                                mId = item.musicianId;
                                pId = item.projectId;
                                iId = item.instrumentId;
                                ratio = item.ratio;
                                estDur = item.estDuration;
                                musDur = item.musicDuration;
                                if (pId) checkType = 'project'; else if (iId) checkType = 'instrument';
                            } else {
                                if (sidebarTab.value === 'musician') mId = item.id;
                                else if (sidebarTab.value === 'project') {
                                    pId = item.id;
                                    checkType = 'project';
                                } else if (sidebarTab.value === 'instrument') {
                                    iId = item.id;
                                    checkType = 'instrument';
                                }
                                ratio = item.defaultRatio || 20;
                                estDur = item.estDuration || '00:30';
                                tCount = item.trackCount || 0;
                            }

                            // é»˜è®¤æ’åœ¨å¼€å¤´ï¼Œæ£€æµ‹å†²çª
                            const defaultStart = settings.startHour + ':00';
                            if (checkOverlap(dateStr, defaultStart, estDur, null, checkType)) {
                                openAlertModal('å†²çª', 'è¯¥æ—¥æœŸå·²æœ‰å®‰æ’ï¼Œè¯·åˆ‡æ¢åˆ°å‘¨è§†å›¾æŸ¥çœ‹è¯¦æƒ…ã€‚');
                                window.triggerTouchHaptic('Error');
                            } else {
                                const nt = {
                                    scheduleId: Date.now(),
                                    sessionId: currentSessionId.value,
                                    musicianId: mId, projectId: pId, instrumentId: iId,
                                    date: dateStr, startTime: defaultStart,
                                    estDuration: estDur, trackCount: tCount, ratio: ratio, musicDuration: musDur
                                };
                                scheduledTasks.value.push(nt);
                                window.triggerTouchHaptic('Success');
                                pushHistory();
                            }
                        }
                    }
                }

                if (dragSourceEl) {
                    dragSourceEl.style.opacity = '';
                    dragSourceEl = null;
                }
                activeDropSlot = null;
            };

            // 1. å¯åŠ¨æ»šåŠ¨
            const startAutoScroll = (vx, vy, xContainer, yContainer) => {
                if (autoScrollInterval) return;

                currentScrollSpeed.x = vx;
                currentScrollSpeed.y = vy;

                // ğŸŸ¢ æœ€å¤§æé€Ÿ (åƒç´ /å¸§)
                // å› ä¸º vx/vy ç°åœ¨æ˜¯ 0~1 çš„å°æ•°ï¼Œè¿™é‡Œè®¾å¤§ä¸€ç‚¹ï¼Œæ¯”å¦‚ 20
                const maxSpeed = 25;

                autoScrollInterval = setInterval(() => {
                    isScrollingProgrammatically = true;

                    // --- å‚ç›´æ»šåŠ¨ (Y) ---
                    // é€Ÿåº¦ = å‘é‡å€¼ * æœ€å¤§æé€Ÿ
                    if (Math.abs(currentScrollSpeed.y) > 0 && yContainer) {
                        yContainer.scrollTop += currentScrollSpeed.y * maxSpeed;
                    }

                    // --- æ°´å¹³æ»šåŠ¨ (X) ---
                    if (Math.abs(currentScrollSpeed.x) > 0 && xContainer) {
                        xContainer.scrollLeft += currentScrollSpeed.x * maxSpeed;
                    }

                    setTimeout(() => {
                        isScrollingProgrammatically = false;
                    }, 50);

                }, 16); // çº¦ 60fps
            };

            const updateAutoScrollDirection = (vx, vy) => {
                currentScrollSpeed.x = vx;
                currentScrollSpeed.y = vy;
            };

            // stopAutoScroll ä¿æŒä¸å˜
            const stopAutoScroll = () => {
                if (autoScrollInterval) {
                    clearInterval(autoScrollInterval);
                    autoScrollInterval = null;
                    currentScrollSpeed.x = 0;
                    currentScrollSpeed.y = 0;
                    isScrollingProgrammatically = false;
                }
            };

            // 1. åˆå§‹åŒ–æ‹–åŠ¨
            const initMobileResize = (e, task) => {
                if (!isMobile.value) return;

                // é˜»æ­¢å†’æ³¡
                e.stopPropagation();
                // éœ‡åŠ¨åé¦ˆ
                window.triggerTouchHaptic('Heavy');

                const touch = e.touches[0];
                const taskEl = e.target.closest('.task-block');
                const rect = taskEl.getBoundingClientRect();

                // åˆå§‹åŒ–çŠ¶æ€
                isResizingMobile.value = true;
                mobileResizeState.task = task;
                mobileResizeState.taskEl = taskEl;
                mobileResizeState.startY = touch.clientY;
                mobileResizeState.startHeight = rect.height; // è®°å½•åˆå§‹é«˜åº¦
                mobileResizeState.originalDuration = task.estDuration; // è®°å½•åŸå§‹æ—¶é•¿

                // ç»‘å®šäº‹ä»¶
                // ğŸŸ¢ å…³é”®ä¿®æ”¹ï¼šä¸éœ€è¦ captureï¼Œå› ä¸º touchmove æ²¡æœ‰è¢«é˜»æ­¢
                window.addEventListener('touchmove', handleMobileResizeMove, { passive: false });

                // ğŸŸ¢ æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ  true (ä½¿ç”¨æ•è·æ¨¡å¼)
                // è¿™æ ·å³ä½¿åº•ä¸‹çš„å…ƒç´ æœ‰ @touchend.stopï¼Œwindow ä¹Ÿèƒ½å…ˆæ”¶åˆ°é€šçŸ¥ï¼
                window.addEventListener('touchend', handleMobileResizeEnd, true);
                window.addEventListener('touchcancel', handleMobileResizeEnd, true);
            };

            // 2. æ‹–åŠ¨è¿‡ç¨‹ (å®æ—¶æ›´æ–°æ•°æ®)
            const handleMobileResizeMove = (e) => {
                if (!isResizingMobile.value) return;

                if (e.cancelable) e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤æ»šåŠ¨

                const touch = e.touches[0];
                const deltaY = touch.clientY - mobileResizeState.startY;

                // 1. è®¡ç®—ç›®æ ‡é«˜åº¦ (åƒç´ )
                const targetHeight = Math.max(slotHeight.value, mobileResizeState.startHeight + deltaY);

                // 2. å¸é™„ç½‘æ ¼é€»è¾‘ (Snap)
                const stepPx = slotHeight.value;
                const snappedHeight = Math.round(targetHeight / stepPx) * stepPx;
                const finalSafeHeight = Math.max(stepPx, snappedHeight);

                // 3. è®¡ç®—æ—¶é—´
                const totalMins = Math.round(finalSafeHeight / pxPerMin.value);

                // 4. å®æ—¶æ›´æ–° Vue æ•°æ®
                const newDurationStr = formatSecs(totalMins * 60);

                if (mobileResizeState.task.estDuration !== newDurationStr) {
                    mobileResizeState.task.estDuration = newDurationStr;
                    window.triggerTouchHaptic('Light');
                }
            };

            // 3. æ‹–åŠ¨ç»“æŸ (æ ¸å¿ƒä¿®æ­£)
            const handleMobileResizeEnd = (e) => {
                // å¼ºåˆ¶ç«‹å³é‡ç½®çŠ¶æ€ (å¿…é¡»æ˜¯ç¬¬ä¸€æ­¥ï¼Œä»¥æœ€é«˜ä¼˜å…ˆçº§æ¸…é™¤æ ‡å¿—ä½)
                const wasResizing = isResizingMobile.value;
                isResizingMobile.value = false;

                // å¼ºåˆ¶æ— æ¡ä»¶ç§»é™¤ç›‘å¬å™¨ (å¿…é¡»æ˜¯ç¬¬äºŒæ­¥)
                window.removeEventListener('touchmove', handleMobileResizeMove);

                // ğŸŸ¢ æ ¸å¿ƒä¿®å¤ï¼šç§»é™¤æ—¶ä¹Ÿè¦å¸¦ä¸Š true (æ•è·æ¨¡å¼)
                window.removeEventListener('touchend', handleMobileResizeEnd, true);
                window.removeEventListener('touchcancel', handleMobileResizeEnd, true);

                if (resizeRaf) cancelAnimationFrame(resizeRaf);

                // å»¶è¿Ÿä¸€å°æ®µæ—¶é—´ï¼Œæ‰§è¡Œä¸€æ¬¡ DOM/CSS çº§åˆ«çš„é‡ç»˜æ“ä½œ
                requestAnimationFrame(() => {
                    document.body.style.display = 'none';
                    document.body.offsetHeight; // å¼ºåˆ¶æµè§ˆå™¨è®¡ç®—
                    document.body.style.display = '';

                    const taskEl = mobileResizeState.taskEl;
                    if (taskEl) {
                        taskEl.style.opacity = '';
                        taskEl.style.transition = '';
                    }
                });

                // åªæœ‰ç¡®å®šæ˜¯æ‹–æ‹½æ“ä½œæ—¶ï¼Œæ‰æ‰§è¡Œè€—æ—¶çš„å†²çªæ£€æµ‹å’Œæ•°æ®ä¿å­˜
                if (wasResizing) {
                    setTimeout(() => {
                        const t = mobileResizeState.task;
                        // ğŸŸ¢ é˜²å¾¡æ€§ç¼–ç¨‹ï¼šé˜²æ­¢ t ä¸ºç©ºå¯¼è‡´æŠ¥é”™
                        if (!t) return;

                        const newDurationStr = t.estDuration;
                        let type = 'musician';
                        if (t.projectId) type = 'project';
                        else if (t.instrumentId) type = 'instrument';

                        // æ‰§è¡Œå†²çªæ£€æµ‹
                        if (checkOverlap(t.date, t.startTime, newDurationStr, t.scheduleId, type)) {
                            t.estDuration = mobileResizeState.originalDuration; // å†²çªå›é€€
                            openAlertModal('å†²çª', 'è°ƒæ•´åçš„æ—¶é—´ä¸ç°æœ‰ä»»åŠ¡å†²çª');
                            window.triggerTouchHaptic('Error');
                        } else {
                            // æ— å†²çªåˆ™ä¿å­˜
                            const m = parseTime(t.musicDuration);
                            const r = parseTime(t.estDuration);
                            if (m > 0) t.ratio = (r / m).toFixed(1);
                            pushHistory();
                            window.triggerTouchHaptic('Success');
                        }

                        // ç¡®ä¿æ¸…é™¤å¼•ç”¨
                        mobileResizeState.task = null;
                    }, 0);
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: calcTrackDiff æ”¯æŒå¤šç»´åº¦
            const calcTrackDiff = (item) => {
                // 1. è·å–å½“å‰è§†å›¾ç±»å‹
                const viewType = trackListData.value.viewType || 'musician';

                // 2. è·å–å¯¹åº”è®°å½•å¯¹è±¡
                const record = item.records[viewType];
                if (!record) return;

                if (record.recStart && record.recEnd) {
                    const [sh, sm] = record.recStart.split(':').map(Number);
                    const [eh, em] = record.recEnd.split(':').map(Number);

                    let startMins = sh * 60 + sm;
                    let endMins = eh * 60 + em;

                    if (endMins < startMins) endMins += 24 * 60;

                    let diffMins = endMins - startMins;

                    if (record.breakMinutes && record.breakMinutes > 0) {
                        diffMins -= parseInt(record.breakMinutes);
                    }

                    if (diffMins < 0) diffMins = 0;
                    const diffSecs = diffMins * 60;

                    // 3. å†™å…¥å¯¹åº”è®°å½•
                    record.actualDuration = formatSecs(diffSecs);

                    // è§¦å‘ä¿å­˜ (æ³¨æ„ saveTrackRecord ä¹Ÿéœ€è¦ä¿®æ”¹)
                    saveTrackRecord(item);

                    autoResizeScheduleByRecords(true);
                }
            };

            const setTrackBreak = (item) => {
                const viewType = trackListData.value.viewType || 'musician';
                const record = item.records[viewType]; // è·å–å¯¹åº”è®°å½•

                openInputModal(
                    'è®¾ç½®ä¸­æ–­/ä¼‘æ¯æ—¶é•¿',
                    record.breakMinutes ? String(record.breakMinutes) : '',
                    'è¯·è¾“å…¥åˆ†é’Ÿæ•°',
                    (val) => {
                        const mins = parseInt(val);
                        record.breakMinutes = (isNaN(mins) || mins < 0) ? 0 : mins;
                        calcTrackDiff(item);
                        pushHistory();
                    },
                    'è¿™æ®µæ—¶é—´å°†ä»æ€»å½•åˆ¶æ—¶é•¿ä¸­æ‰£é™¤'
                );
            };

            // 4. è¾…åŠ©å‡½æ•°ï¼šå¯åŠ¨æ‹–æ‹½æ¨¡å¼
            const startMobileDrag = (originalEl, touch) => {
                // 1. è®°å½•å¹¶å˜æ·¡åŸå…ƒç´ 
                dragSourceEl = originalEl;
                dragSourceEl.style.opacity = '0.3'; // å˜æ·¡ï¼Œæç¤ºç”¨æˆ·å®ƒè¢«â€œæ‹¿â€èµ·æ¥äº†

                window.triggerTouchHaptic('Medium');

                // 2. åˆ›å»ºå…‹éš†ä½“ (ä¿æŒä¹‹å‰çš„é€»è¾‘ä¸å˜)
                dragElClone = originalEl.cloneNode(true);

                // è®¾ç½®å…‹éš†ä½“æ ·å¼ (å›ºå®šå®šä½ï¼Œæµ®åœ¨æœ€ä¸Šå±‚)
                Object.assign(dragElClone.style, {
                    position: 'fixed',
                    top: '0',
                    left: '0',
                    width: `${originalEl.offsetWidth}px`,
                    height: `${originalEl.offsetHeight}px`,
                    zIndex: '9999',
                    opacity: '0.9',
                    pointerEvents: 'none', // å…³é”®ï¼šè®©è§¦æ‘¸äº‹ä»¶ç©¿é€å…‹éš†ä½“
                    transform: `translate3d(${touch.clientX - cloneOffsetX}px, ${touch.clientY - cloneOffsetY}px, 0)`,
                    boxShadow: '0 10px 20px rgba(0,0,0,0.3)',
                    transition: 'none' // ç¦æ­¢è¿‡æ¸¡åŠ¨ç”»ï¼Œä¿è¯è·Ÿéšæ‰‹æŒ‡æ— å»¶è¿Ÿ
                });
                dragElClone.style.opacity = '0.9';

                // æ·»åŠ åˆ° Body
                document.body.appendChild(dragElClone);
            };


            // ğŸŸ¢ å­˜å‚¨è§¦æ‘¸æ—¶çš„èµ·å§‹ç‚¹ï¼Œç”¨äºè®¡ç®—åç§»é‡
            const initialTouchCoords = reactive({x: 0, y: 0});

            // ğŸŸ¢ å­˜å‚¨è¢«æ‹–æ‹½å…ƒç´ çš„åŸå§‹ DOM å¼•ç”¨ (å¯é€‰ï¼Œä½†æœ‰åŠ©äºæŸäº›å¤æ‚æ“ä½œ)
            const draggingTaskElement = ref(null);

            // --- ğŸŸ¢ æ–°å¢ï¼šè·å– Capacitor æ’ä»¶å¼•ç”¨ ---
            // æ³¨æ„ï¼šè¿™é‡Œä¸èƒ½ç”¨ importï¼Œå¿…é¡»ä»å…¨å±€å¯¹è±¡å–
            const LocalNotifications = window.Capacitor ? window.Capacitor.Plugins.LocalNotifications : null;
            const Haptics = window.Capacitor ? window.Capacitor.Plugins.Haptics : null;

            // --- ğŸŸ¢ æ–°å¢ï¼šéœ‡åŠ¨ä¸é€šçŸ¥åŠŸèƒ½å‡½æ•° ---
            const scheduleReminder = async (title, body, delaySeconds = 5) => {
                // 1. å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœåœ¨æµè§ˆå™¨é‡Œè¿è¡Œï¼Œæ²¡æœ‰ Capacitor ç¯å¢ƒï¼Œç›´æ¥è¿”å›
                if (!LocalNotifications || !Haptics) {
                    console.log("é App ç¯å¢ƒï¼Œè·³è¿‡é€šçŸ¥");
                    return;
                }

                try {
                    // 2. è¯·æ±‚æƒé™
                    let perm = await LocalNotifications.checkPermissions();
                    if (perm.display === 'prompt') {
                        perm = await LocalNotifications.requestPermissions();
                    }
                    if (perm.display !== 'granted') {
                        openAlertModal("è¯·æˆæƒé€šçŸ¥æƒé™ï¼Œå¦åˆ™æ— æ³•æé†’ï¼");
                        return;
                    }

                    // 3. å®‰æ’é€šçŸ¥
                    const triggerTime = new Date(Date.now() + delaySeconds * 1000);
                    await LocalNotifications.schedule({
                        notifications: [{
                            title: title,
                            body: body,
                            id: Math.floor(Math.random() * 100000),
                            schedule: {at: triggerTime},
                            sound: 'default'
                        }]
                    });

                    // 4. éœ‡åŠ¨åé¦ˆ
                    await Haptics.impact({style: 'MEDIUM'}); // æ³¨æ„è¿™é‡Œç”¨å­—ç¬¦ä¸² 'MEDIUM'

                    // 5. (å¯é€‰) å¼¹ä¸ªæç¤º
                    // alert(`å·²è®¾ç½®æé†’ï¼š${delaySeconds}ç§’å`);

                } catch (e) {
                    console.error("é€šçŸ¥è®¾ç½®å¤±è´¥", e);
                    openAlertModal("é€šçŸ¥è®¾ç½®å‡ºé”™ï¼š" + e.message);
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: calculateSingleRatio
            const calculateSingleRatio = (item) => {
                // æ—¢ç„¶ trackListData å·²ç»æœ‰äº† viewTypeï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å®ƒ
                // æˆ–è€…æˆ‘ä»¬ç›´æ¥åˆ¤æ–­ï¼šå¦‚æœæ˜¯åœ¨ä¾§è¾¹æ è°ƒç”¨ï¼Œéœ€è¦ä¼ å…¥ viewTypeï¼Ÿ
                // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬ä¼˜å…ˆä½¿ç”¨ trackListData.viewTypeï¼Œå¦‚æœæ²¡æœ‰(æ¯”å¦‚åœ¨ä¾§è¾¹æ )ï¼Œåˆ™é»˜è®¤ä¸º 'musician'
                // ä½†ä¾§è¾¹æ ç°åœ¨ä¹Ÿæœ‰ sidebarTabï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ›´æ™ºèƒ½ä¸€ç‚¹

                let type = 'musician';
                if (trackListData.value && showTrackList.value) {
                    type = trackListData.value.viewType;
                } else {
                    type = sidebarTab.value || 'musician';
                }

                const record = item.records?.[type];
                if (!record || !record.actualDuration || !item.musicDuration) return '-';

                const actualSec = parseTime(record.actualDuration);
                const musicSec = parseTime(item.musicDuration);
                if (musicSec === 0) return '-';
                return (actualSec / musicSec).toFixed(1);
            };

            // --- V11.7 Session çŠ¶æ€ ---
            const currentSessionId = ref('');

            // --- V11.9 Session UI è¾…åŠ©é€»è¾‘ ---

            // 1. è·å–å½“å‰ Session åç§° (ç”¨äºæ˜¾ç¤ºåœ¨æŒ‰é’®ä¸Š)
            const currentSessionName = computed(() => {
                const s = settings.sessions.find(x => x.id === currentSessionId.value);
                return s ? s.name : 'æœªå‘½åæ—¥ç¨‹';
            });

            // 2. åˆ‡æ¢ Session
            const switchSession = (id) => {
                currentSessionId.value = id;
                activeDropdown.value = null; // é€‰å®Œå…³é—­èœå•
            };

            // ğŸŸ¢ ä¿®æ”¹åçš„ handleSessionAction
            const handleSessionAction = (action) => {
                if (action === 'new') {
                    // æ›¿æ¢ prompt
                    openInputModal('æ–°å»ºæ—¥ç¨‹', '', 'è¯·è¾“å…¥æ—¥ç¨‹åç§° (ä¾‹å¦‚: 2026 æ˜¥å­£å½•éŸ³)', (name) => {
                        if (name) {
                            const newId = generateUniqueId('S');
                            settings.sessions.push({id: newId, name: name});
                            currentSessionId.value = newId;
                            pushHistory();
                        }
                    });
                } else if (action === 'rename') {
                    const current = settings.sessions.find(s => s.id === currentSessionId.value);
                    // æ›¿æ¢ prompt
                    openInputModal('é‡å‘½åæ—¥ç¨‹', current.name, 'è¯·è¾“å…¥æ–°åç§°', (name) => {
                        if (name) {
                            current.name = name;
                            pushHistory();
                        }
                    });
                    // ğŸŸ¢ ä¿®æ”¹éƒ¨åˆ†
                } else if (action === 'delete') {
                    if (settings.sessions.length <= 1) {
                        openAlertModal('æ— æ³•åˆ é™¤', 'è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªæ—¥ç¨‹ã€‚');
                        return;
                    }

                    // æ›¿æ¢ confirm
                    openConfirmModal(
                        'åˆ é™¤æ—¥ç¨‹',
                        'ç¡®å®šåˆ é™¤å½“å‰æ—¥ç¨‹ï¼Ÿ\nï¼ˆå±äºè¯¥æ—¥ç¨‹çš„ä»»åŠ¡ä»ç„¶ä¼šä¿ç•™åœ¨æ—¥ç¨‹è¡¨ä¸­ï¼‰',
                        () => {
                            const idx = settings.sessions.findIndex(s => s.id === currentSessionId.value);
                            settings.sessions.splice(idx, 1);
                            currentSessionId.value = settings.sessions[0].id;
                            pushHistory();
                            window.triggerTouchHaptic('Success');
                        },
                        true // isDestructive = true (çº¢è‰²æŒ‰é’®)
                    );
                }
                activeDropdown.value = null;
            };

            // --- ğŸŸ¢ é¡¶éƒ¨èœå•ä¸ä¸»é¢˜é€»è¾‘ ---
            const showMobileMenu = ref(false);

            // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: å¼•å…¥ä¸‰æ€ä¸»é¢˜ç®¡ç† (Auto / Light / Dark)

            // 1. å®šä¹‰çŠ¶æ€: ä¼˜å…ˆè¯»å–æœ¬åœ°å­˜å‚¨ï¼Œæ²¡æœ‰åˆ™é»˜è®¤ä¸º 'auto'
            const themeMode = ref(localStorage.getItem('theme_mode') || 'auto');

            // isDark ä¾ç„¶ä¿ç•™ï¼Œä½œä¸º"å½“å‰å®é™…ç”Ÿæ•ˆé¢œè‰²"çš„è®¡ç®—ç»“æœï¼Œä¾›ç•Œé¢å…¶ä»–éƒ¨åˆ†(å¦‚å›¾è¡¨é¢œè‰²)ä½¿ç”¨
            const isDark = ref(document.documentElement.classList.contains('dark'));

            // 2. åº”ç”¨ä¸»é¢˜çš„æ ¸å¿ƒå‡½æ•°
            const applyTheme = () => {
                let shouldBeDark = false;

                if (themeMode.value === 'auto') {
                    // å¦‚æœæ˜¯è‡ªåŠ¨æ¨¡å¼ï¼ŒæŸ¥è¯¢ç³»ç»Ÿåå¥½
                    shouldBeDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                } else {
                    // å¦åˆ™ç›´æ¥æ ¹æ®è®¾å®šå€¼
                    shouldBeDark = themeMode.value === 'dark';
                }

                // æ“ä½œ DOM
                const html = document.documentElement;
                if (shouldBeDark) {
                    html.classList.add('dark');
                    isDark.value = true;
                } else {
                    html.classList.remove('dark');
                    isDark.value = false;
                }
            };

            // 3. åˆ‡æ¢æŒ‰é’®ç‚¹å‡»äº‹ä»¶ (Auto -> Light -> Dark -> Auto å¾ªç¯)
            const toggleTheme = () => {
                const modes = ['auto', 'light', 'dark'];
                const nextIndex = (modes.indexOf(themeMode.value) + 1) % modes.length;

                themeMode.value = modes[nextIndex];

                // ä¿å­˜åˆ°æœ¬åœ°
                localStorage.setItem('theme_mode', themeMode.value);

                applyTheme();
            };

            // 4. è·å–å½“å‰æ¨¡å¼çš„æ˜¾ç¤ºåç§°å’Œå›¾æ ‡ (ä¾› HTML ä½¿ç”¨)
            const getThemeLabel = computed(() => {
                if (themeMode.value === 'auto') return {text: 'è·Ÿéšç³»ç»Ÿ', icon: 'fa-desktop'};
                if (themeMode.value === 'dark') return {text: 'æ·±è‰²æ¨¡å¼', icon: 'fa-moon'};
                return {text: 'æµ…è‰²æ¨¡å¼', icon: 'fa-sun'};
            });

            // --- ğŸŸ¢ å¤´åƒè£å‰ªä¸ä¸Šä¼ é€»è¾‘ ---
            const showCropModal = ref(false);
            const cropImgSrc = ref('');
            const cropImgRef = ref(null); // ç»‘å®šåˆ° <img> æ ‡ç­¾
            let cropper = null; // å­˜æ”¾ Cropper å®ä¾‹

            // --- ğŸŸ¢ é€šç”¨ç¡®è®¤/æç¤ºå¼¹çª—çŠ¶æ€ (Universal Confirm/Alert) ---
            const showConfirmModal = ref(false);
            const confirmModalConfig = reactive({
                title: '',
                content: '',
                confirmText: 'ç¡®å®š',
                cancelText: 'å–æ¶ˆ',
                isAlert: false,      // true=åªæœ‰ç¡®å®šæŒ‰é’®, false=æœ‰ç¡®å®šå’Œå–æ¶ˆ
                isDestructive: false,// true=æŒ‰é’®å˜çº¢(ç”¨äºåˆ é™¤ç­‰å±é™©æ“ä½œ)
                onConfirm: null
            });

            // 1. æ‰“å¼€æç¤ºæ¡† (æ›¿ä»£ alert)
            const openAlertModal = (title, content, callback) => {
                confirmModalConfig.title = title;
                confirmModalConfig.content = content;
                confirmModalConfig.isAlert = true;
                confirmModalConfig.isDestructive = false;
                confirmModalConfig.confirmText = 'æˆ‘çŸ¥é“äº†';
                confirmModalConfig.onConfirm = callback;
                showConfirmModal.value = true;
                window.triggerTouchHaptic('Light'); // è½»å¾®éœ‡åŠ¨
            };

            // 2. æ‰“å¼€ç¡®è®¤æ¡† (æ›¿ä»£ confirm)
            const openConfirmModal = (title, content, onConfirm, isDestructive = false, confirmText = 'ç¡®å®š', cancelText = 'å–æ¶ˆ') => {
                confirmModalConfig.title = title;
                confirmModalConfig.content = content;
                confirmModalConfig.isAlert = false;
                confirmModalConfig.isDestructive = isDestructive;
                confirmModalConfig.confirmText = confirmText;
                confirmModalConfig.cancelText = cancelText;
                confirmModalConfig.onConfirm = onConfirm;
                showConfirmModal.value = true;
                window.triggerTouchHaptic('Medium'); // è­¦å‘Šéœ‡åŠ¨
            };

            const closeConfirmModal = () => {
                showConfirmModal.value = false;
                // å»¶è¿Ÿæ¸…ç†å›è°ƒï¼Œé˜²æ­¢åŠ¨ç”»æœªç»“æŸå°±æ¸…ç†å¯¼è‡´æŠ¥é”™
                setTimeout(() => {
                    confirmModalConfig.onConfirm = null;
                }, 300);
            };

            const handleConfirmAction = () => {
                if (confirmModalConfig.onConfirm) {
                    confirmModalConfig.onConfirm();
                }
                closeConfirmModal();
            };

            // --- ğŸŸ¢ é€šç”¨è¾“å…¥å¼¹çª—çŠ¶æ€ (Universal Input Modal) ---
            const showInputModal = ref(false);
            const universalInputRef = ref(null);
            const inputModalConfig = reactive({
                title: '',
                value: '',
                placeholder: '',
                hint: '',
                callback: null // å­˜å‚¨ç‚¹å‡»ç¡®å®šåçš„å›è°ƒå‡½æ•°
            });

            // æ‰“å¼€å¼¹çª—çš„é€šç”¨æ–¹æ³•
            const openInputModal = (title, initialValue, placeholder, callback, hint = '') => {
                inputModalConfig.title = title;
                inputModalConfig.value = initialValue;
                inputModalConfig.placeholder = placeholder;
                inputModalConfig.callback = callback;
                inputModalConfig.hint = hint;
                showInputModal.value = true;

                // è‡ªåŠ¨èšç„¦è¾“å…¥æ¡†
                Vue.nextTick(() => {
                    if (universalInputRef.value) universalInputRef.value.focus();
                    if (universalInputRef.value) universalInputRef.value.select(); // å…¨é€‰æ–‡æœ¬æ–¹ä¾¿ä¿®æ”¹
                });
            };

            const closeInputModal = () => {
                showInputModal.value = false;
                inputModalConfig.callback = null; // æ¸…ç†å›è°ƒ
            };

            const confirmInputModal = () => {
                if (!inputModalConfig.value.trim()) {
                    // å¦‚æœæ˜¯å¿…å¡«é¡¹ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ‹¦æˆªï¼Œæˆ–è€…å…è®¸ç©ºå€¼ç”±å›è°ƒå‡½æ•°è‡ªå·±åˆ¤æ–­
                    // è¿™é‡Œæˆ‘ä»¬ç®€å•å¤„ç†ï¼šå¦‚æœæ˜¯ç©ºçš„ä¸”ä¸æ˜¯æ–‡ä»¶åå¯¼å‡ºï¼Œç»™ä¸ªéœ‡åŠ¨åé¦ˆæˆ–ä¸åšååº”
                }

                if (inputModalConfig.callback) {
                    inputModalConfig.callback(inputModalConfig.value.trim());
                }
                closeInputModal();
            };

            // ğŸŸ¢ æ–°å¢: å¿«é€Ÿæ·»åŠ å¼¹çª—çš„çŠ¶æ€
            const showQuickAddModal = ref(false);
            const quickAddType = ref(''); // 'project', 'instrument', 'musician'
            const quickAddForm = reactive({name: '', group: '', defaultRatio: 20});

            // ğŸŸ¢ æ–°å¢: è®¡ç®—å±æ€§ï¼Œä¸“é—¨ç”¨äº Quick Add å¼¹çª—çš„åˆ†ç»„åˆ—è¡¨
            // è¿™èƒ½ç¡®ä¿å½“ quickAddType å˜åŒ–æˆ– settings æ•°æ®å˜åŒ–æ—¶ï¼Œåˆ—è¡¨èƒ½è‡ªåŠ¨æ›´æ–°
            const currentQuickAddGroups = computed(() => {
                // æ˜¾å¼è®¿é—® .valueï¼Œç¡®ä¿ä¾èµ–è¢«è¿½è¸ª
                const type = quickAddType.value;
                // å¤ç”¨å·²æœ‰çš„è·å–é€»è¾‘
                return getExistingGroups(type);
            });

            // ğŸŸ¢ æ–°å¢: æ‰“å¼€å¿«é€Ÿæ·»åŠ å¼¹çª—
            const openQuickAdd = (type) => {
                quickAddType.value = type;
                quickAddForm.name = '';
                quickAddForm.group = '';
                quickAddForm.defaultRatio = 20;
                showQuickAddModal.value = true;

                // è‡ªåŠ¨èšç„¦è¾“å…¥æ¡†
                setTimeout(() => {
                    const input = document.getElementById('quick-add-name');
                    if (input) input.focus();
                }, 100);
            };

            // ğŸŸ¢ ä¿®å¤: å¿«é€Ÿæ·»åŠ æ—¶çš„é‡åæ£€æµ‹
            const confirmQuickAdd = () => {
                const nameStr = quickAddForm.name.trim();
                if (!nameStr) return openAlertModal("åç§°ä¸èƒ½ä¸ºç©º");

                const type = quickAddType.value;

                // 1. è·å–å¯¹åº”åˆ—è¡¨
                let list = [];
                let label = '';
                if (type === 'instrument') {
                    list = settings.instruments;
                    label = 'ä¹å™¨';
                } else if (type === 'musician') {
                    list = settings.musicians;
                    label = 'æ¼”å¥å‘˜';
                } else if (type === 'project') {
                    list = settings.projects;
                    label = 'é¡¹ç›®';
                }

                // ğŸŸ¢ 2. æ ¸å¿ƒä¿®å¤: æ£€æŸ¥é‡å (ä¸åŒºåˆ†å¤§å°å†™)
                if (list.some(i => i.name.toLowerCase() === nameStr.toLowerCase())) {
                    window.triggerTouchHaptic('Error');
                    return openAlertModal('æ— æ³•æ·»åŠ ', `è¯¥${label}åç§° "${nameStr}" å·²å­˜åœ¨ï¼`);
                }

                // 3. æ‰§è¡Œæ·»åŠ 
                const idPrefix = type === 'project' ? 'P' : (type === 'instrument' ? 'I' : 'M');
                const newId = generateUniqueId(idPrefix);

                const newItemObj = {
                    id: newId,
                    name: nameStr,
                    group: quickAddForm.group.trim(),
                    color: generateRandomHexColor()
                };

                if (type === 'project') {
                    settings.projects.push(newItemObj);
                    newItem.projectId = newId;
                } else if (type === 'instrument') {
                    settings.instruments.push(newItemObj);
                    newItem.instrumentId = newId;
                } else if (type === 'musician') {
                    newItemObj.defaultRatio = quickAddForm.defaultRatio;
                    settings.musicians.push(newItemObj);
                    newItem.musicianId = newId;
                    onMusicianSelect();
                }

                pushHistory();
                showQuickAddModal.value = false;
                activeDropdown.value = null;
                window.triggerTouchHaptic('Success');
            };

            // 1. ç”¨æˆ·é€‰æ‹©æ–‡ä»¶ -> æ‰“å¼€è£å‰ªå¼¹çª—
            const onFileSelect = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // æ”¾å®½å¤§å°é™åˆ¶åˆ° 20MB
                if (file.size > 20 * 1024 * 1024) return openAlertModal("å›¾ç‰‡å¤ªå¤§äº†ï¼Œè¯·é€‰æ‹© 20MB ä»¥ä¸‹çš„å›¾ç‰‡");

                const reader = new FileReader();
                reader.onload = (e) => {
                    // é‡ç½®çŠ¶æ€
                    cropImgSrc.value = e.target.result;
                    showCropModal.value = true;

                    Vue.nextTick(() => {
                        // 1. å…ˆå½»åº•é”€æ¯æ—§å®ä¾‹
                        if (cropper) {
                            cropper.destroy();
                            cropper = null;
                        }

                        const imgEl = cropImgRef.value;
                        if (!imgEl) return;

                        // 2. å®šä¹‰åˆå§‹åŒ–å‡½æ•° (å¢åŠ é˜²æŠ–ï¼Œé˜²æ­¢è·‘ä¸¤æ¬¡)
                        let isInitialized = false;
                        const initCropper = () => {
                            if (isInitialized) return; // å¦‚æœå·²ç»è·‘è¿‡ï¼Œç›´æ¥åœæ­¢
                            isInitialized = true;

                            cropper = new Cropper(imgEl, {
                                aspectRatio: 1,
                                viewMode: 1,
                                dragMode: 'move',
                                autoCropArea: 1,
                                background: false,
                                checkCrossOrigin: false,
                                ready() {
                                    // å¯ä»¥åœ¨è¿™é‡ŒåŠ ä¸ª console.log ç¡®è®¤åªæ‰“å°äº†ä¸€æ¬¡
                                    // console.log('Cropper ready');
                                }
                            });
                        };

                        // 3. æ™ºèƒ½åˆ¤æ–­åŠ è½½çŠ¶æ€
                        // å¦‚æœå›¾ç‰‡å·²ç»åœ¨ç¼“å­˜é‡ŒåŠ è½½å¥½äº†ï¼Œç›´æ¥åˆå§‹åŒ–
                        if (imgEl.complete && imgEl.naturalWidth > 0) {
                            initCropper();
                        } else {
                            // å¦åˆ™ç›‘å¬ load äº‹ä»¶ï¼Œä¸”åªç›‘å¬ä¸€æ¬¡
                            imgEl.addEventListener('load', initCropper, {once: true});
                        }
                    });
                };
                reader.readAsDataURL(file);

                event.target.value = '';
            };

            // 2. å–æ¶ˆè£å‰ª
            const cancelCrop = () => {
                showCropModal.value = false;
                if (cropper) {
                    cropper.destroy();
                    cropper = null;
                }
            };

            // 3. ç¡®è®¤è£å‰ªå¹¶ä¸Šä¼ 
            const confirmCrop = () => {
                if (!cropper) return;

                // å°è¯•è·å–è£å‰ªåçš„ Canvas
                const canvas = cropper.getCroppedCanvas({
                    width: 300,
                    height: 300
                });

                // ğŸŸ¢ å…³é”®ä¿®å¤ï¼šå¦‚æœ canvas æ˜¯ nullï¼Œè¯´æ˜è£å‰ªå™¨è¿˜æ²¡å‡†å¤‡å¥½ï¼Œæˆ–è€… CSS æ²¡åŠ è½½
                if (!canvas) {
                    return openAlertModal("è£å‰ªå¤±è´¥ï¼šæœªèƒ½è·å–åˆ°å›¾ç‰‡å†…å®¹ã€‚\nè¯·æ£€æŸ¥æ˜¯å¦å·²å¼•å…¥ cropper.min.css æ ·å¼æ–‡ä»¶ã€‚");
                }

                authLoading.value = true;

                // ğŸŸ¢ ä¿®æ”¹: ä½¿ç”¨ 'image/webp' æ ¼å¼ï¼Œå¹¶å°†è´¨é‡é™ä¸º 0.6
                canvas.toBlob(async (blob) => {
                    if (!blob) {
                        authLoading.value = false;
                        return openAlertModal("ç”Ÿæˆå›¾ç‰‡æ–‡ä»¶å¤±è´¥");
                    }

                    try {
                        const fileName = `${user.value.id}-${Date.now()}.webp`;
                        const filePath = `${fileName}`;
                        const {error: uploadError} = await supabase.storage
                            .from('avatars')
                            .upload(filePath, blob, {
                                contentType: 'image/webp', // æ˜¾å¼æŒ‡å®šç±»å‹
                                upsert: true
                            });

                        if (uploadError) throw uploadError;

                        // è·å– URL
                        const {data} = supabase.storage.from('avatars').getPublicUrl(filePath);
                        const publicUrl = data.publicUrl;

                        // æ›´æ–°ç”¨æˆ·èµ„æ–™
                        const {error: updateError} = await supabase.auth.updateUser({
                            data: {avatar_url: publicUrl}
                        });

                        if (updateError) throw updateError;

                        // æ›´æ–°æˆåŠŸ
                        user.value = (await supabase.auth.getUser()).data.user;

                        // å…³é—­å¼¹çª—
                        cancelCrop();
                        openAlertModal("å¤´åƒæ›´æ–°æˆåŠŸï¼");

                    } catch (error) {
                        console.error(error);
                        openAlertModal("ä¸Šä¼ å¤±è´¥: " + error.message);
                    } finally {
                        authLoading.value = false;
                    }

                }, 'image/webp', 0.6); // ä½¿ç”¨ webp æ ¼å¼å’Œ 0.6 è´¨é‡
            };

            // ğŸŸ¢ ä¿®æ”¹: åˆ é™¤åˆ—è¡¨ä»»åŠ¡
            const deleteTrackFromList = (itemToDelete) => {
                // ğŸŸ¢ æ’å…¥: å°è¯•å½’è¿˜æ—¶é—´
                restoreSplitTime(itemToDelete);
                // 1. ä»å…¨å±€ä»»åŠ¡æ± ä¸­åˆ é™¤
                itemPool.value = itemPool.value.filter(i => i.id !== itemToDelete.id);

                // 2. ä»å½“å‰å¼¹çª—åˆ—è¡¨ä¸­åˆ é™¤
                trackListData.value.items = trackListData.value.items.filter(i => i.id !== itemToDelete.id);

                // ğŸ”´ ç§»é™¤: ä¸è¦åœ¨å¼¹çª—å†…ç«‹å³æ¸…ç†ï¼Œé˜²æ­¢ç•Œé¢è·³å˜
                // pruneEmptySchedules();

                // 3. å¦‚æœå¼¹çª—è¿˜å¼€ç€ï¼Œä¿å­˜å†å²
                if (showTrackList.value) {
                    pushHistory();
                }

                // éœ‡åŠ¨åé¦ˆ
                window.triggerTouchHaptic('Medium');
            };

            // ğŸŸ¢ æ–°å¢: ç›‘å¬ TrackList å¼¹çª—å…³é—­
            // å½“å¼¹çª—å…³é—­æ—¶ï¼Œç»Ÿä¸€æ‰§è¡Œä¸€æ¬¡å…¨å±€æ¸…ç†ï¼Œç§»é™¤é‚£äº›å˜ç©ºçš„æ—¥ç¨‹å—
            watch(showTrackList, (isOpen) => {
                if (!isOpen) {
                    // å¼¹çª—åˆšå…³é—­ -> æ‰§è¡Œæ¸…ç†
                    cleanupEmptySchedules();

                    // å¯é€‰ï¼šä¿å­˜ä¸€æ¬¡å†å²ï¼Œç¡®ä¿æ¸…ç†åçš„çŠ¶æ€è¢«è®°å½•
                    // pushHistory();
                }
            });


            // ğŸŸ¢ æ–°å¢: è‡ªåŠ¨è®¡ç®—æ—¶é—´å·®
            const autoCalcDuration = () => {
                const start = trackListData.value.actualStart;
                const end = trackListData.value.actualEnd;

                if (start && end) {
                    const [sh, sm] = start.split(':').map(Number);
                    const [eh, em] = end.split(':').map(Number);

                    let startMins = sh * 60 + sm;
                    let endMins = eh * 60 + em;

                    // å¦‚æœç»“æŸæ—¶é—´å°äºå¼€å§‹æ—¶é—´ï¼Œå‡è®¾æ˜¯è·¨å¤© (åŠ 24å°æ—¶)
                    if (endMins < startMins) endMins += 24 * 60;

                    const diffSecs = (endMins - startMins) * 60;
                    trackListData.value.actualDuration = formatSecs(diffSecs);
                }
            };

            // ğŸŸ¢ é‡å†™: clearTrackTime (åŸå­æ“ä½œï¼Œå•æ¬¡æ’¤é”€)
            const clearTrackTime = (item) => {
                const viewType = trackListData.value.viewType || 'musician';
                const record = item.records[viewType];

                // 1. æ‰§è¡Œæ¸…é™¤
                record.recStart = '';
                record.recEnd = '';
                record.actualDuration = '';

                // å¦‚æœæœ‰ä¸­æ–­æ—¶é•¿ï¼Œä¹Ÿå»ºè®®ä¸€å¹¶æ¸…é™¤ï¼Œæˆ–è€…ä¿ç•™çœ‹ä½ éœ€æ±‚
                // record.breakMinutes = 0;

                // 2. ç«‹å³æ›´æ–°æ—¥ç¨‹å—å½¢çŠ¶ (ä¸å­˜å†å²)
                // è¿™æ ·æ—¥ç¨‹å—ä¼šé©¬ä¸Šç¼©å›å»ï¼Œè§†è§‰åé¦ˆå¿«
                autoResizeScheduleByRecords(true, false);

                // 3. ç«‹å³æ›´æ–°æ•ˆç‡å€¼ (ä¸å­˜å†å²)
                // æŒ‰é’®ç‚¹å‡»ä¸éœ€è¦é˜²æŠ–ï¼Œç›´æ¥ç®—å³å¯
                autoUpdateMusicianEfficiency(item.musicianId, viewType, false);

                // 4. ç»Ÿä¸€ä¿å­˜ä¸€æ¬¡å†å²
                pushHistory();

                // 5. éœ‡åŠ¨åé¦ˆ
                window.triggerTouchHaptic('Medium');
            };

            // ğŸŸ¢ ä¿®æ”¹: ä¿å­˜å½•éŸ³æ—¶é—´å¹¶å¼ºåˆ¶æ›´æ–°è§†å›¾
            const saveScheduleActualTime = () => {
                const currentScheduleId = trackListData.value.taskRef.scheduleId;

                if (!currentScheduleId) return;

                // 1. æ›´æ–°æ•°æ®
                // ä½¿ç”¨ map åˆ›å»ºæ–°æ•°ç»„ï¼Œç¡®ä¿è§¦å‘ Vue çš„å“åº”å¼æ›´æ–°
                scheduledTasks.value = scheduledTasks.value.map(task => {
                    if (task.scheduleId === currentScheduleId) {
                        return {
                            ...task, // å¤åˆ¶åŸå¯¹è±¡
                            actualStartTime: trackListData.value.actualStart,
                            actualEndTime: trackListData.value.actualEnd,
                            actualDuration: trackListData.value.actualDuration
                        };
                    }
                    return task;
                });

                pushHistory();

                // 2. æç¤ºç”¨æˆ·
                openAlertModal("âœ… å½•éŸ³æ—¶é—´å·²ä¿å­˜ï¼\nè¯¥æ¼”å¥å‘˜çš„ã€ŒçœŸå®å¹³å‡æ¯”å€¼ã€å·²åœ¨ä¾§è¾¹æ è‡ªåŠ¨æ›´æ–°ã€‚");


            };

            // ğŸŸ¢ æ–°å¢: ä¿å­˜å•æ›²å®é™…ç”¨æ—¶
            const saveTrackActual = (item) => {
                // æ‰¾åˆ°æºæ•°æ®å¹¶æ›´æ–°
                const task = scheduledTasks.value.find(t => t.scheduleId === item.scheduleId);
                if (task) {
                    task.actualDuration = item.actualDuration;
                    // å¼ºåˆ¶æ›´æ–°æ•°ç»„ä»¥è§¦å‘ computed é‡æ–°è®¡ç®—
                    scheduledTasks.value = [...scheduledTasks.value];

                    // ä¿å­˜åˆ°å†å²
                    // pushHistory(); // å¯é€‰ï¼šå¦‚æœä¸å¸Œæœ›æ¯æ¬¡è¾“å…¥å­—ç¬¦éƒ½å­˜å†å²ï¼Œå¯ä»¥ä¸åŠ 
                }
            };

            // ğŸŸ¢ æ–°å¢: åˆ é™¤å½“å‰æ‰“å¼€çš„æ—¥ç¨‹å—
            const deleteCurrentSchedule = () => {
                // è·å–å½“å‰å¼¹çª—å¯¹åº”çš„æ—¥ç¨‹ä»»åŠ¡å¼•ç”¨
                const taskToDelete = trackListData.value.taskRef;

                if (!taskToDelete) return;

                // ä»æ—¥ç¨‹æ•°ç»„ä¸­ç§»é™¤è¯¥ ID çš„ä»»åŠ¡
                scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== taskToDelete.scheduleId);

                pushHistory();

                // å…³é—­å¼¹çª—
                showTrackList.value = false;
            };

            // ğŸŸ¢ æ–°å¢ï¼šåœ¨ TrackList å¼¹çª—ä¸­ä¿®æ”¹æé†’æ—¶é—´
            const onTrackListReminderChange = (task) => {
                if (!task) return;

                // 1. è°ƒç”¨ä¹‹å‰å†™å¥½çš„æ›´æ–°é€šçŸ¥å‡½æ•°
                // (ç¡®ä¿ä½ ä¹‹å‰å·²ç»æ·»åŠ äº† updateTaskNotification å‡½æ•°)
                if (typeof updateTaskNotification === 'function') {
                    updateTaskNotification(task);
                }

                // 2. ä¿å­˜æ•°æ®åˆ°å†å²è®°å½•
                pushHistory();

                // 3. (å¯é€‰) ç»™ä¸ªè½»å¾®éœ‡åŠ¨åé¦ˆ
                const Haptics = window.Capacitor?.Plugins?.Haptics;
                if (Haptics) {
                    Haptics.impact({style: 'LIGHT'});
                }
            };

            // --- V9.7.4: settings.projects å–ä»£ settings.projectColors ---
            const settings = reactive({
                startHour: 10, endHour: 22,
                sessions: [
                    {id: 'S_DEFAULT', name: 'é»˜è®¤å½•éŸ³æ—¥ç¨‹'} // åˆå§‹é»˜è®¤ Session
                ],
                instruments: [
                    {id: 'Imi7d0318nsj', name: 'æ›²ç¬› Qudi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d1wio42g', name: 'å¤§ç¬› Dadi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d1zhnrin', name: 'ç®« Xiao', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d22qbj3x', name: 'ç®¡å­ Guanzi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d25hgyts', name: 'è‘«èŠ¦ä¸ Hulusi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d28dmhcu', name: 'å˜Ÿå˜Ÿå…‹ Duduk', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d2czbme5', name: 'å¥ˆä¼Šç¬› Ney', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d2fipt2s', name: 'å¤ç­ Guzheng', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2irx4rn', name: 'çµç¶ Pipa', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2lzuq1k', name: 'ä¸­é˜® Zhongruan', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2okw95k', name: 'å¤§é˜® Daruan', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2usilyh', name: 'æ‰¬ç´ Yangqin', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d2ypsa3n', name: 'ä¸‰å¼¦ Sanxian', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d321n3ff', name: 'äºŒèƒ¡ Erhu', color: '#60a5fa', group: 'Ethnic Strings'},
                    {id: 'Imi7d35n8ore', name: 'é©¬å¤´ç´ Matouqin', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d38kux53', name: 'è¨å¡”å°” Sataer', color: '#60a5fa', group: 'Ethnic Strings'},
                    {id: 'Imi7d3b4omfr', name: 'å¤å…¸å‰ä»– Classical Guitar', color: '#60a5fa', group: 'Plucks'},
                    {id: 'Imi7d3drxrgi', name: 'é’¢å¼¦å‰ä»– Acoustic Guitar', color: '#60a5fa', group: 'Plucks'},
                    {id: 'Imi7d3gz35vm', name: 'è¨å…¹ç´ Saz', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d3jqoe3p', name: 'è¥¿å¡”å°” Sitar', color: '#60a5fa', group: 'Ethnic Plucks'},
                    {id: 'Imi7d3lxykzm', name: 'ç¬™ Sheng', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d3pcnpbh', name: 'å°ºå…« Shakuhachi', color: '#60a5fa', group: 'Ethnic Woodwinds'},
                    {id: 'Imi7d3s0hrcp', name: 'äººå£° Vocal', color: '#60a5fa', group: 'Vocal'},
                    {
                        id: 'tmi8ygljxuqkaatv',
                        name: 'ä½éŸ³é©¬å¤´ç´ Diyin Matouqin',
                        color: '#60a5fa',
                        group: 'Ethnic Strings'
                    },
                    {id: 'tmifto6q9igynzmf', name: 'é’¢ç´ Piano', color: '#60a5fa', group: 'Keys'}
                ],
                musicians: [],
                // V9.7.4: æ–°å¢ Projects åˆ—è¡¨
                projects: [],
            });

            currentSessionId.value = 'S_DEFAULT';

            // ğŸŸ¢ æ–°å¢: é€šç”¨æ’åºå‡½æ•° (ä¼˜å…ˆæŒ‰ Group æ’åºï¼Œåˆ†ç»„ç›¸åŒçš„æŒ‰ Name æ‹¼éŸ³æ’åº)
            const sortSettingsList = (list) => {
                return [...list].sort((a, b) => {
                    const gA = (a.group || '').trim();
                    const gB = (b.group || '').trim();

                    // 1. åˆ†ç»„é€»è¾‘: æœ‰åˆ†ç»„çš„æ’å‰é¢ï¼Œæ²¡åˆ†ç»„(ç©º)çš„æ’åé¢
                    if (gA && !gB) return -1;
                    if (!gA && gB) return 1;

                    // 2. å¦‚æœéƒ½æœ‰åˆ†ç»„ï¼ŒæŒ‰åˆ†ç»„åç§°æ‹¼éŸ³æ’åº
                    if (gA !== gB) return gA.localeCompare(gB, 'zh-CN');

                    // 3. åˆ†ç»„ç›¸åŒï¼ŒæŒ‰åç§°æ‹¼éŸ³æ’åº
                    return (a.name || '').localeCompare(b.name || '', 'zh-CN');
                });
            };

            // ğŸŸ¢ æ–°å¢: ä¸‰ä¸ªæ’åºåçš„è®¡ç®—å±æ€§ (ä¾› HTML æ¸²æŸ“ä½¿ç”¨)
            const sortedInstruments = computed(() => sortSettingsList(settings.instruments));
            const sortedMusicians = computed(() => sortSettingsList(settings.musicians));
            const sortedProjects = computed(() => sortSettingsList(settings.projects));

            /// ğŸŸ¢ ä¿®æ”¹éƒ¨åˆ†
            const removeInstrument = (id) => {
                openConfirmModal('åˆ é™¤ä¹å™¨', 'ç¡®å®šåˆ é™¤è¯¥ä¹å™¨å—ï¼Ÿ\nå·²å…³è”çš„ä»»åŠ¡å°†å˜ä¸º"æœªçŸ¥ä¹å™¨"ã€‚', () => {
                    settings.instruments = settings.instruments.filter(i => i.id !== id);
                    pushHistory();
                }, true);
            };

            const removeMusician = (id) => {
                openConfirmModal('åˆ é™¤æ¼”å¥å‘˜', 'ç¡®å®šåˆ é™¤è¯¥æ¼”å¥å‘˜å—ï¼Ÿ\nè¯¥æ“ä½œæ— æ³•æ’¤é”€ã€‚', () => {
                    settings.musicians = settings.musicians.filter(m => m.id !== id);
                    pushHistory();
                }, true);
            };


            // V9.7.4: newItem ç°åœ¨ç»‘å®š projectId
            const newItem = reactive({projectId: '', instrumentId: '', musicianId: '', musicDuration: '', ratio: 20});

            // ğŸŸ¢ ä¿®æ”¹: çº¯ç²¹çš„ç™»å½•é€»è¾‘ (ä¸å†è‡ªåŠ¨è·³è½¬æ³¨å†Œ)
            const handleLogin = async () => {
                if (!authForm.email || !authForm.password) return openAlertModal("è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ");
                authLoading.value = true;

                // 1. å°è¯•ç™»å½•
                const {data, error} = await supabase.auth.signInWithPassword({
                    email: authForm.email, password: authForm.password
                });

                if (error) {
                    // ğŸŸ¢ å…³é”®ä¿®æ”¹: ç™»å½•å¤±è´¥å°±æ˜¯å¤±è´¥ï¼Œä¸å†è‡ªåŠ¨å°è¯•æ³¨å†Œ
                    // è¿™æ ·è¾“é”™å¯†ç æ—¶ï¼Œå°±ä¼šæ˜ç¡®æç¤º "Invalid login credentials" (è´¦å·æˆ–å¯†ç é”™è¯¯)
                    if (error.message.includes("Invalid login credentials")) {
                        openAlertModal("ç™»å½•å¤±è´¥ï¼šè´¦å·æˆ–å¯†ç é”™è¯¯");
                    } else {
                        openAlertModal("ç™»å½•å¤±è´¥: " + error.message);
                    }
                } else {
                    user.value = data.user;
                    showAuthModal.value = false;
                    await loadCloudData(); // åŠ è½½æ•°æ®
                }
                authLoading.value = false;
            };

            // ğŸŸ¢ æ–°å¢: ç‹¬ç«‹çš„æ³¨å†Œé€»è¾‘
            const handleRegister = async () => {
                if (!authForm.email || !authForm.password) return openAlertModal("è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ");
                authLoading.value = true;

                const {data, error} = await supabase.auth.signUp({
                    email: authForm.email, password: authForm.password
                });

                if (error) {
                    openAlertModal("æ³¨å†Œå¤±è´¥: " + error.message);
                } else {
                    // Supabase é»˜è®¤è¡Œä¸ºï¼šå¦‚æœè¯¥é‚®ç®±å·²æ³¨å†Œï¼ŒsignUp ä¸ä¼šæŠ¥é”™ï¼Œä½†è¿”å›çš„ user ä¸º null (æˆ–å‡æ•°æ®)
                    // æˆ‘ä»¬æç¤ºç”¨æˆ·å»ç¡®è®¤é‚®ä»¶æˆ–ç›´æ¥ç™»å½•
                    if (data.user && data.user.identities && data.user.identities.length === 0) {
                        openAlertModal("è¯¥é‚®ç®±å·²è¢«æ³¨å†Œï¼Œè¯·ç›´æ¥ç™»å½• (è‹¥å¿˜è®°å¯†ç è¯·ç‚¹å‡»æ‰¾å›)ã€‚");
                    } else {
                        openAlertModal("æ³¨å†ŒæˆåŠŸï¼\nè¯·æ£€æŸ¥æ‚¨çš„é‚®ç®±è¿›è¡ŒéªŒè¯ï¼ŒéªŒè¯åå³å¯ç™»å½•ã€‚");
                    }
                }
                authLoading.value = false;
            };

            // --- ğŸŸ¢ æ–°å¢ï¼šè®¾ç½®å•ä¸ªä»»åŠ¡çš„ç³»ç»Ÿé€šçŸ¥ ---
            const updateTaskNotification = async (task) => {
                // 1. å¦‚æœæ²¡æœ‰ Capacitor ç¯å¢ƒï¼Œç›´æ¥è·³è¿‡
                const LocalNotifications = window.Capacitor?.Plugins?.LocalNotifications;
                if (!LocalNotifications) return;

                // 2. ç”Ÿæˆä¸€ä¸ªå®‰å…¨çš„ 32ä½ æ•´æ•° ID (Android é™åˆ¶ ID ä¸èƒ½å¤ªå¤§)
                // æˆ‘ä»¬ç”¨ä»»åŠ¡ ID (æ—¶é—´æˆ³) å¯¹ 21äº¿ å–æ¨¡ï¼Œç¡®ä¿å®ƒæ˜¯å”¯ä¸€çš„ä¸”ç¬¦åˆæ•´æ•°èŒƒå›´
                const notifId = task.scheduleId % 2147483647;

                // 3. å…ˆå–æ¶ˆæ—§çš„é€šçŸ¥ (é˜²æ­¢é‡å¤æˆ–ä¿®æ”¹æ—¶é—´åæ—§çš„è¿˜åœ¨)
                try {
                    await LocalNotifications.cancel({notifications: [{id: notifId}]});
                } catch (e) { /* å¿½ç•¥é”™è¯¯ */
                }

                // 4. å¦‚æœç”¨æˆ·é€‰æ‹©äº†â€œæ— æé†’â€ (0) æˆ–è€…æ²¡æœ‰è®¾ç½®æ—¶é—´ï¼Œå°±ç»“æŸ
                if (!task.reminderMinutes || task.reminderMinutes <= 0) return;

                // 5. è®¡ç®—è§¦å‘æ—¶é—´
                // æ ¼å¼è§£æ: "2025-11-27" + "10:30"
                const dateStr = task.date.replace(/-/g, '/'); // å…¼å®¹ iOS æ—¥æœŸæ ¼å¼
                const taskTime = new Date(`${dateStr} ${task.startTime}:00`);

                // å‡å»æå‰çš„åˆ†é’Ÿæ•°
                const triggerTime = new Date(taskTime.getTime() - task.reminderMinutes * 60 * 1000);

                // å¦‚æœè§¦å‘æ—¶é—´å·²ç»è¿‡å»äº†ï¼Œå°±ä¸è®¾äº†
                if (triggerTime.getTime() < Date.now() - 60 * 1000) {
                    console.warn(`âš ï¸ é€šçŸ¥è·³è¿‡: æé†’æ—¶é—´ ${triggerTime.toLocaleTimeString()} å‘ç”Ÿåœ¨ 1 åˆ†é’Ÿå‰æˆ–æ›´æ—©ï¼Œå·²æ”¾å¼ƒè®¾ç½®ã€‚`);
                    return;
                }

                // 6. å®‰æ’æ–°é€šçŸ¥
                try {
                    // ç¡®ä¿æœ‰æƒé™
                    let perm = await LocalNotifications.checkPermissions();
                    if (perm.display !== 'granted') perm = await LocalNotifications.requestPermissions();
                    if (perm.display !== 'granted') return;

                    await LocalNotifications.schedule({
                        notifications: [{
                            title: `å‡†å¤‡å½•éŸ³: ${getNameById(task.musicianId, 'musician')}`,
                            body: `${task.startTime} å¼€å§‹ (${getNameById(task.projectId, 'project')})`,
                            id: notifId,
                            schedule: {at: triggerTime},
                            sound: 'default', // æˆ– 'beep.wav'
                            smallIcon: 'ic_stat_icon', // Android å›¾æ ‡
                        }]
                    });

                    console.log(`âœ… é€šçŸ¥å·²è®¾å®š: ${triggerTime.toLocaleTimeString()}`);

                } catch (e) {
                    console.error("è®¾ç½®é€šçŸ¥å¤±è´¥:", e);
                }
            };

            // ğŸŸ¢ æ–°å¢: æ‰¾å›å¯†ç é€»è¾‘
            const handleResetPwd = async () => {
                if (!authForm.email) return openAlertModal("è¯·å…ˆåœ¨ä¸Šæ–¹è¾“å…¥æ‚¨çš„é‚®ç®±åœ°å€");

                authLoading.value = true;
                const {data, error} = await supabase.auth.resetPasswordForEmail(authForm.email, {
                    redirectTo: window.location.origin, // é‡ç½®åè·³å›å½“å‰é¡µé¢
                });

                if (error) {
                    openAlertModal("å‘é€å¤±è´¥: " + error.message);
                } else {
                    openAlertModal(`é‡ç½®é‚®ä»¶å·²å‘é€è‡³ ${authForm.email}\nè¯·æŸ¥æ”¶é‚®ä»¶å¹¶ç‚¹å‡»é“¾æ¥é‡è®¾å¯†ç ã€‚`);
                }
                authLoading.value = false;
            };

            // ğŸŸ¢ æ–°å¢: ä¸ªäººä¸­å¿ƒé€»è¾‘

            // è®¡ç®—å½“å‰æ˜¾ç¤ºçš„å¤´åƒ (ä¼˜å…ˆè¯»å– user_metadata)
            const userAvatar = computed(() => {
                if (user.value && user.value.user_metadata && user.value.user_metadata.avatar_url) {
                    return user.value.user_metadata.avatar_url;
                }
                return null;
            });

            // --- ğŸŸ¢ æ–°å¢: æ˜µç§°ç®¡ç†é€»è¾‘ ---
            const tempNickname = ref('');

            // è®¡ç®—æ˜¾ç¤ºåç§° (ä¼˜å…ˆæ˜¾ç¤º full_nameï¼Œå¦åˆ™æ˜¾ç¤ºé‚®ç®±å‰ç¼€)
            const userDisplayName = computed(() => {
                if (user.value && user.value.user_metadata && user.value.user_metadata.full_name) {
                    return user.value.user_metadata.full_name;
                }
                return user.value ? user.value.email.split('@')[0] : 'Guest';
            });

            // æ›´æ–°æ˜µç§°åˆ° Supabase
            const updateNickname = async () => {
                if (!user.value) return;
                if (!tempNickname.value.trim()) return openAlertModal("æ˜µç§°ä¸èƒ½ä¸ºç©º");

                authLoading.value = true;
                try {
                    const {data, error} = await supabase.auth.updateUser({
                        data: {full_name: tempNickname.value.trim()}
                    });

                    if (error) throw error;

                    user.value = data.user; // æ›´æ–°æœ¬åœ°ç”¨æˆ·æ•°æ®ä»¥åˆ·æ–° UI
                    // alert("æ˜µç§°å·²æ›´æ–°ï¼"); // å¯é€‰ï¼šä¸å–œæ¬¢å¼¹çª—å¯ä»¥æ³¨é‡Šæ‰
                    // è¿™é‡Œæˆ‘ä»¬ä¸å…³é—­èœå•ï¼Œæ–¹ä¾¿ç”¨æˆ·çœ‹åˆ°å˜åŒ–
                } catch (error) {
                    openAlertModal("æ›´æ–°å¤±è´¥: " + error.message);
                } finally {
                    authLoading.value = false;
                }
            };

            // ğŸŸ¢ ä¿®æ”¹éƒ¨åˆ†
            const factoryReset = () => {
                openConfirmModal(
                    'æ¢å¤å‡ºå‚è®¾ç½®',
                    'âš ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿ\n\nè¿™å°†ä¼šæ¸…é™¤æ‚¨åœ¨æœ¬åœ°ä¿å­˜çš„æ‰€æœ‰è®¾ç½®å’Œæ•°æ®ã€‚',
                    () => {
                        localStorage.removeItem('v9_data');
                        window.location.reload();
                    },
                    true, // çº¢è‰²è­¦å‘Š
                    'å½»åº•æ¸…ç©º', // ç¡®è®¤æŒ‰é’®æ–‡æ¡ˆ
                    'å†æƒ³æƒ³'   // å–æ¶ˆæŒ‰é’®æ–‡æ¡ˆ
                );
            };

            // å¤„ç†é¡¶éƒ¨æŒ‰é’®ç‚¹å‡»
            // ğŸ”´ ä¿®æ”¹: åŠ å…¥äº’æ–¥é€»è¾‘
            // ğŸ”´ ä¿®æ”¹: å¤„ç†é¡¶éƒ¨å¤´åƒæŒ‰é’®ç‚¹å‡» (åˆå¹¶äº†ä¹‹å‰çš„äº’æ–¥é€»è¾‘å’Œæ˜µç§°å¡«å……)
            const handleUserBtnClick = () => {
                if (user.value) {
                    const wasOpen = showProfileMenu.value;

                    // 1. å¼ºåˆ¶å…³é—­å…¶ä»–èœå• (äº’æ–¥)
                    activeDropdown.value = null;
                    showMobileMenu.value = false;

                    // 2. åˆ‡æ¢è‡ªå·±
                    showProfileMenu.value = !wasOpen;

                    // 3. å¦‚æœæ‰“å¼€äº†ï¼Œåˆå§‹åŒ–æ•°æ®
                    if (showProfileMenu.value) {
                        // å¡«å……å¤´åƒ URL
                        tempAvatarUrl.value = userAvatar.value || '';
                        // å¡«å……å½“å‰æ˜µç§° (å¦‚æœæœ‰)
                        tempNickname.value = userDisplayName.value;
                    }
                } else {
                    showAuthModal.value = true;
                }
            };

            // æ›´æ–°å¤´åƒåˆ° Supabase
            const updateAvatar = async () => {
                if (!user.value) return;

                const url = tempAvatarUrl.value.trim();

                // è°ƒç”¨ Supabase æ›´æ–°ç”¨æˆ·å…ƒæ•°æ®
                const {data, error} = await supabase.auth.updateUser({
                    data: {avatar_url: url}
                });

                if (error) {
                    openAlertModal("æ›´æ–°å¤±è´¥: " + error.message);
                } else {
                    // æ›´æ–°æœ¬åœ° user å¯¹è±¡ä»¥ç«‹å³åˆ·æ–° UI
                    user.value = data.user;
                    openAlertModal("å¤´åƒå·²æ›´æ–°ï¼");
                }
            };

            // ğŸŸ¢ æ–°å¢: åˆ¤æ–­æ˜¯å¦ä¸ºé»˜è®¤å€ç‡ (ç”¨äºéšè—å¡ç‰‡ä¸Šçš„å€ç‡æ ‡ç­¾)
            const isDefaultRatio = (item) => {
                // 1. å¦‚æœæ²¡æœ‰å€ç‡ï¼Œè§†ä½œé»˜è®¤ï¼ˆéšè—ï¼‰
                if (!item.ratio) return true;

                const val = Number(item.ratio);

                // 2. å°è¯•æ‰¾åˆ°å¯¹åº”æ¼”å¥å‘˜çš„é»˜è®¤å€ç‡é…ç½®
                if (item.musicianId) {
                    const m = settings.musicians.find(u => u.id === item.musicianId);
                    // å¦‚æœè¯¥æ¼”å¥å‘˜æœ‰ç‰¹å®šçš„é»˜è®¤å€ç‡ï¼Œåˆ™ä¸è¯¥å€¼æ¯”è¾ƒ
                    if (m && m.defaultRatio) {
                        return val === Number(m.defaultRatio);
                    }
                }

                // 3. å¦‚æœæ‰¾ä¸åˆ°ç‰¹å®šé…ç½®ï¼Œåˆ™å…œåº•æ¯”è¾ƒå…¨å±€é»˜è®¤å€¼ 20
                return val === 20;
            };


            // ğŸŸ¢ ä¿®æ”¹: autoUpdateMusicianEfficiency (åªåœ¨æ¼”å¥å‘˜è§†å›¾ä¸‹æ›´æ–°å€ç‡ï¼Œå…¶ä»–è§†å›¾ä»…ä¿å­˜æ•°æ®)
            const autoUpdateMusicianEfficiency = (musicianId, viewType, shouldPushHistory = true) => {
                // å¦‚æœä¸æ˜¯æ¼”å¥å‘˜è§†å›¾ï¼Œæˆ–è€…æ²¡æœ‰IDï¼Œæˆ‘ä»¬å°±ä¸è‡ªåŠ¨æ›´æ–°å…¨å±€å€ç‡äº†
                // å› ä¸º"é¡¹ç›®è¿›åº¦"é€šå¸¸ä¸å½±å“"æ¼”å¥å‘˜æ•ˆç‡"
                if (viewType !== 'musician' || !musicianId) {
                    pushHistory(); // ä»…ä¿å­˜æ•°æ®
                    return;
                }

                // ... (åŸæœ‰çš„å€ç‡è®¡ç®—é€»è¾‘ï¼Œä¿æŒä¸å˜ï¼Œå®ƒç°åœ¨ä¼šè¯»å– records.musician çš„æ•°æ®) ...
                // è¿™é‡Œéœ€è¦å¾®è°ƒä¸€ä¸‹åŸæœ¬çš„é€»è¾‘ï¼Œè®©å®ƒå»è¯» records.musician

                const items = itemPool.value.filter(i => i.musicianId === musicianId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                let totalActual = 0;
                let totalMusic = 0;

                items.forEach(item => {
                    const rec = item.records?.musician; // ğŸŸ¢ åªè¯» musician è®°å½•
                    if (rec && rec.actualDuration && item.musicDuration) {
                        const act = parseTime(rec.actualDuration);
                        const mus = parseTime(item.musicDuration);
                        if (act > 0 && mus > 0) {
                            totalActual += act;
                            totalMusic += mus;
                        }
                    }
                });

                // 3. è®¡ç®—æ–°æ¯”å€¼
                let newRatio = 20; // å…œåº•é»˜è®¤å€¼
                if (totalMusic > 0) {
                    newRatio = parseFloat((totalActual / totalMusic).toFixed(1));
                }


                // 4. è·å–æ—§çš„é»˜è®¤å€ç‡ (ç”¨äºåˆ¤æ–­å“ªäº›å¡ç‰‡æ˜¯"è·Ÿéšé»˜è®¤"çš„)
                const musicianSettings = settings.musicians.find(m => m.id === musicianId);
                let oldDefaultRatio = 20;
                if (musicianSettings) {
                    oldDefaultRatio = musicianSettings.defaultRatio || 20;
                    // æ›´æ–°å…¨å±€è®¾ç½®
                    musicianSettings.defaultRatio = newRatio;
                }

                // --- ğŸŸ¢ æ ¸å¿ƒä¿®å¤å¼€å§‹ ---

                // 5. æ›´æ–°ã€ä»»åŠ¡æ± ã€‘ä¸­çš„å¡ç‰‡
                itemPool.value.forEach(item => {
                    if (item.musicianId === musicianId && item.musicDuration) {
                        // æ™ºèƒ½åˆ¤æ–­ï¼šå¦‚æœå¡ç‰‡å½“å‰çš„å€ç‡ == æ—§çš„é»˜è®¤å€ç‡ï¼Œè¯´æ˜å®ƒæ²¡æœ‰è¢«æ‰‹åŠ¨æ”¹è¿‡ï¼Œåº”å½“è·Ÿéšæ›´æ–°
                        // æˆ–è€…ï¼šå¦‚æœå¡ç‰‡æ²¡æœ‰å€ç‡ï¼Œä¹Ÿå¼ºåˆ¶æ›´æ–°
                        // (æ³¨æ„ï¼šè¿™é‡Œç”¨ Math.abs å¤„ç†æµ®ç‚¹æ•°æ¯”è¾ƒï¼Œæˆ–è€…ç›´æ¥ç”¨ == æ¯”è¾ƒå­—ç¬¦ä¸²/æ•°å­—)
                        if (!item.ratio || item.ratio == oldDefaultRatio) {
                            item.ratio = newRatio;
                            // å…³é”®ï¼šç«‹å³é‡ç®—é¢„è®¡æ—¶é•¿
                            item.estDuration = calculateEstTime(item.musicDuration, newRatio);
                        }
                    }
                });

                // 6. æ›´æ–°ã€æ—¥ç¨‹è¡¨ã€‘ä¸­çš„æœªå®Œæˆä»»åŠ¡
                scheduledTasks.value.forEach(task => {
                    // æ’é™¤å·²å½•å®Œçš„(æœ‰ actualDuration)ã€æ’é™¤ä¸å±äºè¯¥äººçš„
                    if (task.musicianId === musicianId && !task.actualDuration && task.musicDuration) {

                        // åŒæ ·é€»è¾‘ï¼šåªæœ‰"è·Ÿéšé»˜è®¤"çš„ä»»åŠ¡æ‰è‡ªåŠ¨å˜
                        if (!task.ratio || task.ratio == oldDefaultRatio) {
                            task.ratio = newRatio;
                            // å…³é”®ï¼šç«‹å³é‡ç®—é¢„è®¡æ—¶é•¿
                            task.estDuration = calculateEstTime(task.musicDuration, newRatio);
                        }
                    }
                });
                if (shouldPushHistory) {
                    pushHistory();
                }
            };

            // ğŸŸ¢ æ–°å¢: å¤„ç†å¤´åƒæ–‡ä»¶ä¸Šä¼ 
            const handleAvatarUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // 1. é™åˆ¶æ–‡ä»¶å¤§å° (ä¾‹å¦‚ 2MB)
                if (file.size > 2 * 1024 * 1024) {
                    return openAlertModal("å›¾ç‰‡å¤ªå¤§äº†ï¼Œè¯·é€‰æ‹© 2MB ä»¥ä¸‹çš„å›¾ç‰‡");
                }

                // æ›´æ”¹æŒ‰é’®æ–‡å­—æ˜¾ç¤ºçŠ¶æ€ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
                const btnText = document.getElementById('upload-text');
                if (btnText) btnText.innerText = "ä¸Šä¼ ä¸­...";

                try {
                    // 2. ç”Ÿæˆæ–‡ä»¶å: user_id + æ—¶é—´æˆ³ + åç¼€
                    const fileExt = file.name.split('.').pop();
                    const fileName = `${user.value.id}-${Date.now()}.${fileExt}`;
                    const filePath = `${fileName}`;

                    // 3. ä¸Šä¼ åˆ° 'avatars' æ¡¶
                    const {error: uploadError} = await supabase.storage
                        .from('avatars')
                        .upload(filePath, file);

                    if (uploadError) throw uploadError;

                    // 4. è·å–å…¬å¼€è®¿é—® URL
                    const {data} = supabase.storage
                        .from('avatars')
                        .getPublicUrl(filePath);

                    const publicUrl = data.publicUrl;

                    // 5. æ›´æ–°ç”¨æˆ·å…ƒæ•°æ® (Metadata)
                    const {data: userData, error: updateError} = await supabase.auth.updateUser({
                        data: {avatar_url: publicUrl}
                    });

                    if (updateError) throw updateError;

                    // æˆåŠŸï¼
                    user.value = userData.user;
                    openAlertModal("å¤´åƒä¸Šä¼ æˆåŠŸï¼");

                } catch (error) {
                    openAlertModal("ä¸Šä¼ å¤±è´¥: " + error.message);
                    console.error(error);
                } finally {
                    if (btnText) btnText.innerText = "é€‰æ‹©å›¾ç‰‡...";
                    event.target.value = ''; // é‡ç½® inputï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
                }
            };

            // ğŸŸ¢ æ–°å¢: ç™»å‡ºé€»è¾‘
            // ğŸŸ¢ ä¿®æ”¹: æš´åŠ›æ¸…é™¤æ‰€æœ‰ç¼“å­˜ï¼Œç¡®ä¿é€€å‡ºåä¸ä¼šè‡ªåŠ¨ç™»å½•
            // ğŸŸ¢ ä¿®æ”¹: é€€å‡ºç™»å½•æ—¶ï¼Œåªæ¸…é™¤èº«ä»½ä¿¡æ¯ï¼Œä¿ç•™æœ¬åœ°æ•°æ® (v9_data)
            const handleLogout = async () => {
                // 1. ç•Œé¢ä¸Šç½®ç©ºç”¨æˆ·
                user.value = null;

                // 2. æ‰§è¡Œ Supabase ç™»å‡º
                // (Supabase ä¼šè‡ªåŠ¨æ¸…é™¤æµè§ˆå™¨ä¸­ä¸è´¦å·ç›¸å…³çš„ sb-xxx-tokenï¼Œä½†ä¸ä¼šåŠ¨ä½ çš„ v9_data)
                try {
                    await supabase.auth.signOut();
                } catch (e) {
                    console.error("Cloud signout failed:", e);
                }

                // ğŸ”´ å…³é”®ä¿®æ”¹: åˆ é™¤ä¹‹å‰å†™çš„ localStorage.clear() æˆ– removeItem
                // æˆ‘ä»¬ä¸å†æ¸…é™¤æœ¬åœ°å­˜å‚¨ï¼Œè¿™æ ·â€œæ¸¸å®¢æ¨¡å¼â€çš„æ•°æ®æˆ–è€…åˆšæ‰åŒæ­¥ä¸‹æ¥çš„æ•°æ®éƒ½ä¼šç•™åœ¨æœ¬åœ°

                // 3. æç¤ºå¹¶åˆ·æ–°
                openAlertModal("å·²é€€å‡ºè´¦å·è¿æ¥ã€‚");

                // åˆ·æ–°é¡µé¢ï¼Œæ­¤æ—¶ onMounted ä¼šå‘ç°æ²¡ç™»å½•ï¼Œä»è€ŒåŠ è½½æœ¬åœ°çš„ v9_data
                window.location.reload();
            };

            // ğŸŸ¢ æ–°å¢: åŠ è½½æ•°æ® (æ ¸å¿ƒé€»è¾‘æ”¹é€ )
            // ğŸŸ¢ ä¿®æ”¹: ä¼˜åŒ–åçš„åŠ è½½/ä¸Šä¼ é€»è¾‘
            const loadCloudData = async () => {
                if (!user.value) return;

                // 1. å…ˆä»äº‘ç«¯æ‹‰å–æ•°æ®
                const {data, error} = await supabase
                    .from('user_data')
                    .select('content')
                    .eq('user_id', user.value.id)
                    .single(); // æ³¨æ„ï¼šå¦‚æœæ²¡æœ‰æ•°æ®ï¼Œsingle() å¯èƒ½ä¼šè¿”å› error æˆ– dataä¸ºnull

                if (data && data.content) {
                    // ã€æƒ…å†µ Aã€‘äº‘ç«¯æœ‰æ•°æ® -> è¦†ç›–æœ¬åœ°
                    console.log("âœ… å·²åŠ è½½äº‘ç«¯æ•°æ®");
                    const d = data.content;

                    // æ¢å¤é€»è¾‘ (ä¿æŒä¸å˜)
                    if (d.pool) itemPool.value = d.pool;
                    if (d.tasks) scheduledTasks.value = d.tasks;
                    if (d.settings) {
                        Object.assign(settings, d.settings);
                        if (d.settings.lastSessionId) {
                            const exists = settings.sessions.find(s => s.id === d.settings.lastSessionId);
                            currentSessionId.value = exists ? exists.id : settings.sessions[0].id;
                        }
                    }
                } else {
                    // ã€æƒ…å†µ Bã€‘äº‘ç«¯æ²¡æ•°æ® (æ–°ç”¨æˆ·) -> æ£€æŸ¥æœ¬åœ°æ˜¯å¦æœ‰æ•°æ®
                    console.log("âš ï¸ äº‘ç«¯æ— æ•°æ®");

                    const localStr = localStorage.getItem('v9_data');

                    if (localStr) {
                        // æ£€æŸ¥æœ¬åœ°æ•°æ®æ˜¯å¦æ˜¯ç©ºçš„ (é˜²æ­¢ç©ºå¯¹è±¡ {} ä¹Ÿè§¦å‘å¼¹çª—)
                        const localData = JSON.parse(localStr);
                        const hasRealData = (localData.pool && localData.pool.length > 0) || (localData.tasks && localData.tasks.length > 0);

                        if (hasRealData) {
                            if (hasRealData) {
                                // æ›¿æ¢ confirm
                                openConfirmModal(
                                    'æ•°æ®å†²çª',
                                    'æ£€æµ‹åˆ°æ‚¨æœ¬åœ°æœ‰æ—§æ•°æ®ï¼Œè€Œäº‘ç«¯æ˜¯ç©ºçš„ã€‚\n\næ‚¨å¸Œæœ›å¦‚ä½•å¤„ç†ï¼Ÿ',
                                    async () => {
                                        // --- ç”¨æˆ·ç‚¹å‡» "ä¸Šä¼ æœ¬åœ°æ•°æ®" çš„é€»è¾‘ ---
                                        const dataToUpload = {
                                            pool: localData.pool || [],
                                            tasks: localData.tasks || [],
                                            settings: localData.settings || settings
                                        };
                                        const {error: uploadError} = await supabase
                                            .from('user_data')
                                            .upsert({
                                                user_id: user.value.id,
                                                content: dataToUpload
                                            }, {onConflict: 'user_id'});

                                        if (!uploadError) {
                                            openAlertModal('æˆåŠŸ', 'âœ… æœ¬åœ°æ•°æ®å·²æˆåŠŸä¸Šä¼ ï¼');
                                        } else {
                                            openAlertModal('ä¸Šä¼ å¤±è´¥', uploadError.message);
                                        }
                                    },
                                    false,
                                    'ä¸Šä¼ æœ¬åœ°æ•°æ®', // Confirm Button
                                    'æ”¾å¼ƒæœ¬åœ°æ•°æ®'  // Cancel Button
                                );
                            }
                        }
                    }
                }
            };

            const saveToCloud = async (force = false) => {
                if (!user.value) return;

                const dataToSave = {
                    pool: itemPool.value,
                    tasks: scheduledTasks.value,
                    settings: {...settings, lastSessionId: currentSessionId.value}
                };

                // 1. åŸæœ‰çš„ï¼šæ›´æ–°ä¸»æ•°æ® (ä¿æŒæœ€æ–°)
                await supabase
                    .from('user_data')
                    .upsert({
                        user_id: user.value.id,
                        content: dataToSave
                    }, {onConflict: 'user_id'});

                // 2. ğŸŸ¢ æ–°å¢ï¼šå­˜æ¡£ä¸€ä»½åˆ°å†å²è®°å½•è¡¨
                // ä¸ºäº†é˜²æ­¢å†å²è¡¨æ— é™è†¨èƒ€ï¼Œå¯ä»¥åªåœ¨ç‰¹å®šæ“ä½œ(å¦‚"æ‰‹åŠ¨å¤‡ä»½")æ—¶æ‰æ‰§è¡Œè¿™ä¸€æ­¥
                // æˆ–è€…æ¯éš” 10 æ¬¡ä¿å­˜æ‰§è¡Œä¸€æ¬¡
                await supabase
                    .from('user_data_history')
                    .insert({
                        user_id: user.value.id,
                        content: dataToSave
                    });

                console.log("äº‘ç«¯åŒæ­¥å®Œæˆ (å«å†å²å¤‡ä»½)");
            };

            // --- V11.8 è‡ªå®šä¹‰ä¸‹æ‹‰èœå•çŠ¶æ€ ---
            const activeDropdown = ref(null); // å½“å‰æ‰“å¼€çš„èœå•: 'project' | 'instrument' | 'musician' | null
            const dropdownSearch = ref('');   // ä¸‹æ‹‰èœå•å†…çš„æœç´¢è¯

            // 1. è®¾ç½®å¼¹çª—çš„åˆ†ç»„çŠ¶æ€
            const settingsExpandedGroups = reactive(new Set()); // é»˜è®¤ç©ºSetï¼Œå³å…¨éƒ¨æŠ˜å 

            // 2. ä¸‹æ‹‰èœå•çš„åˆ†ç»„çŠ¶æ€
            const dropdownExpandedGroups = reactive(new Set()); // é»˜è®¤ç©ºSetï¼Œå³å…¨éƒ¨æŠ˜å 

            const toggleDropdownGroup = (groupName) => {
                if (dropdownExpandedGroups.has(groupName)) {
                    dropdownExpandedGroups.delete(groupName);
                } else {
                    dropdownExpandedGroups.add(groupName);
                }
            };

            // 3. ç›‘å¬æœç´¢æ¡†ï¼šå¦‚æœç”¨æˆ·å¼€å§‹æœç´¢ï¼Œè‡ªåŠ¨å±•å¼€æ‰€æœ‰ä¸‹æ‹‰åˆ†ç»„ï¼Œæ–¹ä¾¿æŸ¥æ‰¾
            watch(dropdownSearch, (val) => {
                if (val && val.trim()) {
                    // æœç´¢æ—¶ä¸æ¸…ç©º Setï¼Œè€Œæ˜¯é€»è¾‘ä¸Šè§†ä¸ºå…¨å±•å¼€ (åœ¨ HTML v-show ä¸­å¤„ç†)
                } else {
                    // æœç´¢æ¸…ç©ºæ—¶ï¼Œæ¢å¤ä¹‹å‰çš„æŠ˜å çŠ¶æ€ï¼ˆæˆ–è€…ä½ å¯ä»¥é€‰æ‹©åœ¨è¿™é‡Œ dropdownExpandedGroups.clear() æ¥å…¨éƒ¨æŠ˜å ï¼‰
                    dropdownExpandedGroups.clear();
                }
            });

            // ğŸŸ¢ ä¿®æ”¹ toggleDropdown: æ¯æ¬¡æ‰“å¼€èœå•æ—¶ï¼Œé‡ç½®ä¸ºå…¨æŠ˜å çŠ¶æ€
            const toggleDropdown = (type) => {
                if (activeDropdown.value === type) {
                    activeDropdown.value = null;
                } else {
                    showMobileMenu.value = false;
                    showProfileMenu.value = false;
                    activeDropdown.value = type;
                    dropdownSearch.value = '';
                    activeGroupFilter.value = 'å…¨éƒ¨';

                    // é‡ç½®æŠ˜å çŠ¶æ€
                    dropdownExpandedGroups.clear();

                    setTimeout(() => {
                        const input = document.querySelector('.custom-dropdown-menu input[placeholder*="æœç´¢"]');
                        if (input) input.focus();
                    }, 50);
                }
            };

            // ğŸŸ¢ æ–°å¢: åˆ†ç»„ç­›é€‰çŠ¶æ€
            const activeGroupFilter = ref('å…¨éƒ¨');

            // ğŸŸ¢ ä¿®æ”¹: æ”¯æŒ edit_ å‰ç¼€
            const availableGroups = computed(() => {
                const type = activeDropdown.value;
                if (!type) return [];

                // åŒæ—¶å»é™¤ mobile_ å’Œ edit_ å‰ç¼€
                const realType = type.replace('mobile_', '').replace('edit_', '');

                let list = [];
                if (realType === 'project') list = settings.projects;
                else if (realType === 'instrument') list = settings.instruments;
                else if (realType === 'musician') list = settings.musicians;

                // ... (åç»­å»é‡æ’åºé€»è¾‘ä¿æŒä¸å˜)
                const groups = new Set(list.map(i => (i.group && i.group.trim()) ? i.group : 'æœªåˆ†ç»„'));
                const sorted = Array.from(groups).sort((a, b) => {
                    if (a === 'æœªåˆ†ç»„') return 1;
                    if (b === 'æœªåˆ†ç»„') return -1;
                    return a.localeCompare(b, 'zh-CN');
                });

                return ['å…¨éƒ¨', ...sorted];
            });

            // ğŸ”´ æ–°å¢: åˆ‡æ¢æ‰‹æœºèœå• (äº’æ–¥å…¶ä»–)
            const toggleMobileMenu = () => {
                const wasOpen = showMobileMenu.value;
                // å…ˆå…³é—­å…¶ä»–æ‰€æœ‰èœå•
                activeDropdown.value = null;
                showProfileMenu.value = false;
                // å†åˆ‡æ¢è‡ªå·±
                showMobileMenu.value = !wasOpen;
            };


            // ğŸŸ¢ ä¿®å¤: ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ä¸‹æ‹‰èœå•çš„â€œç‚¹å‡»å¤–éƒ¨å…³é—­â€é€»è¾‘
            const closeDropdowns = (e) => {
                // 1. ä¸»ç•Œé¢ä¸‹æ‹‰èœå• & ç”¨æˆ·èœå•
                const insideSelect = e.target.closest('.custom-select-container');
                const insideUser = e.target.closest('.user-menu-container');

                if (!insideSelect && !insideUser) {
                    activeDropdown.value = null;
                    showProfileMenu.value = false;
                    showMobileMenu.value = false;
                }

                // 2. Settings å¼¹çª—é‡Œçš„åˆ†ç»„ä¸‹æ‹‰
                // å¦‚æœç‚¹å‡»çš„ç›®æ ‡ä¸åœ¨ settings-group-wrapper å†…éƒ¨ï¼Œä¸”å½“å‰æ˜¯æ‰“å¼€çŠ¶æ€ï¼Œåˆ™å…³é—­
                const insideSettingsGroup = e.target.closest('.settings-group-wrapper');
                if (!insideSettingsGroup && settingsGroupFocus.value) {
                    settingsGroupFocus.value = null;
                }

                // âœ¨âœ¨âœ¨ æ–°å¢ï¼šSettings å¼¹çª—é‡Œçš„ã€åç§°ã€‘ä¸‹æ‹‰ âœ¨âœ¨âœ¨
                const insideSettingsName = e.target.closest('.settings-name-wrapper');
                if (!insideSettingsName && settingsNameFocus.value) {
                    settingsNameFocus.value = null;
                }

                // 3. Quick Add å¼¹çª—é‡Œçš„åˆ†ç»„ä¸‹æ‹‰
                // å¦‚æœç‚¹å‡»çš„ç›®æ ‡ä¸åœ¨ quick-add-group-wrapper å†…éƒ¨ï¼Œä¸”å½“å‰æ˜¯æ‰“å¼€çŠ¶æ€ï¼Œåˆ™å…³é—­
                const insideQuickAddGroup = e.target.closest('.quick-add-group-wrapper');
                if (!insideQuickAddGroup && showGroupSuggestions.value) {
                    showGroupSuggestions.value = false;
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: æ”¯æŒ edit_ å‰ç¼€
            const filteredOptions = computed(() => {
                const search = dropdownSearch.value.toLowerCase();
                const type = activeDropdown.value;
                if (!type) return [];

                // åŒæ—¶å»é™¤ mobile_ å’Œ edit_ å‰ç¼€
                const realType = type.replace('mobile_', '').replace('edit_', '');

                let list = [];
                if (realType === 'project') list = settings.projects;
                else if (realType === 'instrument') list = settings.instruments;
                else if (realType === 'musician') list = settings.musicians;

                // ... (åç»­æœç´¢ã€ç­›é€‰ã€æ’åºé€»è¾‘ä¿æŒä¸å˜)
                let result = list.filter(i => i.name.toLowerCase().includes(search));

                if (activeGroupFilter.value !== 'å…¨éƒ¨') {
                    result = result.filter(i => {
                        const g = (i.group && i.group.trim()) ? i.group : 'æœªåˆ†ç»„';
                        return g === activeGroupFilter.value;
                    });
                }

                result.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));
                return result;
            });

            // ğŸŸ¢ æ–°å¢ helper: å°†å¹³é“ºçš„æ•°ç»„è½¬æ¢ä¸ºåˆ†ç»„å¯¹è±¡ {'åˆ†ç»„A': [item1], 'åˆ†ç»„B': [item2]}
            const getGroupedOptions = (list) => {
                const groups = {};
                const defaultKey = 'æœªåˆ†ç»„'; // é»˜è®¤åˆ†ç»„åç§°

                list.forEach(item => {
                    // å¦‚æœæ²¡æœ‰è®¾ç½® group å­—æ®µï¼Œå½’å…¥é»˜è®¤åˆ†ç»„
                    const g = item.group && item.group.trim() ? item.group : defaultKey;
                    if (!groups[g]) groups[g] = [];
                    groups[g].push(item);
                });

                // ç¨å¾®æ’ä¸ªåºï¼ŒæŠŠâ€œæœªåˆ†ç»„â€æ”¾åˆ°æœ€åï¼Œå…¶ä»–åˆ†ç»„æŒ‰åç§°æ’
                const sortedKeys = Object.keys(groups).sort((a, b) => {
                    if (a === defaultKey) return 1;
                    if (b === defaultKey) return -1;
                    return a.localeCompare(b, 'zh-CN');
                });

                // æ„é€ æœ‰åºçš„éå†æ•°ç»„
                return sortedKeys.map(key => ({
                    name: key,
                    items: groups[key]
                }));
            };

            // ğŸŸ¢ ä¿®æ”¹: æ”¯æŒç¼–è¾‘æ¨¡å¼èµ‹å€¼
            const selectOption = (type, item) => {
                // 1. åˆ¤æ–­å½“å‰ä¸Šä¸‹æ–‡ï¼šå¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ (activeDropdown ä»¥ edit_ å¼€å¤´)
                if (activeDropdown.value && activeDropdown.value.startsWith('edit_')) {
                    const realType = activeDropdown.value.replace('edit_', '');

                    if (realType === 'project') editingItem.value.projectId = item.id;
                    else if (realType === 'instrument') editingItem.value.instrumentId = item.id;
                    else if (realType === 'musician') editingItem.value.musicianId = item.id;

                    // é€‰ä¸­åå…³é—­
                    activeDropdown.value = null;
                    return;
                }

                // 2. åŸæœ‰çš„æ–°å»ºæ¨¡å¼é€»è¾‘ (ä¿æŒä¸å˜)
                if (type === 'project') newItem.projectId = item.id;
                if (type === 'instrument') newItem.instrumentId = item.id;
                if (type === 'musician') {
                    newItem.musicianId = item.id;
                    onMusicianSelect();
                }
                activeDropdown.value = null;
            };

            // åœ¨ onMounted é‡Œç»‘å®šç‚¹å‡»å¤–éƒ¨å…³é—­
            // onMounted(() => { ... window.addEventListener('click', closeDropdowns); ... })
            // åˆ«å¿˜äº†åœ¨ onUnmounted ç§»é™¤

            const SLOT_HEIGHT = 40;
            const PX_PER_MIN = 40 / 30;


            // V9.7.4: sortKey/activeColorKey å¯ä»¥æ˜¯ projectId
            // ä¿®æ”¹ï¼šé»˜è®¤åˆ†ç»„æ”¹ä¸º 'projectId' (é¡¹ç›®)
            const sortKey = ref('projectId');
            const activeColorKey = ref('projectId');
            // æ”¹ç”¨ expandedGroupsï¼šå­˜è°å±•å¼€äº†ï¼Œæ²¡å­˜çš„å°±æ˜¯æŠ˜å çš„ (é»˜è®¤å…¨ç©º=å…¨æŠ˜å )
            const expandedGroups = reactive(new Set());

            // --- V10.3 æ’åºçŠ¶æ€ç®¡ç† ---
            const sortField = ref('status'); // 'name' | 'duration'
            const sortAsc = ref(true);     // true=æ­£åº(A-Z, å°-å¤§), false=å€’åº(Z-A, å¤§-å°)

            // 1. æ–°å»ºé¡¹ç›®çš„ä¸´æ—¶çŠ¶æ€
            const newSettingsItem = reactive({
                instrument: {name: '', group: ''},
                musician: {name: '', group: ''},
                project: {name: '', group: ''}
            });

            // --- ğŸŸ¢ åˆ†ç»„é€‰æ‹©å™¨çŠ¶æ€ç®¡ç† ---
            const showGroupSuggestions = ref(false); // ç”¨äº Quick Add å¼¹çª—
            const settingsGroupFocus = ref(null);    // ç”¨äº Settings å¼¹çª—ï¼Œå­˜å‚¨å½“å‰èšç„¦çš„ç±»å‹ ('instrument'/'musician'/'project')

            // 2. è·å–åˆ†ç»„åçš„åˆ—è¡¨ (æ ¸å¿ƒé€»è¾‘)
            const getSettingsGroupedList = (type) => {
                let list = [];
                if (type === 'instrument') list = settings.instruments;
                else if (type === 'musician') list = settings.musicians;
                else if (type === 'project') list = settings.projects;

                const groups = {};
                const defaultKey = 'æœªåˆ†ç»„';

                list.forEach(item => {
                    const g = (item.group && item.group.trim()) ? item.group : defaultKey;
                    if (!groups[g]) groups[g] = [];
                    groups[g].push(item);
                });

                // æ’åºï¼šå…ˆæŒ‰åˆ†ç»„åæ’åºï¼ˆ"æœªåˆ†ç»„"æ”¾æœ€åï¼‰ï¼Œç»„å†…æŒ‰åç§°æ’åº
                return Object.keys(groups).sort((a, b) => {
                    if (a === defaultKey) return 1;
                    if (b === defaultKey) return -1;
                    return a.localeCompare(b, 'zh-CN');
                }).map(key => ({
                    name: key === defaultKey ? '' : key, // æ˜¾ç¤ºæ—¶ï¼Œæœªåˆ†ç»„æ˜¾ç¤ºä¸ºç©ºå­—ç¬¦ä¸²æˆ– "æœªåˆ†ç»„"
                    items: groups[key].sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'))
                }));
            };

            // ğŸŸ¢ ä¿®å¤: å¥å£®çš„åˆ†ç»„è·å–å‡½æ•°
            const getExistingGroups = (type) => {
                // 1. å®‰å…¨è§£åŒ…: æ— è®ºä¼ å…¥çš„æ˜¯ Ref å¯¹è±¡è¿˜æ˜¯æ™®é€šå­—ç¬¦ä¸²ï¼Œéƒ½ç»Ÿä¸€è½¬ä¸ºå­—ç¬¦ä¸²
                let val = type;
                if (typeof type === 'object' && type !== null && 'value' in type) {
                    val = type.value;
                }

                // å¦‚æœå€¼ä¸ºç©ºï¼Œç›´æ¥è¿”å›
                if (!val) return [];

                // 2. ç§»é™¤å¯èƒ½å­˜åœ¨çš„å‰ç¼€
                // å¼ºåˆ¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²å† replaceï¼Œé˜²æ­¢ val æ˜¯éå­—ç¬¦ä¸²ç±»å‹å¯¼è‡´çš„æŠ¥é”™
                const realType = String(val).replace('mobile_', '');

                // 3. åŒ¹é…æ•°æ®æº
                let list = [];
                if (realType === 'instrument') list = settings.instruments;
                else if (realType === 'musician') list = settings.musicians;
                else if (realType === 'project') list = settings.projects;

                // å¦‚æœæ‰¾ä¸åˆ°å¯¹åº”åˆ—è¡¨ï¼Œè¿”å›ç©º
                if (!list || !Array.isArray(list)) return [];

                // 4. æå–åˆ†ç»„å¹¶å»é‡
                const groups = new Set();
                list.forEach(item => {
                    // ç¡®ä¿ group å­—æ®µå­˜åœ¨ï¼Œä¸”ä¸æ˜¯çº¯ç©ºæ ¼
                    if (item.group && typeof item.group === 'string' && item.group.trim() !== '') {
                        groups.add(item.group.trim());
                    }
                });

                // 5. æ’åºè¿”å› (æŒ‰æ‹¼éŸ³æ’åº)
                return Array.from(groups).sort((a, b) => a.localeCompare(b, 'zh-CN'));
            };


            // 4. é‡å‘½ååˆ†ç»„
            const renameGroup = (type, oldName, newName) => {
                const finalNewName = newName.trim();
                if (oldName === finalNewName) return; // æ²¡å˜

                let list = [];
                if (type === 'instrument') list = settings.instruments;
                else if (type === 'musician') list = settings.musicians;
                else if (type === 'project') list = settings.projects;

                // æ‰¹é‡æ›´æ–°æ‰€æœ‰å±äºè¯¥ç»„çš„é¡¹ç›®
                // å¦‚æœ oldName ä¸ºç©ºï¼Œè¡¨ç¤ºå°†"æœªåˆ†ç»„"çš„é¡¹ç›®å½’å…¥æ–°ç»„
                // å¦‚æœ newName ä¸ºç©ºï¼Œè¡¨ç¤ºå°†è¯¥ç»„é¡¹ç›®å˜ä¸º"æœªåˆ†ç»„"
                list.forEach(item => {
                    const g = (item.group || '').trim();
                    if (g === (oldName || '').trim()) {
                        item.group = finalNewName;
                    }
                });
                pushHistory();
            };

            // ğŸŸ¢ ä¿®æ”¹ï¼šaddSettingsItem (æ”¯æŒâ€œç§»åŠ¨åˆ†ç»„â€é€»è¾‘)
            const addSettingsItem = (type) => {
                const form = newSettingsItem[type];
                const nameStr = form.name.trim();
                const groupStr = form.group.trim();

                if (!nameStr && !groupStr) {
                    return openAlertModal('æ— æ³•æ·»åŠ ', 'è¯·è‡³å°‘è¾“å…¥ åç§° æˆ– åˆ†ç»„ã€‚');
                }

                let list = [];
                if (type === 'instrument') list = settings.instruments;
                else if (type === 'musician') list = settings.musicians;
                else if (type === 'project') list = settings.projects;

                // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒåé¡¹ç›®
                if (nameStr) {
                    const existingItem = list.find(i => i.name.toLowerCase() === nameStr.toLowerCase());

                    if (existingItem) {
                        // âœ¨ åœºæ™¯ A: é¡¹ç›®å·²å­˜åœ¨ -> æ‰§è¡Œâ€œç§»åŠ¨åˆ†ç»„â€æ“ä½œ
                        if (existingItem.group !== groupStr) {
                            existingItem.group = groupStr;

                            // å¦‚æœæœ‰æ–°åˆ†ç»„ï¼Œè‡ªåŠ¨å±•å¼€å®ƒ
                            if (groupStr) settingsExpandedGroups.add(type + '|' + groupStr);

                            pushHistory();
                            window.triggerTouchHaptic('Success');

                            // é‡ç½®è¾“å…¥æ¡†ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡æ“ä½œ
                            form.name = '';
                            return; // ç»“æŸå‡½æ•°ï¼Œä¸åˆ›å»ºæ–° ID
                        } else {
                            // å¦‚æœåˆ†ç»„ä¹Ÿä¸€æ ·ï¼Œé‚£å°±æ˜¯çº¯é‡å¤ï¼ŒæŠ¥é”™
                            window.triggerTouchHaptic('Error');
                            return openAlertModal('é‡å¤æ·»åŠ ', 'è¯¥é¡¹ç›®å·²å­˜åœ¨äºå½“å‰åˆ†ç»„ä¸­ã€‚');
                        }
                    }
                }

                // âœ¨ åœºæ™¯ B: é¡¹ç›®ä¸å­˜åœ¨ -> æ‰§è¡Œâ€œæ–°å»ºâ€æ“ä½œ (åŸæœ‰é€»è¾‘)
                const idPrefix = type === 'project' ? 'P' : (type === 'instrument' ? 'I' : 'M');
                const newItem = {
                    id: generateUniqueId(idPrefix),
                    name: nameStr,
                    group: groupStr,
                    color: generateRandomHexColor()
                };
                if (type === 'musician') newItem.defaultRatio = 20;

                list.push(newItem);

                if (groupStr) {
                    settingsExpandedGroups.add(type + '|' + groupStr);
                }

                form.name = '';
                pushHistory();
                window.triggerTouchHaptic('Success');
            };

            // 6. åˆ é™¤é¡¹ç›®
            const removeSettingsItem = (type, id) => {
                // ä½¿ç”¨ä¹‹å‰å®šä¹‰çš„ç‰¹å®šåˆ é™¤å‡½æ•°ä»¥ä¿ç•™ç¡®è®¤å¼¹çª—é€»è¾‘
                if (type === 'instrument') removeInstrument(id);
                else if (type === 'musician') removeMusician(id);
                else if (type === 'project') deleteProject(id);
            };

            const clearSettingsList = (type) => {
                if (type === 'instrument') clearAllInstruments();
                else if (type === 'musician') clearAllMusicians();
                else if (type === 'project') clearAllProjects();
            }

            // --- æ‹–æ‹½é‡åˆ†ç»„é€»è¾‘ ---
            let settingsDragItem = null;

            const onSettingsItemDragStart = (item, type, e) => {
                settingsDragItem = {item, type};
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', JSON.stringify(item)); // å…¼å®¹æ€§
                // ç¨å¾®å˜é€æ˜
                e.target.style.opacity = '0.5';
            };

            const onSettingsDragOver = (e) => {
                if (settingsDragItem) {
                    e.preventDefault(); // å…è®¸æ”¾ç½®
                    e.currentTarget.classList.add('drag-over');
                }
            };

            const onSettingsDragLeave = (e) => {
                e.currentTarget.classList.remove('drag-over');
            };

            const onSettingsDrop = (targetType, targetGroupName, e) => {
                e.currentTarget.classList.remove('drag-over');
                // æ¢å¤æ ·å¼
                const draggables = document.querySelectorAll('[draggable=true]');
                draggables.forEach(el => el.style.opacity = '1');

                if (!settingsDragItem) return;

                // åªèƒ½åœ¨åŒç±»å‹ä¹‹é—´æ‹–æ‹½
                if (settingsDragItem.type !== targetType) return;

                // å¦‚æœæ‹–åˆ°äº†è‡ªå·±æ‰€åœ¨çš„åˆ†ç»„ï¼Œä¸åšå¤„ç†
                const currentGroup = settingsDragItem.item.group || '';
                const targetGroup = targetGroupName || ''; // ç©ºå­—ç¬¦ä¸²ä»£è¡¨æœªåˆ†ç»„

                if (currentGroup === targetGroup) {
                    settingsDragItem = null;
                    return;
                }

                // æ‰§è¡Œç§»åŠ¨ï¼šæ›´æ–° group å±æ€§
                settingsDragItem.item.group = targetGroup;

                pushHistory();
                settingsDragItem = null;
                window.triggerTouchHaptic('Light');
            };


            // é€šç”¨åˆ‡æ¢æ’åºå‡½æ•°
            const toggleSort = (field) => {
                if (sortField.value === field) {
                    // å¦‚æœç‚¹çš„è¿˜æ˜¯å½“å‰å­—æ®µï¼Œå°±åè½¬é¡ºåº
                    sortAsc.value = !sortAsc.value;
                } else {
                    // å¦‚æœç‚¹äº†æ–°å­—æ®µï¼Œåˆ‡æ¢å­—æ®µ
                    sortField.value = field;
                    // è®¾ç½®é»˜è®¤é¡ºåºï¼šåç§°é»˜è®¤æ­£åº(A-Z)ï¼Œæ—¶é•¿é»˜è®¤å€’åº(ä»é•¿åˆ°çŸ­ï¼Œæ–¹ä¾¿çœ‹å·¥ä½œé‡)
                    sortAsc.value = (field === 'name');
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: getSortIcon (å¢åŠ  Status å›¾æ ‡æ”¯æŒ)
            const getSortIcon = (field) => {
                if (sortField.value !== field) return '';
                if (field === 'name') return sortAsc.value ? 'fa-arrow-down-a-z' : 'fa-arrow-up-a-z';
                if (field === 'duration') return sortAsc.value ? 'fa-arrow-up-short-wide' : 'fa-arrow-down-wide-short';
                // status: æ­£åº(å®Œæˆ->æœªæ’)ç”¨ list-check å›¾æ ‡ï¼Œå€’åºç”¨åå‘
                if (field === 'status') return sortAsc.value ? 'fa-arrow-down-short-wide' : 'fa-arrow-up-wide-short';
                return '';
            };

            // --- Core Helpers ---
            const parseTime = s => {
                if (!s) return 0;
                const p = s.split(':').map(Number);
                return p.length === 2 ? p[0] * 60 + p[1] : p[0] * 3600 + p[1] * 60 + p[2];
            };
            const formatSecs = s => {
                const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sec = Math.floor(s % 60);
                return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
            };
            const calculateEstTime = (d, r) => formatSecs(parseTime(d) * (r || 1));
            const timeToMinutes = timeStr => {
                const [h, m] = timeStr.split(':').map(Number);
                return h * 60 + m;
            };

            // --- History & Persistence ---
            // --- History & Persistence ---
            const history = ref([]);
            const historyIndex = ref(-1);

            const user = ref(null);
            const showAuthModal = ref(false);
            const authLoading = ref(false);
            const authForm = reactive({email: '', password: ''});
            const authPasswordRef = ref(null);
            let syncTimeout = null; // ç”¨äºé˜²æŠ–ä¿å­˜

            // ğŸŸ¢ æ–°å¢: åŠ¨æ€è®¡ç®—æŒ‰æ¯”ä¾‹åˆ†é…çš„æ—¶é—´é…é¢
            // é€»è¾‘: (å•æ›²è°±é¢æ—¶é•¿ / åˆ—è¡¨æ‰€æœ‰æ›²ç›®è°±é¢æ€»é•¿) * æ—¥ç¨‹å—æ€»æ—¶é•¿
            const calculateProportionalDuration = (item) => {
                // å®‰å…¨æ£€æŸ¥: å¦‚æœæ²¡æœ‰æ—¥ç¨‹å—å¼•ç”¨æˆ–åˆ—è¡¨ä¸ºç©ºï¼Œå›é€€åˆ°é»˜è®¤æ˜¾ç¤º
                if (!trackListData.value.taskRef || !trackListData.value.items || trackListData.value.items.length === 0) {
                    return item.estDuration;
                }

                // 1. è·å–æ—¥ç¨‹å—çš„æ€»æ—¶é•¿ (ä¾‹å¦‚ "10:43 - 11:05" ä¹‹é—´çš„æ—¶é•¿ï¼Œæˆ–è€…æ˜¯ taskRef.estDuration)
                // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨æ—¥ç¨‹å—çš„ estDuration (å³å·²å®‰æ’æ—¶é•¿)
                const blockSeconds = parseTime(trackListData.value.taskRef.estDuration);

                // 2. è®¡ç®—å½“å‰åˆ—è¡¨ä¸­æ‰€æœ‰æ›²ç›®çš„è°±é¢æ€»é•¿
                let totalMusicSeconds = 0;
                trackListData.value.items.forEach(i => {
                    totalMusicSeconds += parseTime(i.musicDuration || '00:00');
                });

                // é˜²æ­¢é™¤ä»¥é›¶
                if (totalMusicSeconds === 0) return item.estDuration;

                // 3. è®¡ç®—å½“å‰æ›²ç›®çš„æƒé‡å¹¶åˆ†é…æ—¶é—´
                const itemMusicSeconds = parseTime(item.musicDuration || '00:00');
                const allocatedSeconds = (itemMusicSeconds / totalMusicSeconds) * blockSeconds;

                return formatSecs(Math.round(allocatedSeconds));
            };

            // åœ¨ setup å‡½æ•°å†…éƒ¨
            const getDefaultRatio = (musicianId) => {
                // 1. æŸ¥æ‰¾æ¼”å¥å‘˜çš„è®¾ç½®
                const mus = settings.musicians.find(m => m.id === musicianId);
                if (!mus) return 20; // æ‰¾ä¸åˆ°æ¼”å¥å‘˜ï¼Œé»˜è®¤è¿”å› 20

                // 2. æŸ¥æ‰¾è¯¥æ¼”å¥å‘˜çš„ç»Ÿè®¡æ•°æ®
                const stat = musicianStats.value.find(s => s.id === musicianId);

                // 3. ä¼˜å…ˆçº§: å·²è®¡ç®—çš„çœŸå®å¹³å‡å€ç‡ > è®¾ç½®çš„é»˜è®¤å€ç‡ > 20
                if (stat && stat.avgRealRatio > 0) {
                    // å¦‚æœæœ‰çœŸå®çš„å½•éŸ³æ•°æ®ï¼Œåˆ™ä½¿ç”¨å®æ—¶è®¡ç®—å‡ºçš„å¹³å‡å€ç‡
                    return stat.avgRealRatio;
                }

                // å¦‚æœè®¾ç½®é‡Œæœ‰ defaultRatioï¼Œåˆ™ä½¿ç”¨å®ƒï¼ˆå³ä½¿å®ƒæ˜¯ 20ï¼‰
                if (mus.defaultRatio && mus.defaultRatio > 0) {
                    return mus.defaultRatio;
                }

                // æœ€åå›é€€åˆ° 20
                return 20;
            };

            const pushHistory = () => {
                if (historyIndex.value < history.value.length - 1) history.value = history.value.slice(0, historyIndex.value + 1);

                // ğŸŸ¢ ä¿®å¤: å°† settings ä¹ŸåŠ å…¥åˆ°å†å²è®°å½•å¿«ç…§ä¸­
                history.value.push(JSON.stringify({
                    pool: itemPool.value,
                    tasks: scheduledTasks.value,
                    settings: settings // å…³é”®ä¿®æ”¹ï¼šä¿å­˜è®¾ç½®çŠ¶æ€
                }));

                historyIndex.value++;
                if (history.value.length > 50) {
                    history.value.shift();
                    historyIndex.value--;
                }
            };

            // ğŸŸ¢ ä¿®å¤: Undo æ’¤é”€å‡½æ•° (åŠ å…¥ sectionIndex æ’åºæ”¯æŒ)
            const undo = () => {
                if (historyIndex.value > 0) {
                    historyIndex.value--;
                    const s = JSON.parse(history.value[historyIndex.value]);
                    itemPool.value = s.pool;
                    scheduledTasks.value = s.tasks;

                    if (s.settings) {
                        Object.assign(settings, s.settings);
                    }

                    // --- ğŸŸ¢ TrackList è§†å›¾å®æ—¶åˆ·æ–° ---
                    if (showTrackList.value && trackListData.value.taskRef) {
                        // è·å–å½“å‰è§†å›¾ç±»å‹ (ç¡®ä¿èƒ½è¯»åˆ°æ­£ç¡®çš„æ—¶é—´è®°å½•)
                        const viewType = trackListData.value.viewType || 'musician';

                        // 1. æ ¹æ®å½“å‰ä¸Šä¸‹æ–‡ç­›é€‰ä»»åŠ¡
                        let list = [];
                        // å¦‚æœæ˜¯æŒ‰é¡¹ç›®æŸ¥çœ‹ï¼Œå°±ç­›é€‰åŒé¡¹ç›®çš„ä»»åŠ¡
                        if (viewType === 'project') {
                            list = itemPool.value.filter(i => i.projectId === trackListData.value.taskRef.projectId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        }
                        // å¦‚æœæ˜¯æŒ‰ä¹å™¨æŸ¥çœ‹
                        else if (viewType === 'instrument') {
                            list = itemPool.value.filter(i => i.instrumentId === trackListData.value.taskRef.instrumentId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        }
                        // é»˜è®¤æŒ‰æ¼”å¥å‘˜æŸ¥çœ‹
                        else {
                            list = itemPool.value.filter(i => i.musicianId === trackListData.value.taskRef.musicianId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        }

                        // 2. ğŸŸ¢ å…³é”®ä¿®å¤: ä½¿ç”¨å®Œæ•´çš„æ’åºé€»è¾‘ (å…ˆåˆ†æ®µï¼Œåæ—¶é—´)
                        list.sort((a, b) => {
                            // ç¬¬ä¸€ä¼˜å…ˆçº§: åˆ†æ®µç´¢å¼• (Section)
                            const secA = a.sectionIndex || 0;
                            const secB = b.sectionIndex || 0;
                            if (secA !== secB) return secA - secB;

                            // ç¬¬äºŒä¼˜å…ˆçº§: æ—¶é—´ (Time)
                            const recA = a.records?.[viewType];
                            const recB = b.records?.[viewType];
                            const tA = recA?.recStart || '99:99';
                            const tB = recB?.recStart || '99:99';
                            return tA.localeCompare(tB);
                        });

                        // 3. èµ‹å€¼æ›´æ–° UI
                        trackListData.value.items = list;
                    }
                }
            };

// ğŸŸ¢ ä¿®å¤: Redo é‡åšå‡½æ•° (åŠ å…¥ sectionIndex æ’åºæ”¯æŒ)
            const redo = () => {
                if (historyIndex.value < history.value.length - 1) {
                    historyIndex.value++;
                    const s = JSON.parse(history.value[historyIndex.value]);
                    itemPool.value = s.pool;
                    scheduledTasks.value = s.tasks;

                    if (s.settings) {
                        Object.assign(settings, s.settings);
                    }

                    // --- ğŸŸ¢ TrackList è§†å›¾å®æ—¶åˆ·æ–° ---
                    if (showTrackList.value && trackListData.value.taskRef) {
                        const viewType = trackListData.value.viewType || 'musician';

                        let list = [];
                        if (viewType === 'project') {
                            list = itemPool.value.filter(i => i.projectId === trackListData.value.taskRef.projectId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        } else if (viewType === 'instrument') {
                            list = itemPool.value.filter(i => i.instrumentId === trackListData.value.taskRef.instrumentId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        } else {
                            list = itemPool.value.filter(i => i.musicianId === trackListData.value.taskRef.musicianId && (i.sessionId || 'S_DEFAULT') === currentSessionId.value);
                        }

                        // ğŸŸ¢ å…³é”®ä¿®å¤: åŒæ ·çš„æ’åºé€»è¾‘
                        list.sort((a, b) => {
                            const secA = a.sectionIndex || 0;
                            const secB = b.sectionIndex || 0;
                            if (secA !== secB) return secA - secB;

                            const recA = a.records?.[viewType];
                            const recB = b.records?.[viewType];
                            const tA = recA?.recStart || '99:99';
                            const tB = recB?.recStart || '99:99';
                            return tA.localeCompare(tB);
                        });

                        trackListData.value.items = list;
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹åçš„ exportToICS
            const exportToICS = () => {
                if (scheduledTasks.value.length === 0) {
                    openAlertModal("æ—¥ç¨‹è¡¨æ˜¯ç©ºçš„");
                    return;
                }

                openInputModal('å¯¼å‡ºæ—¥å† (ICS)', 'recording_schedule.ics', 'è¯·è¾“å…¥æ–‡ä»¶å', (inputName) => {
                    if (!inputName) return;

                    let fileName = inputName;
                    if (!fileName.toLowerCase().endsWith('.ics')) fileName += '.ics';

                    let ics = "BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//AudioScheduler//CN\n";
                    scheduledTasks.value.forEach(t => {
                        // ... (ä¸­é—´çš„ç”Ÿæˆé€»è¾‘ä¿æŒä¸å˜ï¼Œå®Œå…¨ä¸éœ€è¦æ”¹åŠ¨) ...
                        const dStr = t.date.replace(/-/g, '');
                        const [sh, sm] = t.startTime.split(':').map(Number);
                        const startStr = `${String(sh).padStart(2, '0')}${String(sm).padStart(2, '0')}00`;
                        const durSec = parseTime(t.estDuration);
                        const endD = new Date(new Date(t.date + 'T' + t.startTime).getTime() + durSec * 1000);
                        const endStr = `${endD.getFullYear()}${String(endD.getMonth() + 1).padStart(2, '0')}${String(endD.getDate()).padStart(2, '0')}T${String(endD.getHours()).padStart(2, '0')}${String(endD.getMinutes()).padStart(2, '0')}00`;

                        const musicianName = getNameById(t.musicianId, 'musician');
                        const instrumentName = getNameById(t.instrumentId, 'instrument');
                        const projectName = getNameById(t.projectId, 'project');

                        ics += `BEGIN:VEVENT\nUID:${t.scheduleId}\nDTSTAMP:${dStr}T${startStr}\nDTSTART:${dStr}T${startStr}\nDTEND:${endStr}\nSUMMARY:${musicianName} - ${instrumentName} (${projectName})\nDESCRIPTION:å½•åˆ¶æ—¶é•¿:${t.estDuration}\nEND:VEVENT\n`;
                    });
                    ics += "END:VCALENDAR";

                    const blob = new Blob([ics], {type: 'text/calendar'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName; // ä½¿ç”¨è¾“å…¥çš„æ–‡ä»¶å
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                });
            };

            // ğŸŸ¢ ä¿®æ”¹åçš„ exportJSON
            const exportJSON = () => {
                // è‡ªåŠ¨ç”Ÿæˆé»˜è®¤æ–‡ä»¶å
                const now = new Date();
                const dateStr = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
                const defaultName = `backup_${dateStr}.json`;

                openInputModal('å¤‡ä»½æ•°æ® (JSON)', defaultName, 'è¯·è¾“å…¥æ–‡ä»¶å', (inputName) => {
                    if (!inputName) return;

                    // è‡ªåŠ¨è¡¥å…¨åç¼€
                    let fileName = inputName;
                    if (!fileName.toLowerCase().endsWith('.json')) fileName += '.json';

                    const data = {
                        pool: itemPool.value,
                        tasks: scheduledTasks.value,
                        settings: settings
                    };
                    const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 'æ–‡ä»¶å°†ä¿å­˜åˆ°æ‚¨çš„ä¸‹è½½æ–‡ä»¶å¤¹');
            };

            // --- ğŸŸ¢ å¯¼å…¥å¼¹çª—çŠ¶æ€ ---
            const showImportModal = ref(false);

            // 1. ç‚¹å‡»èœå•ä¸­çš„â€œæ¢å¤æ•°æ®â€æ—¶ï¼Œåªæ‰“å¼€æ¼‚äº®çš„å¼¹çª—
            const importJSON = () => {
                showImportModal.value = true;
            };

            // 2. ç‚¹å‡»å¼¹çª—ä¸­é—´çš„å¤§åŒºåŸŸæ—¶ï¼Œè§¦å‘éšè—çš„ input
            const triggerFileSelect = () => {
                const input = document.getElementById("json-upload");
                if (input) {
                    input.value = ''; // æ¸…ç©ºä¸Šæ¬¡è®°å½•ï¼Œç¡®ä¿é‡å¤é€‰æ–‡ä»¶æœ‰æ•ˆ
                    input.click();
                }
            };

            // ğŸŸ¢ ä¿®æ”¹åçš„ handleJSONFile
            const handleJSONFile = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);

                        // ç®€å•æ ¡éªŒ
                        if (!data.pool && !data.tasks && !data.settings) {
                            throw new Error("æ— æ•ˆçš„å¤‡ä»½æ–‡ä»¶");
                        }

                        pushHistory();
                        itemPool.value = data.pool || [];
                        scheduledTasks.value = data.tasks || [];
                        if (data.settings) Object.assign(settings, data.settings);
                        pushHistory();

                        // âœ… æˆåŠŸåå…³é—­å¯¼å…¥å¼¹çª—
                        showImportModal.value = false;

                        // ä½¿ç”¨æˆ‘ä»¬åˆšæ‰åšçš„æ¼‚äº® Alert æç¤ºæˆåŠŸ
                        openAlertModal('å¯¼å…¥æˆåŠŸ', 'æ•°æ®å·²æˆåŠŸæ¢å¤ï¼');

                    } catch (err) {
                        console.error(err);
                        openAlertModal('å¯¼å…¥å¤±è´¥', 'æ–‡ä»¶æ ¼å¼é”™è¯¯æˆ–å·²æŸåã€‚');
                    }
                };
                reader.readAsText(file, "UTF-8");
                e.target.value = "";
            };


            onMounted(async () => {
                // 1. æ£€æŸ¥æ˜¯å¦æœ‰å·²ç™»å½•ç”¨æˆ·
                const {data} = await supabase.auth.getSession();

                if (data.session) {
                    user.value = data.session.user;
                    await loadCloudData(); // ä¼˜å…ˆåŠ è½½äº‘ç«¯
                } else {
                    // 2. å¦‚æœæ²¡ç™»å½•ï¼ŒåŠ è½½æœ¬åœ° LocalStorage
                    const d = JSON.parse(localStorage.getItem('v9_data') || '{}');

                    if (d.settings) {
                        // ğŸŸ¢ ä¿®å¤: åŠ è½½æ•°æ®æ—¶æ˜¾å¼åŒ…å« group å­—æ®µ
                        settings.instruments = d.settings.instruments.map(i => ({
                            id: i.id || generateUniqueId('I'),
                            name: i.name,
                            color: i.color || '#3b82f6',
                            group: i.group || '' // âœ… åŠ ä¸Šè¿™ä¸€è¡Œ
                        }));

                        // ä¿®æ­£ä¸Šé¢çš„ç¬”è¯¯ï¼Œåº”è¯¥æ˜¯ m.group
                        settings.musicians = d.settings.musicians.map(m => ({
                            id: m.id || generateUniqueId('M'),
                            name: m.name,
                            defaultRatio: m.defaultRatio,
                            color: m.color || '#ef4444',
                            group: m.group || '' // âœ… ä¿®æ­£ä¸º m.group
                        }));

                        settings.startHour = d.settings.startHour;
                        settings.endHour = d.settings.endHour;

                        // é¡¹ç›®åŠ è½½é€»è¾‘
                        let projectsData = [];
                        if (d.settings.projects && Array.isArray(d.settings.projects)) {
                            projectsData = d.settings.projects.map(p => ({
                                id: p.id || generateUniqueId('P'),
                                name: p.name,
                                color: p.color || generateRandomHexColor(),
                                group: p.group || '' // âœ… åŠ ä¸Šè¿™ä¸€è¡Œ
                            }));
                        } else if (d.settings.projectColors) {
                            projectsData = Object.entries(d.settings.projectColors).map(([name, color]) => ({
                                id: generateUniqueId('P'),
                                name: name,
                                color: color
                            }));
                        }
                        settings.projects = projectsData;

                        // åŠ è½½ Sessions
                        if (d.settings.sessions && Array.isArray(d.settings.sessions)) {
                            settings.sessions = d.settings.sessions;
                        } else {
                            settings.sessions = [{id: 'S_DEFAULT', name: 'é»˜è®¤å½•éŸ³æ—¥ç¨‹'}];
                        }

                        if (d.settings.lastSessionId) {
                            const exists = settings.sessions.find(s => s.id === d.settings.lastSessionId);
                            currentSessionId.value = exists ? exists.id : settings.sessions[0].id;
                        } else {
                            currentSessionId.value = settings.sessions[0].id;
                        }
                    }

                    // 3. åŠ è½½ä»»åŠ¡å¹¶è¿›è¡Œ ID è¿ç§»
                    if (d.pool) {
                        // ğŸŸ¢ éå†æ‰€æœ‰ä»»åŠ¡ï¼Œç¡®ä¿ç»“æ„å‡çº§
                        itemPool.value = d.pool.map(item => ensureItemRecords(item));
                    }

                    if (d.tasks) scheduledTasks.value = d.tasks;

                    // ä»»åŠ¡æ•°æ®è¿ç§»
                    const migrateTasks = (tasks) => tasks.map(t => {
                        if (t.project && !t.projectId) {
                            // ç®€å•è¿ç§»é€»è¾‘ï¼Œç•¥å»å¤æ‚åˆ¤æ–­ä»¥èŠ‚çœç¯‡å¹…ï¼Œæ ¸å¿ƒæ˜¯ç¡®ä¿ projectId å­˜åœ¨
                            t.projectId = '';
                        }
                        return t;
                    });
                    // æ³¨æ„ï¼šä¸ºäº†ä»£ç ç®€æ´ï¼Œè¿™é‡Œç•¥å»äº†ä½ åŸä»£ç ä¸­è¯¦ç»†çš„ migrateTasks é€»è¾‘ï¼Œ
                    // å¦‚æœä½ ä¹‹å‰æœ‰å¤æ‚çš„è¿ç§»é€»è¾‘ï¼Œè¯·ç¡®ä¿ä¿ç•™ã€‚ä½†å…³é”®æ˜¯ä¸‹é¢çš„æ‹¬å·è¦é—­åˆã€‚

                    // ç¡®ä¿ settings.projects å§‹ç»ˆå­˜åœ¨
                    if (!settings.projects) settings.projects = [];
                }

                const setVh = () => {
                    let vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                };
                window.addEventListener('resize', setVh);
                setVh(); // åˆå§‹åŒ–æ‰§è¡Œä¸€æ¬¡

                pushHistory();
                // --- ğŸŸ¢ æ–°å¢ï¼šå…¨å±€ Haptics è§¦æ‘¸éœ‡åŠ¨ç›‘å¬ ---
                const appElement = document.getElementById('app');
                if (appElement) {
                    appElement.addEventListener('click', (event) => {
                        // æ£€æŸ¥è¢«ç‚¹å‡»çš„å…ƒç´ æˆ–å…¶çˆ¶çº§æ˜¯å¦æ˜¯æŒ‰é’®ã€é“¾æ¥ã€æˆ–æœ‰ç‰¹æ®Šå¯ç‚¹å‡»æ ·å¼
                        const target = event.target.closest('button, a, [role="button"], .cursor-pointer, .segment-btn');

                        if (target) {
                            // æ’é™¤ç‰¹å®šçš„å…ƒç´ ï¼Œä¾‹å¦‚è¾“å…¥æ¡† (å¦‚æœå®ƒè¢«åŒ…è£¹åœ¨ button é‡Œ)
                            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                                return;
                            }

                            // æ’é™¤ç¦ç”¨çŠ¶æ€çš„å…ƒç´ 
                            if (target.hasAttribute('disabled') || target.classList.contains('disabled')) {
                                return;
                            }

                            // ç»Ÿä¸€è§¦å‘ä¸­ç­‰å¼ºåº¦éœ‡åŠ¨
                            window.triggerTouchHaptic('Medium');
                        }
                    });
                }
                window.addEventListener('keydown', handleGlobalKey);
                window.addEventListener('mousemove', handleResizeMove);
                window.addEventListener('mouseup', handleResizeEnd);
                window.addEventListener('click', closeDropdowns);

                // ğŸŸ¢ æ–°å¢: æ‰€æœ‰ä¸œè¥¿å‡†å¤‡å¥½åï¼Œç§»é™¤åŠ è½½é¡µ
                const loader = document.getElementById('global-loader');
                if (loader) {
                    // ç»™ä¸€ç‚¹ç‚¹å»¶è¿Ÿï¼Œè®©ç•Œé¢æ¸²æŸ“æ›´å¹³æ»‘
                    setTimeout(() => {
                        loader.classList.add('hidden');
                        // åŠ¨ç”»ç»“æŸåå½»åº•ç§»é™¤ DOM (å¯é€‰)
                        // setTimeout(() => loader.remove(), 500);
                    }, 300);
                }
            });

            onUnmounted(() => {
                window.removeEventListener('keydown', handleGlobalKey);
                window.removeEventListener('mousemove', handleResizeMove);
                window.removeEventListener('mouseup', handleResizeEnd);
                window.removeEventListener('click', closeDropdowns);
            });
            // V9.7.4: ç§»é™¤ projectColors çš„ watch
            watch([itemPool, scheduledTasks, settings, currentSessionId], () => {

                // ğŸŸ¢ ä¿®æ”¹: åŒºåˆ†ç™»å½•çŠ¶æ€ï¼Œä¿æŠ¤æœ¬åœ°æ•°æ®
                if (user.value) {
                    // ã€å·²ç™»å½•çŠ¶æ€ã€‘
                    // 1. åªåŒæ­¥åˆ°äº‘ç«¯
                    // 2. ç»å¯¹ä¸è¦å†™å…¥ localStorage('v9_data')ï¼Œé˜²æ­¢è¦†ç›–æ¸¸å®¢åŸæœ¬çš„æ•°æ®
                    clearTimeout(syncTimeout);
                    syncTimeout = setTimeout(() => {
                        saveToCloud();
                    }, 2000);
                } else {
                    // ã€æœªç™»å½•/æ¸¸å®¢çŠ¶æ€ã€‘
                    // 1. ä»…ä¿å­˜åˆ°æœ¬åœ°ï¼Œä½œä¸ºç¦»çº¿æ•°æ®
                    const dataToSave = {
                        pool: itemPool.value,
                        tasks: scheduledTasks.value,
                        settings: {...settings, lastSessionId: currentSessionId.value}
                    };
                    localStorage.setItem('v9_data', JSON.stringify(dataToSave));
                }

            }, {deep: true});

            // ğŸŸ¢ ä¿®æ”¹: addProject (ä¸å†ç”Ÿæˆé¢œè‰²)
            const addProject = () => {
                settings.projects.push({
                    id: generateUniqueId('P'),
                    name: `æ–°é¡¹ç›®${settings.projects.length + 1}`,
                    group: ''
                    // color: ... å·²ç§»é™¤
                });
                pushHistory();
            };

            const jumpToGhostContext = (task) => {
                let changed = false;
                let message = [];

                // 1. æ£€æŸ¥ Session æ˜¯å¦ä¸åŒ
                const taskSession = task.sessionId || 'S_DEFAULT';
                if (currentSessionId.value !== taskSession) {
                    currentSessionId.value = taskSession;
                    changed = true;
                    const sessionName = settings.sessions.find(s => s.id === taskSession)?.name || 'ç›®æ ‡æ—¥ç¨‹';
                    message.push(`å·²åˆ‡æ¢åˆ°: ${sessionName}`);
                }

                // 2. æ£€æŸ¥è§†å›¾ç±»å‹ (Sidebar Tab) æ˜¯å¦ä¸åŒ
                // é€»è¾‘ï¼šå¦‚æœä»»åŠ¡æœ‰ projectIdï¼Œå°±åº”è¯¥åœ¨ Project è§†å›¾ä¸‹çœ‹ï¼›æœ‰ instrumentId å» Instrument è§†å›¾...
                let targetTab = 'musician';
                if (task.projectId) targetTab = 'project';
                else if (task.instrumentId) targetTab = 'instrument';
                else if (task.musicianId) targetTab = 'musician';

                if (sidebarTab.value !== targetTab) {
                    sidebarTab.value = targetTab;
                    changed = true;
                    // const tabName = targetTab === 'project' ? 'é¡¹ç›®è§†å›¾' : (targetTab === 'instrument' ? 'ä¹å™¨è§†å›¾' : 'äººå‘˜è§†å›¾');
                    // message.push(`å·²åˆ‡æ¢åˆ° ${tabName}`);
                }

                if (changed) {
                    window.triggerTouchHaptic('Medium');

                    // é«˜äº®ä¸€ä¸‹è¯¥ä»»åŠ¡ï¼Œè®©ç”¨æˆ·çŸ¥é“è·³åˆ°äº†å“ªé‡Œ
                    flashingTaskId.value = task.scheduleId;
                    setTimeout(() => {
                        if (flashingTaskId.value === task.scheduleId) flashingTaskId.value = null;
                    }, 1500);

                    // å¯é€‰ï¼šå¼¹ä¸ªæç¤º
                    // openAlertModal("è§†å›¾è·³è½¬", message.join('\n'));
                } else {
                    // å¦‚æœä¸Šä¸‹æ–‡éƒ½ä¸€æ ·ï¼Œè¯´æ˜å¯èƒ½æ˜¯é€»è¾‘åˆ¤æ–­æ¼äº†ï¼Œæˆ–è€…å®ƒæœ¬æ¥å°±ä¸æ˜¯å¹½çµ
                    window.triggerTouchHaptic('Error');
                }
            };


            const deleteProject = (projectId) => {
                // ä»…ä»è®¾ç½®ä¸­åˆ é™¤é¡¹ç›®ã€‚å·²ç»‘å®šè¯¥IDçš„ä»»åŠ¡å°†æ˜¾ç¤ºâ€œæœªçŸ¥é¡¹ç›®â€ã€‚
                settings.projects = settings.projects.filter(p => p.id !== projectId);
                pushHistory();
            }

            // --- V9.7: è½¯æ’æœŸé€»è¾‘ ---
            const scheduledTemplateIds = computed(() => {
                return new Set(scheduledTasks.value.map(t => t.templateId).filter(id => id !== undefined));
            });
            const isScheduled = templateId => scheduledTemplateIds.value.has(templateId);

            const handlePoolItemClick = (poolItemId) => {
                selectTask(poolItemId, 'pool');
                // åŸæ¥çš„é€»è¾‘æ˜¯æ‰‹åŠ¨æ‰¾ task ç„¶å scrollTo
                // ç°åœ¨ selectTask å†…éƒ¨å·²ç»è°ƒç”¨äº† smartScrollToTaskï¼Œæ‰€ä»¥è¿™é‡Œå…¶å®åªéœ€è¦ä¿ç•™ selectTask å³å¯
                // ä½†ä¸ºäº†ä¿é™©ï¼Œå¦‚æœä½ è¿™é‡Œæœ‰ç‰¹æ®Šçš„é€»è¾‘ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è°ƒç”¨ï¼š
                /* const firstScheduled = scheduledTasks.value.find(t => t.templateId === poolItemId);
                    if (firstScheduled) {
                        smartScrollToTask(firstScheduled);
                    }
                    */
            };

            // --- V9.7.4: CSV å¯¼å…¥é€»è¾‘ (åŸºäº ID) ---
            const getOrCreateProjectId = (projectName) => {
                let project = settings.projects.find(p => p.name === projectName);
                if (!project) {
                    project = {id: generateUniqueId('P'), name: projectName, color: generateRandomHexColor()};
                    settings.projects.push(project);
                }
                return project.id;
            };

            const parseCSV = (csvText) => {
                const lines = csvText.split('\n').filter(line => line.trim() !== '');
                if (lines.length === 0) return [];

                const headers = lines[0].split(',').map(h => h.trim());
                const requiredHeaders = ['project', 'instrumentName', 'musicianName', 'musicDuration', 'ratio'];

                if (!requiredHeaders.every(h => headers.includes(h))) {
                    console.error('CSV ç¼ºå°‘å¿…éœ€çš„åˆ—å¤´:', requiredHeaders.filter(h => !headers.includes(h)));
                    openAlertModal(`CSV æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼ç¼ºå°‘å¿…éœ€çš„åˆ—ï¼š${requiredHeaders.filter(h => !headers.includes(h)).join(', ')}`);
                    return [];
                }

                // 1. å»ºç«‹ç°æœ‰ä»»åŠ¡æ¨¡æ¿çš„æŸ¥æ‰¾è¡¨ (Key -> Array of Items)
                // å˜æ›´ç‚¹ï¼šMap çš„å€¼ä¸å†æ˜¯å•ä¸ªå¯¹è±¡ï¼Œè€Œæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç”¨æ¥å­˜åŒä¸€ç§ç»„åˆä¸‹çš„å¤šä¸ªä»»åŠ¡
                const existingPoolMap = new Map();

                itemPool.value.forEach(item => {
                    const key = `${item.projectId}_${item.instrumentId}_${item.musicianId}`;
                    if (!existingPoolMap.has(key)) {
                        existingPoolMap.set(key, []);
                    }
                    existingPoolMap.get(key).push(item);
                });

                const tasksToProcess = [];

                // 2. è®¡æ•°å™¨ Mapï¼šç”¨æ¥è®°å½•åœ¨æœ¬æ¬¡ CSV è¯»å–ä¸­ï¼ŒæŸä¸ª Key å‡ºç°äº†å‡ æ¬¡
                const keyCounters = new Map();

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length !== headers.length) continue;

                    const item = {};
                    headers.forEach((header, index) => {
                        item[header] = values[index].trim();
                    });

                    const instrument = settings.instruments.find(inst => inst.name === item.instrumentName);
                    const musician = settings.musicians.find(mus => mus.name === item.musicianName);

                    if (!instrument || !musician || !/^\d{1,2}:\d{2}$/.test(item.musicDuration)) {
                        continue;
                    }

                    const projectId = getOrCreateProjectId(item.project);
                    const key = `${projectId}_${instrument.id}_${musician.id}`;

                    // --- æ ¸å¿ƒé€»è¾‘å˜æ›´å¼€å§‹ ---

                    // è·å–å½“å‰è¿™ä¸ª Key æ˜¯ç¬¬å‡ æ¬¡å‡ºç° (ä» 0 å¼€å§‹)
                    let currentIndex = keyCounters.get(key) || 0;

                    // æ›´æ–°è®¡æ•°å™¨ï¼Œä¾›ä¸‹ä¸€æ¬¡é‡åˆ°åŒ Key æ—¶ä½¿ç”¨
                    keyCounters.set(key, currentIndex + 1);

                    const ratio = parseFloat(item.ratio) || (musician ? musician.defaultRatio : 1);

                    // æ£€æŸ¥ä»»åŠ¡æ± é‡Œæ˜¯å¦å·²ç»æœ‰å¯¹åº”ç´¢å¼•çš„ä»»åŠ¡
                    const existingItems = existingPoolMap.get(key);

                    if (existingItems && existingItems[currentIndex]) {
                        // æƒ…å†µ A: ä»»åŠ¡æ± é‡Œæœ‰è¿™ä¸ª Key çš„ç¬¬ N ä¸ªä»»åŠ¡ -> è¦†ç›–æ›´æ–°å®ƒ
                        const existingItem = existingItems[currentIndex];

                        tasksToProcess.push({
                            id: existingItem.id, // ä¿æŒ ID ä¸å˜ï¼ˆéå¸¸é‡è¦ï¼Œä¸ºäº†ä¿ç•™æ’æœŸï¼‰
                            projectId: projectId,
                            instrumentId: existingItem.instrumentId,
                            musicianId: existingItem.musicianId,
                            musicDuration: item.musicDuration,
                            ratio: ratio,
                            estDuration: calculateEstTime(item.musicDuration, ratio),
                            isOverwrite: true
                        });
                    } else {
                        // æƒ…å†µ B: ä»»åŠ¡æ± é‡Œæ²¡æœ‰è¿™ä¸ª Keyï¼Œæˆ–è€…æ²¡æœ‰ç¬¬ N ä¸ªä»»åŠ¡ -> æ–°å»ºä»»åŠ¡
                        tasksToProcess.push({
                            id: generateUniqueId('T'),
                            projectId: projectId,
                            instrumentId: instrument.id,
                            musicianId: musician.id,
                            musicDuration: item.musicDuration,
                            ratio: ratio,
                            estDuration: calculateEstTime(item.musicDuration, ratio),
                            isOverwrite: false
                        });
                    }
                    // --- æ ¸å¿ƒé€»è¾‘å˜æ›´ç»“æŸ ---
                }

                return tasksToProcess;
            };

            const handleCSVImport = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const csvText = e.target.result;
                        const tasksToProcess = parseCSV(csvText);

                        if (tasksToProcess.length > 0) {
                            let addedCount = 0;
                            let updatedCount = 0;

                            tasksToProcess.forEach(task => {
                                if (task.isOverwrite) {
                                    const idx = itemPool.value.findIndex(t => t.id === task.id);
                                    if (idx !== -1) {
                                        // 1. è¦†ç›–ä»»åŠ¡æ± ä¸­çš„æ¨¡æ¿ (ä½¿ç”¨ projectId)
                                        itemPool.value[idx].projectId = task.projectId;
                                        itemPool.value[idx].musicDuration = task.musicDuration;
                                        itemPool.value[idx].ratio = task.ratio;
                                        itemPool.value[idx].estDuration = task.estDuration;
                                        updatedCount++;

                                        // 2. åŒæ­¥æ›´æ–°æ‰€æœ‰å·²æ’æœŸçš„å®ä¾‹
                                        scheduledTasks.value.filter(st => st.templateId === task.id).forEach(st => {
                                            st.projectId = task.projectId;
                                            st.musicDuration = task.musicDuration;
                                            st.ratio = task.ratio;
                                            st.estDuration = task.estDuration;
                                        });
                                    }
                                } else {
                                    // æ·»åŠ æ–°ä»»åŠ¡
                                    itemPool.value.push(task);
                                    addedCount++;
                                }
                            });

                            pushHistory();
                            openAlertModal(`CSV å¯¼å…¥å®Œæˆï¼æ–°å¢ä»»åŠ¡ï¼š${addedCount}ï¼Œæ›´æ–°ä»»åŠ¡ï¼š${updatedCount}ã€‚`);
                        } else {
                            openAlertModal('æœªå¯¼å…¥/æ›´æ–°ä»»ä½•æœ‰æ•ˆä»»åŠ¡ï¼Œè¯·æ£€æŸ¥CSVæ ¼å¼å’Œè®¾ç½®ä¸­çš„ä¹å™¨/æ¼”å¥å‘˜åç§°æ˜¯å¦åŒ¹é…ã€‚');
                        }
                    } catch (error) {
                        console.error("å¯¼å…¥CSVæ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯:", error);
                        openAlertModal("å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶è¯»å–æˆ–è§£æé”™è¯¯ã€‚");
                    } finally {
                        event.target.value = '';
                    }
                };

                reader.readAsText(file, 'UTF-8');
            };


            // --- V9.7.4 åç§°å’Œé¢œè‰²æŸ¥æ‰¾å™¨ (æ–°å¢é¡¹ç›®ç±»å‹) ---
            const getNameById = (id, type) => {
                if (!id) return 'æœªé€‰æ‹©'; // è¿™é‡Œçš„æ–‡å­—å¯¹åº”ä½ çš„æˆªå›¾

                // ç¡®ä¿ list è·å–æ­£ç¡®
                const list = type === 'instrument' ? settings.instruments :
                    type === 'musician' ? settings.musicians :
                        type === 'project' ? settings.projects : [];

                // ğŸŸ¢ å…³é”®: ä½¿ç”¨ == è€Œä¸æ˜¯ ===ï¼Œé˜²æ­¢ id ç±»å‹(string/number)ä¸ä¸€è‡´å¯¼è‡´æ‰¾ä¸åˆ°
                const item = list.find(i => i.id == id);

                return item ? item.name : (type === 'project' ? 'æœªçŸ¥é¡¹ç›®' : (type === 'instrument' ? 'æœªçŸ¥ä¹å™¨' : 'æœªçŸ¥æ¼”å¥å‘˜'));
            };

            // ğŸŸ¢ ä¿®æ”¹: getGroupColor (å¼ºåˆ¶ç»Ÿä¸€é¢œè‰²ï¼šç´«/é‡‘/è“)
            const getGroupColor = (item, key, isBorder) => {
                // è¿™é‡Œçš„ key å†³å®šäº†æˆ‘ä»¬è¦è·å–å“ªç§ç±»å‹çš„é¢œè‰²

                // 1. æ¼”å¥å‘˜ = ç´«è‰²
                if (key === 'musicianId') return '#a855f7';

                // 2. é¡¹ç›® = é‡‘è‰²
                if (key === 'projectId') return '#eab308';

                // 3. ä¹å™¨ = è“è‰²
                if (key === 'instrumentId') return '#3b82f6';

                // é»˜è®¤ç°è‰²
                return isBorder ? '#9ca3af' : '#f3f4f6';
            };

            // V9.5 ä»»åŠ¡ç§»åŠ¨åŠ©æ‰‹ï¼šæ·»åŠ åˆ†é’Ÿ
            const addMinutesToTime = (timeStr, minutes) => {
                const currentMins = timeToMinutes(timeStr);
                let newMins = currentMins + minutes;

                const minTime = settings.startHour * 60;
                const maxTime = settings.endHour * 60 - 30;

                newMins = Math.max(minTime, Math.min(maxTime, newMins));
                newMins = Math.round(newMins / 30) * 30;

                const h = Math.floor(newMins / 60);
                const m = newMins % 60;
                return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
            };

            // V9.5 ä»»åŠ¡ç§»åŠ¨åŠ©æ‰‹ï¼šæ·»åŠ å¤©æ•°
            const addDaysToDate = (dateStr, days) => {
                const d = new Date(dateStr);
                d.setDate(d.getDate() + days);
                return formatDate(d);
            };

            const onMusicianSelect = () => {
                const m = settings.musicians.find(x => x.id === newItem.musicianId);
                if (m) newItem.ratio = m.defaultRatio;
            };

            // ğŸŸ¢ ä¿®æ”¹: addItemToPool
            const addItemToPool = () => {
                if (!newItem.projectId || !newItem.instrumentId || !newItem.musicianId || !newItem.musicDuration) {
                    openAlertModal('ä¿¡æ¯ä¸å®Œæ•´', 'è¯·åŠ¡å¿…å¡«å†™æ‰€æœ‰ä¿¡æ¯');
                    return;
                }

                const newRatio = getDefaultRatio(newItem.musicianId);

                // åˆ›å»ºæ–°å¯¹è±¡
                const rawItem = {
                    id: generateUniqueId('T'),
                    sessionId: currentSessionId.value,
                    projectId: newItem.projectId,
                    instrumentId: newItem.instrumentId,
                    musicianId: newItem.musicianId,
                    musicDuration: newItem.musicDuration,
                    ratio: newRatio,
                    estDuration: calculateEstTime(newItem.musicDuration, newRatio)
                };

                // ğŸŸ¢ åˆå§‹åŒ–å¤šç»´è®°å½•ç»“æ„
                const finalItem = ensureItemRecords(rawItem);

                itemPool.value.push(finalItem);
                pushHistory();
                showMobileTaskInput.value = false;
            };

            // ğŸŸ¢ ä¿®å¤: åˆ—è¡¨åˆ†ç»„æŠ˜å  (æ–°å¢éœ‡åŠ¨åé¦ˆ)
            const toggleCollapse = (groupKey) => {
                if (isMobile.value) window.triggerTouchHaptic('Medium'); // ğŸŸ¢ å¢åŠ éœ‡åŠ¨åé¦ˆ

                if (expandedGroups.has(groupKey)) {
                    expandedGroups.delete(groupKey);
                } else {
                    expandedGroups.add(groupKey);
                }
            };

            // --- Drag & Drop ---
            let draggedData = null;
            // ğŸŸ¢ ä¿®æ”¹: æ‹–æ‹½å¼€å§‹æ—¶ï¼Œè®¡ç®—é¼ æ ‡ç›¸å¯¹äºä»»åŠ¡é¡¶éƒ¨çš„åç§»é‡
            const dragStart = (e, item, source) => {
                let offsetMinutes = 0;

                // å¦‚æœæ˜¯æ‹–åŠ¨æ—¥ç¨‹è¡¨ä¸Šçš„ä»»åŠ¡
                if (source === 'schedule' && e.target) {
                    const rect = e.target.getBoundingClientRect();
                    // è®¡ç®—é¼ æ ‡è·ç¦»ä»»åŠ¡é¡¶éƒ¨çš„åƒç´ è·ç¦»
                    const offsetY = e.clientY - rect.top;
                    // å°†åƒç´ è½¬æ¢ä¸ºåˆ†é’Ÿ (pxPerMin.value æ˜¯æ¯åˆ†é’Ÿçš„é«˜åº¦)
                    const rawMinutes = offsetY / pxPerMin.value;
                    // å‘ä¸‹å–æ•´åˆ°æœ€è¿‘çš„ 30 åˆ†é’Ÿåˆ»åº¦ï¼Œä¿è¯å¸é™„
                    offsetMinutes = Math.floor(rawMinutes / 30) * 30;
                }

                // å°† offsetMinutes å­˜å…¥ draggedData
                draggedData = {item, source, isCopy: e.altKey, offsetMinutes};

                e.dataTransfer.effectAllowed = 'move';

                // ... (åç»­çš„å…‹éš†æ ·å¼é€»è¾‘ä¿æŒä¸å˜) ...
                if (source === 'schedule' && e.target) {
                    const clone = e.target.cloneNode(true);
                    // ... (å…‹éš†æ ·å¼ä»£ç çœç•¥ï¼Œä¿æŒåŸæ ·å³å¯) ...
                    clone.classList.remove('is-selected');
                    clone.style.setProperty('opacity', '0.4', 'important');
                    clone.style.position = 'absolute';
                    clone.style.top = '-9999px';
                    clone.style.zIndex = '9999';
                    clone.style.width = `${e.target.offsetWidth}px`;
                    document.body.appendChild(clone);
                    // è¿™é‡Œä¸ºäº†è§†è§‰å¯¹é½ï¼Œæ‹–æ‹½æ—¶çš„â€œæŠŠæ‰‹â€ä½ç½®ä¹Ÿå»ºè®®å‡å» offset
                    // ä½†ä¸ºäº†ç®€å•ï¼ŒåŸæœ‰çš„ setDragImage é€»è¾‘é€šå¸¸å¤Ÿç”¨äº†ï¼Œè¿™é‡Œåªç”¨æ”¹æ•°æ®é€»è¾‘
                    const rect = e.target.getBoundingClientRect();
                    const offsetX = e.clientX - rect.left;
                    const offsetY = e.clientY - rect.top;
                    e.dataTransfer.setDragImage(clone, offsetX, offsetY);

                    setTimeout(() => {
                        document.body.removeChild(clone);
                        e.target.classList.add('pointer-events-none');
                        e.target.style.transition = 'none';
                        e.target.style.opacity = '0';
                    }, 0);
                }
            };

            // --- æ–°å¢å¼€å§‹: æ‹–æ‹½ç»“æŸå¤„ç† ---
            const handleDragEnd = (e) => {
                if (e.target) {
                    e.target.classList.remove('pointer-events-none');
                    // æ¸…é™¤è¡Œå†…æ ·å¼ï¼Œæ¢å¤ CSS ç±»ä¸­å®šä¹‰çš„é»˜è®¤æ ·å¼
                    e.target.style.opacity = '';
                    e.target.style.transition = '';
                }
                draggedData = null;
            };
            // --- æ–°å¢ç»“æŸ ---

            const dragEnterPool = e => e.currentTarget.classList.add('drag-over');
            const dragLeavePool = e => e.currentTarget.classList.remove('drag-over');

            // V9.7.2 ä¿®å¤: æ‹–åŠ¨å·²æ’ç¨‹ä»»åŠ¡å›ä»»åŠ¡æ± æ—¶ï¼Œåªåˆ é™¤æ—¥ç¨‹ä¸Šçš„å®ä¾‹ï¼Œä¿ç•™ä»»åŠ¡æ± ä¸­çš„æ¨¡æ¿ã€‚
            const dropToPool = e => {
                e.currentTarget.classList.remove('drag-over');
                if (!draggedData) return;

                // å¦‚æœä»æ—¥ç¨‹è¡¨æ‹–å›å·¦ä¾§ï¼Œè§†ä¸ºåˆ é™¤æ’æœŸ
                if (draggedData.source === 'schedule') {
                    scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== draggedData.item.scheduleId);
                    pushHistory();
                }
                draggedData = null;
            };

            const dragEnterSlot = e => {
                if (e.target.closest('.droppable-slot')) e.target.closest('.droppable-slot').classList.add('drag-over');
            };
            const dragLeaveSlot = e => {
                if (e.target.closest('.droppable-slot')) e.target.closest('.droppable-slot').classList.remove('drag-over');
            };
            // ğŸŸ¢ ä¿®æ”¹: dropToSchedule (åŠ å…¥é˜²é‡å æ£€æµ‹)
            const dropToSchedule = (e, dateStr) => {
                document.querySelectorAll('.grid-slot.drag-over').forEach(el => el.classList.remove('drag-over'));

                const slot = e.target.closest('.grid-slot');
                if (!slot || !draggedData) return;

                const {item, source, offsetMinutes} = draggedData;

                // 1. è®¡ç®—ç›®æ ‡æ—¶é—´ (é€šç”¨é€»è¾‘)
                // æ— è®ºä»å“ªé‡Œæ‹–æ¥ï¼Œè½ç‚¹æ—¶é—´ä¸»è¦å–å†³äºæ ¼å­
                const dropSlotMinutes = timeToMinutes(slot.dataset.time);
                let newStartMinutes = dropSlotMinutes;

                let checkType = 'musician'; // é»˜è®¤ä¸ºäººå‘˜

                if (source === 'aggregate') {
                    // ä»ä¾§è¾¹æ æ‹–å…¥ï¼šç±»å‹ç”±å½“å‰ Tab å†³å®š
                    checkType = sidebarTab.value;
                } else if (source === 'schedule' || source === 'pool') {
                    // ä»æ—¥ç¨‹/æ± æ‹–åŠ¨ï¼šç”±ä»»åŠ¡è‡ªèº«å±æ€§å†³å®š
                    if (item.projectId) checkType = 'project';
                    else if (item.instrumentId) checkType = 'instrument';
                }

                // å¦‚æœæ˜¯æ—¥ç¨‹å†…éƒ¨ç§»åŠ¨ï¼Œéœ€è¦è€ƒè™‘é¼ æ ‡æŠ“å–ä½ç½®çš„åç§»
                if (source === 'schedule') {
                    newStartMinutes = dropSlotMinutes - (offsetMinutes || 0);
                }

                // è¾¹ç•Œæ£€æŸ¥
                const minStartMinutes = settings.startHour * 60;
                if (newStartMinutes < minStartMinutes) newStartMinutes = minStartMinutes;

                // è½¬æ¢ä¸º HH:MM
                const h = Math.floor(newStartMinutes / 60);
                const m = newStartMinutes % 60;
                const newStartTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

                // 2. å‡†å¤‡å‚æ•°è¿›è¡Œæ£€æµ‹
                let newDuration = '';
                let excludeId = null;

                if (source === 'aggregate') {
                    // è®¡ç®—ç»Ÿè®¡å¡ç‰‡å‰©ä½™æ—¶é•¿
                    const remainingSecs = item.totalSeconds - item.scheduledSeconds;
                    if (remainingSecs <= 0) {
                        pushHistory();
                        draggedData = null;
                        return;
                    }
                    let remainingMins = Math.ceil(remainingSecs / 1800) * 30;
                    if (remainingMins === 0) remainingMins = 30;
                    newDuration = formatSecs(remainingMins * 60);
                } else if (source === 'schedule') {
                    newDuration = item.estDuration;
                    excludeId = item.scheduleId;
                } else if (source === 'pool') {
                    const nt = {
                        scheduleId: Date.now(),
                        // ğŸŸ¢ å…³é”®ä¿®å¤: è®°å½•æ¨¡æ¿IDï¼Œå»ºç«‹å…³è”
                        templateId: item.id,

                        sessionId: currentSessionId.value,
                        projectId: item.projectId,
                        instrumentId: item.instrumentId,
                        musicianId: item.musicianId,
                        musicDuration: item.musicDuration,
                        ratio: item.ratio,
                        estDuration: item.estDuration,
                        date: dateStr,
                        startTime: newStartTime
                    };
                    scheduledTasks.value.push(nt);
                    window.triggerTouchHaptic('Success');
                }

                if (checkOverlap(dateStr, newStartTime, newDuration, excludeId, checkType)) {
                    openAlertModal('æ—¶é—´å†²çª', 'è¯¥æ—¶é—´æ®µå·²æœ‰åŒç±»å‹çš„å…¶ä»–å®‰æ’ã€‚'); // æç¤ºæ–‡æ¡ˆå¾®è°ƒ
                    window.triggerTouchHaptic('Error');
                    draggedData = null;
                    return;
                }

                // --- 4. é€šè¿‡æ£€æµ‹ï¼Œæ‰§è¡ŒåŸæœ‰çš„æ”¾ç½®é€»è¾‘ ---

                if (source === 'aggregate') {
                    const nt = {
                        scheduleId: Date.now(),
                        sessionId: currentSessionId.value,
                        musicianId: sidebarTab.value === 'musician' ? item.id : '',
                        projectId: sidebarTab.value === 'project' ? item.id : '',
                        instrumentId: sidebarTab.value === 'instrument' ? item.id : '',
                        date: dateStr,
                        startTime: newStartTime, // ä½¿ç”¨ä¸Šé¢ç®—å¥½çš„
                        estDuration: newDuration,
                        trackCount: item.trackCount,
                        ratio: item.defaultRatio || 20,
                        reminderMinutes: 15,
                        sound: 'default'
                    };
                    scheduledTasks.value.push(nt);
                    window.triggerTouchHaptic('Success');

                } else if (source === 'schedule') {
                    const idx = scheduledTasks.value.findIndex(t => t.scheduleId === item.scheduleId);
                    if (idx !== -1) {
                        const nt = JSON.parse(JSON.stringify(item));
                        nt.date = dateStr;
                        nt.startTime = newStartTime; // ä½¿ç”¨ä¸Šé¢ç®—å¥½çš„
                        scheduledTasks.value[idx] = nt;
                        window.triggerTouchHaptic('Success');
                    }
                } else if (source === 'pool') {
                    const nt = {
                        scheduleId: Date.now(),
                        sessionId: currentSessionId.value,
                        projectId: item.projectId,
                        instrumentId: item.instrumentId,
                        musicianId: item.musicianId,
                        musicDuration: item.musicDuration,
                        ratio: item.ratio,
                        estDuration: item.estDuration,
                        date: dateStr,
                        startTime: newStartTime, // ä½¿ç”¨ä¸Šé¢ç®—å¥½çš„
                        reminderMinutes: 15,
                        sound: 'default'
                    };
                    scheduledTasks.value.push(nt);
                    window.triggerTouchHaptic('Success');
                }

                pushHistory();
                draggedData = null;
            };

            // ğŸŸ¢ ä¿®æ”¹: dropToMonth (åŠ å…¥é˜²é‡å æ£€æµ‹)
            const dropToMonth = (e, dateStr) => {
                document.querySelectorAll('.droppable-slot.drag-over').forEach(el => el.classList.remove('drag-over'));
                if (!draggedData) return;
                const {item, source} = draggedData;

                // 1. ç¡®å®šç›®æ ‡æ—¶é—´å’Œæ—¶é•¿
                let targetStartTime = settings.startHour + ':00'; // é»˜è®¤æ’åœ¨å¼€å¤´
                let targetDuration = '';
                let excludeId = null;
                let checkType = 'musician';
                if (source === 'aggregate') {
                    checkType = sidebarTab.value;
                } else {
                    if (item.projectId) checkType = 'project';
                    else if (item.instrumentId) checkType = 'instrument';
                }

                if (source === 'schedule') {
                    targetStartTime = item.startTime; // ä¿æŒåŸæœ‰æ—¶é—´ä¸å˜
                    targetDuration = item.estDuration;
                    excludeId = item.scheduleId;
                } else {
                    // æ–°ä»»åŠ¡é»˜è®¤æ—¶é•¿ 30åˆ†é’Ÿ æˆ– å‰©ä½™æ—¶é•¿
                    targetDuration = item.estDuration || '00:30';
                }

                if (checkOverlap(dateStr, targetStartTime, targetDuration, excludeId, checkType)) {
                    openAlertModal('æ—¶é—´å†²çª', 'è¯¥æ—¥æœŸå·²æœ‰åŒç±»å‹çš„å…¶ä»–å®‰æ’ã€‚');
                    window.triggerTouchHaptic('Error');
                    draggedData = null;
                    return;
                }

                // --- 3. é€šè¿‡æ£€æµ‹ï¼Œæ‰§è¡ŒåŸæœ‰é€»è¾‘ ---
                if (source === 'schedule') {
                    const task = scheduledTasks.value.find(t => t.scheduleId === item.scheduleId);
                    if (task) {
                        task.date = dateStr;
                        pushHistory();
                    }
                } else if (source === 'aggregate' || source === 'pool') {
                    // ... (ä¿æŒä½ ä¸Šä¸€è½®æ”¹å¥½çš„æ„å»º ID çš„é€»è¾‘) ...
                    let mId = '', pId = '', iId = '';
                    let ratio = 20;
                    let estDur = '00:30';
                    let tCount = 0;
                    let musDur = '';

                    if (source === 'pool') {
                        mId = item.musicianId;
                        pId = item.projectId;
                        iId = item.instrumentId;
                        ratio = item.ratio;
                        estDur = item.estDuration;
                        musDur = item.musicDuration;
                    } else {
                        if (sidebarTab.value === 'musician') mId = item.id;
                        else if (sidebarTab.value === 'project') pId = item.id;
                        else if (sidebarTab.value === 'instrument') iId = item.id;
                        ratio = item.defaultRatio || 20;
                        estDur = item.estDuration || '00:30';
                        tCount = item.trackCount || 0;
                    }
                    const tId = source === 'pool' ? item.id : undefined;

                    const nt = {
                        scheduleId: Date.now(),
                        templateId: tId, // <--- æ·»åŠ è¿™è¡Œ
                        sessionId: currentSessionId.value,
                        musicianId: mId,
                        projectId: pId,
                        instrumentId: iId,
                        date: dateStr,
                        startTime: targetStartTime,
                        estDuration: estDur,
                        trackCount: tCount,
                        ratio: ratio,
                        musicDuration: musDur,
                        reminderMinutes: 15,
                        sound: 'default'
                    };
                    scheduledTasks.value.push(nt);
                    pushHistory();
                }
                draggedData = null;
            };

            // --- Resize Logic ---
            const resizing = ref(null);
            const initResize = (e, t) => {
                e.preventDefault();
                e.stopPropagation();
                const el = e.target.closest('.task-block');
                resizing.value = {
                    task: t,
                    startY: e.clientY,
                    startH: el.offsetHeight,
                    // ğŸŸ¢ è®°å½•åŸå§‹æ—¶é•¿ä»¥ä¾¿å›é€€
                    originalDuration: t.estDuration
                };
                document.body.style.cursor = 'ns-resize';
            };

            const handleResizeMove = e => {
                if (!resizing.value) return;
                const {task, startY, startH} = resizing.value;
                const delta = e.clientY - startY;

                const rawH = Math.max(10, startH + delta);
                // ä½¿ç”¨å½“å‰çš„ slotHeight å¸é™„
                const snappedH = Math.round(rawH / slotHeight.value) * slotHeight.value;

                const finalH = Math.max(slotHeight.value, snappedH);
                const newMins = Math.round(finalH / pxPerMin.value);

                task.estDuration = formatSecs(newMins * 60);
            };
            // ğŸŸ¢ ä¿®æ”¹: handleResizeEnd
            const handleResizeEnd = () => {
                if (!resizing.value) return;
                const t = resizing.value.task;

                // ç¡®å®šç±»å‹
                let type = 'musician';
                if (t.projectId) type = 'project';
                else if (t.instrumentId) type = 'instrument';

                // ä¼ å…¥ type
                if (checkOverlap(t.date, t.startTime, t.estDuration, t.scheduleId, type)) {
                    t.estDuration = resizing.value.originalDuration;
                    openAlertModal('å†²çª', 'è°ƒæ•´åçš„æ—¶é—´æœ‰é‡å ');
                    window.triggerTouchHaptic('Error');
                } else {
                    // âœ… æ— å†²çªï¼Œæ­£å¸¸ä¿å­˜
                    const m = parseTime(t.musicDuration);
                    const r = parseTime(t.estDuration);
                    if (m > 0) t.ratio = (r / m).toFixed(1);
                    pushHistory();
                }

                resizing.value = null;
                document.body.style.cursor = '';
            };

            // ğŸŸ¢ ä¿®å¤åçš„ selectTask
            const selectTask = (id, src, event) => {
                // ... (ä¿æŒå‰é¢çš„ schedule ç‚¹å‡»å¤„ç†ä¸å˜) ...
                if (src === 'schedule') {
                    selectedSource.value = src;
                    selectedTaskId.value = id;
                    selectedPoolIds.value.clear();
                    return;
                }

                if (src === 'pool') {
                    selectedSource.value = src;
                    selectedTaskId.value = id;
                    lastPoolFocusId.value = id;

                    const isShift = event && event.shiftKey;
                    const isCtrl = event && (event.metaKey || event.ctrlKey);

                    // å•é€‰è·³è½¬é€»è¾‘
                    if (!isShift && !isCtrl) {
                        const poolItem = itemPool.value.find(i => i.id === id);
                        if (poolItem) {
                            let targetTask = scheduledTasks.value.find(t =>
                                (t.sessionId || 'S_DEFAULT') === currentSessionId.value &&
                                t.templateId === id
                            );
                            // ... (ä¿æŒä½ çš„é™çº§åŒ¹é…é€»è¾‘ä¸å˜) ...
                            if (!targetTask) {
                                targetTask = scheduledTasks.value.find(t =>
                                    (t.sessionId || 'S_DEFAULT') === currentSessionId.value &&
                                    t.projectId === poolItem.projectId &&
                                    t.instrumentId === poolItem.instrumentId &&
                                    t.musicianId === poolItem.musicianId &&
                                    t.musicDuration === poolItem.musicDuration
                                );
                            }

                            if (targetTask) {
                                // ğŸŸ¢ ç›´æ¥è°ƒç”¨é€šç”¨å‡½æ•°
                                smartScrollToTask(targetTask);
                            }
                        }
                    }

                    // ... (ä¿æŒåé¢çš„å¤šé€‰é€»è¾‘ä¸å˜) ...
                    if (isShift && lastPoolClickId.value) { /* ... */
                    } else if (isCtrl) { /* ... */
                    } else {
                        selectedPoolIds.value.clear();
                        selectedPoolIds.value.add(id);
                        lastPoolClickId.value = id;
                    }
                }
            };

            // æ›¿æ¢åŸæœ‰çš„ clearSelection å‡½æ•°
            const clearSelection = () => {
                selectedTaskId.value = null;
                selectedSource.value = null;
                selectedPoolIds.value.clear(); // æ–°å¢ï¼šæ¸…ç©ºå¤šé€‰
            };

            // V9.5 ä»»åŠ¡é‡å è®¡ç®—
            const getOverlapCount = (targetTask) => {
                const dayTasks = scheduledTasks.value.filter(t => t.date === targetTask.date);
                const targetStart = timeToMinutes(targetTask.startTime);
                const targetEnd = targetStart + parseTime(targetTask.estDuration) / 60;

                let overlapCount = 0;
                for (const task of dayTasks) {
                    if (task.scheduleId === targetTask.scheduleId) continue;

                    const taskStart = timeToMinutes(task.startTime);
                    const taskEnd = taskStart + parseTime(task.estDuration) / 60;

                    if (targetStart < taskEnd && targetEnd > taskStart) {
                        overlapCount++;
                    }
                }
                return overlapCount;
            };

            // V9.5 ä»»åŠ¡é”®ç›˜ç§»åŠ¨é€»è¾‘
            // V9.5 ä»»åŠ¡é”®ç›˜ç§»åŠ¨é€»è¾‘ (V11.2 ä¿®æ”¹ï¼šå·¦å³ç§»åŠ¨è‡ªåŠ¨åˆ‡æ¢å‘¨è§†å›¾)
            // V11.3 å‡çº§ï¼šæ”¯æŒå‘¨è§†å›¾(æ”¹æ—¶é—´)å’Œæœˆè§†å›¾(æ”¹æ—¥æœŸ)çš„é”®ç›˜ç§»åŠ¨
            // ğŸŸ¢ ä¿®å¤: moveTask (ä¿®å¤å˜é‡æœªå®šä¹‰æŠ¥é”™ï¼Œç¡®ä¿å†²çªæ£€æµ‹é€»è¾‘æ­£ç¡®)
            const moveTask = (task, direction) => {
                let updated = false;
                const isMonth = currentView.value === 'month';

                const checkMonthViewSwitch = (dStr) => {
                    if (!isMonth) return;
                    const newD = new Date(dStr);
                    const currentD = new Date(viewDate.value);
                    if (newD.getMonth() !== currentD.getMonth() || newD.getFullYear() !== currentD.getFullYear()) {
                        viewDate.value = newD;
                    }
                };

                // ç¡®å®šç±»å‹
                let type = 'musician';
                if (task.projectId) type = 'project';
                else if (task.instrumentId) type = 'instrument';

                // ğŸŸ¢ ä¿®å¤: å°†è®¡ç®—é€»è¾‘å’Œå†²çªæ£€æµ‹ç§»åˆ°å…·ä½“çš„æ–¹å‘åˆ¤æ–­å†…éƒ¨
                // è¿™æ ·èƒ½ç¡®ä¿ newTime/newDate åœ¨æ£€æµ‹å‰å·²ç»è®¡ç®—å‡ºæ¥

                if (direction === 'up') {
                    if (isMonth) {
                        const newDate = addDaysToDate(task.date, -7);
                        // æ£€æµ‹æ—¥æœŸå†²çª
                        if (checkOverlap(newDate, task.startTime, task.estDuration, task.scheduleId, type)) {
                            window.triggerTouchHaptic('Error');
                            return;
                        }
                        if (newDate !== task.date) {
                            pushHistory();
                            task.date = newDate;
                            updated = true;
                            checkMonthViewSwitch(newDate);
                        }
                    } else {
                        const newTime = addMinutesToTime(task.startTime, -30);
                        // æ£€æµ‹æ—¶é—´å†²çª
                        if (checkOverlap(task.date, newTime, task.estDuration, task.scheduleId, type)) {
                            window.triggerTouchHaptic('Error');
                            return;
                        }
                        if (newTime !== task.startTime) {
                            pushHistory();
                            task.startTime = newTime;
                            updated = true;
                        }
                    }
                } else if (direction === 'down') {
                    if (isMonth) {
                        const newDate = addDaysToDate(task.date, 7);
                        if (checkOverlap(newDate, task.startTime, task.estDuration, task.scheduleId, type)) {
                            window.triggerTouchHaptic('Error');
                            return;
                        }
                        if (newDate !== task.date) {
                            pushHistory();
                            task.date = newDate;
                            updated = true;
                            checkMonthViewSwitch(newDate);
                        }
                    } else {
                        const newTime = addMinutesToTime(task.startTime, 30);
                        if (checkOverlap(task.date, newTime, task.estDuration, task.scheduleId, type)) {
                            window.triggerTouchHaptic('Error');
                            return;
                        }
                        if (newTime !== task.startTime) {
                            pushHistory();
                            task.startTime = newTime;
                            updated = true;
                        }
                    }
                } else if (direction === 'left') {
                    const newDate = addDaysToDate(task.date, -1);
                    if (checkOverlap(newDate, task.startTime, task.estDuration, task.scheduleId, type)) {
                        window.triggerTouchHaptic('Error');
                        return;
                    }
                    if (newDate !== task.date) {
                        pushHistory();
                        task.date = newDate;
                        updated = true;
                        if (isMonth) checkMonthViewSwitch(newDate);
                        else if (currentView.value === 'week' && newDate < currentWeekDays.value[0].dateStr) viewDate.value = new Date(newDate);
                    }
                } else if (direction === 'right') {
                    const newDate = addDaysToDate(task.date, 1);
                    if (checkOverlap(newDate, task.startTime, task.estDuration, task.scheduleId, type)) {
                        window.triggerTouchHaptic('Error');
                        return;
                    }
                    if (newDate !== task.date) {
                        pushHistory();
                        task.date = newDate;
                        updated = true;
                        if (isMonth) checkMonthViewSwitch(newDate);
                        else if (currentView.value === 'week' && newDate > currentWeekDays.value[6].dateStr) viewDate.value = new Date(newDate);
                    }
                }
            };

            // ğŸŸ¢ ä¿®å¤: å…¨å±€å¿«æ·é”®æ§åˆ¶ (å¼¹çª—æ‰“å¼€æ—¶ç¦ç”¨èƒŒæ™¯æ“ä½œ)
            const handleGlobalKey = e => {
                // 1. å®šä¹‰æ‰€æœ‰å¯èƒ½çš„å¼¹çª—çŠ¶æ€
                const isAnyModalOpen = showSettings.value || showEditor.value || showTrackList.value || showAuthModal.value || showCropModal.value || showMobileMenu.value || showColorPickerModal.value;

                // 2. ESC é”®ç‰¹æƒå¤„ç† (ç”¨äºå…³é—­å¼¹çª—)
                // æŒ‰ ESC æ—¶ï¼ŒæŒ‰ä¼˜å…ˆçº§é€ä¸ªå…³é—­é¡¶å±‚å¼¹çª—
                if (e.key === 'Escape') {
                    // ğŸŸ¢ ç¬¬ä¸€ä¼˜å…ˆçº§: å…³é—­æ—¶é—´é€‰æ‹©æ»šè½® (å› ä¸ºå®ƒåœ¨æœ€ä¸Šå±‚)
                    if (showDurationPicker.value) {
                        closePicker(); // æˆ–è€… showDurationPicker.value = false;
                        e.preventDefault();
                        return;
                    }
                    // âœ¨âœ¨âœ¨ æ–°å¢ï¼šé¢œè‰²é€‰æ‹©å™¨ (ä¼˜å…ˆçº§æé«˜ï¼Œå› ä¸ºå®ƒæµ®åœ¨ Settings ä¹‹ä¸Š) âœ¨âœ¨âœ¨
                    if (showColorPickerModal.value) {
                        showColorPickerModal.value = false;
                        e.preventDefault();
                        return;
                    }
                    // ğŸŸ¢ æ–°å¢: å…³é—­æ‰‹æœºç«¯æ·»åŠ ä»»åŠ¡å¼¹çª—
                    if (showConfirmModal.value) {
                        closeConfirmModal();
                        e.preventDefault();
                        return;
                    }
                    if (showInputModal.value) {
                        closeInputModal();
                        e.preventDefault();
                        return;
                    } // âœ… æ–°å¢è¿™è¡Œ
                    if (showQuickAddModal.value) {
                        showQuickAddModal.value = false;
                        e.preventDefault();
                        return;
                    }
                    if (showMobileTaskInput.value) {
                        showMobileTaskInput.value = false;
                        e.preventDefault();
                        return;
                    }
                    if (showCropModal.value) {
                        showCropModal.value = false;
                        e.preventDefault();
                        return;
                    }
                    if (showAuthModal.value) {
                        showAuthModal.value = false;
                        e.preventDefault();
                        return;
                    }
                    if (showTrackList.value) {
                        showTrackList.value = false;
                        e.preventDefault();
                        return;
                    }
                    if (showEditor.value) {
                        showEditor.value = false;
                        e.preventDefault();
                        return;
                    }
                    if (showSettings.value) {
                        showSettings.value = false;
                        e.preventDefault();
                        return;
                    }
                    if (showMobileMenu.value) {
                        showMobileMenu.value = false;
                        e.preventDefault();
                        return;
                    }

                    // å¦‚æœæ²¡æœ‰å¼¹çª—ï¼ŒESC ç”¨æ¥å–æ¶ˆä»»åŠ¡é€‰æ‹©
                    if (selectedTaskId.value || selectedPoolIds.value.size > 0) {
                        clearSelection();
                        e.preventDefault();
                        return;
                    }
                }

                // 4. æ’¤é”€/é‡åš (Cmd+Z / Ctrl+Z) - è¿™äº›é€šå¸¸å…è®¸åœ¨æ— å¼¹çª—æ—¶å…¨å±€è§¦å‘
                if ((e.metaKey || e.ctrlKey)) {
                    if (e.key.toLowerCase() === 'z') {
                        e.preventDefault();
                        if (e.shiftKey) redo(); else undo();
                        return;
                    }
                    if (e.key.toLowerCase() === 'y') {
                        e.preventDefault();
                        redo();
                        return;
                    }
                }

                // 3. ğŸŸ¢ æ ¸å¿ƒä¿®å¤: å¦‚æœæœ‰ä»»ä½•å¼¹çª—æ‰“å¼€ï¼Œç›´æ¥åœæ­¢åç»­é€»è¾‘
                // è¿™é˜²æ­¢äº†åœ¨å¼¹çª—æ‰“å¼€æ—¶ï¼ŒæŒ‰ä¸‹ Delete é”®è¯¯åˆ èƒŒæ™¯é‡Œçš„ä»»åŠ¡ï¼Œæˆ–è€…æŒ‰æ–¹å‘é”®ç§»åŠ¨ä»»åŠ¡
                if (isAnyModalOpen) return;

                // 5. è¾“å…¥æ¡†ä¿æŠ¤: é˜²æ­¢åœ¨ä¾§è¾¹æ æœç´¢æ¡†æ‰“å­—æ—¶è§¦å‘å¿«æ·é”®
                const isTyping = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName);
                if (isTyping) return;

                // ğŸŸ¢ ä¿®æ”¹: handleGlobalKey ä¸­çš„ Tab é”®é€»è¾‘
                if (e.key === 'Tab') {
                    e.preventDefault();
                    if (e.altKey) {
                        // Alt+Tab: åˆ‡æ¢ Session (ä¿æŒä¸å˜)
                        const sessions = settings.sessions;
                        const currentIndex = sessions.findIndex(s => s.id === currentSessionId.value);
                        let nextIndex = e.shiftKey ? (currentIndex - 1 + sessions.length) % sessions.length : (currentIndex + 1) % sessions.length;
                        if (sessions.length > 0) currentSessionId.value = sessions[nextIndex].id;
                    } else if (e.shiftKey) {
                        // Shift+Tab: åˆ‡æ¢ å‘¨/æœˆ è§†å›¾ (ä¿æŒä¸å˜)
                        currentView.value = currentView.value === 'week' ? 'month' : 'week';
                    } else {
                        // ğŸŸ¢ Tab: åœ¨ äººå‘˜ -> é¡¹ç›® -> ä¹å™¨ ä¹‹é—´å¾ªç¯åˆ‡æ¢
                        if (sidebarTab.value === 'musician') {
                            sidebarTab.value = 'project';
                        } else if (sidebarTab.value === 'project') {
                            sidebarTab.value = 'instrument';
                        } else {
                            sidebarTab.value = 'musician';
                        }

                        // å¯é€‰: åˆ‡æ¢æ—¶ç»™ä¸ªè½»å¾®éœ‡åŠ¨åé¦ˆ
                        if (isMobile.value) window.triggerTouchHaptic('Light');
                    }
                    return;
                }

                // ğŸŸ¢ ä¿®æ”¹: Cmd+F / Ctrl+F åˆ‡æ¢å…¨éƒ¨å±•å¼€/æŠ˜å 
                if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'f') {
                    e.preventDefault();

                    // 1. è·å–å½“å‰ä¾§è¾¹æ åˆ—è¡¨çš„æ‰€æœ‰é¡¹
                    const allItems = currentSidebarList.value;
                    if (allItems.length === 0) return;

                    // 2. æ£€æŸ¥å½“å‰çŠ¶æ€ï¼šæ˜¯å¦æ‰€æœ‰é¡¹éƒ½å·²ç»å±•å¼€ï¼Ÿ
                    const isAllExpanded = allItems.every(item => expandedStatsIds.has(item.id));

                    if (isAllExpanded) {
                        // ğŸŸ¢ çŠ¶æ€A: å¦‚æœå…¨å±•å¼€äº† -> å…¨éƒ¨æŠ˜å  (æ¸…ç©º Set)
                        expandedStatsIds.clear();
                    } else {
                        // ğŸŸ¢ çŠ¶æ€B: å¦‚æœæœ‰æœªå±•å¼€çš„ -> å…¨éƒ¨å±•å¼€ (æ·»åŠ åˆ° Set)
                        allItems.forEach(item => expandedStatsIds.add(item.id));
                    }

                    // 3. éœ‡åŠ¨åé¦ˆ
                    if (isMobile.value) window.triggerTouchHaptic('Light');
                    return;
                }

                // 8. ä¾§è¾¹æ å¯¼èˆª (ä»…å½“æœªé€‰ä¸­æ—¥ç¨‹è¡¨ä»»åŠ¡æ—¶ç”Ÿæ•ˆ)
                if (selectedSource.value !== 'schedule' && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                    // Browse æ¨¡å¼ä¸‹çš„å·¦å³é”® (åˆ‡æ¢åˆ†ç»„)
                    if (sidebarTab.value === 'browse' && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                        e.preventDefault();
                        const keys = ['projectId', 'musicianId', 'instrumentId'];
                        const currentIndex = keys.indexOf(sortKey.value);
                        let newIndex = e.key === 'ArrowRight' ? (currentIndex + 1) % keys.length : (currentIndex - 1 + keys.length) % keys.length;
                        sortKey.value = keys[newIndex];
                        activeColorKey.value = keys[newIndex];
                        return;
                    }

                    // ä¸Šä¸‹é”®é€‰æ‹©åˆ—è¡¨é¡¹
                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        e.preventDefault();
                        const visibleItems = [];
                        if (sidebarTab.value === 'browse') {
                            groupedItemPool.value.forEach(group => {
                                if (expandedGroups.has(group.key)) visibleItems.push(...group.items);
                            });
                        } else {
                            musicianStats.value.forEach(stat => {
                                if (expandedStatsIds.has(stat.id)) visibleItems.push(...stat.items);
                            });
                        }
                        if (visibleItems.length === 0) return;

                        let currentIdx = -1;
                        const focusId = lastPoolFocusId.value || lastPoolClickId.value;
                        if (focusId) currentIdx = visibleItems.findIndex(i => i.id === focusId);

                        let newIdx = currentIdx === -1
                            ? (e.key === 'ArrowDown' ? 0 : visibleItems.length - 1)
                            : (e.key === 'ArrowDown' ? Math.min(currentIdx + 1, visibleItems.length - 1) : Math.max(currentIdx - 1, 0));

                        const targetItem = visibleItems[newIdx];
                        if (targetItem) {
                            selectTask(targetItem.id, 'pool', e);
                            // ç®€å•çš„æ»šåŠ¨è·Ÿéšé€»è¾‘
                            setTimeout(() => {
                                const activeEl = document.querySelector('#sidebar .border-blue-600') || document.querySelector('#sidebar .ring-2');
                                if (activeEl) activeEl.scrollIntoView({behavior: 'smooth', block: 'nearest'});
                            }, 0);
                        }
                        return;
                    }
                }

                // 9. æ—¥ç¨‹è¡¨æ“ä½œ (ç§»åŠ¨ä»»åŠ¡)
                if (selectedTaskId.value && selectedSource.value === 'schedule') {
                    const task = scheduledTasks.value.find(t => t.scheduleId === selectedTaskId.value);
                    if (!task) return;

                    const keyMap = {'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right'};
                    const direction = keyMap[e.key];

                    if (direction) {
                        e.preventDefault();
                        moveTask(task, direction);
                    }
                }

                // 10. åˆ é™¤æ“ä½œ
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    // æƒ…å†µ A: åˆ é™¤ä¾§è¾¹æ é€‰ä¸­çš„ä»»åŠ¡æ± é¡¹ç›® (æ”¯æŒå¤šé€‰)
                    if (selectedSource.value === 'pool' && selectedPoolIds.value.size > 0) {
                        // ğŸŸ¢ æ’å…¥: éå†é€‰ä¸­çš„ IDï¼Œå°è¯•å½’è¿˜æ—¶é—´
                        selectedPoolIds.value.forEach(id => {
                            const task = itemPool.value.find(i => i.id === id);
                            if (task) restoreSplitTime(task); // <--- è°ƒç”¨å½’è¿˜å‡½æ•°
                        });
                        scheduledTasks.value = scheduledTasks.value.filter(t => !selectedPoolIds.value.has(t.templateId));
                        itemPool.value = itemPool.value.filter(i => !selectedPoolIds.value.has(i.id));
                        cleanupEmptySchedules();
                        clearSelection();
                        pushHistory();
                    }
                    // æƒ…å†µ B: åˆ é™¤æ—¥ç¨‹è¡¨é€‰ä¸­çš„ä»»åŠ¡ (å•é€‰)
                    else if (selectedTaskId.value && selectedSource.value === 'schedule') {
                        pushHistory();
                        scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== selectedTaskId.value);
                        clearSelection();
                        pushHistory();
                    }
                }
            };

            // ğŸŸ¢ ä¿®æ”¹: handleTaskDblClick é€‚é…ä¸‰ç§è§†å›¾é€»è¾‘
            const handleTaskDblClick = (e, task) => {
                if (isTaskGhost(task)) {
                    jumpToGhostContext(task);
                    return;
                }
                window.triggerTouchHaptic('Heavy');

                if (e.metaKey || e.ctrlKey) {
                    // ... (ä¿ç•™åŸæœ‰çš„æ‹†åˆ†é€»è¾‘ä¸å˜) ...
                    const rect = e.currentTarget.getBoundingClientRect();
                    const clickY = e.clientY - rect.top;
                    const splitM = Math.round((clickY / pxPerMin.value) / 30) * 30;
                    const tot = parseTime(task.estDuration);
                    if (splitM * 60 >= tot || splitM <= 0) return;
                    const t1 = JSON.parse(JSON.stringify(task));
                    t1.scheduleId = Date.now();
                    t1.estDuration = formatSecs(splitM * 60);
                    const t2 = JSON.parse(JSON.stringify(task));
                    t2.scheduleId = Date.now() + 1;
                    const [h, m] = task.startTime.split(':').map(Number);
                    const sm = h * 60 + m + splitM;
                    t2.startTime = `${Math.floor(sm / 60)}:${String(sm % 60).padStart(2, '0')}`;
                    t2.estDuration = formatSecs(tot - splitM * 60);
                    scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== task.scheduleId);
                    scheduledTasks.value.push(t1, t2);
                    pushHistory();
                } else {
                    const currentSchedule = scheduledTasks.value.find(t => t.scheduleId === task.scheduleId);
                    if (!currentSchedule) return;

                    // 1. ç¡®å®šæ—¥ç¨‹å—ç±»å‹ (ç”¨äºåç»­ç­›é€‰å’Œæ˜¾ç¤º)
                    let blockType = 'musician';
                    let filterId = task.musicianId;

                    if (task.musicianId) {
                        blockType = 'musician';
                        filterId = task.musicianId;
                    } else if (task.projectId) {
                        blockType = 'project';
                        filterId = task.projectId;
                    } else if (task.instrumentId) {
                        blockType = 'instrument';
                        filterId = task.instrumentId;
                    }

                    // 2. ç­›é€‰ç›¸å…³çš„æ—¥ç¨‹ (ç”¨äºè®¡ç®—åˆ†æ®µ)
                    // æ³¨æ„ï¼šè¿™é‡Œè¦æ ¹æ®ç±»å‹ç­›é€‰ï¼Œæ¯”å¦‚æ˜¯é¡¹ç›®å—ï¼Œå°±è¦æ‰¾åŒé¡¹ç›®åŒSessionçš„æ‰€æœ‰å—
                    const relatedSchedules = scheduledTasks.value
                        .filter(t => {
                            if ((t.sessionId || 'S_DEFAULT') !== currentSessionId.value) return false;
                            if (blockType === 'musician') return t.musicianId === filterId;
                            if (blockType === 'project') return t.projectId === filterId && !t.musicianId; // ä¸¥æ ¼åŒ¹é…ç±»å‹
                            if (blockType === 'instrument') return t.instrumentId === filterId && !t.musicianId && !t.projectId;
                            return false;
                        })
                        .sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));

                    const currentSectionIndex = relatedSchedules.findIndex(t => t.scheduleId === task.scheduleId);
                    const totalSections = relatedSchedules.length;

                    // 3. ç­›é€‰ä»»åŠ¡æ±  (Pool Items)
                    // æ ¹æ® blockType å†³å®šç­›é€‰æ¡ä»¶
                    const poolItems = itemPool.value.filter(i => {
                        if ((i.sessionId || 'S_DEFAULT') !== currentSessionId.value) return false;
                        if (blockType === 'musician') return i.musicianId === filterId;
                        if (blockType === 'project') return i.projectId === filterId;
                        if (blockType === 'instrument') return i.instrumentId === filterId;
                        return false;
                    });

                    // åˆå§‹åŒ–åˆ†æ®µ
                    poolItems.forEach(i => {
                        ensureItemRecords(i);
                        if (i.sectionIndex === undefined) i.sectionIndex = 0;
                        if (i.sectionIndex >= totalSections) i.sectionIndex = totalSections - 1;
                    });

                    // 4. è®¾ç½®å¼¹çª—æ•°æ®
                    let modalTitle = '';
                    if (blockType === 'musician') modalTitle = getNameById(filterId, 'musician');
                    else if (blockType === 'project') modalTitle = getNameById(filterId, 'project');
                    else if (blockType === 'instrument') modalTitle = getNameById(filterId, 'instrument');

                    trackListData.value = {
                        name: modalTitle,
                        items: poolItems,
                        taskRef: currentSchedule,
                        totalSections: totalSections,
                        currentSectionIndex: currentSectionIndex,
                        schedules: relatedSchedules,
                        viewType: blockType // ğŸŸ¢ å…³é”®ï¼šä¼ å…¥è§†å›¾ç±»å‹ï¼Œä¾› HTML æ¨¡æ¿åˆ¤æ–­æ˜¾ç¤ºå†…å®¹
                    };

                    // ... (å‰é¢çš„ä»£ç ä¿æŒä¸å˜)
                    autoSortTrackList();
                    showTrackList.value = true;

                    // âœ¨âœ¨âœ¨ ä¿®å¤ç‰ˆï¼šè‡ªåŠ¨æ»šåŠ¨é€»è¾‘ âœ¨âœ¨âœ¨
                    // ä½¿ç”¨ setTimeout ä»£æ›¿å•çº¯çš„ nextTickï¼Œç»™æµè§ˆå™¨ 50ms-100ms çš„æ¸²æŸ“ç¼“å†²æ—¶é—´
                    setTimeout(() => {
                        const container = trackListContainerRef.value;
                        if (!container) return;

                        const targetIdx = trackListData.value.currentSectionIndex;

                        // å¦‚æœæ˜¯ç¬¬ 0 æ®µï¼Œç›´æ¥æ»šåˆ°é¡¶éƒ¨ (æœ€ç¨³å¦¥)
                        if (targetIdx === 0) {
                            container.scrollTo({ top: 0, behavior: 'auto' });
                        } else {
                            const dividerId = 'sec-divider-' + targetIdx;
                            const dividerEl = document.getElementById(dividerId);

                            if (dividerEl) {
                                // ğŸŸ¢ å…³é”®ï¼šå…ˆå°è¯•ç¬ç§»
                                dividerEl.scrollIntoView({ behavior: 'auto', block: 'start' });

                                // ğŸŸ¢ åŒé‡ä¿é™©ï¼š
                                // å› ä¸º TransitionGroup çš„åŠ¨ç”»å¯èƒ½ä¼šåœ¨æ»šåŠ¨åæŠŠå…ƒç´ ä½ç½®æŒ¤å
                                // æ‰€ä»¥åœ¨åŠ¨ç”»ç»“æŸ(300ms)åï¼Œå†å¾®è°ƒä¸€æ¬¡ï¼Œç¡®ä¿ä½ç½®ç»å¯¹æ­£ç¡®
                                setTimeout(() => {
                                    const retryEl = document.getElementById(dividerId);
                                    if(retryEl) retryEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }, 350);
                            } else {
                                // è°ƒè¯•ç”¨ï¼šå¦‚æœæ‰¾ä¸åˆ°å…ƒç´ ï¼Œæ‰“å°æ—¥å¿—
                                // console.warn('æœªæ‰¾åˆ°åˆ†å‰²çº¿å…ƒç´ :', dividerId);
                            }
                        }
                    }, 50); // ğŸ‘ˆ è¿™é‡Œè®¾ç½® 50ms å»¶è¿Ÿï¼Œæ—¢ä¸æ˜æ˜¾å¡é¡¿ï¼Œåˆèƒ½é¿å¼€æ¸²æŸ“å†²çª
                    // âœ¨âœ¨âœ¨ ä¿®å¤ç»“æŸ âœ¨âœ¨âœ¨
                }
            };

            const setTrackNow = (item, type) => {
                const viewType = trackListData.value.viewType || 'musician';
                const record = item.records[viewType];

                const now = new Date();
                const timeStr = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

                if (type === 'start') record.recStart = timeStr;
                if (type === 'end') record.recEnd = timeStr;

                calcTrackDiff(item);
                pushHistory();
            };

            // ğŸŸ¢ ä¿®æ”¹: checkOverlap (æ”¯æŒåˆ†å±‚æ£€æµ‹)
            const checkOverlap = (date, startTime, durationStr, excludeId, checkType) => {
                // 1. è®¡ç®—å½“å‰æ„å›¾çš„æ—¶é—´æ®µ
                const newStart = timeToMinutes(startTime);
                const newEnd = newStart + parseTime(durationStr) / 60;

                return scheduledTasks.value.some(t => {
                    // æ’é™¤è‡ªèº«
                    if (t.scheduleId === excludeId) return false;

                    // æ’é™¤å…¶ä»–æ—¥æœŸ
                    if (t.date !== date) return false;

                    // æ’é™¤å…¶ä»– Session
                    if ((t.sessionId || 'S_DEFAULT') !== currentSessionId.value) return false;

                    // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: åˆ¤æ–­ç°æœ‰ä»»åŠ¡ t çš„ç±»å‹
                    let tType = 'musician';
                    if (t.projectId) tType = 'project';
                    else if (t.instrumentId) tType = 'instrument';

                    // ğŸŸ¢ åªæœ‰ç±»å‹ä¸€è‡´æ—¶ï¼Œæ‰æ£€æŸ¥æ—¶é—´å†²çª
                    // (å³: é¡¹ç›®ä»»åŠ¡åªè·Ÿé¡¹ç›®ä»»åŠ¡æ’ï¼Œä¸è·Ÿäººå‘˜ä»»åŠ¡æ’)
                    if (tType !== checkType) return false;

                    // è®¡ç®—ç°æœ‰ä»»åŠ¡çš„æ—¶é—´æ®µ
                    const tStart = timeToMinutes(t.startTime);
                    const tEnd = tStart + parseTime(t.estDuration) / 60;

                    return (newStart < tEnd && newEnd > tStart);
                });
            };


            // ğŸŸ¢ ä¿®æ”¹: saveTrackRecord
            const saveTrackRecord = (item) => {
                if (trackSaveTimer) clearTimeout(trackSaveTimer);

                trackSaveTimer = setTimeout(() => {
                    // ä¼ å…¥å½“å‰è§†å›¾ç±»å‹ï¼Œä»¥ä¾¿æ•ˆç‡è®¡ç®—åªæ›´æ–°å¯¹åº”ç»´åº¦çš„å€ç‡
                    const viewType = trackListData.value.viewType || 'musician';
                    autoUpdateMusicianEfficiency(item.musicianId, viewType);
                }, 1500);
            };

            // ğŸŸ¢ ä¿®å¤: TrackList æ’åºæŒ‰é’®é€»è¾‘ (æ’åº + é‡ç½®å¸é™„)
            const sortTrackList = () => {
                if (!trackListData.value.items) return;

                const viewType = trackListData.value.viewType || 'musician';

                // 1. æ‰§è¡Œæ’åº (åŸæœ‰é€»è¾‘)
                // ä½¿ç”¨ [...array] åˆ›å»ºæ–°æ•°ç»„å¼•ç”¨ï¼Œå¼ºåˆ¶åˆ·æ–°åˆ—è¡¨ DOM
                trackListData.value.items = [...trackListData.value.items].sort((a, b) => {
                    // ç¬¬ä¸€ä¼˜å…ˆçº§: åˆ†æ®µç´¢å¼• (Section)
                    const secA = a.sectionIndex || 0;
                    const secB = b.sectionIndex || 0;
                    if (secA !== secB) return secA - secB;

                    // ç¬¬äºŒä¼˜å…ˆçº§: æ—¶é—´ (Time)
                    const recA = a.records?.[viewType];
                    const recB = b.records?.[viewType];
                    const tA = recA?.recStart || '99:99';
                    const tB = recB?.recStart || '99:99';

                    return tA.localeCompare(tB);
                });

                // ğŸŸ¢ 2. æ–°å¢ï¼šåŒæ—¶æ‰§è¡Œâ€œä»»åŠ¡å—å¸é™„â€é€»è¾‘
                // å‚æ•°1 (true): é™é»˜æ¨¡å¼ï¼Œä¸å¼¹å‡º"è‡ªåŠ¨è°ƒæ•´å®Œæˆ"çš„æç¤ºæ¡†
                // å‚æ•°2 (false): æš‚ä¸ä¿å­˜å†å²ï¼Œç­‰ä¸‹é¢ç»Ÿä¸€ä¿å­˜
                autoResizeScheduleByRecords(true, false);

                // 3. ç»Ÿä¸€ä¿å­˜å†å² & éœ‡åŠ¨åé¦ˆ
                pushHistory();
                window.triggerTouchHaptic('Medium');
            };

            const autoSortTrackList = () => {
                if (!trackListData.value.items) return;

                const viewType = trackListData.value.viewType || 'musician';

                trackListData.value.items.sort((a, b) => {
                    // 1. ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šåˆ†æ®µç´¢å¼• (Section)
                    const secA = a.sectionIndex || 0;
                    const secB = b.sectionIndex || 0;
                    if (secA !== secB) return secA - secB;

                    // 2. ç¬¬äºŒä¼˜å…ˆçº§ï¼šæ—¶é—´ (Time)
                    // æ ¹æ®è§†å›¾ç±»å‹åŠ¨æ€è·å–æ—¶é—´
                    const recA = a.records?.[viewType];
                    const recB = b.records?.[viewType];

                    const tA = recA?.recStart || '99:99';
                    const tB = recB?.recStart || '99:99';
                    return tA.localeCompare(tB);
                });
            };

            // ğŸŸ¢ ä¿®æ”¹: å¢åŠ  shouldSaveHistory å‚æ•°ï¼Œé˜²æ­¢æ‹–åŠ¨æ—¶å¡é¡¿
            const moveDivider = (dividerIndex, direction, shouldSaveHistory = true) => {
                const upperSection = dividerIndex - 1;
                const lowerSection = dividerIndex;
                const items = trackListData.value.items;

                if (direction === 'up') {
                    // å‘ä¸Šç§»ï¼šæŠŠä¸Šæ–¹åˆ†æ®µçš„æœ€åä¸€ä¸ªä»»åŠ¡ï¼Œæ‹‰åˆ°ä¸‹æ–¹åˆ†æ®µ
                    for (let i = items.length - 1; i >= 0; i--) {
                        if (items[i].sectionIndex === upperSection) {
                            items[i].sectionIndex = lowerSection;
                            break;
                        }
                    }
                } else if (direction === 'down') {
                    // å‘ä¸‹ç§»ï¼šæŠŠä¸‹æ–¹åˆ†æ®µçš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œæ¨åˆ°ä¸Šæ–¹åˆ†æ®µ
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].sectionIndex === lowerSection) {
                            items[i].sectionIndex = upperSection;
                            break;
                        }
                    }
                }

                // é‡æ–°æ’åº
                autoSortTrackList();

                // ğŸŸ¢ å…³é”®: æ‹–åŠ¨è¿‡ç¨‹ä¸­ä¸å­˜å†å²ï¼Œåªåœ¨æ¾æ‰‹æ—¶å­˜
                if (shouldSaveHistory) {
                    pushHistory();
                }
            };

            // --- Date/View Logic ---
            const timeSlots = computed(() => {
                const s = [];
                for (let i = settings.startHour; i < settings.endHour; i++) {
                    s.push(`${i}:00`);
                    s.push(`${i}:30`);
                }
                return s;
            });

            // ğŸŸ¢ ä¿®æ”¹: getTaskStyle (å¢åŠ  z-index æ§åˆ¶)
            const getTaskStyle = t => {
                const [h, m] = t.startTime.split(':').map(Number);
                const top = ((h - settings.startHour) * 60 + m) * pxPerMin.value;
                const hgt = (parseTime(t.estDuration) / 60) * pxPerMin.value;

                let baseColor = '#a855f7';
                if (t.projectId) baseColor = '#eab308';
                else if (t.instrumentId) baseColor = '#3b82f6';

                // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: è®¡ç®—å±‚çº§
                // å¦‚æœä»»åŠ¡ä¸æ˜¯å¹½çµï¼ˆå³å®ƒæ˜¯å½“å‰è§†å›¾çš„ä»»åŠ¡ï¼‰ï¼Œå±‚çº§è®¾ä¸º 20 (é«˜)
                // å¦‚æœæ˜¯å¹½çµï¼Œå±‚çº§è®¾ä¸º 1 (ä½)
                const isGhost = isTaskGhost(t); // å¤ç”¨ä¹‹å‰çš„åˆ¤æ–­å‡½æ•°
                const zIndex = isGhost ? 1 : 20;

                return {
                    top: `${top}px`,
                    height: `${hgt}px`,
                    '--task-border': baseColor,
                    zIndex: zIndex, // åº”ç”¨å±‚çº§
                };
            };

            // ğŸŸ¢ æ–°å¢: è·å–æ—¥ç¨‹å—æ˜¾ç¤ºçš„æ ‡é¢˜
            const getBlockTitle = (task) => {
                if (task.musicianId) return getNameById(task.musicianId, 'musician');
                if (task.projectId) return getNameById(task.projectId, 'project');
                if (task.instrumentId) return getNameById(task.instrumentId, 'instrument');
                return 'æœªå‘½åæ—¥ç¨‹';
            };

            // ğŸŸ¢ æ–°å¢: åˆ¤æ–­ä»»åŠ¡æ˜¯å¦ä¸º"å¹½çµ"çŠ¶æ€ (Sessionä¸åŒ¹é… æˆ– è§†å›¾ç±»å‹ä¸åŒ¹é…)
            const isTaskGhost = (task) => {
                // 1. æ£€æŸ¥ Session æ˜¯å¦åŒ¹é… (æœ€åŸºç¡€æ¡ä»¶)
                const taskSession = task.sessionId || 'S_DEFAULT';
                if (taskSession !== currentSessionId.value) return true;

                // 2. æ£€æŸ¥è§†å›¾ç±»å‹æ˜¯å¦åŒ¹é…
                // å½“å‰ä¾§è¾¹æ åœ¨ä»€ä¹ˆæ¨¡å¼ï¼Œå°±åªäº®æ˜¾ä»€ä¹ˆç±»å‹çš„å—

                // å¦‚æœæ˜¯ 'musician' (äººå‘˜) è§†å›¾ -> åªæœ‰å« musicianId çš„å—äº®æ˜¾
                if (sidebarTab.value === 'musician') {
                    return !task.musicianId;
                }

                // å¦‚æœæ˜¯ 'project' (é¡¹ç›®) è§†å›¾ -> åªæœ‰å« projectId çš„å—äº®æ˜¾
                if (sidebarTab.value === 'project') {
                    return !task.projectId;
                }

                // å¦‚æœæ˜¯ 'instrument' (ä¹å™¨) è§†å›¾ -> åªæœ‰å« instrumentId çš„å—äº®æ˜¾
                if (sidebarTab.value === 'instrument') {
                    return !task.instrumentId;
                }

                return false; // é»˜è®¤ä¸å˜æˆå¹½çµ
            };

            // ğŸŸ¢ æ–°å¢: ç¡®ä¿ä»»åŠ¡å¯¹è±¡æ‹¥æœ‰å¤šç»´åº¦è®°å½•ç»“æ„
            const ensureItemRecords = (item) => {
                if (!item.records) {
                    item.records = {
                        musician: {},
                        project: {},
                        instrument: {}
                    };

                    // ğŸŸ¢ è¿ç§»æ—§æ•°æ®: å¦‚æœæœ‰æ—§çš„ flat æ•°æ®ï¼Œé»˜è®¤å½’å…¥ 'musician' (ä¿æŒå‘ä¸‹å…¼å®¹)
                    if (item.actualDuration || item.recStart || item.recEnd) {
                        item.records.musician = {
                            recStart: item.recStart || '',
                            recEnd: item.recEnd || '',
                            actualDuration: item.actualDuration || '',
                            breakMinutes: item.breakMinutes || 0
                        };
                        // æ¸…ç†æ—§å­—æ®µï¼Œé¿å…æ··æ·† (å¯é€‰ï¼Œä¸ºäº†å®‰å…¨ä¹Ÿå¯ä»¥ä¿ç•™)
                        // delete item.actualDuration;
                        // delete item.recStart;
                        // delete item.recEnd;
                    }
                }
                // ç¡®ä¿ä¸‰ä¸ªé”®éƒ½å­˜åœ¨ï¼Œé˜²æ­¢ undefined æŠ¥é”™
                if (!item.records.musician) item.records.musician = {};
                if (!item.records.project) item.records.project = {};
                if (!item.records.instrument) item.records.instrument = {};

                return item;
            };

            const formatDate = d => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            const isToday = d => formatDate(new Date()) === d;

            // --- ğŸŸ¢ æ—¥æœŸåˆ‡æ¢åŠ¨ç”»æ§åˆ¶ ---
            const dateTransitionName = ref('slide-next'); // é»˜è®¤æ–¹å‘

            // ğŸŸ¢ ä¿®å¤: changeDate (ä¿®å¤æœˆè§†å›¾åˆ‡æ¢å¡é¡¿/è·³æœˆé—®é¢˜)
            const changeDate = (dir) => {
                // 1. è®¾ç½®åŠ¨ç”»æ–¹å‘
                if (dir > 0) {
                    dateTransitionName.value = 'slide-next';
                } else {
                    dateTransitionName.value = 'slide-prev';
                }

                const d = new Date(viewDate.value);

                if (currentView.value === 'week') {
                    // --- å‘¨è§†å›¾é€»è¾‘ ---
                    // ç®€å•åŠ å‡ 7 å¤©å³å¯
                    d.setDate(d.getDate() + 7 * dir);
                } else {
                    // --- æœˆè§†å›¾é€»è¾‘ (æ ¸å¿ƒä¿®å¤) ---
                    // 1. å…ˆæŠŠæ—¥æœŸè®¾ä¸º 1 å·
                    // (æ˜¯ä¸ºäº†é˜²æ­¢å¦‚ "1æœˆ31æ—¥ + 1ä¸ªæœˆ" å˜æˆ "3æœˆ3æ—¥" ä»è€Œè·³è¿‡2æœˆçš„é—®é¢˜)
                    d.setDate(1);

                    // 2. å®‰å…¨åœ°åŠ å‡æœˆä»½
                    d.setMonth(d.getMonth() + dir);
                }

                viewDate.value = d;
                window.triggerTouchHaptic('Light'); // éœ‡åŠ¨åé¦ˆ
            };

            const currentWeekDays = computed(() => {
                const d = new Date(viewDate.value);
                const day = d.getDay();
                const diff = d.getDate() - day;
                const s = new Date(d.setDate(diff));
                const r = [];
                for (let i = 0; i < 7; i++) {
                    const c = new Date(s);
                    c.setDate(s.getDate() + i);
                    r.push({
                        dateStr: formatDate(c),
                        weekday: ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][c.getDay()],
                        dateShort: `${c.getMonth() + 1}/${c.getDate()}`
                    });
                }
                return r;
            });

            // ğŸŸ¢ ä¿®å¤: æœˆè§†å›¾æ—¥å†æ•°æ®ç”Ÿæˆ (æ”¯æŒ 5è¡Œ/6è¡Œ è‡ªé€‚åº”)
            const currentMonthDays = computed(() => {
                const y = viewDate.value.getFullYear();
                const m = viewDate.value.getMonth();
                const f = new Date(y, m, 1); // å½“æœˆç¬¬ä¸€å¤©
                const l = new Date(y, m + 1, 0); // å½“æœˆæœ€åä¸€å¤©
                const r = [];

                // 1. ä¸Šä¸ªæœˆè¡¥ä½
                // f.getDay() è¿”å› 0(å‘¨æ—¥) ~ 6(å‘¨å…­)
                for (let i = f.getDay(); i > 0; i--) {
                    const d = new Date(y, m, 1 - i);
                    r.push({
                        fullDate: formatDate(d),
                        dayNum: d.getDate(),
                        isCurrentMonth: false
                    });
                }

                // 2. å½“æœˆæ—¥æœŸ
                for (let i = 1; i <= l.getDate(); i++) {
                    const d = new Date(y, m, i);
                    r.push({
                        fullDate: formatDate(d),
                        dayNum: i,
                        isCurrentMonth: true
                    });
                }

                // 3. ä¸‹ä¸ªæœˆè¡¥ä½ (æ™ºèƒ½åˆ¤æ–­æ˜¯è¡¥åˆ° 35 è¿˜æ˜¯ 42)
                // å¦‚æœå½“å‰æ€»æ•° <= 35ï¼Œè¯´æ˜5è¡Œå°±å¤Ÿäº†ï¼›å¦åˆ™éœ€è¦6è¡Œ(42)
                const targetLen = r.length <= 35 ? 35 : 42;

                while (r.length < targetLen) {
                    const nextDateNum = r.length - l.getDate() - f.getDay() + 1;
                    const d = new Date(y, m + 1, nextDateNum);
                    r.push({
                        fullDate: formatDate(d),
                        dayNum: nextDateNum,
                        isCurrentMonth: false
                    });
                }

                return r;
            });
            const currentDateLabel = computed(() => `${viewDate.value.getFullYear()}å¹´ ${viewDate.value.getMonth() + 1}æœˆ`);
            // ğŸŸ¢ ä¼˜åŒ–: ä½¿ç”¨è®¡ç®—å±æ€§é¢„å…ˆåˆ†ç»„ï¼Œå¹¶æŒ‰æ—¶é—´è‡ªåŠ¨æ’åº
            const tasksByDateMap = computed(() => {
                const map = {};
                // 1. åˆ†ç»„
                for (const task of scheduledTasks.value) {
                    if (!map[task.date]) {
                        map[task.date] = [];
                    }
                    map[task.date].push(task);
                }

                // 2. ğŸŸ¢ ä¿®å¤: å¯¹æ¯ä¸€å¤©çš„ä»»åŠ¡æŒ‰ startTime è¿›è¡Œæ’åº
                for (const date in map) {
                    map[date].sort((a, b) => {
                        // å­—ç¬¦ä¸²æ¯”è¾ƒ "09:00" < "14:00" åœ¨24å°æ—¶åˆ¶ä¸‹æ˜¯æœ‰æ•ˆçš„
                        return a.startTime.localeCompare(b.startTime);
                    });
                }

                return map;
            });

            // è¾…åŠ©å‡½æ•°ï¼šä»…ä¿ç•™ç”¨äºæ¨¡æ¿ä¸­ä»ç„¶éœ€è¦å‡½æ•°è°ƒç”¨çš„æå°‘æ•°æƒ…å†µ (å¯é€‰ï¼Œä¸»è¦ä¸ºäº†å…¼å®¹)
            const getTasksForDate = (d) => {
                return tasksByDateMap.value[d] || [];
            };
            const switchToWeek = d => {
                viewDate.value = new Date(d);
                currentView.value = 'week';
            };
            const openEditModal = (i, s) => {
                editingItem.value = JSON.parse(JSON.stringify(i));

                // ğŸŸ¢ å…³é”®ä¿®æ”¹ï¼šå¦‚æœå€ç‡ä¸ºç©ºæˆ–0ï¼Œé»˜è®¤è®¾ä¸º getDefaultRatio
                if (!editingItem.value.ratio || editingItem.value.ratio <= 0) {
                    editingItem.value.ratio = getDefaultRatio(editingItem.value.musicianId); // ğŸŸ¢ ä½¿ç”¨é€šç”¨é»˜è®¤å€ç‡
                }

                editingSource.value = s;
                showEditor.value = true;
            };

            const saveEdit = () => {
                // ğŸŸ¢ æ–°å¢ï¼šä¿å­˜å‰çš„æœ€åä¸€é“é˜²çº¿ï¼Œå¦‚æœä¸ºç©ºå¼ºåˆ¶è®¾ä¸º 20
                if (!editingItem.value.ratio || editingItem.value.ratio <= 0) {
                    editingItem.value.ratio = getDefaultRatio(editingItem.value.musicianId);
                }

                // æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿ä¹æ›²æ—¶é•¿å’Œå€æ•°æ›´æ–°åï¼Œä¼°ç®—æ—¶é•¿ä¹Ÿä¼šæ›´æ–°
                editingItem.value.estDuration = calculateEstTime(editingItem.value.musicDuration, editingItem.value.ratio);

                if (editingSource.value === 'pool') {
                    const idx = itemPool.value.findIndex(x => x.id === editingItem.value.id);
                    if (idx !== -1) {
                        // æ›´æ–°ä»»åŠ¡æ¨¡æ¿
                        itemPool.value[idx] = editingItem.value;
                        // å¦‚æœæ˜¯æ¨¡æ¿ï¼ŒåŒæ—¶æ›´æ–°æ‰€æœ‰å·²æ’æœŸçš„å®ä¾‹
                        scheduledTasks.value.filter(st => st.templateId === editingItem.value.id).forEach(st => {
                            st.projectId = editingItem.value.projectId;
                            st.instrumentId = editingItem.value.instrumentId;
                            st.musicianId = editingItem.value.musicianId;
                            st.musicDuration = editingItem.value.musicDuration;
                            st.ratio = editingItem.value.ratio;
                            st.estDuration = editingItem.value.estDuration;
                        });
                    }
                } else {
                    const idx = scheduledTasks.value.findIndex(x => x.scheduleId === editingItem.value.scheduleId);
                    if (idx !== -1) {
                        scheduledTasks.value[idx] = editingItem.value;
                        updateTaskNotification(scheduledTasks.value[idx]);
                    }
                }
                showEditor.value = false;
                pushHistory();
            };

            const deleteEditingItem = () => {
                // ğŸŸ¢ æ’å…¥ä»£ç  START
                // å¦‚æœæ˜¯åˆ é™¤æ—¥ç¨‹ï¼Œå…ˆå–æ¶ˆå¯¹åº”çš„ç³»ç»Ÿé€šçŸ¥
                if (editingSource.value !== 'pool') {
                    const LocalNotifications = window.Capacitor?.Plugins?.LocalNotifications;
                    if (LocalNotifications) {
                        // ä½¿ç”¨åŒæ ·çš„ ID ç®—æ³•
                        const notifId = editingItem.value.scheduleId % 2147483647;
                        LocalNotifications.cancel({notifications: [{id: notifId}]});
                    }
                }
                // ğŸŸ¢ æ’å…¥ä»£ç  END
                if (editingSource.value === 'pool') {
                    // 1. åˆ é™¤å…³è”æ—¥ç¨‹
                    scheduledTasks.value = scheduledTasks.value.filter(t => t.templateId !== editingItem.value.id);
                    // 2. åˆ é™¤ä»»åŠ¡æœ¬èº«
                    itemPool.value = itemPool.value.filter(i => i.id !== editingItem.value.id);
                    // 3. æ¸…ç†ç©ºå£³
                    cleanupEmptySchedules();
                } else {
                    scheduledTasks.value = scheduledTasks.value.filter(t => t.scheduleId !== editingItem.value.scheduleId);
                }
                showEditor.value = false;
                pushHistory();
            };

            const sidebarTab = ref('musician');

            // ğŸŸ¢ ä¿®å¤: calculateGroupStats (æ€»æ—¶é•¿é€»è¾‘ä¼˜åŒ–ï¼šæŒ‰æ—¥ç¨‹å—åˆ†æ®µè®¡ç®— Span)
            const calculateGroupStats = (sourceList, filterKey) => {
                const currentSessionItems = itemPool.value.filter(t =>
                    (t.sessionId || 'S_DEFAULT') === currentSessionId.value
                );

                const recordTypeMap = {
                    'musicianId': 'musician',
                    'projectId': 'project',
                    'instrumentId': 'instrument'
                };
                const currentRecordType = recordTypeMap[filterKey] || 'musician';

                const stats = sourceList.map(group => {
                    // 1. è·å–è¯¥ç»„ä¸‹çš„ä»»åŠ¡æ± é¡¹ç›®
                    const poolItems = currentSessionItems.filter(t => t[filterKey] === group.id);
                    if (poolItems.length === 0) return null;

                    // 2. è·å–è¯¥ç»„çš„æ—¥ç¨‹å—
                    const scheduleItems = scheduledTasks.value.filter(t =>
                        t[filterKey] === group.id &&
                        (t.sessionId || 'S_DEFAULT') === currentSessionId.value
                    );
                    // æ’åºç¡®ä¿ç´¢å¼•å¯¹é½
                    scheduleItems.sort((a, b) => a.date.localeCompare(b.date) || a.startTime.localeCompare(b.startTime));
                    const scheduleCount = scheduleItems.length;

                    // --- ğŸŸ¢ A. è®¡ç®—æ€»éœ€æ—¶é•¿ (Total Duration) [æ ¸å¿ƒä¿®æ”¹] ---
                    // é€»è¾‘ï¼šæŒ‰ sectionIndex åˆ†ç»„ï¼Œåˆ†åˆ«è®¡ç®—æ¯ç»„çš„æ—¶é—´è·¨åº¦ (Span) + æœªå½•åˆ¶æ›²ç›®çš„æ—¶é•¿

                    const sectionGroups = {};
                    let totalSecs = 0;

                    // (1) å…ˆå°†ä»»åŠ¡æŒ‰æ—¥ç¨‹å—åˆ†ç»„
                    poolItems.forEach(item => {
                        // é»˜è®¤å½’ä¸ºç¬¬ 0 å—
                        const sIdx = item.sectionIndex !== undefined ? item.sectionIndex : 0;
                        if (!sectionGroups[sIdx]) sectionGroups[sIdx] = [];
                        sectionGroups[sIdx].push(item);
                    });

                    // (2) éå†æ¯ä¸€ç»„ï¼Œè®¡ç®— Span
                    Object.values(sectionGroups).forEach(items => {
                        let minStart = Infinity;
                        let maxEnd = -Infinity;
                        let hasRecordInThisSection = false;

                        items.forEach(item => {
                            ensureItemRecords(item);
                            const rec = item.records ? item.records[currentRecordType] : null;

                            if (rec && rec.recStart && rec.recEnd) {
                                // === æœ‰èµ·æ­¢æ—¶é—´è®°å½•çš„æ›²ç›® ===
                                hasRecordInThisSection = true;

                                const [sh, sm] = rec.recStart.split(':').map(Number);
                                const [eh, em] = rec.recEnd.split(':').map(Number);

                                const startVal = sh * 60 + sm;
                                let endVal = eh * 60 + em;

                                // å¤„ç†è·¨å¤©
                                if (endVal < startVal) endVal += 24 * 60;

                                if (startVal < minStart) minStart = startVal;
                                if (endVal > maxEnd) maxEnd = endVal;
                            } else {
                                // === æ²¡æœ‰èµ·æ­¢è®°å½•çš„æ›²ç›® ===
                                // ç›´æ¥ç´¯åŠ å…¶é¢„è®¡æ—¶é•¿ (æˆ–æ‰‹åŠ¨å¡«å†™çš„ actualDuration)
                                const dur = (rec && rec.actualDuration && item.musicDuration) ? rec.actualDuration : item.estDuration;
                                totalSecs += parseTime(dur || '00:00');
                            }
                        });

                        // å¦‚æœè¯¥æ®µå†…æœ‰å½•éŸ³è®°å½•ï¼ŒåŠ ä¸Šè¯¥æ®µçš„æ—¶é—´è·¨åº¦ (Span)
                        // Span = æœ€æ™šç»“æŸ - æœ€æ—©å¼€å§‹
                        if (hasRecordInThisSection) {
                            const spanSecs = (maxEnd - minStart) * 60;
                            totalSecs += spanSecs;
                        }
                    });


                    // --- B. è®¡ç®—å®é™…å®Œæˆæ—¶é•¿ (Total Actual / Completed) ---
                    // é€»è¾‘ï¼šç´¯åŠ æ‰€æœ‰æ›²ç›®çš„å‡€å½•éŸ³æ—¶é•¿
                    let totalActualSec = 0;
                    let totalMusicSec = 0;
                    let recordedCount = 0;

                    // ğŸŸ¢ å‡†å¤‡è§†å›¾åˆ—è¡¨ (Display Items)
                    const displayItems = poolItems.map(rawItem => {
                        ensureItemRecords(rawItem);
                        const rec = rawItem.records ? rawItem.records[currentRecordType] : null;
                        const actualDur = (rec && rec.actualDuration) ? rec.actualDuration : null;
                        const recStart = (rec && rec.recStart) ? rec.recStart : null;

                        // ç»Ÿè®¡ Total Completed
                        if (actualDur && rawItem.musicDuration) {
                            const act = parseTime(actualDur);
                            const mus = parseTime(rawItem.musicDuration);
                            if (act > 0 && mus > 0) {
                                totalActualSec += act;
                                totalMusicSec += mus;
                                recordedCount++;
                            }
                        }

                        return {
                            ...rawItem,
                            actualDuration: actualDur, // ä¿®å¤å°å¡ç‰‡æ˜¾ç¤º
                            _sortTime: recStart || '99:99'
                        };
                    });

                    // åˆ—è¡¨æ’åºï¼šå…ˆæŒ‰åˆ†æ®µï¼Œå†æŒ‰æ—¶é—´
                    displayItems.sort((a, b) => {
                        const secA = a.sectionIndex || 0;
                        const secB = b.sectionIndex || 0;
                        if (secA !== secB) return secA - secB;
                        return a._sortTime.localeCompare(b._sortTime);
                    });


                    // --- C. è®¡ç®—å·²æ’æœŸæ—¶é•¿ (Allocated / Scheduled) ---
                    // é€»è¾‘ï¼šæŒ‰æ—¥ç¨‹å—åŒ¹é…ï¼Œæœ‰å½•éŸ³ç®—å‡€æ—¶é•¿ï¼Œæ— å½•éŸ³ç®—é¢„è®¡æ—¶é•¿
                    let scheduledSecs = 0;

                    scheduleItems.forEach((block, blockIndex) => {
                        const itemsInBlock = poolItems.filter(item => {
                            const sIdx = item.sectionIndex !== undefined ? item.sectionIndex : 0;
                            return sIdx === blockIndex;
                        });

                        const hasActualRecord = itemsInBlock.some(item => {
                            const rec = item.records && item.records[currentRecordType];
                            return rec && rec.actualDuration && parseTime(rec.actualDuration) > 0;
                        });

                        if (hasActualRecord) {
                            const netDuration = itemsInBlock.reduce((sum, item) => {
                                const rec = item.records[currentRecordType];
                                const act = (rec && rec.actualDuration) ? parseTime(rec.actualDuration) : 0;
                                return sum + act;
                            }, 0);
                            scheduledSecs += netDuration;
                        } else {
                            scheduledSecs += parseTime(block.estDuration);
                        }
                    });


                    // --- D. çŠ¶æ€ä¸æ¯”ç‡ ---
                    const trackCount = poolItems.length;
                    const avgRealRatio = (totalMusicSec > 0)
                        ? parseFloat((totalActualSec / totalMusicSec).toFixed(1))
                        : 0;

                    let statusKey = 'unscheduled';
                    if (trackCount > 0 && recordedCount === trackCount) {
                        statusKey = 'completed';
                    } else if (scheduledSecs > 0 && scheduledSecs < totalSecs) {
                        statusKey = 'insufficient'; // ç¼ºæ—¶
                    } else if (recordedCount > 0) {
                        statusKey = 'in-progress';
                    } else if (scheduledSecs >= totalSecs && totalSecs > 0) {
                        statusKey = 'full';
                    }

                    return {
                        ...group,
                        id: group.id,
                        items: displayItems,
                        trackCount,
                        scheduleCount,
                        totalDuration: formatSecs(totalSecs),
                        totalSeconds: totalSecs,
                        scheduledSeconds: scheduledSecs,
                        completedSeconds: totalActualSec,
                        statusKey,
                        avgRealRatio,
                        recordedCount,
                        isFullyScheduled: (statusKey === 'full' || statusKey === 'completed')
                    };
                }).filter(Boolean);

                // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹: æ’åºé€»è¾‘
                return stats.sort((a, b) => {
                    // 1. æŒ‰åç§°æ’åº
                    if (sortField.value === 'name') {
                        return sortAsc.value ? a.name.localeCompare(b.name, 'zh-CN') : b.name.localeCompare(a.name, 'zh-CN');
                    }

                    // 2. æŒ‰çŠ¶æ€æ’åº (æ–°å¢)
                    if (sortField.value === 'status') {
                        // å®šä¹‰æƒé‡: è¶Šå°è¶Šé å‰ (æ­£åºæ—¶: å®Œæˆ -> è¿›è¡Œä¸­ -> ç¼ºæ—¶ -> å·²æ’ -> æœªæ’)
                        const statusWeight = {
                            'completed': 0,
                            'in-progress': 1,
                            'insufficient': 2,
                            'full': 3,
                            'unscheduled': 4
                        };

                        const wA = statusWeight[a.statusKey] ?? 99;
                        const wB = statusWeight[b.statusKey] ?? 99;

                        if (wA !== wB) {
                            return sortAsc.value ? (wA - wB) : (wB - wA);
                        }

                        // çŠ¶æ€ç›¸åŒæ—¶ï¼ŒæŒ‰åç§°ä½œä¸ºäºŒçº§æ’åº
                        return a.name.localeCompare(b.name, 'zh-CN');
                    }

                    // 3. æŒ‰æ—¶é•¿æ’åº (é»˜è®¤)
                    const valA = a.totalSeconds;
                    const valB = b.totalSeconds;
                    if (valA < valB) return sortAsc.value ? -1 : 1;
                    if (valA > valB) return sortAsc.value ? 1 : -1;
                    return 0;
                });
            };

            // 3. ä¸‰ä¸ªç»´åº¦çš„è®¡ç®—å±æ€§
            // ä»ç„¶ä¿ç•™ musicianStats è¿™ä¸ªåå­—ï¼Œä»¥å…¼å®¹ä½ ä»£ç ä¸­å¯èƒ½å¼•ç”¨å®ƒçš„åœ°æ–¹
            const musicianStats = computed(() => calculateGroupStats(settings.musicians, 'musicianId'));
            const projectStats = computed(() => calculateGroupStats(settings.projects, 'projectId'));
            const instrumentStats = computed(() => calculateGroupStats(settings.instruments, 'instrumentId'));

            // 4. å½“å‰ä¾§è¾¹æ æ˜¾ç¤ºçš„æ•°æ®æº
            const currentSidebarList = computed(() => {
                if (sidebarTab.value === 'project') return projectStats.value;
                if (sidebarTab.value === 'instrument') return instrumentStats.value;
                return musicianStats.value;
            });

            // V10.0 æ–°å¢ï¼šè®¡ç®—æ¼”å¥å‘˜ç»Ÿè®¡æ•°æ®
            // --- V10.4 æ–°å¢ï¼šç»Ÿè®¡å¡ç‰‡å±•å¼€çŠ¶æ€ ---
            const expandedStatsIds = reactive(new Set());

            const toggleStatCollapse = (id) => {
                if (expandedStatsIds.has(id)) {
                    expandedStatsIds.delete(id);
                } else {
                    expandedStatsIds.add(id);
                }
            };

            // ğŸŸ¢ æ–°å¢: è®¡ç®—å½“å‰å¼¹çª—å†…æ—¥ç¨‹å—çš„å®æ—¶æ¯”ç‡
            const getSessionRatio = () => {
                const actual = trackListData.value.actualDuration;
                const items = trackListData.value.items;

                if (!actual || !items || items.length === 0) return '-';

                const actualSec = parseTime(actual);
                if (actualSec === 0) return '-';

                // è®¡ç®—è¯¥å—å†…æ‰€æœ‰æ›²ç›®çš„è°±é¢æ€»é•¿
                const totalMusicSec = items.reduce((sum, item) => sum + parseTime(item.musicDuration), 0);

                if (totalMusicSec === 0) return '-';

                return (actualSec / totalMusicSec).toFixed(1);
            };

            // ğŸŸ¢ æ–°å¢: å°†çœŸå®æ¯”å€¼åº”ç”¨ä¸ºé»˜è®¤æ¯”å€¼
            // ğŸŸ¢ ä¿®å¤: æ›´æ–°å€ç‡å¹¶é‡ç®—æ‰€æœ‰ä»»åŠ¡æ—¶é•¿
            // ğŸŸ¢ ä¿®æ”¹: ç§»é™¤ç¡®è®¤å¼¹çª—ï¼Œç›´æ¥æ›´æ–°å…¨å±€å€ç‡
            // ğŸŸ¢ ä¿®å¤: æ›´æ–°æ•ˆç‡ (ä¿®å¤æ—¥ç¨‹å—ç¼©ä¸º0çš„Bug)
            const updateMusicianRatio = (stat) => {
                if (!stat.avgRealRatio || stat.avgRealRatio <= 0) return;

                const newRatio = parseFloat(stat.avgRealRatio);

                // 1. æ›´æ–°æ¼”å¥å‘˜çš„å…¨å±€é»˜è®¤è®¾ç½®
                const mus = settings.musicians.find(m => m.id === stat.id);
                if (mus) {
                    mus.defaultRatio = newRatio;
                }

                // 2. æ›´æ–°ã€ä»»åŠ¡æ± ã€‘é‡Œè¯¥æ¼”å¥å‘˜çš„æ‰€æœ‰ä»»åŠ¡
                // ä»»åŠ¡æ± é‡Œçš„éƒ½æ˜¯æ¨¡æ¿ï¼Œè‚¯å®šæœ‰ musicDurationï¼Œæ‰€ä»¥å¿…é¡»æ›´æ–° estDuration ä»¥ä¾¿ä¸‹æ¬¡æ‹–æ‹½
                itemPool.value.forEach(item => {
                    if (item.musicianId === stat.id) {
                        item.ratio = newRatio;
                        if (item.musicDuration) {
                            item.estDuration = calculateEstTime(item.musicDuration, newRatio);
                        }
                    }
                });

                // 3. æ›´æ–°ã€æ—¥ç¨‹è¡¨ã€‘é‡Œè¯¥æ¼”å¥å‘˜çš„æ‰€æœ‰ä»»åŠ¡
                scheduledTasks.value.forEach(task => {
                    if (task.musicianId === stat.id) {
                        task.ratio = newRatio;

                        // ğŸŸ¢ å…³é”®ä¿®å¤: åªæœ‰å½“ä»»åŠ¡æ‹¥æœ‰â€œè°±é¢æ—¶é•¿â€æ—¶ï¼Œæ‰æ ¹æ®æ–°å€ç‡é‡ç®—æ—¶é•¿
                        // å¦‚æœæ˜¯çº¯æ—¶é—´å ä½å—(æ²¡æœ‰musicDuration)ï¼Œåˆ™ä¿æŒåŸæœ‰æ’æœŸæ—¶é—´ä¸å˜
                        if (task.musicDuration) {
                            task.estDuration = calculateEstTime(task.musicDuration, newRatio);
                        }
                    }
                });

                pushHistory();
            };

            const musicianScheduledStats = computed(() => {
                const map = {};

                for (const mus of settings.musicians) {
                    map[mus.id] = {
                        id: mus.id,
                        name: mus.name,
                        color: mus.color,
                        scheduledSeconds: 0
                    };
                }

                for (const task of scheduledTasks.value) {
                    const sec = parseTime(task.estDuration);
                    if (map[task.musicianId]) {
                        map[task.musicianId].scheduledSeconds += sec;
                    }
                }

                // æ ¼å¼åŒ–
                return Object.values(map).map(m => ({
                    ...m,
                    scheduledFormatted: formatSecs(m.scheduledSeconds)
                }));
            });

            // ğŸŸ¢ ä¿®å¤: è·³è½¬å›ä»Šå¤© (ä¿®å¤åŠ¨ç”»æ–¹å‘)
            const jumpToToday = () => {
                const now = new Date();

                // ğŸŸ¢ å…³é”®ä¿®å¤: åˆ¤æ–­ä»Šå¤©æ˜¯åœ¨å½“å‰è§†å›¾çš„"å·¦è¾¹"è¿˜æ˜¯"å³è¾¹"
                if (now.getTime() > viewDate.value.getTime()) {
                    dateTransitionName.value = 'slide-next'; // ä»Šå¤©åœ¨æœªæ¥ -> å·¦æ»‘
                } else if (now.getTime() < viewDate.value.getTime()) {
                    dateTransitionName.value = 'slide-prev'; // ä»Šå¤©åœ¨è¿‡å» -> å³æ»‘
                }

                // 1. é‡ç½®æ—¥æœŸ
                viewDate.value = now;

                // 2. åªæœ‰åœ¨å‘¨è§†å›¾æ‰éœ€è¦æ»šåŠ¨å®šä½
                if (currentView.value === 'week') {
                    setTimeout(() => {
                        if (weekContainer.value) {
                            // --- A. è®¡ç®—å‚ç›´ä½ç½® (å®šä½åˆ°å½“å‰æ—¶é—´) ---
                            const currentMins = now.getHours() * 60 + now.getMinutes();
                            const startMins = settings.startHour * 60;
                            // å‚ç›´ç›®æ ‡ä½ç½® (åƒç´ )
                            const targetTop = (currentMins - startMins) * pxPerMin.value;
                            // å‚ç›´å±…ä¸­ä¿®æ­£
                            const screenHeight = weekContainer.value.clientHeight;
                            const scrollTop = Math.max(0, targetTop - (screenHeight / 2));

                            // --- B. è®¡ç®—æ°´å¹³ä½ç½® (å®šä½åˆ°ä»Šå¤©è¿™ä¸€åˆ—) ---
                            const dayIndex = now.getDay();
                            const timeColWidth = window.innerWidth < 800 ? 40 : 70;
                            const dayColWidth = 100; // è¿™é‡Œçš„å®½åº¦ä¼°ç®—å¯èƒ½éœ€è¦æ ¹æ®å®é™… dayColWidth.value è°ƒæ•´ï¼Œä½†é€šå¸¸å¤Ÿç”¨
                            const targetCenterX = timeColWidth + (dayIndex * dayColWidth) + (dayColWidth / 2);
                            const containerWidth = weekContainer.value.clientWidth;
                            const scrollLeft = Math.max(0, targetCenterX - (containerWidth / 2));

                            // --- C. æ‰§è¡ŒåŒå‘æ»šåŠ¨ ---
                            weekContainer.value.scrollTo({
                                top: scrollTop,
                                left: scrollLeft,
                                behavior: 'smooth'
                            });
                        }
                    }, 100);
                }
            };

            // ğŸŸ¢ æ–°å¢: ä¸“é—¨ç”¨äºç‚¹å‡»é¢œè‰²æ¡è·³è½¬æ—¥ç¨‹çš„å‡½æ•°
            const jumpToStatSchedule = (stat) => {
                if (isMobile.value) window.triggerTouchHaptic('Medium');

                // 1. æŸ¥æ‰¾ç›¸å…³ä»»åŠ¡ (æ ¹æ®å½“å‰ Tab ç±»å‹ç­›é€‰)
                let relatedTasks = [];
                if (sidebarTab.value === 'project') {
                    relatedTasks = scheduledTasks.value.filter(t => t.projectId === stat.id);
                } else if (sidebarTab.value === 'instrument') {
                    relatedTasks = scheduledTasks.value.filter(t => t.instrumentId === stat.id);
                } else {
                    relatedTasks = scheduledTasks.value.filter(t => t.musicianId === stat.id);
                }

                // 2. è¿‡æ»¤æ‰éå½“å‰ Session çš„ä»»åŠ¡
                relatedTasks = relatedTasks.filter(t => (t.sessionId || 'S_DEFAULT') === currentSessionId.value);

                // å¦‚æœæ²¡æœ‰å·²æ’æœŸçš„ä»»åŠ¡ï¼Œæ— æ³•è·³è½¬
                if (relatedTasks.length === 0) {
                    openAlertModal("æœªæ’æœŸ", "è¯¥æ¡ç›®ä¸‹æš‚æ—¶æ²¡æœ‰å·²å®‰æ’çš„æ—¥ç¨‹ã€‚");
                    return;
                }

                // 3. æ’åº (æŒ‰æ—¶é—´é¡ºåºï¼Œç¡®ä¿è·³è½¬é€»è¾‘ç¬¦åˆç›´è§‰)
                relatedTasks.sort((a, b) => {
                    const dateA = new Date(a.date + 'T' + a.startTime);
                    const dateB = new Date(b.date + 'T' + b.startTime);
                    return dateA - dateB;
                });

                // 4. å¾ªç¯è·å–ç›®æ ‡ä»»åŠ¡
                let currentIndex = statClickIndexMap[stat.id] || 0;
                if (currentIndex >= relatedTasks.length) currentIndex = 0;

                const targetTask = relatedTasks[currentIndex];

                // æ›´æ–°ä¸‹ä¸€æ¬¡ç‚¹å‡»çš„ç´¢å¼• (+1)
                statClickIndexMap[stat.id] = (currentIndex + 1) % relatedTasks.length;

                // 5. æ‰§è¡Œè·³è½¬
                smartScrollToTask(targetTask);
            };

            // ğŸŸ¢ ä¿®å¤åçš„ handleStatCardClick (ä»…åœ¨å±•å¼€æ—¶è·³è½¬)
            const handleStatCardClick = (stat) => {
                if (isMobile.value) window.triggerTouchHaptic('Medium');

                // 1. åˆ‡æ¢å±•å¼€/æŠ˜å çŠ¶æ€
                toggleStatCollapse(stat.id);

                // ğŸ›‘ æ ¸å¿ƒä¿®æ”¹: æ£€æŸ¥çŠ¶æ€ï¼Œå¦‚æœæ˜¯"æ”¶èµ·"æ“ä½œï¼Œç›´æ¥ç»“æŸï¼Œä¸è·³è½¬
                /*if (!expandedStatsIds.has(stat.id)) {
                    return;
                }

                // --- ä»¥ä¸‹æ˜¯å±•å¼€åçš„è·³è½¬é€»è¾‘ ---

                // 2. æŸ¥æ‰¾ç›¸å…³ä»»åŠ¡
                let relatedTasks = [];
                if (sidebarTab.value === 'project') {
                    relatedTasks = scheduledTasks.value.filter(t => t.projectId === stat.id);
                } else if (sidebarTab.value === 'instrument') {
                    relatedTasks = scheduledTasks.value.filter(t => t.instrumentId === stat.id);
                } else {
                    relatedTasks = scheduledTasks.value.filter(t => t.musicianId === stat.id);
                }

                // è¿‡æ»¤æ‰éå½“å‰ Session çš„ä»»åŠ¡
                relatedTasks = relatedTasks.filter(t => (t.sessionId || 'S_DEFAULT') === currentSessionId.value);

                // å¦‚æœè¯¥å¡ç‰‡ä¸‹æ²¡æœ‰å·²æ’æœŸçš„ä»»åŠ¡ï¼Œåªå±•å¼€åˆ—è¡¨ï¼Œä¸è·³è½¬
                if (relatedTasks.length === 0) return;

                // æ’åº (æŒ‰æ—¥æœŸå’Œæ—¶é—´)
                relatedTasks.sort((a, b) => {
                    const dateA = new Date(a.date + 'T' + a.startTime);
                    const dateB = new Date(b.date + 'T' + b.startTime);
                    return dateA - dateB;
                });

                // 3. è·å–ç›®æ ‡ä»»åŠ¡ (å¾ªç¯ç‚¹å‡»é€»è¾‘)
                let currentIndex = statClickIndexMap[stat.id] || 0;
                if (currentIndex >= relatedTasks.length) currentIndex = 0;

                const targetTask = relatedTasks[currentIndex];

                // æ›´æ–°ä¸‹ä¸€æ¬¡ç‚¹å‡»çš„ç´¢å¼•
                statClickIndexMap[stat.id] = (currentIndex + 1) % relatedTasks.length;

                // 4. æ‰§è¡Œè·³è½¬ (è°ƒç”¨ä¸Šä¸€è½®å°è£…å¥½çš„é€šç”¨å‡½æ•°)
                smartScrollToTask(targetTask);*/
            };


            // --- V11.6 ä¿®æ”¹: æ— éœ€ç¡®è®¤ï¼Œç›´æ¥æ¸…ç©ºï¼Œæ”¯æŒæ’¤é”€ ---
            const clearAllInstruments = () => {
                pushHistory(); // 1. å…ˆä¿å­˜å½“å‰çŠ¶æ€ï¼ˆç”¨äºæ’¤é”€ï¼‰
                settings.instruments = [];
                pushHistory(); // 2. ä¿å­˜æ¸…ç©ºåçš„çŠ¶æ€
            };

            const clearAllMusicians = () => {
                pushHistory();
                settings.musicians = [];
                pushHistory();
            };

            const clearAllProjects = () => {
                pushHistory();
                settings.projects = [];
                pushHistory();
            };


            // --- ğŸŸ¢ æ‰‹æœºç«¯é€‚é…é€»è¾‘ ---
            // --- ğŸŸ¢ æ‰‹æœºç«¯é€‚é… & å¸ƒå±€è‡ªåŠ¨ä¿®å¤ ---
            const isMobile = ref(window.innerWidth < 800);
            const mobileTab = ref('schedule');

            // ğŸŸ¢ ä¼˜åŒ–: å¢å¼ºç‰ˆå¸ƒå±€åˆ·æ–°å‡½æ•°
            const refreshLayout = () => {
                const w = window.innerWidth;

                // 1. è·å–ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸² (åˆ¤æ–­æ˜¯å¦ä¸º Android/iPhone ç­‰)
                const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                // 2. åˆ¤æ–­æ˜¯å¦æ”¯æŒç²—ç•¥æŒ‡é’ˆ (é€šå¸¸æŒ‡è§¦æ‘¸å±) - è¿™æ˜¯ä¸€ä¸ªæ›´ç°ä»£çš„ CSS/JS åª’ä½“ç‰¹æ€§æ£€æµ‹
                const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;

                // 3. ç»¼åˆåˆ¤æ–­:
                // åªæœ‰å½“ [å®½åº¦å°äº 800] ä¸” ([æ˜¯ç§»åŠ¨ç«¯UA] æˆ– [æ˜¯è§¦æ‘¸è®¾å¤‡]) æ—¶ï¼Œæ‰åˆ¤å®šä¸ºç§»åŠ¨ç«¯ã€‚
                // è¿™æ ·ç”µè„‘æµè§ˆå™¨ç¼©çª„æ—¶ï¼Œå› ä¸ºä¸æ»¡è¶³åä¸¤ä¸ªæ¡ä»¶ï¼Œä¾ç„¶ä¼šä¿æŒç”µè„‘ç«¯è§†å›¾ã€‚
                isMobile.value = w < 800 && (isMobileUA || isCoarsePointer);

                // 2. é‡æ–°è®¡ç®—è§†å£é«˜åº¦ (è§£å†³åœ°å€æ é®æŒ¡)
                let vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);

                // 3. ğŸŸ¢ æ–°å¢: ç”µè„‘ç«¯å“åº”å¼ä¿æŠ¤é€»è¾‘
                // å½“å±å¹•å®½åº¦å°äº 1100px (æ¥è¿‘ iPad æ¨ªå±å°ºå¯¸) æ—¶ï¼Œè‡ªåŠ¨æ”¶èµ·ä¾§è¾¹æ ï¼Œé˜²æ­¢é¡¶éƒ¨æ—¥æœŸæ–‡å­—è¢«æŒ¤å‹æ¢è¡Œ
                if (!isMobile.value && w < 1100) {
                    if (isSidebarOpen.value) {
                        isSidebarOpen.value = false;
                    }
                } else if (!isMobile.value && w >= 1100) {
                    // å¯é€‰: å®½åº¦è¶³å¤Ÿå¤§æ—¶ï¼Œå¦‚æœæ‚¨å¸Œæœ›è‡ªåŠ¨å±•å¼€ï¼Œå¯ä»¥å–æ¶ˆä¸‹é¢è¿™è¡Œçš„æ³¨é‡Š
                    isSidebarOpen.value = true;
                }

                // 4. å¼ºåˆ¶é‡ç»˜ (ä¿æŒåŸæœ‰é€»è¾‘)
                if (isMobile.value) {
                    document.body.style.display = 'none';
                    document.body.offsetHeight;
                    document.body.style.display = '';
                }
            };

            onMounted(() => {
                // åˆå§‹åŒ–æ‰§è¡Œ
                refreshLayout();

                // ğŸŸ¢ 1. åˆå§‹åŒ–åº”ç”¨ä¸»é¢˜
                applyTheme();

                // ğŸŸ¢ 2. ç›‘å¬ç³»ç»Ÿé¢œè‰²å˜åŒ– (å®ç°"è·Ÿéšç³»ç»Ÿ"çš„å®æ—¶åˆ‡æ¢)
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                    // åªæœ‰å½“å½“å‰æ¨¡å¼æ˜¯ 'auto' æ—¶ï¼Œæ‰å“åº”ç³»ç»Ÿçš„å˜åŒ–
                    if (themeMode.value === 'auto') {
                        applyTheme();
                    }
                });

                // ç›‘å¬çª—å£å¤§å°æ”¹å˜ (æ—‹è½¬å±å¹•ç­‰)
                window.addEventListener('resize', refreshLayout);

                // ğŸŸ¢ å…³é”®: ç›‘å¬ç½‘é¡µâ€œæ˜¾ç¤º/éšè—â€ (åˆ‡åå°å›æ¥)
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        refreshLayout();
                        // å»¶è¿Ÿ 200ms å†æ‰§è¡Œä¸€æ¬¡ï¼Œç¡®ä¿æµè§ˆå™¨ UI åŠ¨ç”»å·²ç»“æŸ
                        setTimeout(refreshLayout, 200);
                    }
                });

                // ğŸŸ¢ å…³é”®: ç›‘å¬ Safari çš„é¡µé¢ç¼“å­˜æ¢å¤ (BFCache)
                window.addEventListener('pageshow', (e) => {
                    if (e.persisted) {
                        refreshLayout();
                    }
                });
            });

            onUnmounted(() => {
                window.removeEventListener('resize', refreshLayout);
                // è¿™é‡Œçœç•¥äº† remove å…¶ä»–ç›‘å¬ï¼Œå› ä¸ºè¿™æ˜¯æ ¹ç»„ä»¶ï¼Œé”€æ¯å³åˆ·æ–°ï¼Œé€šå¸¸ä¸éœ€è¦æ¸…ç†
            });


            return {
                sidebarTab,
                musicianStats,
                projectStats,
                instrumentStats,
                itemPool,
                scheduledTasks,
                settings,
                currentView,
                currentDateLabel,
                currentWeekDays,
                currentMonthDays,
                timeSlots,
                selectedTaskId,
                showSettings,
                showEditor,
                editingItem,
                editingSource,
                newItem,
                weekContainer,
                dragStart,
                dragEnterPool,
                dragLeavePool,
                dropToPool,
                dragEnterSlot,
                dragLeaveSlot,
                dropToSchedule,
                dropToMonth,
                handleDragEnd,
                initResize,
                selectTask,
                clearSelection,
                onMusicianSelect,
                addItemToPool,
                changeDate,
                isToday,
                getTasksForDate,
                getTaskStyle,
                switchToWeek,
                calculateEstTime,
                openEditModal,
                saveEdit,
                deleteEditingItem,
                handleTaskDblClick,
                handleGlobalKey,
                undo,
                redo,
                historyIndex,
                history,
                pushHistory,
                exportToICS,
                currentSidebarList,

                sortKey,
                expandedGroups,
                toggleCollapse,
                cleanupEmptySchedules,
                sortField,
                sortAsc,
                toggleSort,
                getSortIcon,
                calculateGroupStats,
                expandedStatsIds,
                toggleStatCollapse,
                resetAutoHide,
                showTrackList,
                trackListData,
                slotHeight,
                getNameById,
                generateUniqueId,
                getOverlapCount,
                jumpToGhostContext,
                activeColorKey,
                getGroupColor,
                getTextColor,

                exportJSON,
                importJSON,
                handleJSONFile,

                selectedPoolIds,
                lastPoolClickId,
                sidebarWidth,

                handlePoolItemClick,
                isScheduled,
                clearAllInstruments,
                clearAllMusicians,
                clearAllProjects,

                flashingTaskId,
                handleStatCardClick,
                isSidebarOpen,

                activeDropdown,
                dropdownSearch,
                toggleDropdown,
                selectOption,
                filteredOptions,

                user,
                showAuthModal,
                authForm,
                authLoading,
                handleLogin,
                handleRegister,
                handleResetPwd,
                handleLogout,

                showProfileMenu,
                tempAvatarUrl,
                userAvatar,
                handleUserBtnClick,
                updateAvatar,

                currentSessionId,
                currentSessionName,
                switchSession,
                handleSessionAction,
                tempNickname,
                userDisplayName,
                updateNickname,
                ensureItemRecords,

                handleCSVImport,
                handleAvatarUpload,
                authPasswordRef,
                addProject,
                deleteCurrentSchedule,
                clearTrackTime,
                isTaskGhost,
                deleteProject,
                deleteTrackFromList,
                getGroupedOptions,
                isSyncing,
                handleManualSync,
                viewTransitionName,
                switchView,
                onMainTouchStart,
                onMainTouchEnd,

                isMobile,
                mobileTab,
                showMobileMenu,
                isDark,
                toggleTheme,
                themeMode,
                applyTheme,
                getThemeLabel,
                showMobileTaskInput,
                calculateSingleRatio,
                updateMusicianRatio,
                getSessionRatio,
                autoCalcDuration,
                saveScheduleActualTime,
                saveTrackActual,
                setTrackNow,
                calcTrackDiff,
                autoUpdateMusicianEfficiency,
                toggleMobileMenu,
                closeDropdowns,
                calculateProportionalDuration,
                getDefaultRatio,
                onDragStart,
                showInputModal,
                inputModalConfig,
                openInputModal,
                closeInputModal,
                confirmInputModal,
                universalInputRef,
                showConfirmModal,
                confirmModalConfig,
                openAlertModal,
                openConfirmModal,
                closeConfirmModal,
                handleConfirmAction,
                showImportModal,
                triggerFileSelect,

                showCropModal,
                cropImgSrc,
                cropImgRef,
                checkOverlap,
                autoResizeScheduleByRecords,
                onFileSelect,
                cancelCrop,
                confirmCrop,
                smartScrollToTask,
                currentQuickAddGroups,
                activeGroupFilter,
                availableGroups,
                factoryReset,
                jumpToToday,
                tasksByDateMap,
                showQuickAddModal,
                quickAddForm,
                openQuickAdd,
                confirmQuickAdd,
                draggingTaskElement,
                scheduleReminder,
                onTrackListReminderChange,
                initialTouchCoords,
                dayColWidth,
                widthIcon,
                cycleDayWidth,
                settingsExpandedGroups,
                toggleSettingsGroup,
                dropdownExpandedGroups,
                toggleDropdownGroup,
                showGroupSuggestions,
                settingsGroupFocus,
                dragElClone,
                dragSourceType,
                showDurationPicker,
                tempDuration,
                pickerMinRef,
                pickerPos,
                closePicker,
                resetDuration,
                formatDate,
                viewDate,
                isDefaultRatio,
                isResizingMobile,
                mobileResizeState,
                initMobileResize,
                handleMobileResizeMove,
                handleMobileResizeEnd,
                pickerSecRef,
                openDurationPicker,
                onScroll,
                confirmDurationPicker,
                formatSecs,
                handleTouchStart,
                handleTouchMove,
                handleTouchEnd,
                handlePoolTouchStart,
                sortedInstruments,
                sortedMusicians,
                sortedProjects,
                removeInstrument,
                removeMusician,
                startAutoScroll,
                stopAutoScroll,
                updateAutoScrollDirection,
                setTrackBreak,
                sortTrackList,
                moveDivider,
                autoSortTrackList,
                trackListContainerRef,
                startDividerDrag,
                draggingSectionIndex,
                onDividerDragMove,
                onDividerDragEnd,
                getBlockTitle,
                dateTransitionName,
                jumpToStatSchedule,
                getSettingsGroupedList,
                renameGroup,
                addSettingsItem,
                removeSettingsItem,
                newSettingsItem,
                getExistingGroups,
                clearSettingsList,
                onSettingsItemDragStart,
                onSettingsDragOver,
                onSettingsDragLeave,
                onSettingsDrop,
                onSidebarTouchStart,
                onSidebarTouchEnd,
                sidebarTransitionName,
                sidebarScrollRef,
                switchSidebarTab,
                isAllGroupsExpanded,
                toggleAllGroups,
                showColorPickerModal,
                presetColors,
                tempColor,
                openColorPicker,
                resetColorPicker,
                saveColorPicker,
                settingsNameFocus,
                getUngroupedItems,
                inputRects,
                updateInputRect,
                getFloatingStyle,
                onSettingsScroll,
                splitTrack,
                restoreSplitTime,
                showSplitModal,
                splitState,
                openSplitSlider,
                onSplitSliderInput,
                confirmSplitSlider,
            };
        }
    }).mount('#app');
</script>
</body>
</html>